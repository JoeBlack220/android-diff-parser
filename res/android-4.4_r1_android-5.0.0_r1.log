Find a functionally equivalent code:android.provider.Settings.Global.getStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return sNameValueCache.getStringForUser(resolver, name, userHandle);
}
Body of Second Method:
{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, returning read-only value.");
        return Secure.getStringForUser(resolver, name, userHandle);
    }
    return sNameValueCache.getStringForUser(resolver, name, userHandle);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.applyPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0 || (win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD)) {
        if (mForcingShowNavBarLayer < 0) {
            mForcingShowNavBar = true;
            mForcingShowNavBarLayer = win.getSurfaceLayer();
        }
    }
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if (attrs.type == TYPE_KEYGUARD) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_KEYGUARD) {
            mShowingLockscreen = true;
        }
        boolean applyWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                applyWindow = true;
            }
        }
        if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Fullscreen window: " + win);
            mTopFullscreenOpaqueWindowState = win;
            if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                mHideLockScreen = true;
                mForceStatusBarFromKeyguard = false;
            }
            if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                mWinDismissingKeyguard = win;
                mForceStatusBarFromKeyguard = mShowingLockscreen && isKeyguardSecure();
            }
            if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                mAllowLockscreenWhenOn = true;
            }
        }
    }
}
Body of Second Method:
{
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        mForceStatusBarFromKeyguard = true;
    }
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mShowingLockscreen = true;
        }
        boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
        final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
        final boolean secureKeyguard = isKeyguardSecure();
        if (appWindow) {
            final IApplicationToken appToken = win.getAppToken();
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty() && isKeyguardSecureIncludingHidden()) {
                    mWinShowWhenLocked = win;
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
            } else if (dismissKeyguard) {
                if (secureKeyguard) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && secureKeyguard;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken()) {
                win.hideLw(false);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.startBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#startBluetoothSco()
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("startBluetoothSco()") || !mBootCompleted) {
        return;
    }
    ScoClient client = getScoClient(cb, true);
    // The calling identity must be cleared before calling ScoClient.incCount().
    // inCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    // The caller identity must be cleared after getScoClient() because it is needed if a new
    // client is created.
    final long ident = Binder.clearCallingIdentity();
    client.incCount(targetSdkVersion);
    Binder.restoreCallingIdentity(ident);
}
Body of Second Method:
{
    int scoAudioMode = (targetSdkVersion < Build.VERSION_CODES.JELLY_BEAN_MR2) ? SCO_MODE_VIRTUAL_CALL : SCO_MODE_UNDEFINED;
    startBluetoothScoInt(cb, scoAudioMode);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:android.test.ProviderTestCase2.newResolverWithContentProviderFromSql:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>
 * Creates a new content provider of the same type as that passed to the test case class,
 * with an authority name set to the authority parameter, and using an SQLite database as
 * the underlying data source. The SQL statement parameter is used to create the database.
 * This method also creates a new {@link MockContentResolver} and adds the provider to it.
 * </p>
 * <p>
 * Both the new provider and the new resolver are put into an {@link IsolatedContext}
 * that uses the targetContext parameter for file operations and a {@link MockContext}
 * for everything else. The IsolatedContext prepends the filenamePrefix parameter to
 * file, database, and directory names.
 * </p>
 * <p>
 * This is a convenience method for creating a "mock" provider that can contain test data.
 * </p>
 *
 * @param targetContext The context to use as the basis of the IsolatedContext
 * @param filenamePrefix A string that is prepended to file, database, and directory names
 * @param providerClass The type of the provider being tested
 * @param authority The authority string to associated with the test provider
 * @param databaseName The name assigned to the database
 * @param databaseVersion The version assigned to the database
 * @param sql A string containing the SQL statements that are needed to create the desired
 * database and its tables. The format is the same as that generated by the
 * <a href="http://www.sqlite.org/sqlite.html">sqlite3</a> tool's <code>.dump</code> command.
 * @return ContentResolver A new {@link MockContentResolver} linked to the provider
 *
 * @throws IllegalAccessException
 * @throws InstantiationException
 */

Body of Frist Method:
{
    MockContentResolver resolver = new MockContentResolver();
    RenamingDelegatingContext targetContextWrapper = new RenamingDelegatingContext(// The context that most methods are delegated to
    new MockContext(), // The context that file methods are delegated to
    targetContext, filenamePrefix);
    Context context = new IsolatedContext(resolver, targetContextWrapper);
    DatabaseUtils.createDbFromSqlStatements(context, databaseName, databaseVersion, sql);
    T provider = providerClass.newInstance();
    provider.attachInfoForTesting(context, null);
    resolver.addProvider(authority, provider);
    return resolver;
}
Body of Second Method:
{
    MockContentResolver resolver = new MockContentResolver();
    RenamingDelegatingContext targetContextWrapper = new RenamingDelegatingContext(// The context that most methods are delegated to
    new MockContext(), // The context that file methods are delegated to
    targetContext, filenamePrefix);
    Context context = new IsolatedContext(resolver, targetContextWrapper);
    DatabaseUtils.createDbFromSqlStatements(context, databaseName, databaseVersion, sql);
    T provider = createProviderForTest(context, providerClass, authority);
    resolver.addProvider(authority, provider);
    return resolver;
}
------------------------
Find a functionally equivalent code:android.net.http.CertificateChainValidator.verifyServerDomainAndCertificates:COMMENT
Method Modifier: private     static      
Comment:/**
 * Common code of doHandshakeAndValidateServerCertificates and verifyServerCertificates.
 * Calls DomainNamevalidator to verify the domain, and TrustManager to verify the certs.
 * @param chain the cert chain in X509 cert format.
 * @param domain The full website hostname and domain
 * @param authType The authentication type for the cert chain
 * @return An SSL error object if there is an error and null otherwise
 */

Body of Frist Method:
{
    // check if the first certificate in the chain is for this site
    X509Certificate currCertificate = chain[0];
    if (currCertificate == null) {
        throw new IllegalArgumentException("certificate for this site is null");
    }
    boolean valid = domain != null && !domain.isEmpty() && sVerifier.verify(domain, currCertificate);
    if (!valid) {
        if (HttpLog.LOGV) {
            HttpLog.v("certificate not for this host: " + domain);
        }
        return new SslError(SslError.SSL_IDMISMATCH, currCertificate);
    }
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.checkServerTrusted(chain, authType, domain);
        } else {
            x509TrustManager.checkServerTrusted(chain, authType);
        }
        // No errors.
        return null;
    } catch (GeneralSecurityException e) {
        if (HttpLog.LOGV) {
            HttpLog.v("failed to validate the certificate chain, error: " + e.getMessage());
        }
        return new SslError(SslError.SSL_UNTRUSTED, currCertificate);
    }
}
Body of Second Method:
{
    // check if the first certificate in the chain is for this site
    X509Certificate currCertificate = chain[0];
    if (currCertificate == null) {
        throw new IllegalArgumentException("certificate for this site is null");
    }
    boolean valid = domain != null && !domain.isEmpty() && NoPreloadHolder.sVerifier.verify(domain, new DelegatingSSLSession.CertificateWrap(currCertificate));
    if (!valid) {
        if (HttpLog.LOGV) {
            HttpLog.v("certificate not for this host: " + domain);
        }
        return new SslError(SslError.SSL_IDMISMATCH, currCertificate);
    }
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultX509TrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.checkServerTrusted(chain, authType, domain);
        } else {
            x509TrustManager.checkServerTrusted(chain, authType);
        }
        // No errors.
        return null;
    } catch (GeneralSecurityException e) {
        if (HttpLog.LOGV) {
            HttpLog.v("failed to validate the certificate chain, error: " + e.getMessage());
        }
        return new SslError(SslError.SSL_UNTRUSTED, currCertificate);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setXfermode:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the xfermode object.
 * <p />
 * Pass null to clear any previous xfermode.
 * As a convenience, the parameter passed is also returned.
 *
 * @param xfermode May be null. The xfermode to be installed in the paint
 * @return         xfermode
 */

Body of Frist Method:
{
    int xfermodeNative = 0;
    if (xfermode != null)
        xfermodeNative = xfermode.native_instance;
    native_setXfermode(mNativePaint, xfermodeNative);
    mXfermode = xfermode;
    return xfermode;
}
Body of Second Method:
{
    long xfermodeNative = 0;
    if (xfermode != null)
        xfermodeNative = xfermode.native_instance;
    native_setXfermode(mNativePaint, xfermodeNative);
    mXfermode = xfermode;
    return xfermode;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    String stringValue = value.getValue();
    if (stringValue == null || RenderResources.REFERENCE_NULL.equals(stringValue)) {
        return null;
    }
    return ResourceHelper.getDrawable(value, mContext);
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext);
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.loadDrawable:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadDrawable", name);
        }
    }
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException("Resource is not a Drawable (color or path): " + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, "Loading framework drawable #" + Integer.toHexString(id) + ": " + name + " at " + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, "Loading drawable for cookie " + value.assetCookie + ": " + file);
            if (file.endsWith(".xml")) {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "drawable");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            } else {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println("Opened file " + file + ": " + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println("Created stream: " + dr);
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                final int changingConfigs = cs.getChangingConfigurations();
                if (isColorDrawable) {
                    if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, "drawable")) {
                        sPreloadedColorDrawables.put(key, cs);
                    }
                } else {
                    if (verifyPreloadConfig(changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, "drawable")) {
                        if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {
                            // If this resource does not vary based on layout direction,
                            // we can put it in all of the preload maps.
                            sPreloadedDrawables[0].put(key, cs);
                            sPreloadedDrawables[1].put(key, cs);
                        } else {
                            // Otherwise, only in the layout dir we loaded it for.
                            final LongSparseArray<Drawable.ConstantState> preloads = sPreloadedDrawables[mConfiguration.getLayoutDirection()];
                            preloads.put(key, cs);
                        }
                    }
                }
            } else {
                synchronized (mAccessLock) {
                    // + " in " + this + ": " + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this, theme);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.createPreviewTextView:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a view into which preview text can be placed.
 */

Body of Frist Method:
{
    final LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    final Resources res = context.getResources();
    final int minSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_size);
    final ColorStateList textColor = ta.getColorStateList(TEXT_COLOR);
    final float textSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_text_size);
    final TextView textView = new TextView(context);
    textView.setLayoutParams(params);
    textView.setTextColor(textColor);
    textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
    textView.setSingleLine(true);
    textView.setEllipsize(TruncateAt.MIDDLE);
    textView.setGravity(Gravity.CENTER);
    textView.setAlpha(0f);
    // Manually propagate inherited layout direction.
    textView.setLayoutDirection(mList.getLayoutDirection());
    return textView;
}
Body of Second Method:
{
    final LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    final TextView textView = new TextView(context);
    textView.setLayoutParams(params);
    textView.setSingleLine(true);
    textView.setEllipsize(TruncateAt.MIDDLE);
    textView.setGravity(Gravity.CENTER);
    textView.setAlpha(0f);
    // Manually propagate inherited layout direction.
    textView.setLayoutDirection(mList.getLayoutDirection());
    return textView;
}
------------------------
Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.updateSlider:COMMENT
Method Modifier: private     
Comment:/**
 * Fetch the brightness from the system settings and update the slider
 */

Body of Frist Method:
{
    int value;
    try {
        value = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, UserHandle.USER_CURRENT);
    } catch (SettingNotFoundException ex) {
        value = mMaximumBacklight;
    }
    mControl.setMax(mMaximumBacklight - mMinimumBacklight);
    mControl.setValue(value - mMinimumBacklight);
}
Body of Second Method:
{
    if (mAutomatic) {
        float value = Settings.System.getFloatForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0, UserHandle.USER_CURRENT);
        mControl.setMax((int) BRIGHTNESS_ADJ_RESOLUTION);
        mControl.setValue((int) ((value + 1) * BRIGHTNESS_ADJ_RESOLUTION / 2f));
    } else {
        int value;
        value = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT);
        mControl.setMax(mMaximumBacklight - mMinimumBacklight);
        mControl.setValue(value - mMinimumBacklight);
    }
}
------------------------
Find a functionally equivalent code:android.app.SharedPreferencesImpl.hasFileChangedUnexpectedly:COMMENT
Method Modifier: private     
Comment:// we didn't instigate.

Body of Frist Method:
{
    synchronized (this) {
        if (mDiskWritesInFlight > 0) {
            // If we know we caused it, it's not unexpected.
            if (DEBUG)
                Log.d(TAG, "disk write in flight, not unexpected.");
            return false;
        }
    }
    final StructStat stat;
    try {
        /*
             * Metadata operations don't usually count as a block guard
             * violation, but we explicitly want this one.
             */
        BlockGuard.getThreadPolicy().onReadFromDisk();
        stat = Libcore.os.stat(mFile.getPath());
    } catch (ErrnoException e) {
        return true;
    }
    synchronized (this) {
        return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mDiskWritesInFlight > 0) {
            // If we know we caused it, it's not unexpected.
            if (DEBUG)
                Log.d(TAG, "disk write in flight, not unexpected.");
            return false;
        }
    }
    final StructStat stat;
    try {
        /*
             * Metadata operations don't usually count as a block guard
             * violation, but we explicitly want this one.
             */
        BlockGuard.getThreadPolicy().onReadFromDisk();
        stat = Os.stat(mFile.getPath());
    } catch (ErrnoException e) {
        return true;
    }
    synchronized (this) {
        return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;
    }
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.verifyFileDownloadSucceeded:COMMENT
Method Modifier: public      
Comment:/**
 * Waits for a previously-initiated download and verifies it has completed successfully.
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_5MB_FILENAME;
    long filesize = DOWNLOAD_5MB_FILESIZE;
    long dlRequest = -1;
    boolean rebootMarkerValid = false;
    DataInputStream dataInputFile = null;
    setWiFiStateOn(true);
    setAirplaneModeOn(false);
    try {
        FileInputStream inFile = mContext.openFileInput(DOWNLOAD_STARTED_FLAG);
        dataInputFile = new DataInputStream(inFile);
        dlRequest = dataInputFile.readLong();
    } catch (Exception e) {
        // The file was't valid so we just leave the flag false
        Log.i(LOG_TAG, "Unable to determine initial download id.");
        throw e;
    } finally {
        if (dataInputFile != null) {
            dataInputFile.close();
        }
        mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
    }
    assertTrue(dlRequest != -1);
    Cursor cursor = getCursor(dlRequest);
    ParcelFileDescriptor pfd = null;
    try {
        assertTrue("Unable to query last initiated download!", cursor.moveToFirst());
        int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
        int status = cursor.getInt(columnIndex);
        int currentWaitTime = 0;
        // Wait until the download finishes; don't wait for a notification b/c
        // the download may well have been completed before the last reboot.
        waitForDownloadOrTimeout_skipNotification(dlRequest);
        Log.i(LOG_TAG, "Verifying download information...");
        // Verify specific info about the file (size, name, etc)...
        pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } catch (Exception e) {
        Log.i(LOG_TAG, "error: " + e.toString());
        throw e;
    } finally {
        // Clean up...
        cursor.close();
        mDownloadManager.remove(dlRequest);
        if (pfd != null) {
            pfd.close();
        }
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    long filesize = DOWNLOAD_FILESIZE;
    long dlRequest = -1;
    boolean rebootMarkerValid = false;
    DataInputStream dataInputFile = null;
    setWiFiStateOn(true);
    setAirplaneModeOn(false);
    try {
        FileInputStream inFile = mContext.openFileInput(DOWNLOAD_STARTED_FLAG);
        dataInputFile = new DataInputStream(inFile);
        dlRequest = dataInputFile.readLong();
    } catch (Exception e) {
        // The file was't valid so we just leave the flag false
        Log.i(LOG_TAG, "Unable to determine initial download id.");
        throw e;
    } finally {
        if (dataInputFile != null) {
            dataInputFile.close();
        }
        mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
    }
    assertTrue("request id is -1 from download manager", dlRequest != -1);
    Cursor cursor = getCursor(dlRequest);
    ParcelFileDescriptor pfd = null;
    try {
        assertTrue("Unable to query last initiated download!", cursor.moveToFirst());
        int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
        int status = cursor.getInt(columnIndex);
        int currentWaitTime = 0;
        assertTrue("download not finished", waitForDownload(dlRequest, 15 * 60 * 1000));
        Log.i(LOG_TAG, "Verifying download information...");
        // Verify specific info about the file (size, name, etc)...
        pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } catch (Exception e) {
        Log.i(LOG_TAG, "error: " + e.toString());
        throw e;
    } finally {
        // Clean up...
        cursor.close();
        mDownloadManager.remove(dlRequest);
        if (pfd != null) {
            pfd.close();
        }
    }
}
------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.cancelTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sensor != null && Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT) {
        return false;
    }
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, disable);
            }
            if (result && !queue.hasSensors()) {
                mTriggerListeners.remove(listener);
                queue.dispose();
            }
            return result;
        }
        return false;
    }
}
Body of Second Method:
{
    if (sensor != null && sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT) {
        return false;
    }
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, disable);
            }
            if (result && !queue.hasSensors()) {
                mTriggerListeners.remove(listener);
                queue.dispose();
            }
            return result;
        }
        return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onKeyguardVisibilityChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onKeyguardVisibilityChanged(boolean)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the visibility of the keyguard changes.
 * @param showing Indicates if the keyguard is now visible.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DependencyFinder.DependencyVisitor.considerName:COMMENT
Method Modifier: public      
Comment:/**
 * Considers the given class name as a dependency.
 */

Body of Frist Method:
{
    if (className == null) {
        return;
    }
    className = internalToBinaryClassName(className);
    try {
        // exclude classes that are part of the default JRE (the one executing this program)
        if (getClass().getClassLoader().loadClass(className) != null) {
            return;
        }
    } catch (ClassNotFoundException e) {
    // ignore
    }
    // Add it to the dependency set for the currently visited class, as needed.
    assert mCurrentDepSet != null;
    if (mCurrentDepSet != null) {
        mCurrentDepSet.add(className);
    }
}
Body of Second Method:
{
    if (className == null) {
        return;
    }
    className = internalToBinaryClassName(className);
    try {
        // exclude classes that are part of the default JRE (the one executing this program)
        if (getClass().getClassLoader().loadClass(className) != null) {
            return;
        }
    } catch (ClassNotFoundException e) {
    // ignore
    }
    // Add it to the dependency set for the currently visited class, as needed.
    assert mCurrentDepSet != null;
    mCurrentDepSet.add(className);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onEmergencyCallAction:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onEmergencyCallAction()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the emergency call button is pressed.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<CharSequence> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequenceArrayList(key, value);
}
------------------------
Find a functionally equivalent code:android.widget.Switch.setThumbDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param thumb Thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

Body of Frist Method:
{
    mThumbDrawable = thumb;
    requestLayout();
}
Body of Second Method:
{
    if (mThumbDrawable != null) {
        mThumbDrawable.setCallback(null);
    }
    mThumbDrawable = thumb;
    if (thumb != null) {
        thumb.setCallback(this);
    }
    requestLayout();
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.selectRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use
 */

Body of Frist Method:
{
    selectRouteStatic(types, route);
}
Body of Second Method:
{
    selectRouteStatic(types, route, explicit);
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.start:COMMENT
Method Modifier: private     
Comment:/**
 * Start the animation playing. This version of start() takes a boolean flag that indicates
 * whether the animation should play in reverse. The flag is usually false, but may be set
 * to true if called from the reverse() method.
 *
 * <p>The animation started by calling this method will be run on the thread that called
 * this method. This thread should have a Looper on it (a runtime exception will be thrown if
 * this is not the case). Also, if the animation will animate
 * properties of objects in the view hierarchy, then the calling thread should be the UI
 * thread for that view hierarchy.</p>
 *
 * @param playBackwards Whether the ValueAnimator should start playing in reverse.
 */

Body of Frist Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mPlayingBackwards = playBackwards;
    mCurrentIteration = 0;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        setCurrentPlayTime(0);
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
Body of Second Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mPlayingBackwards = playBackwards;
    mCurrentIteration = 0;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    // in case the scale factor has changed since creation time
    updateScaledDuration();
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        setCurrentPlayTime(0);
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

Body of Frist Method:
{
    if (mShowWeekNumber == showWeekNumber) {
        return;
    }
    mShowWeekNumber = showWeekNumber;
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}
Body of Second Method:
{
    mDelegate.setShowWeekNumber(showWeekNumber);
}
------------------------
Find a functionally equivalent code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycle();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether to show the week number.
 *
 * @return True if showing the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

Body of Frist Method:
{
    return mShowWeekNumber;
}
Body of Second Method:
{
    return mDelegate.getShowWeekNumber();
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.restore:COMMENT
<android.graphics.Canvas: void restore()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * This call balances a previous call to save(), and is used to remove all
 * modifications to the matrix/clip state since the last save call. It is
 * an error to call restore() more times than save() was called.
 */

Body of Frist Method:

Body of Second Method:
{
    native_restore(mNativeCanvasWrapper);
}
------------------------
Find a functionally equivalent code:android.media.MediaScanner.scanSingleFile:COMMENT
Method Modifier: public      
Comment:// this function is used to scan a single file

Body of Frist Method:
{
    try {
        initialize(volumeName);
        prescan(path, true);
        File file = new File(path);
        if (!file.exists()) {
            return null;
        }
        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;
        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(), false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        initialize(volumeName);
        prescan(path, true);
        File file = new File(path);
        if (!file.exists()) {
            return null;
        }
        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;
        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(), false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    } finally {
        releaseResources();
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawARGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified ARGB color, using srcover porterduff mode.
 *
 * @param a alpha component (0..255) of the color to draw onto the canvas
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawARGB(mNativeCanvas, a, r, g, b);
}
Body of Second Method:
{
    drawColor(Color.argb(a, r, g, b));
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.prepare:COMMENT
<android.media.MediaPlayer: void prepare()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Prepares the player for playback, synchronously.
 *
 * After setting the datasource and the display surface, you need to either
 * call prepare() or prepareAsync(). For files, it is OK to call prepare(),
 * which blocks until MediaPlayer is ready for playback.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

Body of Frist Method:

Body of Second Method:
{
    _prepare();
    scanInternalSubtitleTracks();
}
------------------------
Find a functionally equivalent code:android.media.MiniThumbFile.getMiniThumbFromFile:COMMENT
Method Modifier: public      
Comment:/**
 * Gallery app can use this method to retrieve mini-thumbnail. Full size
 * images share the same IDs with their corresponding thumbnails.
 *
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */

Body of Frist Method:
{
    RandomAccessFile r = miniThumbDataFile();
    if (r == null)
        return null;
    long pos = id * BYTES_PER_MINTHUMB;
    FileLock lock = null;
    try {
        mBuffer.clear();
        lock = mChannel.lock(pos, BYTES_PER_MINTHUMB, true);
        int size = mChannel.read(mBuffer, pos);
        if (size > 1 + 8 + 4) {
            // flag, magic, length
            mBuffer.position(0);
            byte flag = mBuffer.get();
            long magic = mBuffer.getLong();
            int length = mBuffer.getInt();
            if (size >= 1 + 8 + 4 + length && data.length >= length) {
                mBuffer.get(data, 0, length);
                return data;
            }
        }
    } catch (IOException ex) {
        Log.w(TAG, "got exception when reading thumbnail id=" + id + ", exception: " + ex);
    } catch (RuntimeException ex) {
        // Other NIO related exception like disk full, read only channel..etc
        Log.e(TAG, "Got exception when reading thumbnail, id = " + id + ", disk full or mount read-only? " + ex.getClass());
    } finally {
        try {
            if (lock != null)
                lock.release();
        } catch (IOException ex) {
        // ignore it.
        }
    }
    return null;
}
Body of Second Method:
{
    RandomAccessFile r = miniThumbDataFile();
    if (r == null)
        return null;
    long pos = id * BYTES_PER_MINTHUMB;
    FileLock lock = null;
    try {
        mBuffer.clear();
        lock = mChannel.lock(pos, BYTES_PER_MINTHUMB, true);
        int size = mChannel.read(mBuffer, pos);
        if (size > 1 + 8 + 4) {
            // flag, magic, length
            mBuffer.position(0);
            byte flag = mBuffer.get();
            long magic = mBuffer.getLong();
            int length = mBuffer.getInt();
            if (size >= 1 + 8 + 4 + length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
                mBuffer.get(data, 0, length);
                return data;
            }
        }
    } catch (IOException ex) {
        Log.w(TAG, "got exception when reading thumbnail id=" + id + ", exception: " + ex);
    } catch (RuntimeException ex) {
        // Other NIO related exception like disk full, read only channel..etc
        Log.e(TAG, "Got exception when reading thumbnail, id = " + id + ", disk full or mount read-only? " + ex.getClass());
    } finally {
        try {
            if (lock != null)
                lock.release();
        } catch (IOException ex) {
        // ignore it.
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.attach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called when the Dream is ready to be shown.
 *
 * Must run on mHandler.
 *
 * @param windowToken A window token that will allow a window to be created in the correct layer.
 */

Body of Frist Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mDebug)
        Slog.v(TAG, "Attached on thread " + Thread.currentThread().getId());
    if (mSandman == null) {
        loadSandman();
    }
    mWindowToken = windowToken;
    mWindow = PolicyManager.makeNewWindow(this);
    mWindow.setCallback(this);
    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
    mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
    mWindow.setFormat(PixelFormat.OPAQUE);
    if (mDebug)
        Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
    WindowManager.LayoutParams lp = mWindow.getAttributes();
    lp.type = WindowManager.LayoutParams.TYPE_DREAM;
    lp.token = windowToken;
    lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
    lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
    mWindow.setAttributes(lp);
    if (mDebug)
        Slog.v(TAG, "Created and attached window: " + mWindow);
    mWindow.setWindowManager(null, windowToken, "dream", true);
    mWindowManager = mWindow.getWindowManager();
    if (mDebug)
        Slog.v(TAG, "Window added on thread " + Thread.currentThread().getId());
    try {
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed adding window view", t);
        safelyFinish();
        return;
    }
    // start it up
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                onDreamingStarted();
            } catch (Throwable t) {
                Slog.w(TAG, "Crashed in onDreamingStarted()", t);
                safelyFinish();
            }
        }
    });
}
Body of Second Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mFinished || mWaking) {
        Slog.w(TAG, "attach() called after dream already finished");
        try {
            mSandman.finishSelf(windowToken, true);
        } catch (RemoteException ex) {
        // system server died
        }
        return;
    }
    mWindowToken = windowToken;
    mCanDoze = canDoze;
    if (mWindowless && !mCanDoze) {
        throw new IllegalStateException("Only doze dreams can be windowless");
    }
    if (!mWindowless) {
        mWindow = PolicyManager.makeNewWindow(this);
        mWindow.setCallback(this);
        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
        mWindow.setFormat(PixelFormat.OPAQUE);
        if (mDebug)
            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
        WindowManager.LayoutParams lp = mWindow.getAttributes();
        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
        lp.token = windowToken;
        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
        mWindow.setAttributes(lp);
        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
        // along well. Dreams usually don't need such bars anyways, so disable them by default.
        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        mWindow.setWindowManager(null, windowToken, "dream", true);
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        try {
            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
        } catch (WindowManager.BadTokenException ex) {
            // This can happen because the dream manager service will remove the token
            // immediately without necessarily waiting for the dream to start.
            // We should receive a finish message soon.
            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
            mWindow = null;
            return;
        }
    }
    // We need to defer calling onDreamingStarted until after onWindowAttached,
    // which is posted to the handler by addView, so we post onDreamingStarted
    // to the handler also.  Need to watch out here in case detach occurs before
    // this callback is invoked.
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mWindow != null || mWindowless) {
                if (mDebug)
                    Slog.v(TAG, "Calling onDreamingStarted()");
                mStarted = true;
                onDreamingStarted();
            }
        }
    });
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.clearShadowLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Clear the shadow layer.
 */

Body of Frist Method:
{
    hasShadow = false;
    nSetShadowLayer(0, 0, 0, 0);
}
Body of Second Method:
{
    setShadowLayer(0, 0, 0, 0);
}
------------------------
Find a functionally equivalent code:android.view.Window.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flags of the window, as per the
 * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
 * flags.
 *
 * <p>Note that some flags must be set before the window decoration is
 * created (by the first call to
 * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
 * {@link #getDecorView()}:
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
 * will be set for you based on the {@link android.R.attr#windowIsFloating}
 * attribute.
 *
 * @param flags The new window flags (see WindowManager.LayoutParams).
 * @param mask Which of the window flag bits to modify.
 * @see #addFlags
 * @see #clearFlags
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSyncManager.startSync:COMMENT
Method Modifier: public      
Comment:/**
 * startSync() requests sync manager to start sync
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "***  WebSyncManager startSync ***, Ref count:" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (++mStartSyncRefCount == 1) {
        Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
        mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
    }
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.removeFocusStackEntry:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove a focus listener from the focus stack.
 * @param clientToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
 * focus, notify the next item in the stack it gained focus.
 */

Body of Frist Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
            // there's a new top of the stack, let the remote control know
            synchronized (mRCStack) {
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = (FocusRequester) stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
Body of Second Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.readFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */

Body of Frist Method:
{
    int length = parcel.readInt();
    if (length < 0) {
        throw new RuntimeException("Bad length in parcel: " + length);
    }
    readFromParcelInner(parcel, length);
}
Body of Second Method:
{
    super.readFromParcelInner(parcel);
    mHasFds = mParcelledData.hasFileDescriptors();
    mFdsKnown = true;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.dumpGeneratedClass:COMMENT
Method Modifier: private     
Comment:/**
 * For debugging, it's useful to dump the content of the generated classes
 * along with the exception that was generated.
 *
 * However to make it work you need to pull in the org.objectweb.asm.util.TraceClassVisitor
 * class and associated utilities which are found in the ASM source jar. Since we don't
 * want that dependency in the source code, we only put it manually for development and
 * access the TraceClassVisitor via reflection if present.
 *
 * @param t The exception thrown by {@link ClassLoader2#testModifiedInstance()}
 * @param cl2 The {@link ClassLoader2} instance with the generated bytecode.
 * @return Either original {@code t} or a new wrapper {@link Throwable}
 */

Body of Frist Method:
{
    try {
        // For debugging, dump the bytecode of the class in case of unexpected error
        // if we can find the TraceClassVisitor class.
        Class<?> tcvClass = Class.forName("org.objectweb.asm.util.TraceClassVisitor");
        StringBuilder sb = new StringBuilder();
        sb.append('\n').append(t.getClass().getCanonicalName());
        if (t.getMessage() != null) {
            sb.append(": ").append(t.getMessage());
        }
        for (Entry<String, byte[]> entry : cl2.getByteCode()) {
            String className = entry.getKey();
            byte[] bytes = entry.getValue();
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            // next 2 lines do: TraceClassVisitor tcv = new TraceClassVisitor(pw);
            Constructor<?> cons = tcvClass.getConstructor(new Class<?>[] { pw.getClass() });
            Object tcv = cons.newInstance(new Object[] { pw });
            ClassReader cr2 = new ClassReader(bytes);
            cr2.accept((ClassVisitor) tcv, 0);
            sb.append("\nBytecode dump: <").append(className).append(">:\n").append(sw.toString());
        }
        // Re-throw exception with new message
        RuntimeException ex = new RuntimeException(sb.toString(), t);
        return ex;
    } catch (Throwable ignore) {
        // In case of problem, just throw the original exception as-is.
        return t;
    }
}
Body of Second Method:
{
    try {
        // For debugging, dump the bytecode of the class in case of unexpected error
        // if we can find the TraceClassVisitor class.
        Class<?> tcvClass = Class.forName("org.objectweb.asm.util.TraceClassVisitor");
        StringBuilder sb = new StringBuilder();
        sb.append('\n').append(t.getClass().getCanonicalName());
        if (t.getMessage() != null) {
            sb.append(": ").append(t.getMessage());
        }
        for (Entry<String, byte[]> entry : cl2.getByteCode()) {
            String className = entry.getKey();
            byte[] bytes = entry.getValue();
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            // next 2 lines do: TraceClassVisitor tcv = new TraceClassVisitor(pw);
            Constructor<?> cons = tcvClass.getConstructor(pw.getClass());
            Object tcv = cons.newInstance(pw);
            ClassReader cr2 = new ClassReader(bytes);
            cr2.accept((ClassVisitor) tcv, 0);
            sb.append("\nBytecode dump: <").append(className).append(">:\n").append(sw.toString());
        }
        // Re-throw exception with new message
        return new RuntimeException(sb.toString(), t);
    } catch (Throwable ignore) {
        // In case of problem, just throw the original exception as-is.
        return t;
    }
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleSimultaneously:COMMENT
Method Modifier: public      
Comment:/**
 * Tests 15 concurrent downloads of 1,000,000-byte files.
 *
 * @throws Exception if test failed
 */

Body of Frist Method:
{
    final int TOTAL_DOWNLOADS = 15;
    HashSet<Long> downloadIds = new HashSet<Long>(TOTAL_DOWNLOADS);
    MultipleDownloadsCompletedReceiver receiver = registerNewMultipleDownloadsReceiver();
    // Make sure there are no pending downloads currently going on
    removeAllCurrentDownloads();
    try {
        for (int i = 0; i < TOTAL_DOWNLOADS; ++i) {
            long dlRequest = -1;
            String filename = FILE_CONCURRENT_DOWNLOAD_FILE_PREFIX + i + FILE_CONCURRENT_DOWNLOAD_FILE_EXTENSION;
            Uri remoteUri = getExternalFileUri(filename);
            Request request = new Request(remoteUri);
            request.setTitle(filename);
            dlRequest = mDownloadManager.enqueue(request);
            assertTrue(dlRequest != -1);
            downloadIds.add(dlRequest);
        }
        // wait 15 mins max
        waitForDownloadsOrTimeout(DEFAULT_WAIT_POLL_TIME, 15 * 60 * 2000);
        assertEquals(TOTAL_DOWNLOADS, receiver.numDownloadsCompleted());
    } finally {
        removeAllCurrentDownloads();
    }
}
Body of Second Method:
{
    final int TOTAL_DOWNLOADS = 15;
    HashSet<Long> downloadIds = new HashSet<Long>(TOTAL_DOWNLOADS);
    // Make sure there are no pending downloads currently going on
    removeAllCurrentDownloads();
    try {
        for (int i = 0; i < TOTAL_DOWNLOADS; ++i) {
            long dlRequest = -1;
            String filename = FILE_CONCURRENT_DOWNLOAD_FILE_PREFIX + i + FILE_CONCURRENT_DOWNLOAD_FILE_EXTENSION;
            Uri remoteUri = getExternalFileUri(filename);
            Request request = new Request(remoteUri);
            request.setTitle(filename);
            dlRequest = mDownloadManager.enqueue(request);
            assertTrue("request id is -1 from download manager", dlRequest != -1);
            downloadIds.add(dlRequest);
        }
        // wait 15 mins max
        assertTrue("download not finished", waitForMultipleDownloads(downloadIds, 15 * 60 * 2000));
    } finally {
        removeAllCurrentDownloads();
    }
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getBluetoothOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that bluetooth has been on while the device was
 * running on battery.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

Body of Frist Method:
{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId());
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
Body of Second Method:
{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.initFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityNodeInfo}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    SparseLongArray childIds = mChildNodeIds;
    final int childrenSize = parcel.readInt();
    for (int i = 0; i < childrenSize; i++) {
        final long childId = parcel.readLong();
        childIds.put(i, childId);
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    mActions = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioRecord.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

Body of Frist Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
}
Body of Second Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeQueueing:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (isScreenOn ? mKeyguardDelegate.isShowingAndNotHidden() : mKeyguardDelegate.isShowing()));
    if (keyCode == KeyEvent.KEYCODE_POWER) {
        policyFlags |= WindowManagerPolicy.FLAG_WAKE;
    }
    final boolean isWakeKey = (policyFlags & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags) + " isWakeKey=" + isWakeKey);
    }
    if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    // Basic policy based on screen state and keyguard.
    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
    // is on or off, really.  We should care about whether the device is in an
    // interactive state or is in suspend pretending to be "off".
    // The primary screen might be turned off due to proximity sensor or
    // because we are presenting media on an auxiliary screen or remotely controlling
    // the device some other way (which is why we have an exemption here for injected
    // events).
    int result;
    if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
        // When the screen is on or if the key is injected pass the key to the application.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
            result |= ACTION_WAKE_UP;
        }
    }
    // key processing.
    if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        return result;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (isScreenOn && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeDownKeyTriggered = true;
                            mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (isScreenOn && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // If an incoming call is ringing, either VOLUME key means
                                // "silence ringer".  We handle these keys here, rather than
                                // in the InCallScreen, to make sure we'll respond to them
                                // even if the InCallScreen hasn't come to the foreground yet.
                                // Look for the DOWN event here, to agree with the "fallback"
                                // behavior in the InCallScreen.
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                                // Silence the ringer.  (It's safe to call this
                                // even if the ringer has already been silenced.)
                                telephonyService.silenceRinger();
                                // And *don't* pass this key thru to the current activity
                                // (which is probably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                                break;
                            }
                            if (telephonyService.isOffhook() && (result & ACTION_PASS_TO_USER) == 0) {
                                // If we are in call but we decided not to pass the key to
                                // the application, handle the volume change here.
                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
                                break;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If music is playing but we decided not to pass the key to the
                        // application, handle the volume change here.
                        handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            hungUp = telephonyService.endCall();
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp);
                } else {
                    if (interceptPowerKeyUp(canceled)) {
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                            if (goHome()) {
                                break;
                            }
                        }
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    mImmersiveModeConfirmation.onPowerKeyDown(isScreenOn, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
                    if (isScreenOn && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mPowerKeyTriggered = true;
                        mPowerKeyTime = event.getDownTime();
                        interceptScreenshotChord();
                    }
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // Pressing Power while there's a ringing incoming
                                // call should silence the ringer.
                                telephonyService.silenceRinger();
                            } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telephonyService.isOffhook()) {
                                // Otherwise, if "Power button ends call" is enabled,
                                // the Power button will hang up any current active call.
                                hungUp = telephonyService.endCall();
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                } else {
                    mPowerKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                    }
                    mPendingPowerKeyUpCanceled = false;
                }
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            if (down) {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null) {
                    try {
                        if (!telephonyService.isIdle()) {
                            // to avoid music playback.
                            break;
                        }
                    } catch (RemoteException ex) {
                        Log.w(TAG, "ITelephony threw RemoteException", ex);
                    }
                }
            }
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                                telephonyService.answerRingingCall();
                                // And *don't* pass this key thru to the current activity
                                // (which is presumably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                }
                break;
            }
    }
    return result;
}
Body of Second Method:
{
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? mKeyguardDelegate.isShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            mPowerManager.wakeUp(event.getEventTime());
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeDownKeyTriggered = true;
                            mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                    if ((result & ACTION_PASS_TO_USER) == 0) {
                        // If we aren't passing to the user and no one else
                        // handled it send it to the session manager to figure
                        // out.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    interceptPowerKeyDown(!interactive || hungUp);
                } else {
                    if (interceptPowerKeyUp(canceled)) {
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                            if (goHome()) {
                                break;
                            }
                        }
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                            mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                            isWakeKey = false;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
                    if (panic) {
                        mHandler.post(mRequestTransientNav);
                    }
                    if (interactive && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mPowerKeyTriggered = true;
                        mPowerKeyTime = event.getDownTime();
                        interceptScreenshotChord();
                    }
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // Pressing Power while there's a ringing incoming
                            // call should silence the ringer.
                            telecomManager.silenceRinger();
                        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
                            // Otherwise, if "Power button ends call" is enabled,
                            // the Power button will hang up any current active call.
                            hungUp = telecomManager.endCall();
                        }
                    }
                    interceptPowerKeyDown(!interactive || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                } else {
                    mPowerKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
                        if (mScreenOnEarly && !mScreenOnFully) {
                            Slog.i(TAG, "Suppressed redundant power key press while " + "already in the process of turning the screen on.");
                        } else {
                            powerShortPress(event.getEventTime());
                        }
                        isWakeKey = false;
                    }
                    mPendingPowerKeyUpCanceled = false;
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                isWakeKey = false;
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        mPowerManager.wakeUp(event.getEventTime());
    }
    return result;
}
------------------------
Find a functionally equivalent code:com.android.wallpapercropper.WallpaperCropActivity.BitmapCropTask.regenerateInputStream:COMMENT
Method Modifier: private     
Comment:// Helper to setup input stream

Body of Frist Method:
{
    if (mInUri == null && mInResId == 0 && mInFilePath == null && mInImageBytes == null) {
        Log.w(LOGTAG, "cannot read original file, no input URI, resource ID, or " + "image byte array given");
    } else {
        Utils.closeSilently(mInStream);
        try {
            if (mInUri != null) {
                mInStream = new BufferedInputStream(mContext.getContentResolver().openInputStream(mInUri));
            } else if (mInFilePath != null) {
                mInStream = mContext.openFileInput(mInFilePath);
            } else if (mInImageBytes != null) {
                mInStream = new BufferedInputStream(new ByteArrayInputStream(mInImageBytes));
            } else {
                mInStream = new BufferedInputStream(mResources.openRawResource(mInResId));
            }
        } catch (FileNotFoundException e) {
            Log.w(LOGTAG, "cannot read file: " + mInUri.toString(), e);
        }
    }
}
Body of Second Method:
{
    if (mInUri == null && mInResId == 0 && mInFilePath == null && mInImageBytes == null) {
        Log.w(LOGTAG, "cannot read original file, no input URI, resource ID, or " + "image byte array given");
    } else {
        try {
            if (mInUri != null) {
                return new BufferedInputStream(mContext.getContentResolver().openInputStream(mInUri));
            } else if (mInFilePath != null) {
                return mContext.openFileInput(mInFilePath);
            } else if (mInImageBytes != null) {
                return new BufferedInputStream(new ByteArrayInputStream(mInImageBytes));
            } else {
                return new BufferedInputStream(mResources.openRawResource(mInResId));
            }
        } catch (FileNotFoundException e) {
            Log.w(LOGTAG, "cannot read file: " + mInUri.toString(), e);
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getWifiOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that wifi has been on while the device was
 * running on battery.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.util.ArraySet.contains:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether a value exists in the set.
 *
 * @param key The value to search for.
 * @return Returns true if the value exists, else false.
 */

Body of Frist Method:
{
    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
}
Body of Second Method:
{
    return indexOf(key) >= 0;
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setEvaluator:COMMENT
Method Modifier: public      
Comment:/**
 * The TypeEvaluator will be automatically determined based on the type of values
 * supplied to PropertyValuesHolder. The evaluator can be manually set, however, if so
 * desired. This may be important in cases where either the type of the values supplied
 * do not match the way that they should be interpolated between, or if the values
 * are of a custom type or one not currently understood by the animation system. Currently,
 * only values of type float and int (and their Object equivalents: Float
 * and Integer) are  correctly interpolated; all other types require setting a TypeEvaluator.
 * @param evaluator
 */

Body of Frist Method:
{
    mEvaluator = evaluator;
    mKeyframeSet.setEvaluator(evaluator);
}
Body of Second Method:
{
    mEvaluator = evaluator;
    mKeyframes.setEvaluator(evaluator);
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.setUp:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc }
 */

Body of Frist Method:
{
    super.setUp();
    DownloadManagerTestRunner mRunner = (DownloadManagerTestRunner) getInstrumentation();
    externalDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
    assertNotNull(externalDownloadUriValue);
    externalLargeDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
    assertNotNull(externalLargeDownloadUriValue);
}
Body of Second Method:
{
    super.setUp();
    DownloadManagerTestRunner mRunner = (DownloadManagerTestRunner) getInstrumentation();
    externalDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
    assertNotNull("download url is null", externalDownloadUriValue);
    externalLargeDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
    assertNotNull("large download url is null", externalLargeDownloadUriValue);
}
------------------------
Find a functionally equivalent code:android.view.LayoutInflater.setPrivateFactory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide for use by framework
 */

Body of Frist Method:
{
    mPrivateFactory = factory;
}
Body of Second Method:
{
    if (mPrivateFactory == null) {
        mPrivateFactory = factory;
    } else {
        mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setPlaybackStream:COMMENT
Method Modifier: public      
Comment:/**
 * Defines over what stream type the media is presented.
 * @param stream
 */

Body of Frist Method:
{
    if (mPlaybackStream != stream) {
        mPlaybackStream = stream;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_USES_STREAM, stream);
    }
}
Body of Second Method:
{
    if (mPlaybackStream != stream) {
        mPlaybackStream = stream;
        configureSessionVolume();
    }
}
------------------------
Find a functionally equivalent code:android.util.JsonReader.skipValue:COMMENT
Method Modifier: public      
Comment:/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */

Body of Frist Method:
{
    skipping = true;
    try {
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}
Body of Second Method:
{
    skipping = true;
    try {
        if (!hasNext() || peek() == JsonToken.END_DOCUMENT) {
            throw new IllegalStateException("No element left to skip");
        }
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readValueXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a flattened object from an XmlPullParser.  The XML data could
 * previously have been written with writeMapXml(), writeListXml(), or
 * writeValueXml().  The XmlPullParser must be positioned <em>at</em> the
 * tag that defines the value.
 *
 * @param parser The XmlPullParser from which to read the object.
 * @param name An array of one string, used to return the name attribute
 * of the value's tag.
 *
 * @return Object The newly generated value object.
 *
 * @see #readMapXml
 * @see #readListXml
 * @see #writeValueXml
 */

Body of Frist Method:
{
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            return readThisValueXml(parser, name);
        } else if (eventType == parser.END_TAG) {
            throw new XmlPullParserException("Unexpected end tag at: " + parser.getName());
        } else if (eventType == parser.TEXT) {
            throw new XmlPullParserException("Unexpected text: " + parser.getText());
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Unexpected end of document");
}
Body of Second Method:
{
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            return readThisValueXml(parser, name, null);
        } else if (eventType == parser.END_TAG) {
            throw new XmlPullParserException("Unexpected end tag at: " + parser.getName());
        } else if (eventType == parser.TEXT) {
            throw new XmlPullParserException("Unexpected text: " + parser.getText());
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Unexpected end of document");
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.Static.startMonitoringRoutes:COMMENT
Method Modifier: 
Comment:// Called after sStatic is initialized

Body of Frist Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.mPresentationDisplay = choosePresentationDisplayForRoute(mDefaultAudioVideo, getAllPresentationDisplays());
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectRouteStatic(mDefaultAudioVideo.getSupportedTypes(), mDefaultAudioVideo);
    }
}
Body of Second Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.updatePresentationDisplay();
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // Bind to the media router service.
    rebindAsUser(UserHandle.myUserId());
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectDefaultRouteStatic();
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetManager.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the AppWidgetManager instance to use for the supplied {@link android.content.Context
 * Context} object.
 */

Body of Frist Method:
{
    synchronized (sManagerCache) {
        if (sService == null) {
            IBinder b = ServiceManager.getService(Context.APPWIDGET_SERVICE);
            sService = IAppWidgetService.Stub.asInterface(b);
        }
        WeakReference<AppWidgetManager> ref = sManagerCache.get(context);
        AppWidgetManager result = null;
        if (ref != null) {
            result = ref.get();
        }
        if (result == null) {
            result = new AppWidgetManager(context);
            sManagerCache.put(context, new WeakReference<AppWidgetManager>(result));
        }
        return result;
    }
}
Body of Second Method:
{
    return (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
}
------------------------
Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.onPostExecute:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " onPostExecute");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " onPostExecute");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.interceptMediaKey:COMMENT
<com.android.keyguard.KeyguardViewBase: boolean interceptMediaKey(KeyEvent)>
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Allows the media keys to work when the keyguard is showing.
 * The media keys should be of no interest to the actual keyguard view(s),
 * so intercepting them here should not be of any harm.
 * @param event The key event
 * @return whether the event was consumed as a media key.
 */

Body of Frist Method:
{
    final int keyCode = event.getKeyCode();
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_MEDIA_PLAY:
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                /* Suppress PLAY/PAUSE toggle when phone is ringing or
                     * in-call to avoid music playback */
                if (mTelephonyManager == null) {
                    mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
                }
                if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
                    // suppress key event
                    return true;
                }
            case KeyEvent.KEYCODE_MUTE:
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_STOP:
            case KeyEvent.KEYCODE_MEDIA_NEXT:
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
            case KeyEvent.KEYCODE_MEDIA_REWIND:
            case KeyEvent.KEYCODE_MEDIA_RECORD:
            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
                {
                    handleMediaKeyEvent(event);
                    return true;
                }
            case KeyEvent.KEYCODE_VOLUME_UP:
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            case KeyEvent.KEYCODE_VOLUME_MUTE:
                {
                    if (KEYGUARD_MANAGES_VOLUME) {
                        synchronized (this) {
                            if (mAudioManager == null) {
                                mAudioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
                            }
                        }
                        // Volume buttons should only function for music (local or remote).
                        // TODO: Actually handle MUTE.
                        mAudioManager.adjustLocalOrRemoteStreamVolume(AudioManager.STREAM_MUSIC, keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER);
                        // Don't execute default volume behavior
                        return true;
                    } else {
                        return false;
                    }
                }
        }
    } else if (event.getAction() == KeyEvent.ACTION_UP) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_MUTE:
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_PLAY:
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_STOP:
            case KeyEvent.KEYCODE_MEDIA_NEXT:
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
            case KeyEvent.KEYCODE_MEDIA_REWIND:
            case KeyEvent.KEYCODE_MEDIA_RECORD:
            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
                {
                    handleMediaKeyEvent(event);
                    return true;
                }
        }
    }
    return false;
}
Body of Second Method:
{
    final int keyCode = event.getKeyCode();
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_MEDIA_PLAY:
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                /* Suppress PLAY/PAUSE toggle when phone is ringing or
                     * in-call to avoid music playback */
                if (mTelephonyManager == null) {
                    mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
                }
                if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
                    // suppress key event
                    return true;
                }
            case KeyEvent.KEYCODE_MUTE:
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_STOP:
            case KeyEvent.KEYCODE_MEDIA_NEXT:
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
            case KeyEvent.KEYCODE_MEDIA_REWIND:
            case KeyEvent.KEYCODE_MEDIA_RECORD:
            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
                {
                    handleMediaKeyEvent(event);
                    return true;
                }
            case KeyEvent.KEYCODE_VOLUME_UP:
            case KeyEvent.KEYCODE_VOLUME_DOWN:
            case KeyEvent.KEYCODE_VOLUME_MUTE:
                {
                    if (KEYGUARD_MANAGES_VOLUME) {
                        synchronized (this) {
                            if (mAudioManager == null) {
                                mAudioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
                            }
                        }
                        // Volume buttons should only function for music (local or remote).
                        // TODO: Actually handle MUTE.
                        mAudioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER, /* direction */
                        AudioManager.STREAM_MUSIC, /* stream */
                        0);
                        // Don't execute default volume behavior
                        return true;
                    } else {
                        return false;
                    }
                }
        }
    } else if (event.getAction() == KeyEvent.ACTION_UP) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_MUTE:
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_PLAY:
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            case KeyEvent.KEYCODE_MEDIA_STOP:
            case KeyEvent.KEYCODE_MEDIA_NEXT:
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
            case KeyEvent.KEYCODE_MEDIA_REWIND:
            case KeyEvent.KEYCODE_MEDIA_RECORD:
            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
                {
                    handleMediaKeyEvent(event);
                    return true;
                }
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardFaceUnlockView.maybeStartBiometricUnlock:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the biometric unlock if it should be started based on a number of factors.  If it
 * should not be started, it either goes to the back up, or remains showing to prepare for
 * it being started later.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "maybeStartBiometricUnlock()");
    if (mBiometricUnlock != null) {
        KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);
        final boolean backupIsTimedOut = (monitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT);
        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
        boolean isShowing;
        synchronized (mIsShowingLock) {
            isShowing = mIsShowing;
        }
        // showing.
        if (!powerManager.isScreenOn() || !isShowing) {
            // It shouldn't be running but calling this can't hurt.
            mBiometricUnlock.stop();
            return;
        }
        // the logic here is capable of suppressing Face Unlock.
        if (monitor.getPhoneState() == TelephonyManager.CALL_STATE_IDLE && monitor.isAlternateUnlockEnabled() && !monitor.getMaxBiometricUnlockAttemptsReached() && !backupIsTimedOut) {
            mBiometricUnlock.start();
        } else {
            mBiometricUnlock.stopAndShowBackup();
        }
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "maybeStartBiometricUnlock()");
    if (mBiometricUnlock != null) {
        KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);
        final boolean backupIsTimedOut = (monitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT);
        boolean isBouncerVisibleToUser;
        synchronized (mIsBouncerVisibleToUserLock) {
            isBouncerVisibleToUser = mIsBouncerVisibleToUser;
        }
        // it here and ready for when the bouncer does show.
        if (!isBouncerVisibleToUser) {
            // It shouldn't be running but calling this can't hurt.
            mBiometricUnlock.stop();
            return;
        }
        // the logic here is capable of suppressing Face Unlock.
        if (monitor.getPhoneState() == TelephonyManager.CALL_STATE_IDLE && monitor.isAlternateUnlockEnabled() && !monitor.getMaxBiometricUnlockAttemptsReached() && !backupIsTimedOut) {
            mBiometricUnlock.start();
        } else {
            mBiometricUnlock.stopAndShowBackup();
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.Ringtone.setUri:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set {@link Uri} to be used for ringtone playback. Attempts to open
 * locally, otherwise will delegate playback to remote
 * {@link IRingtonePlayer}.
 *
 * @hide
 */

Body of Frist Method:
{
    destroyLocalPlayer();
    mUri = uri;
    if (mUri == null) {
        return;
    }
    // TODO: detect READ_EXTERNAL and specific content provider case, instead of relying on throwing
    // try opening uri locally before delegating to remote player
    mLocalPlayer = new MediaPlayer();
    try {
        mLocalPlayer.setDataSource(mContext, mUri);
        mLocalPlayer.setAudioStreamType(mStreamType);
        mLocalPlayer.prepare();
    } catch (SecurityException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    } catch (IOException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    }
    if (LOGD) {
        if (mLocalPlayer != null) {
            Log.d(TAG, "Successfully created local player");
        } else {
            Log.d(TAG, "Problem opening; delegating to remote player");
        }
    }
}
Body of Second Method:
{
    destroyLocalPlayer();
    mUri = uri;
    if (mUri == null) {
        return;
    }
    // TODO: detect READ_EXTERNAL and specific content provider case, instead of relying on throwing
    // try opening uri locally before delegating to remote player
    mLocalPlayer = new MediaPlayer();
    try {
        mLocalPlayer.setDataSource(mContext, mUri);
        mLocalPlayer.setAudioAttributes(mAudioAttributes);
        mLocalPlayer.prepare();
    } catch (SecurityException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    } catch (IOException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    }
    if (LOGD) {
        if (mLocalPlayer != null) {
            Log.d(TAG, "Successfully created local player");
        } else {
            Log.d(TAG, "Problem opening; delegating to remote player");
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.Process.myTid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of the calling thread, which be used with
 * {@link #setThreadPriority(int, int)}.
 */

Body of Frist Method:
{
    return Libcore.os.gettid();
}
Body of Second Method:
{
    return Os.gettid();
}
------------------------
Find a functionally equivalent code:android.view.PointerIcon.load:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Loads the bitmap and hotspot information for a pointer icon, if it is not already loaded.
 * Returns a pointer icon (not necessarily the same instance) with the information filled in.
 *
 * @param context The context.
 * @return The loaded pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 * @see #isLoaded()
 * @hide
 */

Body of Frist Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (mSystemIconResourceId == 0 || mBitmap != null) {
        return this;
    }
    PointerIcon result = new PointerIcon(mStyle);
    result.mSystemIconResourceId = mSystemIconResourceId;
    result.loadResource(context.getResources(), mSystemIconResourceId);
    return result;
}
Body of Second Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (mSystemIconResourceId == 0 || mBitmap != null) {
        return this;
    }
    PointerIcon result = new PointerIcon(mStyle);
    result.mSystemIconResourceId = mSystemIconResourceId;
    result.loadResource(context, context.getResources(), mSystemIconResourceId);
    return result;
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerStart:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to boolean: " + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getBoolean of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to boolean: " + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getBoolean of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a functionally equivalent code:android.transition.Transition.captureValues:COMMENT
Method Modifier: 
Comment:/**
 * Recursive method that captures values for the given view and the
 * hierarchy underneath it.
 * @param sceneRoot The root of the view hierarchy being captured
 * @param start true if this capture is happening before the scene change,
 * false otherwise
 */

Body of Frist Method:
{
    if (start) {
        mStartValues.viewValues.clear();
        mStartValues.idValues.clear();
        mStartValues.itemIdValues.clear();
    } else {
        mEndValues.viewValues.clear();
        mEndValues.idValues.clear();
        mEndValues.itemIdValues.clear();
    }
    if (mTargetIds.size() > 0 || mTargets.size() > 0) {
        if (mTargetIds.size() > 0) {
            for (int i = 0; i < mTargetIds.size(); ++i) {
                int id = mTargetIds.get(i);
                View view = sceneRoot.findViewById(id);
                if (view != null) {
                    TransitionValues values = new TransitionValues();
                    values.view = view;
                    if (start) {
                        captureStartValues(values);
                    } else {
                        captureEndValues(values);
                    }
                    if (start) {
                        mStartValues.viewValues.put(view, values);
                        if (id >= 0) {
                            mStartValues.idValues.put(id, values);
                        }
                    } else {
                        mEndValues.viewValues.put(view, values);
                        if (id >= 0) {
                            mEndValues.idValues.put(id, values);
                        }
                    }
                }
            }
        }
        if (mTargets.size() > 0) {
            for (int i = 0; i < mTargets.size(); ++i) {
                View view = mTargets.get(i);
                if (view != null) {
                    TransitionValues values = new TransitionValues();
                    values.view = view;
                    if (start) {
                        captureStartValues(values);
                    } else {
                        captureEndValues(values);
                    }
                    if (start) {
                        mStartValues.viewValues.put(view, values);
                    } else {
                        mEndValues.viewValues.put(view, values);
                    }
                }
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
}
Body of Second Method:
{
    clearValues(start);
    if ((mTargetIds.size() > 0 || mTargets.size() > 0) && (mTargetNames == null || mTargetNames.isEmpty()) && (mTargetTypes == null || mTargetTypes.isEmpty())) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            int id = mTargetIds.get(i);
            View view = sceneRoot.findViewById(id);
            if (view != null) {
                TransitionValues values = new TransitionValues();
                values.view = view;
                if (start) {
                    captureStartValues(values);
                } else {
                    captureEndValues(values);
                }
                values.targetedTransitions.add(this);
                capturePropagationValues(values);
                if (start) {
                    addViewValues(mStartValues, view, values);
                } else {
                    addViewValues(mEndValues, view, values);
                }
            }
        }
        for (int i = 0; i < mTargets.size(); ++i) {
            View view = mTargets.get(i);
            TransitionValues values = new TransitionValues();
            values.view = view;
            if (start) {
                captureStartValues(values);
            } else {
                captureEndValues(values);
            }
            values.targetedTransitions.add(this);
            capturePropagationValues(values);
            if (start) {
                addViewValues(mStartValues, view, values);
            } else {
                addViewValues(mEndValues, view, values);
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
    if (!start && mNameOverrides != null) {
        int numOverrides = mNameOverrides.size();
        ArrayList<View> overriddenViews = new ArrayList<View>(numOverrides);
        for (int i = 0; i < numOverrides; i++) {
            String fromName = mNameOverrides.keyAt(i);
            overriddenViews.add(mStartValues.nameValues.remove(fromName));
        }
        for (int i = 0; i < numOverrides; i++) {
            View view = overriddenViews.get(i);
            if (view != null) {
                String toName = mNameOverrides.valueAt(i);
                mStartValues.nameValues.put(toName, view);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setColorFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the paint's colorfilter, returning the parameter.
 *
 * @param filter May be null. The new filter to be installed in the paint
 * @return       filter
 */

Body of Frist Method:
{
    int filterNative = 0;
    if (filter != null)
        filterNative = filter.native_instance;
    native_setColorFilter(mNativePaint, filterNative);
    mColorFilter = filter;
    return filter;
}
Body of Second Method:
{
    long filterNative = 0;
    if (filter != null)
        filterNative = filter.native_instance;
    native_setColorFilter(mNativePaint, filterNative);
    mColorFilter = filter;
    return filter;
}
------------------------
Find a functionally equivalent code:com.android.systemui.SwipeHelper.dismissChild:COMMENT
Method Modifier: public      
Comment:/**
 * @param view The view to be dismissed
 * @param velocity The desired pixels/second speed at which the view should move
 */

Body of Frist Method:
{
    final View animView = mCallback.getChildContentView(view);
    final boolean canAnimViewBeDismissed = mCallback.canChildBeDismissed(view);
    float newPos;
    if (velocity < 0 || (velocity == 0 && getTranslation(animView) < 0) || // if we use the Menu to dismiss an item in landscape, animate up
    (velocity == 0 && getTranslation(animView) == 0 && mSwipeDirection == Y)) {
        newPos = -getSize(animView);
    } else {
        newPos = getSize(animView);
    }
    int duration = MAX_ESCAPE_ANIMATION_DURATION;
    if (velocity != 0) {
        duration = Math.min(duration, (int) (Math.abs(newPos - getTranslation(animView)) * 1000f / Math.abs(velocity)));
    } else {
        duration = DEFAULT_ESCAPE_ANIMATION_DURATION;
    }
    animView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    ObjectAnimator anim = createTranslationAnimation(animView, newPos);
    anim.setInterpolator(sLinearInterpolator);
    anim.setDuration(duration);
    anim.addListener(new AnimatorListenerAdapter() {

        public void onAnimationEnd(Animator animation) {
            mCallback.onChildDismissed(view);
            animView.setLayerType(View.LAYER_TYPE_NONE, null);
        }
    });
    anim.addUpdateListener(new AnimatorUpdateListener() {

        public void onAnimationUpdate(ValueAnimator animation) {
            updateAlphaFromOffset(animView, canAnimViewBeDismissed);
        }
    });
    anim.start();
}
Body of Second Method:
{
    dismissChild(view, velocity, null, 0, false, 0);
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.setMasterSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param sync the master auto-sync setting that applies to all the providers and accounts
 */

Body of Frist Method:
{
    try {
        getContentService().setMasterSyncAutomatically(sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    setMasterSyncAutomaticallyAsUser(sync, UserHandle.myUserId());
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.openFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */

Body of Frist Method:
{
    return openDocument(getDocumentId(uri), mode, signal);
}
Body of Second Method:
{
    enforceTree(uri);
    return openDocument(getDocumentId(uri), mode, signal);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */

Body of Frist Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
Body of Second Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getChildCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of children.
 *
 * @return The child count.
 */

Body of Frist Method:
{
    return mChildNodeIds.size();
}
Body of Second Method:
{
    return mChildNodeIds == null ? 0 : mChildNodeIds.size();
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.addNewDelegate:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a delegate to the manager and returns the native int used to identify it.
 * @param newDelegate the delegate to add
 * @return a unique native int to identify the delegate
 */

Body of Frist Method:
{
    int native_object = ++mDelegateCounter;
    mDelegates.put(native_object, newDelegate);
    assert !mJavaReferences.contains(newDelegate);
    mJavaReferences.add(newDelegate);
    if (Debug.DEBUG) {
        System.out.println("New " + mClass.getSimpleName() + " with int " + native_object);
    }
    return native_object;
}
Body of Second Method:
{
    long native_object = ++mDelegateCounter;
    mDelegates.put(native_object, newDelegate);
    assert !mJavaReferences.contains(newDelegate);
    mJavaReferences.add(newDelegate);
    if (Debug.DEBUG) {
        System.out.println("New " + mClass.getSimpleName() + " with int " + native_object);
    }
    return native_object;
}
------------------------
Find a functionally equivalent code:com.android.systemui.usb.StorageNotification.setUsbStorageNotification:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the USB storage notification.
 */

Body of Frist Method:
{
    if (!visible && mUsbStorageNotification == null) {
        return;
    }
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (visible) {
        Resources r = Resources.getSystem();
        CharSequence title = r.getText(titleId);
        CharSequence message = r.getText(messageId);
        if (mUsbStorageNotification == null) {
            mUsbStorageNotification = new Notification();
            mUsbStorageNotification.icon = icon;
            mUsbStorageNotification.when = 0;
        }
        if (sound) {
            mUsbStorageNotification.defaults |= Notification.DEFAULT_SOUND;
        } else {
            mUsbStorageNotification.defaults &= ~Notification.DEFAULT_SOUND;
        }
        mUsbStorageNotification.flags = Notification.FLAG_ONGOING_EVENT;
        mUsbStorageNotification.tickerText = title;
        if (pi == null) {
            Intent intent = new Intent();
            pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
        }
        mUsbStorageNotification.setLatestEventInfo(mContext, title, message, pi);
        final boolean adbOn = 1 == Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.ADB_ENABLED, 0);
        if (POP_UMS_ACTIVITY_ON_CONNECT && !adbOn) {
            // Pop up a full-screen alert to coach the user through enabling UMS. The average
            // user has attached the device to USB either to charge the phone (in which case
            // this is harmless) or transfer files, and in the latter case this alert saves
            // several steps (as well as subtly indicates that you shouldn't mix UMS with other
            // activities on the device).
            // 
            // If ADB is enabled, however, we suppress this dialog (under the assumption that a
            // developer (a) knows how to enable UMS, and (b) is probably using USB to install
            // builds or use adb commands.
            mUsbStorageNotification.fullScreenIntent = pi;
        }
    }
    final int notificationId = mUsbStorageNotification.icon;
    if (visible) {
        notificationManager.notifyAsUser(null, notificationId, mUsbStorageNotification, UserHandle.ALL);
    } else {
        notificationManager.cancelAsUser(null, notificationId, UserHandle.ALL);
    }
}
Body of Second Method:
{
    if (!visible && mUsbStorageNotification == null) {
        return;
    }
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (visible) {
        Resources r = Resources.getSystem();
        CharSequence title = r.getText(titleId);
        CharSequence message = r.getText(messageId);
        if (mUsbStorageNotification == null) {
            mUsbStorageNotification = new Notification();
            mUsbStorageNotification.icon = icon;
            mUsbStorageNotification.when = 0;
        }
        if (sound) {
            mUsbStorageNotification.defaults |= Notification.DEFAULT_SOUND;
        } else {
            mUsbStorageNotification.defaults &= ~Notification.DEFAULT_SOUND;
        }
        mUsbStorageNotification.flags = Notification.FLAG_ONGOING_EVENT;
        mUsbStorageNotification.tickerText = title;
        if (pi == null) {
            Intent intent = new Intent();
            pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
        }
        mUsbStorageNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
        mUsbStorageNotification.setLatestEventInfo(mContext, title, message, pi);
        mUsbStorageNotification.visibility = Notification.VISIBILITY_PUBLIC;
        mUsbStorageNotification.category = Notification.CATEGORY_SYSTEM;
        final boolean adbOn = 1 == Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.ADB_ENABLED, 0);
        if (POP_UMS_ACTIVITY_ON_CONNECT && !adbOn) {
            // Pop up a full-screen alert to coach the user through enabling UMS. The average
            // user has attached the device to USB either to charge the phone (in which case
            // this is harmless) or transfer files, and in the latter case this alert saves
            // several steps (as well as subtly indicates that you shouldn't mix UMS with other
            // activities on the device).
            // 
            // If ADB is enabled, however, we suppress this dialog (under the assumption that a
            // developer (a) knows how to enable UMS, and (b) is probably using USB to install
            // builds or use adb commands.
            mUsbStorageNotification.fullScreenIntent = pi;
        }
    }
    final int notificationId = mUsbStorageNotification.icon;
    if (visible) {
        notificationManager.notifyAsUser(null, notificationId, mUsbStorageNotification, UserHandle.ALL);
    } else {
        notificationManager.cancelAsUser(null, notificationId, UserHandle.ALL);
    }
}
------------------------
Find a functionally equivalent code:android.util.ArrayMap.remove:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an existing key from the array map.
 * @param key The key of the mapping to remove.
 * @return Returns the value that was stored under the key, or null if there
 * was no such key.
 */

Body of Frist Method:
{
    int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}
Body of Second Method:
{
    final int index = indexOfKey(key);
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        default:
            return null;
    }
}
------------------------
Find a functionally equivalent code:android.os.FileUtils.getUid:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return owning UID of given path, otherwise -1.
 */

Body of Frist Method:
{
    try {
        return Libcore.os.stat(path).st_uid;
    } catch (ErrnoException e) {
        return -1;
    }
}
Body of Second Method:
{
    try {
        return Os.stat(path).st_uid;
    } catch (ErrnoException e) {
        return -1;
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.BigTextStyle.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.addExtras(extras);
    extras.putCharSequence(EXTRA_TEXT, mBigText);
}
Body of Second Method:
{
    super.addExtras(extras);
    extras.putCharSequence(EXTRA_BIG_TEXT, mBigText);
}
------------------------
Find a functionally equivalent code:android.transition.TransitionSet.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Setting a non-negative duration on a TransitionSet causes all of the child
 * transitions (current and future) to inherit this duration.
 *
 * @param duration The length of the animation, in milliseconds.
 * @return This transitionSet object.
 */

Body of Frist Method:
{
    super.setDuration(duration);
    if (mDuration >= 0) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}
Body of Second Method:
{
    super.setDuration(duration);
    if (mDuration >= 0 && mTransitions != null) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}
------------------------
Find a functionally equivalent code:android.transition.TransitionSet.runAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setupStartEndListeners();
    if (!mPlayTogether) {
        // TODO: Need to add listeners in such a way that we can remove them later if canceled
        for (int i = 1; i < mTransitions.size(); ++i) {
            Transition previousTransition = mTransitions.get(i - 1);
            final Transition nextTransition = mTransitions.get(i);
            previousTransition.addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    nextTransition.runAnimators();
                    transition.removeListener(this);
                }
            });
        }
        Transition firstTransition = mTransitions.get(0);
        if (firstTransition != null) {
            firstTransition.runAnimators();
        }
    } else {
        for (Transition childTransition : mTransitions) {
            childTransition.runAnimators();
        }
    }
}
Body of Second Method:
{
    if (mTransitions.isEmpty()) {
        start();
        end();
        return;
    }
    setupStartEndListeners();
    int numTransitions = mTransitions.size();
    if (!mPlayTogether) {
        // TODO: Need to add listeners in such a way that we can remove them later if canceled
        for (int i = 1; i < numTransitions; ++i) {
            Transition previousTransition = mTransitions.get(i - 1);
            final Transition nextTransition = mTransitions.get(i);
            previousTransition.addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    nextTransition.runAnimators();
                    transition.removeListener(this);
                }
            });
        }
        Transition firstTransition = mTransitions.get(0);
        if (firstTransition != null) {
            firstTransition.runAnimators();
        }
    } else {
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).runAnimators();
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.BaseStatusBar.visibilityChanged:COMMENT
Method Modifier: protected   
Comment:/**
 * The LEDs are turned o)ff when the notification panel is shown, even just a little bit.
 * This was added last-minute and is inconsistent with the way the rest of the notifications
 * are handled, because the notification isn't really cancelled.  The lights are just
 * turned off.  If any other notifications happen, the lights will turn back on.  Steve says
 * this is what he wants. (see bug 1131461)
 */

Body of Frist Method:
{
    if (mPanelSlightlyVisible != visible) {
        mPanelSlightlyVisible = visible;
        try {
            mBarService.onPanelRevealed();
        } catch (RemoteException ex) {
        // Won't fail unless the world has ended.
        }
    }
}
Body of Second Method:
{
    if (mPanelSlightlyVisible != visible) {
        mPanelSlightlyVisible = visible;
        if (!visible) {
            dismissPopups();
        }
        try {
            if (visible) {
                mBarService.onPanelRevealed();
            } else {
                mBarService.onPanelHidden();
            }
        } catch (RemoteException ex) {
        // Won't fail unless the world has ended.
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the background color for the selected week.
 *
 * @param color The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

Body of Frist Method:
{
    if (mSelectedWeekBackgroundColor != color) {
        mSelectedWeekBackgroundColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasSelectedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setSelectedWeekBackgroundColor(color);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHostView.getRemoteContext:COMMENT
Method Modifier: private     
Comment:/**
 * Build a {@link Context} cloned into another package name, usually for the
 * purposes of reading remote resources.
 */

Body of Frist Method:
{
    // Bail if missing package name
    final String packageName = views.getPackage();
    if (packageName == null)
        return mContext;
    try {
        // Return if cloned successfully, otherwise default
        return mContext.createPackageContextAsUser(packageName, Context.CONTEXT_RESTRICTED, mUser);
    } catch (NameNotFoundException e) {
        Log.e(TAG, "Package name " + packageName + " not found");
        return mContext;
    }
}
Body of Second Method:
{
    try {
        // Return if cloned successfully, otherwise default
        return mContext.createApplicationContext(mInfo.providerInfo.applicationInfo, Context.CONTEXT_RESTRICTED);
    } catch (NameNotFoundException e) {
        Log.e(TAG, "Package name " + mInfo.providerInfo.packageName + " not found");
        return mContext;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Rect.unflattenFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a Rect from a string of the form returned by {@link #flattenToString},
 * or null if the string is not of that form.
 */

Body of Frist Method:
{
    Matcher matcher = FLATTENED_PATTERN.matcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
Body of Second Method:
{
    Matcher matcher = UnflattenHelper.getMatcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Stop listening to changes for this AppWidget.
 */

Body of Frist Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(appWidgetId, mContext.getUserId());
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.provider.MediaStore.InternalThumbnails.getThumbnail:COMMENT
Method Modifier: default     static      
Comment:/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */

Body of Frist Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
Body of Second Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    if (RenderResources.REFERENCE_NULL.equals(value)) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser);
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser);
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mDataLoadMode is valid

Body of Frist Method:
{
    // stream type
    if ((streamType != AudioManager.STREAM_ALARM) && (streamType != AudioManager.STREAM_MUSIC) && (streamType != AudioManager.STREAM_RING) && (streamType != AudioManager.STREAM_SYSTEM) && (streamType != AudioManager.STREAM_VOICE_CALL) && (streamType != AudioManager.STREAM_NOTIFICATION) && (streamType != AudioManager.STREAM_BLUETOOTH_SCO) && (streamType != AudioManager.STREAM_DTMF)) {
        throw new IllegalArgumentException("Invalid stream type.");
    }
    mStreamType = streamType;
    // sample rate, note these values are subject to change
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannels = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannels = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannels = channelConfig;
            mChannelCount = Integer.bitCount(channelConfig);
    }
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
    // audio load mode
    if ((mode != MODE_STREAM) && (mode != MODE_STATIC)) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
Body of Second Method:
{
    // sample rate, note these values are subject to change
    if (sampleRateInHz < SAMPLE_RATE_HZ_MIN || sampleRateInHz > SAMPLE_RATE_HZ_MAX) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannels = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannels = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannels = channelConfig;
            mChannelCount = Integer.bitCount(channelConfig);
    }
    // audio format
    if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
        audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    }
    if (!AudioFormat.isValidEncoding(audioFormat)) {
        throw new IllegalArgumentException("Unsupported audio encoding.");
    }
    mAudioFormat = audioFormat;
    // audio load mode
    if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.invalidateChildInParent:COMMENT
Method Modifier: public      
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */

Body of Frist Method:
{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}
Body of Second Method:
{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.app.AlertDialog.Builder.setView:COMMENT
Method Modifier: public      
Comment:/**
 * Set a custom view to be the contents of the Dialog. If the supplied view is an instance
 * of a {@link ListView} the light background will be used.
 *
 * @param view The view to use as the contents of the Dialog.
 *
 * @return This Builder object to allow for chaining of calls to set methods
 */

Body of Frist Method:
{
    P.mView = view;
    P.mViewSpacingSpecified = false;
    return this;
}
Body of Second Method:
{
    P.mView = view;
    P.mViewLayoutResId = 0;
    P.mViewSpacingSpecified = false;
    return this;
}
------------------------
Find a functionally equivalent code:android.media.MediaRecorder.setCaptureRate:COMMENT
Method Modifier: public      
Comment:/**
 * Set video frame capture rate. This can be used to set a different video frame capture
 * rate than the recorded video's playback rate. This method also sets the recording mode
 * to time lapse. In time lapse video recording, only video is recorded. Audio related
 * parameters are ignored when a time lapse recording session starts, if an application
 * sets them.
 *
 * @param fps Rate at which frames should be captured in frames per second.
 * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
 * For resolutions that can be captured by the video camera, the fastest fps can be computed using
 * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
 * resolutions the fastest fps may be more restrictive.
 * Note that the recorder cannot guarantee that frames will be captured at the
 * given rate due to camera/encoder limitations. However it tries to be as close as
 * possible.
 */

Body of Frist Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    double timeBetweenFrameCapture = 1 / fps;
    int timeBetweenFrameCaptureMs = (int) (1000 * timeBetweenFrameCapture);
    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureMs);
}
Body of Second Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    double timeBetweenFrameCapture = 1 / fps;
    long timeBetweenFrameCaptureUs = (long) (1000000 * timeBetweenFrameCapture);
    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureUs);
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    String value = mResourceData[index].getValue();
    if (value != null) {
        if (RenderResources.REFERENCE_NULL.equals(value)) {
            return null;
        }
        return new CharSequence[] { value };
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format(// DEBUG
    String.format(// DEBUG
    "Unknown value for getTextArray(%d) => %s", index, mResourceData[index].getName())), null);
    return null;
}
Body of Second Method:
{
    String value = getString(index);
    if (value != null) {
        return new CharSequence[] { value };
    }
    return null;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getActivePasswordQuality:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Used by device policy manager to validate the current password
 * information it has.
 */

Body of Frist Method:
{
    int activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
    // Note we don't want to use getKeyguardStoredPasswordQuality() because we want this to
    // return biometric_weak if that is being used instead of the backup
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    switch(quality) {
        case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:
            if (isLockPatternEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK:
            if (isBiometricWeakInstalled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_COMPLEX:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
            }
            break;
    }
    return activePasswordQuality;
}
Body of Second Method:
{
    int activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
    // Note we don't want to use getKeyguardStoredPasswordQuality() because we want this to
    // return biometric_weak if that is being used instead of the backup
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    switch(quality) {
        case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:
            if (isLockPatternEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK:
            if (isBiometricWeakInstalled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;
            }
            break;
        case DevicePolicyManager.PASSWORD_QUALITY_COMPLEX:
            if (isLockPasswordEnabled()) {
                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
            }
            break;
    }
    return activePasswordQuality;
}
------------------------
Find a functionally equivalent code:android.app.SearchManager.startSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */

Body of Frist Method:
{
    startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, null);
}
Body of Second Method:
{
    startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, null);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callGet:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link OuterClass#get} or {@link InnerClass#get}via reflection.
 */

Body of Frist Method:
{
    Method m = instance.getClass().getMethod("get", new Class<?>[] { int.class, long.class });
    Object result = m.invoke(instance, new Object[] { a, b });
    return ((Integer) result).intValue();
}
Body of Second Method:
{
    Method m = instance.getClass().getMethod("get", int.class, long.class);
    Object result = m.invoke(instance, a, b);
    return (Integer) result;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyUpPanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Called when the panel key is released.
 * @param featureId The feature ID of the relevant panel (defaults to FEATURE_OPTIONS_PANEL}.
 * @param event The key event.
 */

Body of Frist Method:
{
    // The panel key was released, so clear the chording key
    if (mPanelChordingKey != 0) {
        mPanelChordingKey = 0;
        if (event.isCanceled() || (mDecor != null && mDecor.mActionMode != null)) {
            return;
        }
        boolean playSoundEffect = false;
        final PanelFeatureState st = getPanelState(featureId, true);
        if (featureId == FEATURE_OPTIONS_PANEL && mActionBar != null && mActionBar.isOverflowReserved() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
            if (mActionBar.getVisibility() == View.VISIBLE) {
                if (!mActionBar.isOverflowMenuShowing()) {
                    if (!isDestroyed() && preparePanel(st, event)) {
                        playSoundEffect = mActionBar.showOverflowMenu();
                    }
                } else {
                    playSoundEffect = mActionBar.hideOverflowMenu();
                }
            }
        } else {
            if (st.isOpen || st.isHandled) {
                // Play the sound effect if the user closed an open menu (and not if
                // they just released a menu shortcut)
                playSoundEffect = st.isOpen;
                // Close menu
                closePanel(st, true);
            } else if (st.isPrepared) {
                boolean show = true;
                if (st.refreshMenuContent) {
                    // Something may have invalidated the menu since we prepared it.
                    // Re-prepare it to refresh.
                    st.isPrepared = false;
                    show = preparePanel(st, event);
                }
                if (show) {
                    // Write 'menu opened' to event log
                    EventLog.writeEvent(50001, 0);
                    // Show menu
                    openPanel(st, event);
                    playSoundEffect = true;
                }
            }
        }
        if (playSoundEffect) {
            AudioManager audioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
            if (audioManager != null) {
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
            } else {
                Log.w(TAG, "Couldn't get audio manager");
            }
        }
    }
}
Body of Second Method:
{
    // The panel key was released, so clear the chording key
    if (mPanelChordingKey != 0) {
        mPanelChordingKey = 0;
        if (event.isCanceled() || (mDecor != null && mDecor.mActionMode != null)) {
            return;
        }
        boolean playSoundEffect = false;
        final PanelFeatureState st = getPanelState(featureId, true);
        if (featureId == FEATURE_OPTIONS_PANEL && mDecorContentParent != null && mDecorContentParent.canShowOverflowMenu() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
            if (!mDecorContentParent.isOverflowMenuShowing()) {
                if (!isDestroyed() && preparePanel(st, event)) {
                    playSoundEffect = mDecorContentParent.showOverflowMenu();
                }
            } else {
                playSoundEffect = mDecorContentParent.hideOverflowMenu();
            }
        } else {
            if (st.isOpen || st.isHandled) {
                // Play the sound effect if the user closed an open menu (and not if
                // they just released a menu shortcut)
                playSoundEffect = st.isOpen;
                // Close menu
                closePanel(st, true);
            } else if (st.isPrepared) {
                boolean show = true;
                if (st.refreshMenuContent) {
                    // Something may have invalidated the menu since we prepared it.
                    // Re-prepare it to refresh.
                    st.isPrepared = false;
                    show = preparePanel(st, event);
                }
                if (show) {
                    // Write 'menu opened' to event log
                    EventLog.writeEvent(50001, 0);
                    // Show menu
                    openPanel(st, event);
                    playSoundEffect = true;
                }
            }
        }
        if (playSoundEffect) {
            AudioManager audioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
            if (audioManager != null) {
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
            } else {
                Log.w(TAG, "Couldn't get audio manager");
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getPhoneSignalStrengthTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been running with
 * the given signal strength.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.transition.TransitionInflater.from:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtains the TransitionInflater from the given context.
 */

Body of Frist Method:
{
    TransitionInflater inflater = sInflaterMap.get(context);
    if (inflater != null) {
        return inflater;
    }
    inflater = new TransitionInflater(context);
    sInflaterMap.put(context, inflater);
    return inflater;
}
Body of Second Method:
{
    return new TransitionInflater(context);
}
------------------------
Find a functionally equivalent code:android.graphics.Path.isInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the filltype is one of the INVERSE variants
 *
 * @return true if the filltype is one of the INVERSE variants
 */

Body of Frist Method:
{
    final int ft = native_getFillType(mNativePath);
    return (ft & 2) != 0;
}
Body of Second Method:
{
    final int ft = native_getFillType(mNativePath);
    return (ft & FillType.INVERSE_WINDING.nativeInt) != 0;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.CollectionInfo.obtain:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtains a pooled instance.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 */

Body of Frist Method:
{
    CollectionInfo info = sPool.acquire();
    return (info != null) ? info : new CollectionInfo(rowCount, columnCount, hierarchical);
}
Body of Second Method:
{
    return obtain(rowCount, columnCount, hierarchical, SELECTION_MODE_NONE);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.checkSendBecomingNoisyIntent:COMMENT
Method Modifier: private     
Comment:// must be called before removing the device from mConnectedDevices

Body of Frist Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if ((dev & mBecomingNoisyIntentDevices) != 0) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
Body of Second Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
------------------------
Find a functionally equivalent code:android.widget.TextView.getTextColors:COMMENT
Method Modifier: public      final       
Comment:/**
 * Gets the text colors for the different states (normal, selected, focused) of the TextView.
 *
 * @see #setTextColor(ColorStateList)
 * @see #setTextColor(int)
 *
 * @attr ref android.R.styleable#TextView_textColor
 */

Body of Frist Method:
{
    return mTextColor;
}
Body of Second Method:
{
    return mTextColor;
}
------------------------
Find a functionally equivalent code:android.content.pm.Signature.areExactMatch:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Test if given {@link Signature} sets are exactly equal.
 *
 * @hide
 */

Body of Frist Method:
{
    return ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
Body of Second Method:
{
    return (a.length == b.length) && ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
------------------------
Find a functionally equivalent code:android.os.storage.IMountService.encryptStorage:COMMENT
Method Modifier: public      
Comment:/**
 * Encrypts storage.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the type for this restriction.
 * @param type the type for this restriction.
 */

Body of Frist Method:
{
    this.type = type;
}
Body of Second Method:
{
    this.mType = type;
}
------------------------
Find a functionally equivalent code:android.animation.AnimatorSet.Builder.before:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */

Body of Frist Method:
{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}
Body of Second Method:
{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */

Body of Frist Method:
{
    unparcel();
    if (DEBUG)
        Log.d(TAG, "Getting boolean in " + Integer.toHexString(System.identityHashCode(this)));
    return getBoolean(key, false);
}
Body of Second Method:
{
    return super.getBoolean(key);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.stop:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Stops the animation. This method has no effect if the animation is
 * not running.</p>
 *
 * @see #isRunning()
 * @see #start()
 */

Body of Frist Method:
{
    if (isRunning()) {
        unscheduleSelf(this);
    }
}
Body of Second Method:
{
    mAnimating = false;
    if (isRunning()) {
        unscheduleSelf(this);
    }
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.onLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * Subclasses should NOT override this method but
 * {@link #layoutChildren()} instead.
 */

Body of Frist Method:
{
    super.onLayout(changed, l, t, r, b);
    mInLayout = true;
    if (changed) {
        int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }
    if (mFastScroller != null && (mItemCount != mOldItemCount || mDataChanged)) {
        mFastScroller.onItemCountChanged(mItemCount);
    }
    layoutChildren();
    mInLayout = false;
    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
}
Body of Second Method:
{
    super.onLayout(changed, l, t, r, b);
    mInLayout = true;
    final int childCount = getChildCount();
    if (changed) {
        for (int i = 0; i < childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }
    layoutChildren();
    mInLayout = false;
    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
    // TODO: Move somewhere sane. This doesn't belong in onLayout().
    if (mFastScroll != null) {
        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

Body of Frist Method:
{
    return mMinDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getMinDate();
}
------------------------
Find a functionally equivalent code:android.widget.TextView.handleTextChanged:COMMENT
Method Modifier: 
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
Body of Second Method:
{
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    resetErrorChangedFlag();
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
------------------------
Find a functionally equivalent code:android.print.PrintJobInfo.Builder.putAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Puts an advanced (printer specific) option.
 *
 * @param key The option key.
 * @param value The option value.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (mPrototype.mAdvancedOptions == null) {
        mPrototype.mAdvancedOptions = new Bundle();
    }
    mPrototype.mAdvancedOptions.putInt(key, value);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.saveHierarchyState:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    Bundle outState = new Bundle();
    if (mContentParent == null) {
        return outState;
    }
    SparseArray<Parcelable> states = new SparseArray<Parcelable>();
    mContentParent.saveHierarchyState(states);
    outState.putSparseParcelableArray(VIEWS_TAG, states);
    // save the focused view id
    View focusedView = mContentParent.findFocus();
    if (focusedView != null) {
        if (focusedView.getId() != View.NO_ID) {
            outState.putInt(FOCUSED_ID_TAG, focusedView.getId());
        } else {
            if (false) {
                Log.d(TAG, "couldn't save which view has focus because the focused view " + focusedView + " has no id.");
            }
        }
    }
    // save the panels
    SparseArray<Parcelable> panelStates = new SparseArray<Parcelable>();
    savePanelState(panelStates);
    if (panelStates.size() > 0) {
        outState.putSparseParcelableArray(PANELS_TAG, panelStates);
    }
    if (mActionBar != null) {
        SparseArray<Parcelable> actionBarStates = new SparseArray<Parcelable>();
        mActionBar.saveHierarchyState(actionBarStates);
        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
    }
    return outState;
}
Body of Second Method:
{
    Bundle outState = new Bundle();
    if (mContentParent == null) {
        return outState;
    }
    SparseArray<Parcelable> states = new SparseArray<Parcelable>();
    mContentParent.saveHierarchyState(states);
    outState.putSparseParcelableArray(VIEWS_TAG, states);
    // save the focused view id
    View focusedView = mContentParent.findFocus();
    if (focusedView != null) {
        if (focusedView.getId() != View.NO_ID) {
            outState.putInt(FOCUSED_ID_TAG, focusedView.getId());
        } else {
            if (false) {
                Log.d(TAG, "couldn't save which view has focus because the focused view " + focusedView + " has no id.");
            }
        }
    }
    // save the panels
    SparseArray<Parcelable> panelStates = new SparseArray<Parcelable>();
    savePanelState(panelStates);
    if (panelStates.size() > 0) {
        outState.putSparseParcelableArray(PANELS_TAG, panelStates);
    }
    if (mDecorContentParent != null) {
        SparseArray<Parcelable> actionBarStates = new SparseArray<Parcelable>();
        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);
        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
    }
    return outState;
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.seekTo:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the new playback position.
 * This method can only be called on a registered RemoteController.
 * @param timeMs a 0 or positive value for the new playback position, expressed in ms.
 * @return true if the command to set the playback position was successfully sent.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!mEnabled) {
        Log.e(TAG, "Cannot use seekTo() from a disabled RemoteController");
        return false;
    }
    if (timeMs < 0) {
        throw new IllegalArgumentException("illegal negative time value");
    }
    final int genId;
    synchronized (mGenLock) {
        genId = mClientGenerationIdCurrent;
    }
    mAudioManager.setRemoteControlClientPlaybackPosition(genId, timeMs);
    return true;
}
Body of Second Method:
{
    if (!mEnabled) {
        Log.e(TAG, "Cannot use seekTo() from a disabled RemoteController");
        return false;
    }
    if (timeMs < 0) {
        throw new IllegalArgumentException("illegal negative time value");
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            mCurrentSession.getTransportControls().seekTo(timeMs);
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.doInBackground:COMMENT
Method Modifier: protected   
Comment:/* Runs on a worker thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " >>> doInBackground");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + "  <<< doInBackground");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
        return null;
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " >>> doInBackground");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Log.v(TAG, this + "  <<< doInBackground");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Log.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
        return null;
    }
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runLargeDownloadOverWiFi:COMMENT
Method Modifier: public      
Comment:/**
 * Tests downloading a large file over WiFi (~10 Mb).
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_10MB_FILENAME;
    long filesize = DOWNLOAD_10MB_FILESIZE;
    long dlRequest = -1;
    doCommonDownloadSetup();
    // Make sure there are no pending downloads currently going on
    removeAllCurrentDownloads();
    Uri remoteUri = getExternalFileUri(filename);
    Request request = new Request(remoteUri);
    request.setMimeType("application/vnd.android.package-archive");
    dlRequest = mDownloadManager.enqueue(request);
    // Rather large file, so wait up to 15 mins...
    waitForDownloadOrTimeout(dlRequest, WAIT_FOR_DOWNLOAD_POLL_TIME, 15 * 60 * 1000);
    Cursor cursor = getCursor(dlRequest);
    ParcelFileDescriptor pfd = null;
    try {
        Log.i(LOG_TAG, "Verifying download information...");
        // Verify specific info about the file (size, name, etc)...
        pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        if (pfd != null) {
            pfd.close();
        }
        mDownloadManager.remove(dlRequest);
        cursor.close();
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    long filesize = DOWNLOAD_FILESIZE;
    long dlRequest = -1;
    doCommonDownloadSetup();
    // Make sure there are no pending downloads currently going on
    removeAllCurrentDownloads();
    Uri remoteUri = getExternalFileUri(filename);
    Request request = new Request(remoteUri);
    request.setMimeType("application/vnd.android.package-archive");
    dlRequest = mDownloadManager.enqueue(request);
    // Rather large file, so wait up to 15 mins...
    assertTrue("download not finished", waitForDownload(dlRequest, 15 * 60 * 1000));
    Cursor cursor = getCursor(dlRequest);
    ParcelFileDescriptor pfd = null;
    try {
        Log.i(LOG_TAG, "Verifying download information...");
        // Verify specific info about the file (size, name, etc)...
        pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        if (pfd != null) {
            pfd.close();
        }
        mDownloadManager.remove(dlRequest);
        cursor.close();
    }
}
------------------------
Find a functionally equivalent code:android.view.ScaleGestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a byte array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putByteArray(key, value);
}
------------------------
Find a functionally equivalent code:android.view.HardwareRenderer.setupDiskCache:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Sets the directory to use as a persistent storage for hardware rendering
 * resources.
 *
 * @param cacheDir A directory the current process can write to
 *
 * @hide
 */

Body of Frist Method:
{
    nSetupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
}
Body of Second Method:
{
    ThreadedRenderer.setupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
}
------------------------
Find a functionally equivalent code:android.util.TimeUtils.getTimeZone:COMMENT
Method Modifier: public      static      
Comment:/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */

Body of Frist Method:
{
    TimeZone best = null;
    Resources r = Resources.getSystem();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
    Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}
Body of Second Method:
{
    TimeZone best = null;
    final Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.launchDefaultSearch:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Helper method for adding launch-search to most applications. Opens the
 * search window using default settings.
 *
 * @return true if search window opened
 */

Body of Frist Method:
{
    final Callback cb = getCallback();
    if (cb == null || isDestroyed()) {
        return false;
    } else {
        sendCloseSystemWindows("search");
        return cb.onSearchRequested();
    }
}
Body of Second Method:
{
    boolean result;
    final Callback cb = getCallback();
    if (cb == null || isDestroyed()) {
        result = false;
    } else {
        sendCloseSystemWindows("search");
        result = cb.onSearchRequested();
    }
    if (!result && (getContext().getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_TELEVISION) {
        // On TVs, if the app doesn't implement search, we want to launch assist.
        return ((SearchManager) getContext().getSystemService(Context.SEARCH_SERVICE)).launchAssistAction(0, null, UserHandle.myUserId());
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.util.ArrayMap.containsKey:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether a key exists in the array.
 *
 * @param key The key to search for.
 * @return Returns true if the key exists, else false.
 */

Body of Frist Method:
{
    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
}
Body of Second Method:
{
    return indexOfKey(key) >= 0;
}
------------------------
Find a functionally equivalent code:android.printservice.PrintJob.hasAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether this job has a given advanced (printer specific) print
 * option.
 *
 * @param key The option key.
 * @return Whether the option is present.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return false;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().hasAdvancedOption(key);
}
------------------------
Find a functionally equivalent code:android.view.textservice.TextServicesManager.newSpellCheckerSession:COMMENT
Method Modifier: public      
Comment:/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. "en"), the specified locale in Settings (e.g. "en_US") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */

Body of Frist Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String inputLocale = locale.toString();
            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}
Body of Second Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeString(ipAssignment.name());
    dest.writeString(proxySettings.name());
    dest.writeParcelable(linkProperties, flags);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(noInternetAccess ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
}
------------------------
Find a functionally equivalent code:android.widget.AutoCompleteTextView.setDropDownBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the background of the auto-complete drop-down list.</p>
 *
 * @param id the id of the drawable to set as the background
 *
 * @attr ref android.R.styleable#PopupWindow_popupBackground
 */

Body of Frist Method:
{
    mPopup.setBackgroundDrawable(getResources().getDrawable(id));
}
Body of Second Method:
{
    mPopup.setBackgroundDrawable(getContext().getDrawable(id));
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.SignalClusterView.apply:COMMENT
Method Modifier: private     
Comment:// Run after each indicator change.

Body of Frist Method:
{
    if (mWifiGroup == null)
        return;
    if (mWifiVisible) {
        mWifi.setImageResource(mWifiStrengthId);
        mWifiGroup.setContentDescription(mWifiDescription);
        mWifiGroup.setVisibility(View.VISIBLE);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Log.d(TAG, String.format("wifi: %s sig=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId));
    if (mMobileVisible && !mIsAirplaneMode) {
        mMobile.setImageResource(mMobileStrengthId);
        mMobileType.setImageResource(mMobileTypeId);
        mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
        mMobileGroup.setVisibility(View.VISIBLE);
    } else {
        mMobileGroup.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode) {
        mAirplane.setImageResource(mAirplaneIconId);
        mAirplane.setVisibility(View.VISIBLE);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
        mSpacer.setVisibility(View.INVISIBLE);
    } else {
        mSpacer.setVisibility(View.GONE);
    }
    if (DEBUG)
        Log.d(TAG, String.format("mobile: %s sig=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileTypeId));
    mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
}
Body of Second Method:
{
    if (mWifiGroup == null)
        return;
    mVpn.setVisibility(mVpnVisible ? View.VISIBLE : View.GONE);
    if (DEBUG)
        Log.d(TAG, String.format("vpn: %s", mVpnVisible ? "VISIBLE" : "GONE"));
    if (mWifiVisible) {
        mWifi.setImageResource(mWifiStrengthId);
        mWifiGroup.setContentDescription(mWifiDescription);
        mWifiGroup.setVisibility(View.VISIBLE);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Log.d(TAG, String.format("wifi: %s sig=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId));
    if (mMobileVisible && !mIsAirplaneMode) {
        mMobile.setImageResource(mMobileStrengthId);
        mMobileType.setImageResource(mMobileTypeId);
        mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
        mMobileGroup.setVisibility(View.VISIBLE);
    } else {
        mMobileGroup.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode) {
        mAirplane.setImageResource(mAirplaneIconId);
        mAirplane.setVisibility(View.VISIBLE);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode && mWifiVisible) {
        mWifiAirplaneSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiAirplaneSpacer.setVisibility(View.GONE);
    }
    if (mRoaming && mMobileVisible && mWifiVisible) {
        mWifiSignalSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiSignalSpacer.setVisibility(View.GONE);
    }
    mMobile.setPaddingRelative(mIsMobileTypeIconWide ? mWideTypeIconStartPadding : 0, 0, 0, 0);
    if (DEBUG)
        Log.d(TAG, String.format("mobile: %s sig=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileTypeId));
    mMobileType.setVisibility((mRoaming || mMobileTypeId != 0) ? View.VISIBLE : View.GONE);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockPasswordEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether the lock password is enabled, or if it is set as a backup for biometric weak
 */

Body of Frist Method:
{
    long mode = getLong(PASSWORD_TYPE_KEY, 0);
    long backupMode = getLong(PASSWORD_TYPE_ALTERNATE_KEY, 0);
    final boolean passwordEnabled = mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
    final boolean backupEnabled = backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
    return savedPasswordExists() && (passwordEnabled || (usingBiometricWeak() && backupEnabled));
}
Body of Second Method:
{
    long mode = getLong(PASSWORD_TYPE_KEY, 0);
    long backupMode = getLong(PASSWORD_TYPE_ALTERNATE_KEY, 0);
    final boolean passwordEnabled = mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
    final boolean backupEnabled = backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX || backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
    return savedPasswordExists() && (passwordEnabled || (usingBiometricWeak() && backupEnabled));
}
------------------------
Find a functionally equivalent code:android.view.MotionEvent.PointerCoords.getAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

Body of Frist Method:
{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & (axisBit - 1L));
                return mPackedAxisValues[index];
            }
    }
}
Body of Second Method:
{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                return mPackedAxisValues[index];
            }
    }
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleSPSE(request);
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, "Method");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, "Sample");
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.test3GToWifiNotification:COMMENT
Method Modifier: public      
Comment:// event should be expected.

Body of Frist Method:
{
    if (mWifiOnlyFlag) {
        Log.v(TAG, this.getName() + " is excluded for wifi-only test");
        return;
    }
    // Enable Wi-Fi to avoid initial UNKNOWN state
    enableWifi();
    sleep(2 * SHORT_TIMEOUT);
    // Wi-Fi is disabled
    disableWifi();
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, LONG_TIMEOUT));
    // Wait for 10 seconds for broadcasts to be sent out
    sleep(10 * 1000);
    // As Wifi stays in DISCONNETED, Mobile statys in CONNECTED,
    // the connectivity manager will not broadcast any network connectivity event for Wifi
    NetworkInfo networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
    setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE, networkInfo.getState(), NetworkState.DO_NOTHING, State.CONNECTED);
    networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.DO_NOTHING, State.DISCONNECTED);
    // Eanble Wifi without associating with any AP
    enableWifi();
    sleep(2 * SHORT_TIMEOUT);
    // validate state and broadcast
    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
        log("the state for WIFI is changed");
        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
        assertTrue("state validation fail", false);
    }
    if (!validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
        log("the state for MOBILE is changed");
        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
        assertTrue("state validation fail", false);
    }
    // Verify that the device is still connected to MOBILE
    verifyCellularConnection();
}
Body of Second Method:
{
    if (mWifiOnlyFlag) {
        logv(getName() + " is excluded for wifi-only test");
        return;
    }
    // disable WiFi
    assertTrue("failed to disable WiFi", disableWifi());
    // wait for mobile
    assertTrue("failed to wait for mobile connection", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, LONG_TIMEOUT));
    // assert that we are indeed using mobile
    NetworkInfo ni = mCm.getActiveNetworkInfo();
    assertEquals("active network is not mobile", ConnectivityManager.TYPE_MOBILE, ni.getType());
    long timestamp = SystemClock.uptimeMillis();
    // now enable WiFi
    assertTrue("failed to enable WiFi", enableWifi());
    // assert that WiFi state settles at disconnected since no AP should be configured
    assertTrue("WiFi state is not DISCONNECTED after enabling", waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
    // assert that no connectivity change broadcast was sent since we enable wifi
    assertTrue("connectivity has changed since wifi enable", timestamp > getLastConnectivityChangeTime());
    // verify that the device is still connected to MOBILE
    verifyCellularConnection();
    // verify that connection actually works
    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.dispatchBootCompleted:COMMENT
<com.android.keyguard.KeyguardUpdateMonitor: void dispatchBootCompleted()>
Method Modifier: public      protected   
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * This is exposed since {@link Intent#ACTION_BOOT_COMPLETED} is not sticky. If
 * keyguard crashes sometime after boot, then it will never receive this
 * broadcast and hence not handle the event. This method is ultimately called by
 * PhoneWindowManager in this case.
 */

Body of Frist Method:
{
    mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);
}
Body of Second Method:
{
    mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a bitmap for the canvas to draw into. All canvas state such as
 * layers, filters, and the save/restore stack are reset with the exception
 * of the current matrix and clip stack. Additionally, as a side-effect
 * the canvas' target density is updated to match that of the bitmap.
 *
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */

Body of Frist Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a GL canvas");
    }
    if (bitmap == null) {
        safeCanvasSwap(initRaster(0), false);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        safeCanvasSwap(initRaster(bitmap.ni()), true);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
Body of Second Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    if (bitmap == null) {
        native_setBitmap(mNativeCanvasWrapper, 0, false);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        native_setBitmap(mNativeCanvasWrapper, bitmap.ni(), true);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothSocket.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */

Body of Frist Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
------------------------
Find a functionally equivalent code:com.android.externalstorage.ExternalStorageProvider.removeExtension:COMMENT
Method Modifier: private     static      
Comment:/**
 * Remove file extension from name, but only if exact MIME type mapping
 * exists. This means we can reapply the extension later.
 */

Body of Frist Method:
{
    final int lastDot = name.lastIndexOf('.');
    if (lastDot >= 0) {
        final String extension = name.substring(lastDot + 1);
        final String nameMime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
        if (mimeType.equals(nameMime)) {
            return name.substring(0, lastDot);
        }
    }
    return name;
}
Body of Second Method:
{
    final int lastDot = name.lastIndexOf('.');
    if (lastDot >= 0) {
        final String extension = name.substring(lastDot + 1).toLowerCase();
        final String nameMime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
        if (mimeType.equals(nameMime)) {
            return name.substring(0, lastDot);
        }
    }
    return name;
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setClassVariablesFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Set all class variables using current values from the given
 * {@link Paint}.
 */

Body of Frist Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    if (paint.mShader != null) {
        mShader = paint.mShader.copy();
    } else {
        mShader = null;
    }
    mTypeface = paint.mTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    hasShadow = paint.hasShadow;
    shadowDx = paint.shadowDx;
    shadowDy = paint.shadowDy;
    shadowRadius = paint.shadowRadius;
    shadowColor = paint.shadowColor;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
}
Body of Second Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    if (paint.mShader != null) {
        mShader = paint.mShader.copy();
    } else {
        mShader = null;
    }
    mTypeface = paint.mTypeface;
    mNativeTypeface = paint.mNativeTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
    mFontFeatureSettings = paint.mFontFeatureSettings;
}
------------------------
Find a functionally equivalent code:android.widget.EdgeEffect.setSize:COMMENT
Method Modifier: public      
Comment:/**
 * Set the size of this edge effect in pixels.
 *
 * @param width Effect width in pixels
 * @param height Effect height in pixels
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
}
Body of Second Method:
{
    final float r = width * 0.75f / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * 0.75f / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
}
------------------------
Find a functionally equivalent code:android.media.MediaRecorder.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Prepares the recorder to begin capturing and encoding data. This method
 * must be called after setting up the desired audio and video sources,
 * encoders, file format, etc., but before start().
 *
 * @throws IllegalStateException if it is called after
 * start() or before setOutputFormat().
 * @throws IOException if prepare fails otherwise.
 */

Body of Frist Method:
{
    if (mPath != null) {
        FileOutputStream fos = new FileOutputStream(mPath);
        try {
            _setOutputFile(fos.getFD(), 0, 0);
        } finally {
            fos.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd, 0, 0);
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
Body of Second Method:
{
    if (mPath != null) {
        RandomAccessFile file = new RandomAccessFile(mPath, "rws");
        try {
            _setOutputFile(file.getFD(), 0, 0);
        } finally {
            file.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd, 0, 0);
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
------------------------
Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.updateMode:COMMENT
Method Modifier: private     
Comment:/**
 * Fetch the brightness mode from the system settings and update the icon
 */

Body of Frist Method:
{
    if (mAutomaticAvailable) {
        int automatic;
        try {
            automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
        } catch (SettingNotFoundException snfe) {
            automatic = 0;
        }
        mControl.setChecked(automatic != 0);
        updateIcon(automatic != 0);
    } else {
        mControl.setChecked(false);
        updateIcon(false);
    }
}
Body of Second Method:
{
    if (mAutomaticAvailable) {
        int automatic;
        automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
        mAutomatic = automatic != Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
        updateIcon(mAutomatic);
    } else {
        mControl.setChecked(false);
        updateIcon(false);
    }
}
------------------------
Find a functionally equivalent code:android.app.admin.DevicePolicyManager.getActiveAdmins:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.getActiveAdmins(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
Body of Second Method:
{
    return getActiveAdminsAsUser(UserHandle.myUserId());
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.setOnTimeChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Set the callback that indicates the time has been adjusted by the user.
 *
 * @param onTimeChangedListener the callback, should not be null.
 */

Body of Frist Method:
{
    mOnTimeChangedListener = onTimeChangedListener;
}
Body of Second Method:
{
    mDelegate.setOnTimeChangedListener(onTimeChangedListener);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.setHasAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the bitmap if all of the pixels are known to be opaque (false)
 * or if some of the pixels may contain non-opaque alpha values (true).
 * Note, for some configs (e.g. RGB_565) this call is ignored, since it
 * does not support per-pixel alpha values.
 *
 * This is meant as a drawing hint, as in some cases a bitmap that is known
 * to be opaque can take a faster drawing case than one that may have
 * non-opaque per-pixel alpha values.
 */

Body of Frist Method:
{
    nativeSetHasAlpha(mNativeBitmap, hasAlpha);
}
Body of Second Method:
{
    nativeSetHasAlpha(mNativeBitmap, hasAlpha, mRequestPremultiplied);
}
------------------------
Find a functionally equivalent code:android.app.Activity.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Implement to provide correct calling token.
 */

Body of Frist Method:
{
    startActivityAsUser(intent, null, user);
}
Body of Second Method:
{
    startActivityAsUser(intent, null, user);
}
------------------------
Find a functionally equivalent code:android.app.UiAutomation.takeScreenshot:COMMENT
Method Modifier: public      
Comment:/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while taking screnshot!", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}
Body of Second Method:
{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while taking screnshot!", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot.recycle();
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.DrawableContainer.DrawableContainerState.ConstantStateFuture.get:COMMENT
Method Modifier: public      
Comment:/**
 * Obtains and prepares the Drawable represented by this future.
 *
 * @param state the container into which this future will be placed
 * @return a prepared Drawable
 */

Body of Frist Method:
{
    final Drawable result = (state.mRes == null) ? mConstantState.newDrawable() : mConstantState.newDrawable(state.mRes);
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
Body of Second Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else if (state.mTheme == null) {
        result = mConstantState.newDrawable(state.mRes);
    } else {
        result = mConstantState.newDrawable(state.mRes, state.mTheme);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.registerMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * no-op if (pi == null) or (eventReceiver == null)
 */

Body of Frist Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    IAudioService service = getService();
    try {
        // pi != null
        service.registerMediaButtonIntent(pi, eventReceiver, eventReceiver == null ? mToken : null);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in registerMediaButtonIntent" + e);
    }
}
Body of Second Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.addMediaButtonListener(pi, eventReceiver, mContext);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setParent:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the parent to be a virtual descendant of the given <code>root</code>.
 * If <code>virtualDescendantId</code> equals to {@link View#NO_ID} the root
 * is set as the parent.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report them selves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 */

Body of Frist Method:
{
    enforceNotSealed();
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
    mParentNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
Body of Second Method:
{
    enforceNotSealed();
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
    mParentNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testConnectToWifi:COMMENT
Method Modifier: public      
Comment:// Test case 2: test connection to a given AP

Body of Frist Method:
{
    assertNotNull("SSID is null", mTestAccessPoint);
    NetworkInfo networkInfo;
    if (!mWifiOnlyFlag) {
        // Prepare for connectivity verification
        networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
        setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE, networkInfo.getState(), NetworkState.TO_DISCONNECTION, State.DISCONNECTED);
    }
    networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.TO_CONNECTION, State.CONNECTED);
    // Enable Wifi and connect to a test access point
    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
    log("wifi state is enabled");
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    if (!mWifiOnlyFlag) {
        assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
    }
    // validate states
    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
        log("Wifi state transition validation failed.");
        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
        assertTrue(false);
    }
    if (!mWifiOnlyFlag) {
        if (!validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
            log("Mobile state transition validation failed.");
            log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
            assertTrue(false);
        }
    }
}
Body of Second Method:
{
    assertNotNull("SSID is null", mSsid);
    // assert that we are able to connect to the ap
    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
    // assert that WifiManager reports correct state
    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
    // assert that ConnectivityManager reports correct state for Wifi
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // below check disbabled since we have bug in what ConnectivityManager returns
    // if (!mWifiOnlyFlag) {
    // // assert that ConnectivityManager reports correct state for mobile
    // assertTrue("mobile not disconnected", waitForNetworkState(
    // ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
    // }
    // verify that connection actually works
    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
}
------------------------
Find a functionally equivalent code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeLong(seen);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a functionally equivalent code:android.transition.TransitionSet.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.pause();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).pause();
    }
}
Body of Second Method:
{
    super.pause(sceneRoot);
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).pause(sceneRoot);
    }
}
------------------------
Find a functionally equivalent code:android.media.Ringtone.isPlaying:COMMENT
Method Modifier: public      
Comment:/**
 * Whether this ringtone is currently playing.
 *
 * @return True if playing, false otherwise.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        return mLocalPlayer.isPlaying();
    } else if (mAllowRemote) {
        try {
            return mRemotePlayer.isPlaying(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem checking ringtone: " + e);
            return false;
        }
    } else {
        Log.w(TAG, "Neither local nor remote playback available");
        return false;
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        return mLocalPlayer.isPlaying();
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        try {
            return mRemotePlayer.isPlaying(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem checking ringtone: " + e);
            return false;
        }
    } else {
        Log.w(TAG, "Neither local nor remote playback available");
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.obtainView:COMMENT
Method Modifier: 
Comment:/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView == null) {
        scrapView = mRecycler.getScrapView(position);
    }
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a functionally equivalent code:android.app.Dialog.show:COMMENT
Method Modifier: public      
Comment:/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */

Body of Frist Method:
{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new ActionBarImpl(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}
Body of Second Method:
{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.getWindowManager:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the current {@link android.view.WindowManager} for the dream.
 * Behaves similarly to {@link android.app.Activity#getWindowManager()}.
 *
 * @return The current window manager, or null if the dream is not started.
 */

Body of Frist Method:
{
    return mWindowManager;
}
Body of Second Method:
{
    return mWindow != null ? mWindow.getWindowManager() : null;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getNextAlarm:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return A formatted string of the next alarm (for showing on the lock screen),
 * or null if there is no next alarm.
 */

Body of Frist Method:
{
    String nextAlarm = Settings.System.getStringForUser(mContentResolver, Settings.System.NEXT_ALARM_FORMATTED, UserHandle.USER_CURRENT);
    if (nextAlarm == null || TextUtils.isEmpty(nextAlarm)) {
        return null;
    }
    return nextAlarm;
}
Body of Second Method:
{
    AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    return alarmManager.getNextAlarmClock(UserHandle.USER_CURRENT);
}
------------------------
Find a functionally equivalent code:android.media.MediaDrm.provideProvisionResponse:COMMENT
<android.media.MediaDrm: void provideProvisionResponse(byte[])>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * After a provision response is received by the app, it is provided to the DRM
 * engine plugin using this method.
 *
 * @param response the opaque provisioning response byte array to provide to the
 * DRM engine plugin.
 *
 * @throws DeniedByServerException if the response indicates that the
 * server rejected the request
 */

Body of Frist Method:

Body of Second Method:
{
    provideProvisionResponseNative(response);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRefreshBatteryInfo:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshBatteryInfo(BatteryStatus)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the battery status changes, e.g. when plugged in or unplugged, charge
 * level, etc. changes.
 *
 * @param status current battery status
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothSocket.write:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
Body of Second Method:
{
    if (mSocketOS == null)
        throw new IOException("write is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.outputDisplayList:COMMENT
Method Modifier: hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mAttachInfo != null && mAttachInfo.mHardwareCanvas != null) {
        DisplayList displayList = view.getDisplayList();
        if (displayList != null) {
            mAttachInfo.mHardwareCanvas.outputDisplayList(displayList);
        }
    }
}
Body of Second Method:
{
    RenderNode renderNode = view.getDisplayList();
    if (renderNode != null) {
        renderNode.output();
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaMuxer.nativeSetup:COMMENT
Method Modifier: private     static      native      
Comment:// All the native functions are listed here.

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all property animations that are currently running or pending.
 */

Body of Frist Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mView.removeCallbacks(mAnimationStarter);
}
Body of Second Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mPendingSetupAction = null;
    mPendingCleanupAction = null;
    mPendingOnStartAction = null;
    mPendingOnEndAction = null;
    mView.removeCallbacks(mAnimationStarter);
    if (mRTBackend != null) {
        mRTBackend.cancelAll();
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchGenericPointerEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final View[] children = mChildren;
        final float x = event.getX();
        final float y = event.getY();
        final boolean customOrder = isChildrenDrawingOrderEnabled();
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = children[childIndex];
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                return true;
            }
        }
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}
Body of Second Method:
{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.connectToWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean connectToWifi(String)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Associate the device to given SSID
 * If the device is already associated with a WiFi, disconnect and forget it,
 * We don't verify whether the connection is successful or not, leave this to the test
 */

Body of Frist Method:
{
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = knownSSID;
    config.allowedKeyManagement.set(KeyMgmt.NONE);
    return connectToWifiWithConfiguration(config);
}
Body of Second Method:
{
    WifiConfiguration config;
    if (password == null) {
        config = WifiConfigurationHelper.createOpenConfig(ssid);
    } else {
        config = WifiConfigurationHelper.createPskConfig(ssid, password);
    }
    return connectToWifiWithConfiguration(config);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visitMethod:COMMENT
Method Modifier: public      
Comment:/* Visits a method. */

Body of Frist Method:
{
    if (mDeleteReturns != null) {
        Type t = Type.getReturnType(desc);
        if (t.getSort() == Type.OBJECT) {
            String returnType = t.getInternalName();
            if (returnType != null) {
                if (mDeleteReturns.contains(returnType)) {
                    return null;
                }
            }
        }
    }
    String methodSignature = mClassName.replace('/', '.') + "#" + name;
    // change access to public
    if (Main.sOptions.generatePublicAccess) {
        access &= ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);
        access |= Opcodes.ACC_PUBLIC;
    }
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // and don't try to stub interfaces nor abstract non-native methods.
    if (!mIsInterface && ((access & (Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE)) != Opcodes.ACC_ABSTRACT) && (mStubAll || (access & Opcodes.ACC_NATIVE) != 0) || mStubMethods.contains(methodSignature)) {
        boolean isStatic = (access & Opcodes.ACC_STATIC) != 0;
        boolean isNative = (access & Opcodes.ACC_NATIVE) != 0;
        // remove abstract, final and native
        access = access & ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL | Opcodes.ACC_NATIVE);
        String invokeSignature = methodSignature + desc;
        mLog.debug("  Stub: %s (%s)", invokeSignature, isNative ? "native" : "");
        MethodVisitor mw = super.visitMethod(access, name, desc, signature, exceptions);
        return new StubMethodAdapter(mw, name, returnType(desc), invokeSignature, isStatic, isNative);
    } else {
        mLog.debug("  Keep: %s %s", name, desc);
        return super.visitMethod(access, name, desc, signature, exceptions);
    }
}
Body of Second Method:
{
    if (mDeleteReturns != null) {
        Type t = Type.getReturnType(desc);
        if (t.getSort() == Type.OBJECT) {
            String returnType = t.getInternalName();
            if (returnType != null) {
                if (mDeleteReturns.contains(returnType)) {
                    return null;
                }
            }
        }
    }
    String methodSignature = mClassName.replace('/', '.') + "#" + name;
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // and don't try to stub interfaces nor abstract non-native methods.
    if (!mIsInterface && ((access & (Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE)) != Opcodes.ACC_ABSTRACT) && (mStubAll || (access & Opcodes.ACC_NATIVE) != 0) || mStubMethods.contains(methodSignature)) {
        boolean isStatic = (access & Opcodes.ACC_STATIC) != 0;
        boolean isNative = (access & Opcodes.ACC_NATIVE) != 0;
        // remove abstract, final and native
        access = access & ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL | Opcodes.ACC_NATIVE);
        String invokeSignature = methodSignature + desc;
        mLog.debug("  Stub: %s (%s)", invokeSignature, isNative ? "native" : "");
        MethodVisitor mw = super.visitMethod(access, name, desc, signature, exceptions);
        return new StubMethodAdapter(mw, name, returnType(desc), invokeSignature, isStatic, isNative);
    } else {
        mLog.debug("  Keep: %s %s", name, desc);
        return super.visitMethod(access, name, desc, signature, exceptions);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardHostView.ensureTransportPresentOrRemoved:COMMENT
Method Modifier: private     
Comment:/**
 * Examines the current state and adds the transport to the widget pager when the state changes.
 *
 * Showing the initial transport and keeping it around is a bit tricky because the signals
 * coming from music players aren't always clear. Here's how the states are handled:
 *
 * {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.
 *
 * {@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a music
 * player is registered but not currently playing music (or we don't know the state yet). The
 * code adds it conditionally on play state.
 *
 * {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.
 *
 * Once the transport is showing, we always show it until keyguard is dismissed. This state is
 * maintained by onSave/RestoreInstanceState(). This state is cleared in
 * {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to be
 * gone when keyguard is restarted until we get an update with the current state.
 *
 * @param state
 */

Body of Frist Method:
{
    final boolean showing = getWidgetPosition(R.id.keyguard_transport_control) != -1;
    final boolean visible = state == TRANSPORT_VISIBLE;
    final boolean shouldBeVisible = state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
    if (!showing && (visible || shouldBeVisible)) {
        if (DEBUGXPORT)
            Log.v(TAG, "add transport");
        // insert to left of camera if it exists, otherwise after right-most widget
        int lastWidget = mAppWidgetContainer.getChildCount() - 1;
        // handle no widget case
        int position = 0;
        if (lastWidget >= 0) {
            position = mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
        }
        mAppWidgetContainer.addWidget(getOrCreateTransportControl(), position);
    } else if (showing && state == TRANSPORT_GONE) {
        if (DEBUGXPORT)
            Log.v(TAG, "remove transport");
        mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
        mTransportControl = null;
        KeyguardUpdateMonitor.getInstance(getContext()).dispatchSetBackground(null);
    }
}
Body of Second Method:
{
    final boolean showing = getWidgetPosition(R.id.keyguard_transport_control) != -1;
    final boolean visible = state == TRANSPORT_VISIBLE;
    final boolean shouldBeVisible = state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
    if (!showing && (visible || shouldBeVisible)) {
        // insert to left of camera if it exists, otherwise after right-most widget
        int lastWidget = mAppWidgetContainer.getChildCount() - 1;
        // handle no widget case
        int position = 0;
        if (lastWidget >= 0) {
            position = mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
        }
        if (DEBUGXPORT)
            Log.v(TAG, "add transport at " + position);
        mAppWidgetContainer.addWidget(getOrCreateTransportControl(), position);
        return true;
    } else if (showing && state == TRANSPORT_GONE) {
        if (DEBUGXPORT)
            Log.v(TAG, "remove transport");
        mAppWidgetContainer.removeWidget(getOrCreateTransportControl());
        mTransportControl = null;
        KeyguardUpdateMonitor.getInstance(getContext()).dispatchSetBackground(null);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.animation.ObjectAnimator.animateValue:COMMENT
Method Modifier: 
Comment:/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */

Body of Frist Method:
{
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(mTarget);
    }
}
Body of Second Method:
{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}
------------------------
Find a functionally equivalent code:android.print.PrintDocumentInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link PrintDocumentInfo} instance.
 *
 * @return The new instance.
 */

Body of Frist Method:
{
    return new PrintDocumentInfo(mPrototype);
}
Body of Second Method:
{
    // wiritten PDF file for the page count.
    if (mPrototype.mPageCount == 0) {
        mPrototype.mPageCount = PAGE_COUNT_UNKNOWN;
    }
    return new PrintDocumentInfo(mPrototype);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.removeFocusStackEntryForClient:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove focus listeners from the focus stack for a particular client when it has died.
 */

Body of Frist Method:
{
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().hasSameBinder(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusRequester fr = (FocusRequester) stackIterator.next();
        if (fr.hasSameBinder(cb)) {
            Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + cb);
            stackIterator.remove();
        // the client just died, no need to unlink to its death
        }
    }
    if (isTopOfStackForClientToRemove) {
        // we removed an entry at the top of the stack:
        // notify the new top of the stack it gained focus.
        notifyTopOfAudioFocusStack();
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
Body of Second Method:
{
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().hasSameBinder(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusRequester fr = stackIterator.next();
        if (fr.hasSameBinder(cb)) {
            Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + cb);
            stackIterator.remove();
        // the client just died, no need to unlink to its death
        }
    }
    if (isTopOfStackForClientToRemove) {
        // we removed an entry at the top of the stack:
        // notify the new top of the stack it gained focus.
        notifyTopOfAudioFocusStack();
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getPositionDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a message about the parser state suitable for printing error messages.
 */

Body of Frist Method:
{
    return mXml != null ? mXml.getPositionDescription() : "<internal>";
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mXml != null ? mXml.getPositionDescription() : "<internal>";
}
------------------------
Find a functionally equivalent code:android.text.PackedIntVector.growBuffer:COMMENT
Method Modifier: private     final       
Comment:/**
 * Grows the value and gap arrays to be large enough to store at least
 * one more than the current number of rows.
 */

Body of Frist Method:
{
    final int columns = mColumns;
    int newsize = size() + 1;
    newsize = ArrayUtils.idealIntArraySize(newsize * columns) / columns;
    int[] newvalues = new int[newsize * columns];
    final int[] valuegap = mValueGap;
    final int rowgapstart = mRowGapStart;
    int after = mRows - (rowgapstart + mRowGapLength);
    if (mValues != null) {
        System.arraycopy(mValues, 0, newvalues, 0, columns * rowgapstart);
        System.arraycopy(mValues, (mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
    }
    for (int i = 0; i < columns; i++) {
        if (valuegap[i] >= rowgapstart) {
            valuegap[i] += newsize - mRows;
            if (valuegap[i] < rowgapstart) {
                valuegap[i] = rowgapstart;
            }
        }
    }
    mRowGapLength += newsize - mRows;
    mRows = newsize;
    mValues = newvalues;
}
Body of Second Method:
{
    final int columns = mColumns;
    int[] newvalues = ArrayUtils.newUnpaddedIntArray(GrowingArrayUtils.growSize(size()) * columns);
    int newsize = newvalues.length / columns;
    final int[] valuegap = mValueGap;
    final int rowgapstart = mRowGapStart;
    int after = mRows - (rowgapstart + mRowGapLength);
    if (mValues != null) {
        System.arraycopy(mValues, 0, newvalues, 0, columns * rowgapstart);
        System.arraycopy(mValues, (mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
    }
    for (int i = 0; i < columns; i++) {
        if (valuegap[i] >= rowgapstart) {
            valuegap[i] += newsize - mRows;
            if (valuegap[i] < rowgapstart) {
                valuegap[i] = rowgapstart;
            }
        }
    }
    mRowGapLength += newsize - mRows;
    mRows = newsize;
    mValues = newvalues;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.remoteControlDisplayUsesBitmapSize:COMMENT
Method Modifier: protected   
Comment:/**
 * Update the size of the artwork used by an IRemoteControlDisplay.
 * @see android.media.IAudioService#remoteControlDisplayUsesBitmapSize(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay with the new artwork size requirement
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        boolean artworkSizeUpdate = false;
        while (displayIterator.hasNext() && !artworkSizeUpdate) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                if ((di.mArtworkExpectedWidth != w) || (di.mArtworkExpectedHeight != h)) {
                    di.mArtworkExpectedWidth = w;
                    di.mArtworkExpectedHeight = h;
                    artworkSizeUpdate = true;
                }
            }
        }
        if (artworkSizeUpdate) {
            // RCD is currently plugged in and its artwork size has changed, notify all RCCs,
            // stack traversal order doesn't matter
            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                final RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.setBitmapSizeForDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error setting bitmap size for RCD on RCC: ", e);
                    }
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        boolean artworkSizeUpdate = false;
        while (displayIterator.hasNext() && !artworkSizeUpdate) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                if ((di.mArtworkExpectedWidth != w) || (di.mArtworkExpectedHeight != h)) {
                    di.mArtworkExpectedWidth = w;
                    di.mArtworkExpectedHeight = h;
                    artworkSizeUpdate = true;
                }
            }
        }
        if (artworkSizeUpdate) {
            // RCD is currently plugged in and its artwork size has changed, notify all RCCs,
            // stack traversal order doesn't matter
            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                final PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().setBitmapSizeForDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error setting bitmap size for RCD on RCC: ", e);
                    }
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardMessageArea.update:COMMENT
Method Modifier: 
Comment:/**
 * Update the status lines based on these rules:
 * AlarmStatus: Alarm state always gets it's own line.
 * Status1 is shared between help, battery status and generic unlock instructions,
 * prioritized in that order.
 * @param showStatusLines status lines are shown if true
 */

Body of Frist Method:
{
    MutableInt icon = new MutableInt(0);
    CharSequence status = concat(getChargeInfo(icon), getOwnerInfo(), getCurrentMessage());
    setCompoundDrawablesWithIntrinsicBounds(icon.value, 0, 0, 0);
    setText(status);
}
Body of Second Method:
{
    MutableInt icon = new MutableInt(0);
    CharSequence status = getCurrentMessage();
    setCompoundDrawablesWithIntrinsicBounds(icon.value, 0, 0, 0);
    setText(status);
}
------------------------
Find a functionally equivalent code:android.os.storage.IMountService.Stub.Proxy.mountSecureContainer:COMMENT
Method Modifier: public      
Comment:/*
             * Mount a secure container with the specified key and owner UID.
             * Returns an int consistent with MountServiceResultCode
             */

Body of Frist Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(id);
        _data.writeString(key);
        _data.writeInt(ownerUid);
        mRemote.transact(Stub.TRANSACTION_mountSecureContainer, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
Body of Second Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(id);
        _data.writeString(key);
        _data.writeInt(ownerUid);
        _data.writeInt(readOnly ? 1 : 0);
        mRemote.transact(Stub.TRANSACTION_mountSecureContainer, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
------------------------
Find a functionally equivalent code:com.android.documentsui.RootsCache.updatePackageAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Gather roots from storage providers belonging to given package name.
 */

Body of Frist Method:
{
    // Need at least first load, since we're going to be using previously
    // cached values for non-matching packages.
    waitForFirstLoad();
    new UpdateTask(packageName).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
Body of Second Method:
{
    new UpdateTask(packageName).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the week day abbreviation of the calendar header.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

Body of Frist Method:
{
    if (mWeekDayTextAppearanceResId != resourceId) {
        mWeekDayTextAppearanceResId = resourceId;
        setUpHeader();
    }
}
Body of Second Method:
{
    mDelegate.setWeekDayTextAppearance(resourceId);
}
------------------------
Find a functionally equivalent code:android.inputmethodservice.SoftInputWindow.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set which boundary of the screen the DockWindow sticks to.
 *
 * @param gravity The boundary of the screen to stick. See {#link
 * android.view.Gravity.LEFT}, {#link android.view.Gravity.TOP},
 * {#link android.view.Gravity.BOTTOM}, {#link
 * android.view.Gravity.RIGHT}.
 */

Body of Frist Method:
{
    WindowManager.LayoutParams lp = getWindow().getAttributes();
    boolean oldIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
    lp.gravity = gravity;
    boolean newIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
    if (oldIsVertical != newIsVertical) {
        int tmp = lp.width;
        lp.width = lp.height;
        lp.height = tmp;
        getWindow().setAttributes(lp);
    }
}
Body of Second Method:
{
    WindowManager.LayoutParams lp = getWindow().getAttributes();
    lp.gravity = gravity;
    updateWidthHeight(lp);
    getWindow().setAttributes(lp);
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarSetupVocabulary:COMMENT
Method Modifier: private     static      native      
Comment:// const struct SR_Nametag_t* nametag, int weight, String tag);

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(null, null, is, srcName, null);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(null, null, is, srcName);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the MediaPlayer to its uninitialized state. After calling
 * this method, you will have to initialize it again by setting the
 * data source and calling prepare().
 */

Body of Frist Method:
{
    mSelectedSubtitleTrackIndex = -1;
    synchronized (mOpenSubtitleSources) {
        for (final InputStream is : mOpenSubtitleSources) {
            try {
                is.close();
            } catch (IOException e) {
            }
        }
        mOpenSubtitleSources.clear();
    }
    mOutOfBandSubtitleTracks.clear();
    mInbandSubtitleTracks = new SubtitleTrack[0];
    if (mSubtitleController != null) {
        mSubtitleController.reset();
    }
    if (mTimeProvider != null) {
        mTimeProvider.close();
        mTimeProvider = null;
    }
    stayAwake(false);
    _reset();
    // make sure none of the listeners get called anymore
    if (mEventHandler != null) {
        mEventHandler.removeCallbacksAndMessages(null);
    }
    disableProxyListener();
}
Body of Second Method:
{
    mSelectedSubtitleTrackIndex = -1;
    synchronized (mOpenSubtitleSources) {
        for (final InputStream is : mOpenSubtitleSources) {
            try {
                is.close();
            } catch (IOException e) {
            }
        }
        mOpenSubtitleSources.clear();
    }
    mOutOfBandSubtitleTracks.clear();
    mInbandSubtitleTracks = new SubtitleTrack[0];
    if (mSubtitleController != null) {
        mSubtitleController.reset();
    }
    if (mTimeProvider != null) {
        mTimeProvider.close();
        mTimeProvider = null;
    }
    stayAwake(false);
    _reset();
    // make sure none of the listeners get called anymore
    if (mEventHandler != null) {
        mEventHandler.removeCallbacksAndMessages(null);
    }
}
------------------------
Find a functionally equivalent code:android.media.SubtitleTrack.hide:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mVisible) {
        return;
    }
    if (mTimeProvider != null) {
        mTimeProvider.cancelNotifications(this);
    }
    getRenderingWidget().setVisible(false);
    mVisible = false;
}
Body of Second Method:
{
    if (!mVisible) {
        return;
    }
    if (mTimeProvider != null) {
        mTimeProvider.cancelNotifications(this);
    }
    RenderingWidget renderingWidget = getRenderingWidget();
    if (renderingWidget != null) {
        renderingWidget.setVisible(false);
    }
    mVisible = false;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.setEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * @param enabled Whether the fast scroll thumb is enabled.
 */

Body of Frist Method:
{
    if (mEnabled != enabled) {
        mEnabled = enabled;
        onStateDependencyChanged();
    }
}
Body of Second Method:
{
    if (mEnabled != enabled) {
        mEnabled = enabled;
        onStateDependencyChanged(true);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Return an index in the array that has data.
 *
 * @param at The index you would like to returned, ranging from 0 to
 * {@link #getIndexCount()}.
 *
 * @return The index at the given offset, which can be used with
 * {@link #getValue} and related APIs.
 */

Body of Frist Method:
{
    return mIndices[1 + at];
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mIndices[1 + at];
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.createSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisListXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read an ArrayList object from an XmlPullParser.  The XML data could
 * previously have been generated by writeListXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the list.
 *
 * @param parser The XmlPullParser from which to read the list data.
 * @param endTag Name of the tag that will end the list, usually "list".
 * @param name An array of one string, used to return the name attribute
 * of the list's tag.
 *
 * @return HashMap The newly generated list.
 *
 * @see #readListXml
 */

Body of Frist Method:
{
    ArrayList list = new ArrayList();
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            Object val = readThisValueXml(parser, name);
            list.add(val);
        // System.out.println("Adding to list: " + val);
        } else if (eventType == parser.END_TAG) {
            if (parser.getName().equals(endTag)) {
                return list;
            }
            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
}
Body of Second Method:
{
    return readThisListXml(parser, endTag, name, null);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.GcSnapshot.createCustomGraphics:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new {@link Graphics2D} based on the {@link Paint} parameters.
 * <p/>The object must be disposed ({@link Graphics2D#dispose()}) after being used.
 */

Body of Frist Method:
{
    // make new one graphics
    Graphics2D g = (Graphics2D) original.create();
    if (paint.isAntiAliased()) {
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    }
    boolean customShader = false;
    // get the shader first, as it'll replace the color if it can be used it.
    if (compositeOnly == false) {
        Shader_Delegate shaderDelegate = paint.getShader();
        if (shaderDelegate != null) {
            if (shaderDelegate.isSupported()) {
                java.awt.Paint shaderPaint = shaderDelegate.getJavaPaint();
                assert shaderPaint != null;
                if (shaderPaint != null) {
                    g.setPaint(shaderPaint);
                    customShader = true;
                }
            } else {
                Bridge.getLog().fidelityWarning(LayoutLog.TAG_SHADER, shaderDelegate.getSupportMessage(), null, /*throwable*/
                null);
            }
        }
        // if no shader, use the paint color
        if (customShader == false) {
            g.setColor(new Color(paint.getColor(), true));
        }
        // set the stroke
        g.setStroke(paint.getJavaStroke());
    }
    // the alpha for the composite. Always opaque if the normal paint color is used since
    // it contains the alpha
    int alpha = (compositeOnly || customShader) ? paint.getAlpha() : 0xFF;
    if (forceSrcMode) {
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, (float) alpha / 255.f));
    } else {
        boolean customXfermode = false;
        Xfermode_Delegate xfermodeDelegate = paint.getXfermode();
        if (xfermodeDelegate != null) {
            if (xfermodeDelegate.isSupported()) {
                Composite composite = xfermodeDelegate.getComposite(alpha);
                assert composite != null;
                if (composite != null) {
                    g.setComposite(composite);
                    customXfermode = true;
                }
            } else {
                Bridge.getLog().fidelityWarning(LayoutLog.TAG_XFERMODE, xfermodeDelegate.getSupportMessage(), null, /*throwable*/
                null);
            }
        }
        // that will handle the alpha.
        if (customXfermode == false && alpha != 0xFF) {
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) alpha / 255.f));
        }
    }
    return g;
}
Body of Second Method:
{
    // make new one graphics
    Graphics2D g = (Graphics2D) original.create();
    if (paint.isAntiAliased()) {
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    }
    // set the shader first, as it'll replace the color if it can be used it.
    boolean customShader = false;
    if (!compositeOnly) {
        customShader = setShader(g, paint);
        // set the stroke
        g.setStroke(paint.getJavaStroke());
    }
    // set the composite.
    setComposite(g, paint, compositeOnly || customShader, forceMode);
    return g;
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onStopped:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStopped");
        mPaused = true;
        scheduleNotification(NOTIFY_STOP, 0);
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStopped");
        mPaused = true;
        mStopped = true;
        mSeeking = false;
        scheduleNotification(NOTIFY_STOP, 0);
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothDevice.connectGatt:COMMENT
Method Modifier: public      
Comment:/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */

Body of Frist Method:
{
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}
------------------------
Find a functionally equivalent code:android.view.DisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, rotation");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
------------------------
Find a functionally equivalent code:android.app.backup.BackupManager.beginRestoreSession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Begin the process of restoring data from backup.  See the
 * {@link android.app.backup.RestoreSession} class for documentation on that process.
 * @hide
 */

Body of Frist Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSession(null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.w(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
Body of Second Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSession(null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function should be called from checkAndProcessPlusCode only
 * And it is used for test purpose also.
 *
 * It checks the dial string by looping through the network portion,
 * post dial portion 1, post dial porting 2, etc. If there is any
 * plus sign, then process the plus sign.
 * Currently, this function supports the plus sign conversion within NANP only.
 * Specifically, it handles the plus sign in the following ways:
 * 1)+1NANP,remove +, e.g.
 * +18475797000 is converted to 18475797000,
 * 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g,
 * +8475797000 is converted to 0118475797000,
 * +11875767800 is converted to 01111875767800
 * 3)+1NANP in post dial string(s), e.g.
 * 8475797000;+18475231753 is converted to 8475797000;18475231753
 *
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,
 * and if there is the "+" in the original dial string. Otherwise, the original dial
 * string returns.
 *
 * @hide
 */

Body of Frist Method:
{
    String retStr = dialStr;
    // Checks if the plus sign character is in the passed-in dial string
    if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
        // and the current country the phone is camped on.
        if ((currFormat == defaultFormat) && (currFormat == FORMAT_NANP)) {
            // Handle case where default and current telephone numbering plans are NANP.
            String postDialStr = null;
            String tempDialStr = dialStr;
            // Sets the retStr to null since the conversion will be performed below.
            retStr = null;
            if (DBG)
                log("checkAndProcessPlusCode,dialStr=" + dialStr);
            // applied
            do {
                String networkDialStr;
                networkDialStr = extractNetworkPortion(tempDialStr);
                // Handles the conversion within NANP
                networkDialStr = processPlusCodeWithinNanp(networkDialStr);
                // Concatenates the string that is converted from network portion
                if (!TextUtils.isEmpty(networkDialStr)) {
                    if (retStr == null) {
                        retStr = networkDialStr;
                    } else {
                        retStr = retStr.concat(networkDialStr);
                    }
                } else {
                    // This should never happen since we checked the if dialStr is null
                    // and if it contains the plus sign in the beginning of this function.
                    // The plus sign is part of the network portion.
                    Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
                    return dialStr;
                }
                postDialStr = extractPostDialPortion(tempDialStr);
                if (!TextUtils.isEmpty(postDialStr)) {
                    int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
                    // dialableIndex should always be greater than 0
                    if (dialableIndex >= 1) {
                        retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
                        // Skips the P/W character, extracts the dialable portion
                        tempDialStr = postDialStr.substring(dialableIndex);
                    } else {
                        // Set the postDialStr to "" to break out of the loop
                        if (dialableIndex < 0) {
                            postDialStr = "";
                        }
                        Rlog.e("wrong postDialStr=", postDialStr);
                    }
                }
                if (DBG)
                    log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
            } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
        } else {
            // TODO: Support NANP international conversion and other telephone numbering plans.
            // Currently the phone is never used in non-NANP system, so return the original
            // dial string.
            Rlog.e("checkAndProcessPlusCode:non-NANP not supported", dialStr);
        }
    }
    return retStr;
}
Body of Second Method:
{
    String retStr = dialStr;
    boolean useNanp = (currFormat == defaultFormat) && (currFormat == FORMAT_NANP);
    // Checks if the plus sign character is in the passed-in dial string
    if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
        // Handle case where default and current telephone numbering plans are NANP.
        String postDialStr = null;
        String tempDialStr = dialStr;
        // Sets the retStr to null since the conversion will be performed below.
        retStr = null;
        if (DBG)
            log("checkAndProcessPlusCode,dialStr=" + dialStr);
        // applied
        do {
            String networkDialStr;
            // and the current country the phone is camped
            if (useNanp) {
                networkDialStr = extractNetworkPortion(tempDialStr);
            } else {
                networkDialStr = extractNetworkPortionAlt(tempDialStr);
            }
            networkDialStr = processPlusCode(networkDialStr, useNanp);
            // Concatenates the string that is converted from network portion
            if (!TextUtils.isEmpty(networkDialStr)) {
                if (retStr == null) {
                    retStr = networkDialStr;
                } else {
                    retStr = retStr.concat(networkDialStr);
                }
            } else {
                // This should never happen since we checked the if dialStr is null
                // and if it contains the plus sign in the beginning of this function.
                // The plus sign is part of the network portion.
                Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
                return dialStr;
            }
            postDialStr = extractPostDialPortion(tempDialStr);
            if (!TextUtils.isEmpty(postDialStr)) {
                int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
                // dialableIndex should always be greater than 0
                if (dialableIndex >= 1) {
                    retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
                    // Skips the P/W character, extracts the dialable portion
                    tempDialStr = postDialStr.substring(dialableIndex);
                } else {
                    // Set the postDialStr to "" to break out of the loop
                    if (dialableIndex < 0) {
                        postDialStr = "";
                    }
                    Rlog.e("wrong postDialStr=", postDialStr);
                }
            }
            if (DBG)
                log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
        } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
    }
    return retStr;
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.nativeExtractAlpha:COMMENT
Method Modifier: private     static      native      
Comment:// returns a new bitmap built from the native bitmap's alpha, and the paint

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateGroupCapability:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateGroupCapability(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    validateDeviceAddress(deviceAddress);
    WifiP2pDevice d = mDevices.get(deviceAddress);
    if (d != null) {
        d.groupCapability = groupCapab;
    }
}
Body of Second Method:
{
    validateDeviceAddress(deviceAddress);
    WifiP2pDevice d = mDevices.get(deviceAddress);
    if (d != null) {
        d.groupCapability = groupCapab;
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putByte:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a byte
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putByte(key, value);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a float
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putFloat(key, value);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.systemReady:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mHeadless) {
        mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);
        mKeyguardDelegate.onSystemReady();
    }
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
    }
}
Body of Second Method:
{
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);
    mKeyguardDelegate.onSystemReady();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
    }
}
------------------------
Find a functionally equivalent code:android.view.PointerIcon.getSystemIcon:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets a system pointer icon for the given style.
 * If style is not recognized, returns the default pointer icon.
 *
 * @param context The context.
 * @param style The pointer icon style.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 */

Body of Frist Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (style == STYLE_NULL) {
        return gNullIcon;
    }
    int styleIndex = getSystemIconStyleIndex(style);
    if (styleIndex == 0) {
        styleIndex = getSystemIconStyleIndex(STYLE_DEFAULT);
    }
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, com.android.internal.R.attr.pointerStyle, 0);
    int resourceId = a.getResourceId(styleIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, "Missing theme resources for pointer icon style " + style);
        return style == STYLE_DEFAULT ? gNullIcon : getSystemIcon(context, STYLE_DEFAULT);
    }
    PointerIcon icon = new PointerIcon(style);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context.getResources(), resourceId);
    }
    return icon;
}
Body of Second Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (style == STYLE_NULL) {
        return gNullIcon;
    }
    int styleIndex = getSystemIconStyleIndex(style);
    if (styleIndex == 0) {
        styleIndex = getSystemIconStyleIndex(STYLE_DEFAULT);
    }
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, com.android.internal.R.attr.pointerStyle, 0);
    int resourceId = a.getResourceId(styleIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, "Missing theme resources for pointer icon style " + style);
        return style == STYLE_DEFAULT ? gNullIcon : getSystemIcon(context, STYLE_DEFAULT);
    }
    PointerIcon icon = new PointerIcon(style);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context, context.getResources(), resourceId);
    }
    return icon;
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.allocate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Method to create a new CallerInfoAsyncQueryHandler object, ensuring correct
 * state of context and uri.
 */

Body of Frist Method:
{
    if ((context == null) || (contactRef == null)) {
        throw new QueryPoolException("Bad context or query uri.");
    }
    mHandler = new CallerInfoAsyncQueryHandler(context);
    mHandler.mQueryContext = context;
    mHandler.mQueryUri = contactRef;
}
Body of Second Method:
{
    if ((context == null) || (contactRef == null)) {
        throw new QueryPoolException("Bad context or query uri.");
    }
    mHandler = new CallerInfoAsyncQueryHandler(context);
    mHandler.mQueryUri = contactRef;
}
------------------------
Find a functionally equivalent code:android.os.CountDownTimer.start:COMMENT
Method Modifier: public      final       
Comment:/**
 * Start the countdown.
 */

Body of Frist Method:
{
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}
Body of Second Method:
{
    mCancelled = false;
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getChoiceValues:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of possible string values set earlier.
 * @return the list of possible values.
 */

Body of Frist Method:
{
    return values;
}
Body of Second Method:
{
    return mChoiceValues;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawRoundRect:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified round-rect using the specified paint. The roundrect
 * will be filled or framed based on the Style in the paint.
 *
 * @param rect  The rectangular bounds of the roundRect to be drawn
 * @param rx    The x-radius of the oval used to round the corners
 * @param ry    The y-radius of the oval used to round the corners
 * @param paint The paint used to draw the roundRect
 */

Body of Frist Method:
{
    if (rect == null) {
        throw new NullPointerException();
    }
    native_drawRoundRect(mNativeCanvas, rect, rx, ry, paint.mNativePaint);
}
Body of Second Method:
{
    drawRoundRect(rect.left, rect.top, rect.right, rect.bottom, rx, ry, paint);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.unregisterMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterMediaButtonEventReceiverForCalls()
 */

Body of Frist Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
        return;
    }
    synchronized (mRCStack) {
        mMediaReceiverForCalls = null;
    }
}
Body of Second Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
        return;
    }
    synchronized (mPRStack) {
        mMediaReceiverForCalls = null;
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.removeUserRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an app-specified route for media from the MediaRouter.
 *
 * @param info Definition of the route to remove
 * @see #addUserRoute(UserRouteInfo)
 */

Body of Frist Method:
{
    removeRoute(info);
}
Body of Second Method:
{
    removeRouteStatic(info);
}
------------------------
Find a functionally equivalent code:android.text.TextLine.handleText:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function for measuring and rendering text.  The text must
 * not include a tab or emoji.
 *
 * @param wp the working paint
 * @param start the start of the text
 * @param end the end of the text
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null if rendering is not needed
 * @param x the edge of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width of the run is needed
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    int contextLen = contextEnd - contextStart;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
        if (mCharsValid) {
            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, flags, null, 0);
        } else {
            int delta = mStart;
            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, flags, null, 0);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
Body of Second Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    int contextLen = contextEnd - contextStart;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, runIsRtl, null, 0);
        } else {
            int delta = mStart;
            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, null, 0);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
------------------------
Find a functionally equivalent code:android.hardware.location.GeofenceHardwareImpl.reportGeofenceMonitorStatus:COMMENT
Method Modifier: public      
Comment:/**
 * Used to report Monitor status changes.
 */

Body of Frist Method:
{
    // TODO: use the source if needed in the future
    setMonitorAvailability(monitoringType, monitoringStatus);
    acquireWakeLock();
    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, location);
    message.arg1 = monitoringStatus;
    message.arg2 = monitoringType;
    message.sendToTarget();
}
Body of Second Method:
{
    setMonitorAvailability(monitoringType, monitoringStatus);
    acquireWakeLock();
    GeofenceHardwareMonitorEvent event = new GeofenceHardwareMonitorEvent(monitoringType, monitoringStatus, source, location);
    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, event);
    message.sendToTarget();
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.requestSetVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request a volume change for this route.
 * @param volume value between 0 and getVolumeMax
 */

Body of Frist Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        Log.e(TAG, getClass().getSimpleName() + ".requestSetVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
    }
}
Body of Second Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        sStatic.requestSetVolume(this, volume);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.addAssetPath:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Add an additional set of assets to the asset manager.  This can be
 * either a directory or ZIP file.  Not for use by applications.  Returns
 * the cookie of the added asset, or 0 on failure.
 * {@hide}
 */

Body of Frist Method:
{
    int res = addAssetPathNative(path);
    return res;
}
Body of Second Method:
{
    synchronized (this) {
        int res = addAssetPathNative(path);
        makeStringBlocks(mStringBlocks);
        return res;
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a short[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (short[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "short[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getShortArray(key);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.LayerDrawable.setDrawableByLayerId:COMMENT
Method Modifier: public      
Comment:/**
 * Sets (or replaces) the {@link Drawable} for the layer with the given id.
 *
 * @param id The layer ID to search for.
 * @param drawable The replacement {@link Drawable}.
 * @return Whether the {@link Drawable} was replaced (could return false if
 * the id was not found).
 */

Body of Frist Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = mLayerState.mNum - 1; i >= 0; i--) {
        if (layers[i].mId == id) {
            if (layers[i].mDrawable != null) {
                if (drawable != null) {
                    Rect bounds = layers[i].mDrawable.getBounds();
                    drawable.setBounds(bounds);
                }
                layers[i].mDrawable.setCallback(null);
            }
            if (drawable != null) {
                drawable.setCallback(this);
            }
            layers[i].mDrawable = drawable;
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final ChildDrawable childDrawable = layers[i];
        if (childDrawable.mId == id) {
            if (childDrawable.mDrawable != null) {
                if (drawable != null) {
                    final Rect bounds = childDrawable.mDrawable.getBounds();
                    drawable.setBounds(bounds);
                }
                childDrawable.mDrawable.setCallback(null);
            }
            if (drawable != null) {
                drawable.setCallback(this);
            }
            childDrawable.mDrawable = drawable;
            mLayerState.invalidateCache();
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.checkUpdateRemoteStateIfActive:COMMENT
Method Modifier: protected   
Comment:/**
 * Checks if a remote client is active on the supplied stream type. Update the remote stream
 * volume state if found and playing
 * @param streamType
 * @return false if no remote playing is currently playing
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        // iterating from top of stack as active playback is more likely on entries at the top
        try {
            for (int index = mRCStack.size() - 1; index >= 0; index--) {
                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                if ((rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(rcse.mPlaybackState.mState) && (rcse.mPlaybackStream == streamType)) {
                    if (DEBUG_RC)
                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + rcse.mPlaybackVolume);
                    synchronized (mMainRemote) {
                        mMainRemote.mRccId = rcse.mRccId;
                        mMainRemote.mVolume = rcse.mPlaybackVolume;
                        mMainRemote.mVolumeMax = rcse.mPlaybackVolumeMax;
                        mMainRemote.mVolumeHandling = rcse.mPlaybackVolumeHandling;
                        mMainRemoteIsActive = true;
                    }
                    return true;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
    }
    synchronized (mMainRemote) {
        mMainRemoteIsActive = false;
    }
    return false;
}
Body of Second Method:
{
    synchronized (mPRStack) {
        // iterating from top of stack as active playback is more likely on entries at the top
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if ((prse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(prse.mPlaybackState.mState) && (prse.mPlaybackStream == streamType)) {
                    if (DEBUG_RC)
                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + prse.mPlaybackVolume);
                    synchronized (mMainRemote) {
                        mMainRemote.mRccId = prse.getRccId();
                        mMainRemote.mVolume = prse.mPlaybackVolume;
                        mMainRemote.mVolumeMax = prse.mPlaybackVolumeMax;
                        mMainRemote.mVolumeHandling = prse.mPlaybackVolumeHandling;
                        mMainRemoteIsActive = true;
                    }
                    return true;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
    }
    synchronized (mMainRemote) {
        mMainRemoteIsActive = false;
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.setupTabHost:COMMENT
Method Modifier: private     
Comment:/**
 * Sets up a {@link TabHost} object.
 * @param tabHost the TabHost to setup.
 * @param projectCallback The project callback object to access the project R class.
 * @throws PostInflateException
 */

Body of Frist Method:
{
    // look for the TabWidget, and the FrameLayout. They have their own specific names
    View v = tabHost.findViewById(android.R.id.tabs);
    if (v == null) {
        throw new PostInflateException("TabHost requires a TabWidget with id \"android:id/tabs\".\n");
    }
    if ((v instanceof TabWidget) == false) {
        throw new PostInflateException(String.format("TabHost requires a TabWidget with id \"android:id/tabs\".\n" + "View found with id 'tabs' is '%s'", v.getClass().getCanonicalName()));
    }
    v = tabHost.findViewById(android.R.id.tabcontent);
    if (v == null) {
        // TODO: see if we can fake tabs even without the FrameLayout (same below when the framelayout is empty)
        throw new PostInflateException("TabHost requires a FrameLayout with id \"android:id/tabcontent\".");
    }
    if ((v instanceof FrameLayout) == false) {
        throw new PostInflateException(String.format("TabHost requires a FrameLayout with id \"android:id/tabcontent\".\n" + "View found with id 'tabcontent' is '%s'", v.getClass().getCanonicalName()));
    }
    FrameLayout content = (FrameLayout) v;
    // now process the content of the framelayout and dynamically create tabs for it.
    final int count = content.getChildCount();
    // this must be called before addTab() so that the TabHost searches its TabWidget
    // and FrameLayout.
    tabHost.setup();
    if (count == 0) {
        // Create a dummy child to get a single tab
        TabSpec spec = tabHost.newTabSpec("tag").setIndicator("Tab Label", tabHost.getResources().getDrawable(android.R.drawable.ic_menu_info_details)).setContent(new TabHost.TabContentFactory() {

            @Override
            public View createTabContent(String tag) {
                return new LinearLayout(getContext());
            }
        });
        tabHost.addTab(spec);
        return;
    } else {
        // for each child of the framelayout, add a new TabSpec
        for (int i = 0; i < count; i++) {
            View child = content.getChildAt(i);
            String tabSpec = String.format("tab_spec%d", i + 1);
            int id = child.getId();
            Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
            String name;
            if (resource != null) {
                name = resource.getSecond();
            } else {
                // default name if id is unresolved.
                name = String.format("Tab %d", i + 1);
            }
            tabHost.addTab(tabHost.newTabSpec(tabSpec).setIndicator(name).setContent(id));
        }
    }
}
Body of Second Method:
{
    // look for the TabWidget, and the FrameLayout. They have their own specific names
    View v = tabHost.findViewById(android.R.id.tabs);
    if (v == null) {
        throw new PostInflateException("TabHost requires a TabWidget with id \"android:id/tabs\".\n");
    }
    if (!(v instanceof TabWidget)) {
        throw new PostInflateException(String.format("TabHost requires a TabWidget with id \"android:id/tabs\".\n" + "View found with id 'tabs' is '%s'", v.getClass().getCanonicalName()));
    }
    v = tabHost.findViewById(android.R.id.tabcontent);
    if (v == null) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException("TabHost requires a FrameLayout with id \"android:id/tabcontent\".");
    }
    if (!(v instanceof FrameLayout)) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException(String.format("TabHost requires a FrameLayout with id \"android:id/tabcontent\".\n" + "View found with id 'tabcontent' is '%s'", v.getClass().getCanonicalName()));
    }
    FrameLayout content = (FrameLayout) v;
    // now process the content of the frameLayout and dynamically create tabs for it.
    final int count = content.getChildCount();
    // this must be called before addTab() so that the TabHost searches its TabWidget
    // and FrameLayout.
    tabHost.setup();
    if (count == 0) {
        // Create a dummy child to get a single tab
        TabSpec spec = tabHost.newTabSpec("tag").setIndicator("Tab Label", tabHost.getResources().getDrawable(android.R.drawable.ic_menu_info_details)).setContent(new TabHost.TabContentFactory() {

            @Override
            public View createTabContent(String tag) {
                return new LinearLayout(getContext());
            }
        });
        tabHost.addTab(spec);
    } else {
        // for each child of the frameLayout, add a new TabSpec
        for (int i = 0; i < count; i++) {
            View child = content.getChildAt(i);
            String tabSpec = String.format("tab_spec%d", i + 1);
            int id = child.getId();
            @SuppressWarnings("deprecation") Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
            String name;
            if (resource != null) {
                name = resource.getSecond();
            } else {
                // default name if id is unresolved.
                name = String.format("Tab %d", i + 1);
            }
            tabHost.addTab(tabHost.newTabSpec(tabSpec).setIndicator(name).setContent(id));
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.ListPopupWindow.DropDownListView.onForwardedEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Handles forwarded events.
 *
 * @param activePointerId id of the pointer that activated forwarding
 * @return whether the event was handled
 */

Body of Frist Method:
{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}
Body of Second Method:
{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position, x, y);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}
------------------------
Find a functionally equivalent code:android.test.TouchUtils.scrollToBottom:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Scroll a ViewGroup to the bottom by repeatedly calling
 * {@link #dragQuarterScreenUp(InstrumentationTestCase, Activity)}
 *
 * @param test The test case that is being run
 * @param v The ViewGroup that should be dragged
 *
 * @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of
 * {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for
 * configuring the Activity under test
 */

Body of Frist Method:
{
    scrollToBottom(test, test.getActivity(), v);
}
Body of Second Method:
{
    scrollToBottom(test, test.getActivity(), v);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callCallNativeInstance:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link ClassWithNative#callNativeInstance(int, double, Object[])}
 * via reflection.
 */

Body of Frist Method:
{
    Method m = instance.getClass().getMethod("callNativeInstance", new Class<?>[] { int.class, double.class, Object[].class });
    Object result = m.invoke(instance, new Object[] { a, d, o });
    return ((Integer) result).intValue();
}
Body of Second Method:
{
    Method m = instance.getClass().getMethod("callNativeInstance", int.class, double.class, Object[].class);
    Object result = m.invoke(instance, a, d, o);
    return (Integer) result;
}
------------------------
Find a functionally equivalent code:android.net.LocalSocketImpl.close:COMMENT
Method Modifier: public      
Comment:/**
 * Closes the socket.
 *
 * @throws IOException
 */

Body of Frist Method:
{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Libcore.os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}
Body of Second Method:
{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.unregisterCallbacks:COMMENT
Method Modifier: public      
Comment:/**
 * Unregister all call backs, both to and from the controller
 */

Body of Frist Method:
{
    mBrightnessObserver.stopObserving();
    mChangeCallbacks.clear();
    mUserTracker.stopTracking();
}
Body of Second Method:
{
    if (!mListening) {
        return;
    }
    mBrightnessObserver.stopObserving();
    mUserTracker.stopTracking();
    mControl.setOnChangedListener(null);
    mListening = false;
}
------------------------
Find a functionally equivalent code:android.app.WallpaperManager.suggestDesiredDimensions:COMMENT
Method Modifier: public      
Comment:/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */

Body of Frist Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt("sys.max_texture_size", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleCancel:COMMENT
Method Modifier: 
Comment:/**
 * Stops the Face Unlock service and goes to the backup lock.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "handleCancel()");
    // We are going to the backup method, so we don't want to see Face Unlock again until the
    // next time the user visits keyguard.
    KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
    mKeyguardScreenCallback.showBackupSecurity();
    stop();
    mKeyguardScreenCallback.userActivity(BACKUP_LOCK_TIMEOUT);
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "handleCancel()");
    // We are going to the backup method, so we don't want to see Face Unlock again until the
    // next time the user visits keyguard.
    KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
    mKeyguardScreenCallback.showBackupSecurity();
    stop();
    mKeyguardScreenCallback.userActivity();
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the user-visible title for the entry, if any.
 * @return the user-visible title for the entry, null if none was set earlier.
 */

Body of Frist Method:
{
    return title;
}
Body of Second Method:
{
    return mTitle;
}
------------------------
Find a functionally equivalent code:android.graphics.Path.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Rewinds the path: clears any lines and curves from the path but
 * keeps the internal data structure for faster reuse.
 */

Body of Frist Method:
{
    isSimplePath = true;
    if (mDetectSimplePaths) {
        mLastDirection = null;
        if (rects != null)
            rects.setEmpty();
    }
    native_rewind(mNativePath);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    native_rewind(mNativePath);
}
------------------------
Find a functionally equivalent code:android.view.GLES20Canvas.getRenderer:COMMENT
Method Modifier: 
Comment:/**
 * Returns the native OpenGLRenderer object.
 */

Body of Frist Method:
{
    return mRenderer;
}
Body of Second Method:
{
    return mRenderer;
}
------------------------
Find a functionally equivalent code:android.widget.SuggestionsAdapter.getDrawable:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a drawable by URI, without using the cache.
 *
 * @return A drawable, or {@code null} if the drawable could not be loaded.
 */

Body of Frist Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id);
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
Body of Second Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id, mContext.getTheme());
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.view.InputQueue.sendInputEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    ActiveInputEvent event = obtainActiveInputEvent(token, callback);
    int id;
    if (e instanceof KeyEvent) {
        id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
    } else {
        id = nativeSendMotionEvent(mPtr, (MotionEvent) e);
    }
    mActiveEventArray.put(id, event);
}
Body of Second Method:
{
    ActiveInputEvent event = obtainActiveInputEvent(token, callback);
    long id;
    if (e instanceof KeyEvent) {
        id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
    } else {
        id = nativeSendMotionEvent(mPtr, (MotionEvent) e);
    }
    mActiveEventArray.put(id, event);
}
------------------------
Find a functionally equivalent code:android.preference.Preference.setIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the icon for this Preference with a Drawable.
 * This icon will be placed into the ID
 * {@link android.R.id#icon} within the View created by
 * {@link #onCreateView(ViewGroup)}.
 *
 * @param icon The optional icon for this Preference.
 */

Body of Frist Method:
{
    if ((icon == null && mIcon != null) || (icon != null && mIcon != icon)) {
        mIcon = icon;
        notifyChanged();
    }
}
Body of Second Method:
{
    if ((icon == null && mIcon != null) || (icon != null && mIcon != icon)) {
        mIcon = icon;
        notifyChanged();
    }
}
------------------------
Find a functionally equivalent code:android.net.Proxy.getProxy:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Return the proxy object to be used for the URL given as parameter.
 * @param ctx A Context used to get the settings for the proxy host.
 * @param url A URL to be accessed. Used to evaluate exclusion list.
 * @return Proxy (java.net) object containing the host name. If the
 * user did not set a hostname it returns the default host.
 * A null value means that no host is to be used.
 * {@hide}
 */

Body of Frist Method:
{
    String host = "";
    if (url != null) {
        URI uri = URI.create(url);
        host = uri.getHost();
    }
    if (!isLocalHost(host)) {
        if (sConnectivityManager == null) {
            sConnectivityManager = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
        }
        if (sConnectivityManager == null)
            return java.net.Proxy.NO_PROXY;
        ProxyProperties proxyProperties = sConnectivityManager.getProxy();
        if (proxyProperties != null) {
            if (!proxyProperties.isExcluded(host)) {
                return proxyProperties.makeProxy();
            }
        }
    }
    return java.net.Proxy.NO_PROXY;
}
Body of Second Method:
{
    String host = "";
    if ((url != null) && !isLocalHost(host)) {
        URI uri = URI.create(url);
        ProxySelector proxySelector = ProxySelector.getDefault();
        List<java.net.Proxy> proxyList = proxySelector.select(uri);
        if (proxyList.size() > 0) {
            return proxyList.get(0);
        }
    }
    return java.net.Proxy.NO_PROXY;
}
------------------------
Find a functionally equivalent code:android.os.Process.myUid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process's uid.  This is the kernel uid
 * that the process is running under, which is the identity of its
 * app-specific sandbox.  It is different from {@link #myUserHandle} in that
 * a uid identifies a specific app sandbox in a specific user.
 */

Body of Frist Method:
{
    return Libcore.os.getuid();
}
Body of Second Method:
{
    return Os.getuid();
}
------------------------
Find a functionally equivalent code:android.widget.Scroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */

Body of Frist Method:
{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
Body of Second Method:
{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<Integer> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putIntegerArrayList(key, value);
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */

Body of Frist Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mUnscaledDuration = duration;
    mDuration = (long) (duration * sDurationScale);
    return this;
}
Body of Second Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mUnscaledDuration = duration;
    updateScaledDuration();
    return this;
}
------------------------
Find a functionally equivalent code:android.text.GraphicsOperations.drawTextRun:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Canvas#drawTextRun}.
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.NetworkStats.findIndexHinted:COMMENT
Method Modifier: public      
Comment:/**
 * Find first stats index that matches the requested parameters, starting
 * search around the hinted index as an optimization.
 */

Body of Frist Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.setVisiblePatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Set whether the visible pattern is enabled.
 */

Body of Frist Method:
{
    setBoolean(Settings.Secure.LOCK_PATTERN_VISIBLE, enabled);
}
Body of Second Method:
{
    setBoolean(Settings.Secure.LOCK_PATTERN_VISIBLE, enabled);
    // Update for crypto if owner
    int userId = getCurrentOrCallingUserId();
    if (userId != UserHandle.USER_OWNER) {
        return;
    }
    IBinder service = ServiceManager.getService("mount");
    if (service == null) {
        Log.e(TAG, "Could not find the mount service to update the user info");
        return;
    }
    IMountService mountService = IMountService.Stub.asInterface(service);
    try {
        mountService.setField(StorageManager.PATTERN_VISIBLE_KEY, enabled ? "1" : "0");
    } catch (RemoteException e) {
        Log.e(TAG, "Error changing pattern visible state", e);
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.focusableViewAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mParent != null && // getting focus
    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && // an ancestor of v; this will get checked for at ViewAncestor
    !(isFocused() && getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) {
        mParent.focusableViewAvailable(v);
    }
}
Body of Second Method:
{
    if (mParent != null && // getting focus
    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen()) && // an ancestor of v; this will get checked for at ViewAncestor
    !(isFocused() && getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) {
        mParent.focusableViewAvailable(v);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSyncManager.resetSync:COMMENT
Method Modifier: public      
Comment:/**
 * resetSync() resets sync manager's timer
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager resetSync ***");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.getTrackInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an array of track information.
 *
 * @return Array of track info. The total number of tracks is the array length.
 * Must be called again if an external timed text source has been added after any of the
 * addTimedTextSource methods are called.
 * @throws IllegalStateException if it is called in an invalid state.
 */

Body of Frist Method:
{
    TrackInfo[] trackInfo = getInbandTrackInfo();
    // add out-of-band tracks
    TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + mOutOfBandSubtitleTracks.size()];
    System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
    int i = trackInfo.length;
    for (SubtitleTrack track : mOutOfBandSubtitleTracks) {
        allTrackInfo[i] = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, track.getFormat());
        ++i;
    }
    return allTrackInfo;
}
Body of Second Method:
{
    TrackInfo[] trackInfo = getInbandTrackInfo();
    // add out-of-band tracks
    TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + mOutOfBandSubtitleTracks.size()];
    System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
    int i = trackInfo.length;
    for (SubtitleTrack track : mOutOfBandSubtitleTracks) {
        int type = track.isTimedText() ? TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT : TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE;
        allTrackInfo[i] = new TrackInfo(type, track.getFormat());
        ++i;
    }
    return allTrackInfo;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.CaptioningManager.CaptionStyle.getCustomStyle:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final CaptionStyle defStyle = CaptionStyle.DEFAULT_CUSTOM;
    final int foregroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR, defStyle.foregroundColor);
    final int backgroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR, defStyle.backgroundColor);
    final int edgeType = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE, defStyle.edgeType);
    final int edgeColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR, defStyle.edgeColor);
    String rawTypeface = Secure.getString(cr, Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
    if (rawTypeface == null) {
        rawTypeface = defStyle.mRawTypeface;
    }
    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, rawTypeface);
}
Body of Second Method:
{
    final CaptionStyle defStyle = CaptionStyle.DEFAULT_CUSTOM;
    final int foregroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR, defStyle.foregroundColor);
    final int backgroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR, defStyle.backgroundColor);
    final int edgeType = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE, defStyle.edgeType);
    final int edgeColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR, defStyle.edgeColor);
    final int windowColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR, defStyle.windowColor);
    String rawTypeface = Secure.getString(cr, Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
    if (rawTypeface == null) {
        rawTypeface = defStyle.mRawTypeface;
    }
    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, windowColor, rawTypeface);
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onPaused:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onPaused: " + paused);
        if (mStopped) {
            // handle as seek if we were stopped
            scheduleNotification(NOTIFY_SEEK, 0);
        } else {
            // special handling if player disappeared
            mPausing = paused;
            scheduleNotification(REFRESH_AND_NOTIFY_TIME, 0);
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onPaused: " + paused);
        if (mStopped) {
            // handle as seek if we were stopped
            mStopped = false;
            mSeeking = true;
            scheduleNotification(NOTIFY_SEEK, 0);
        } else {
            // special handling if player disappeared
            mPausing = paused;
            mSeeking = false;
            scheduleNotification(REFRESH_AND_NOTIFY_TIME, 0);
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.Window.setWindowAnimations:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom animations to use for the window, as per
 * {@link WindowManager.LayoutParams#windowAnimations
 * WindowManager.LayoutParams.windowAnimations}.  Providing anything besides
 * 0 here will override the animations the window would
 * normally retrieve from its theme.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.windowAnimations = resId;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.windowAnimations = resId;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.app.ActivityThread.performStopActivityInner:COMMENT
Method Modifier: private     
Comment:/**
 * Core implementation of stopping an activity.  Note this is a little
 * tricky because the server's meaning of stop is slightly different
 * than our client -- for the server, stop means to save state and give
 * it the result when it is done, but the window may still be visible.
 * For the client, we want to call onStop()/onStart() to indicate when
 * the activity's UI visibillity changes.
 */

Body of Frist Method:
{
    if (localLOGV)
        Slog.v(TAG, "Performing stop of " + r);
    Bundle state = null;
    if (r != null) {
        if (!keepShown && r.stopped) {
            if (r.activity.mFinished) {
                // if the activity isn't resumed.
                return;
            }
            RuntimeException e = new RuntimeException("Performing stop of activity that is not resumed: " + r.intent.getComponent().toShortString());
            Slog.e(TAG, e.getMessage(), e);
        }
        if (info != null) {
            try {
                // First create a thumbnail for the activity...
                // For now, don't create the thumbnail here; we are
                // doing that by doing a screen snapshot.
                // createThumbnailBitmap(r);
                info.thumbnail = null;
                info.description = r.activity.onCreateDescription();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to save state of activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        // Next have the activity save its current state and managed dialogs...
        if (!r.activity.mFinished && saveState) {
            if (r.state == null) {
                state = new Bundle();
                state.setAllowFds(false);
                mInstrumentation.callActivityOnSaveInstanceState(r.activity, state);
                r.state = state;
            } else {
                state = r.state;
            }
        }
        if (!keepShown) {
            try {
                // Now we are idle.
                r.activity.performStop();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to stop activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
            r.stopped = true;
        }
        r.paused = true;
    }
}
Body of Second Method:
{
    if (localLOGV)
        Slog.v(TAG, "Performing stop of " + r);
    if (r != null) {
        if (!keepShown && r.stopped) {
            if (r.activity.mFinished) {
                // if the activity isn't resumed.
                return;
            }
            RuntimeException e = new RuntimeException("Performing stop of activity that is not resumed: " + r.intent.getComponent().toShortString());
            Slog.e(TAG, e.getMessage(), e);
        }
        if (info != null) {
            try {
                // First create a thumbnail for the activity...
                // For now, don't create the thumbnail here; we are
                // doing that by doing a screen snapshot.
                info.description = r.activity.onCreateDescription();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to save state of activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        // Next have the activity save its current state and managed dialogs...
        if (!r.activity.mFinished && saveState) {
            if (r.state == null) {
                callCallActivityOnSaveInstanceState(r);
            }
        }
        if (!keepShown) {
            try {
                // Now we are idle.
                r.activity.performStop();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to stop activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
            r.stopped = true;
        }
        r.paused = true;
    }
}
------------------------
Find a functionally equivalent code:android.hardware.SensorManager.getRotationMatrixFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a rotation matrix.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
 * 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
 * If R.length == 9, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   \
 * |  R[ 3]   R[ 4]   R[ 5]   |
 * \  R[ 6]   R[ 7]   R[ 8]   /
 * </pre>
 * If R.length == 16, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   0  \
 * |  R[ 4]   R[ 5]   R[ 6]   0  |
 * |  R[ 8]   R[ 9]   R[10]   0  |
 * \  0       0       0       1  /
 * </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */

Body of Frist Method:
{
    float q0;
    float q1 = rotationVector[0];
    float q2 = rotationVector[1];
    float q3 = rotationVector[2];
    if (rotationVector.length == 4) {
        q0 = rotationVector[3];
    } else {
        q0 = 1 - q1 * q1 - q2 * q2 - q3 * q3;
        q0 = (q0 > 0) ? (float) Math.sqrt(q0) : 0;
    }
    float sq_q1 = 2 * q1 * q1;
    float sq_q2 = 2 * q2 * q2;
    float sq_q3 = 2 * q3 * q3;
    float q1_q2 = 2 * q1 * q2;
    float q3_q0 = 2 * q3 * q0;
    float q1_q3 = 2 * q1 * q3;
    float q2_q0 = 2 * q2 * q0;
    float q2_q3 = 2 * q2 * q3;
    float q1_q0 = 2 * q1 * q0;
    if (R.length == 9) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = q1_q2 + q3_q0;
        R[4] = 1 - sq_q1 - sq_q3;
        R[5] = q2_q3 - q1_q0;
        R[6] = q1_q3 - q2_q0;
        R[7] = q2_q3 + q1_q0;
        R[8] = 1 - sq_q1 - sq_q2;
    } else if (R.length == 16) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = 0.0f;
        R[4] = q1_q2 + q3_q0;
        R[5] = 1 - sq_q1 - sq_q3;
        R[6] = q2_q3 - q1_q0;
        R[7] = 0.0f;
        R[8] = q1_q3 - q2_q0;
        R[9] = q2_q3 + q1_q0;
        R[10] = 1 - sq_q1 - sq_q2;
        R[11] = 0.0f;
        R[12] = R[13] = R[14] = 0.0f;
        R[15] = 1.0f;
    }
}
Body of Second Method:
{
    float q0;
    float q1 = rotationVector[0];
    float q2 = rotationVector[1];
    float q3 = rotationVector[2];
    if (rotationVector.length >= 4) {
        q0 = rotationVector[3];
    } else {
        q0 = 1 - q1 * q1 - q2 * q2 - q3 * q3;
        q0 = (q0 > 0) ? (float) Math.sqrt(q0) : 0;
    }
    float sq_q1 = 2 * q1 * q1;
    float sq_q2 = 2 * q2 * q2;
    float sq_q3 = 2 * q3 * q3;
    float q1_q2 = 2 * q1 * q2;
    float q3_q0 = 2 * q3 * q0;
    float q1_q3 = 2 * q1 * q3;
    float q2_q0 = 2 * q2 * q0;
    float q2_q3 = 2 * q2 * q3;
    float q1_q0 = 2 * q1 * q0;
    if (R.length == 9) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = q1_q2 + q3_q0;
        R[4] = 1 - sq_q1 - sq_q3;
        R[5] = q2_q3 - q1_q0;
        R[6] = q1_q3 - q2_q0;
        R[7] = q2_q3 + q1_q0;
        R[8] = 1 - sq_q1 - sq_q2;
    } else if (R.length == 16) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = 0.0f;
        R[4] = q1_q2 + q3_q0;
        R[5] = 1 - sq_q1 - sq_q3;
        R[6] = q2_q3 - q1_q0;
        R[7] = 0.0f;
        R[8] = q1_q3 - q2_q0;
        R[9] = q2_q3 + q1_q0;
        R[10] = 1 - sq_q1 - sq_q2;
        R[11] = 0.0f;
        R[12] = R[13] = R[14] = 0.0f;
        R[15] = 1.0f;
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.hasFileDescriptors:COMMENT
Method Modifier: public      
Comment:/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */

Body of Frist Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
Body of Second Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
------------------------
Find a functionally equivalent code:android.os.storage.IMountService.mountSecureContainer:COMMENT
Method Modifier: public      
Comment:/*
     * Mount a secure container with the specified key and owner UID. Returns an
     * int consistent with MountServiceResultCode
     */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.getStatSize:COMMENT
Method Modifier: public      
Comment:/**
 * Return the total size of the file representing this fd, as determined by
 * {@code stat()}. Returns -1 if the fd is not a file.
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Libcore.os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, "fstat() failed: " + e);
            return -1;
        }
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, "fstat() failed: " + e);
            return -1;
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.Surface.unlockCanvasAndPost:COMMENT
Method Modifier: public      
Comment:/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */

Body of Frist Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Integer.toHexString(mNativeObject) + ") != mLockedObject (0x" + Integer.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        nativeUnlockCanvasAndPost(mLockedObject, canvas);
        nativeRelease(mLockedObject);
        mLockedObject = 0;
    }
}
Body of Second Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Long.toHexString(mNativeObject) + ") != mLockedObject (0x" + Long.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.start:COMMENT
Method Modifier: public      
Comment:/**
 * Binds to the Face Unlock service.  Face Unlock will be started when the bind completes.  The
 * Face Unlock view is displayed to hide the backup lock while the service is starting up.
 * Called on the UI thread.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "start()");
    if (mHandler.getLooper() != Looper.myLooper()) {
        Log.e(TAG, "start() called off of the UI thread");
    }
    if (mIsRunning) {
        Log.w(TAG, "start() called when already running");
    }
    if (!mBoundToService) {
        Log.d(TAG, "Binding to Face Unlock service for user=" + mLockPatternUtils.getCurrentUser());
        mContext.bindServiceAsUser(new Intent(IFaceLockInterface.class.getName()), mConnection, Context.BIND_AUTO_CREATE, new UserHandle(mLockPatternUtils.getCurrentUser()));
        mBoundToService = true;
    } else {
        Log.w(TAG, "Attempt to bind to Face Unlock when already bound");
    }
    mIsRunning = true;
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "start()");
    if (mHandler.getLooper() != Looper.myLooper()) {
        Log.e(TAG, "start() called off of the UI thread");
    }
    if (mIsRunning) {
        Log.w(TAG, "start() called when already running");
    }
    if (!mBoundToService) {
        Log.d(TAG, "Binding to Face Unlock service for user=" + mLockPatternUtils.getCurrentUser());
        mContext.bindServiceAsUser(new Intent(IFaceLockInterface.class.getName()).setPackage(FACE_LOCK_PACKAGE), mConnection, Context.BIND_AUTO_CREATE, new UserHandle(mLockPatternUtils.getCurrentUser()));
        mBoundToService = true;
    } else {
        Log.w(TAG, "Attempt to bind to Face Unlock when already bound");
    }
    mIsRunning = true;
    return true;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visit:COMMENT
Method Modifier: public      
Comment:/* Visits the class header. */

Body of Frist Method:
{
    // This class might be being renamed.
    name = mClassName;
    // remove protected or private and set as public
    if (Main.sOptions.generatePublicAccess) {
        access = access & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED);
        access |= Opcodes.ACC_PUBLIC;
    }
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // note: leave abstract classes as such
    // don't try to implement stub for interfaces
    mIsInterface = ((access & Opcodes.ACC_INTERFACE) != 0);
    super.visit(version, access, name, signature, superName, interfaces);
}
Body of Second Method:
{
    // This class might be being renamed.
    name = mClassName;
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // note: leave abstract classes as such
    // don't try to implement stub for interfaces
    mIsInterface = ((access & Opcodes.ACC_INTERFACE) != 0);
    super.visit(version, access, name, signature, superName, interfaces);
}
------------------------
Find a functionally equivalent code:android.view.MotionEvent.axisFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets an axis by its symbolic name such as "AXIS_X" or an
 * equivalent numeric constant such as "42".
 *
 * @param symbolicName The symbolic name of the axis.
 * @return The axis or -1 if not found.
 * @see KeyEvent#keyCodeToString(int)
 */

Body of Frist Method:
{
    if (symbolicName == null) {
        throw new IllegalArgumentException("symbolicName must not be null");
    }
    final int count = AXIS_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(AXIS_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}
Body of Second Method:
{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int axis = nativeAxisFromString(symbolicName);
        if (axis >= 0) {
            return axis;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSyncManager.sync:COMMENT
Method Modifier: public      
Comment:/**
 * sync() forces sync manager to sync now
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager sync ***");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_NOW_INTERVAL);
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.getPropertyFunction:COMMENT
Method Modifier: private     
Comment:/**
 * Determine the setter or getter function using the JavaBeans convention of setFoo or
 * getFoo for a property named 'foo'. This function figures out what the name of the
 * function should be and uses reflection to find the Method with that name on the
 * target object.
 *
 * @param targetClass The class to search for the method
 * @param prefix "set" or "get", depending on whether we need a setter or getter.
 * @param valueType The type of the parameter (in the case of a setter). This type
 * is derived from the values set on this PropertyValuesHolder. This type is used as
 * a first guess at the parameter type, but we check for methods with several different
 * types to avoid problems with slight mis-matches between supplied values and actual
 * value types used on the setter.
 * @return Method the method associated with mPropertyName.
 */

Body of Frist Method:
{
    // TODO: faster implementation...
    Method returnVal = null;
    String methodName = getMethodName(prefix, mPropertyName);
    Class[] args = null;
    if (valueType == null) {
        try {
            returnVal = targetClass.getMethod(methodName, args);
        } catch (NoSuchMethodException e) {
        // Swallow the error, log it later
        }
    } else {
        args = new Class[1];
        Class[] typeVariants;
        if (mValueType.equals(Float.class)) {
            typeVariants = FLOAT_VARIANTS;
        } else if (mValueType.equals(Integer.class)) {
            typeVariants = INTEGER_VARIANTS;
        } else if (mValueType.equals(Double.class)) {
            typeVariants = DOUBLE_VARIANTS;
        } else {
            typeVariants = new Class[1];
            typeVariants[0] = mValueType;
        }
        for (Class typeVariant : typeVariants) {
            args[0] = typeVariant;
            try {
                returnVal = targetClass.getMethod(methodName, args);
                // change the value type to suit
                mValueType = typeVariant;
                return returnVal;
            } catch (NoSuchMethodException e) {
            // Swallow the error and keep trying other variants
            }
        }
    // If we got here, then no appropriate function was found
    }
    if (returnVal == null) {
        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + mValueType + " not found on target class " + targetClass);
    }
    return returnVal;
}
Body of Second Method:
{
    // TODO: faster implementation...
    Method returnVal = null;
    String methodName = getMethodName(prefix, mPropertyName);
    Class[] args = null;
    if (valueType == null) {
        try {
            returnVal = targetClass.getMethod(methodName, args);
        } catch (NoSuchMethodException e) {
        // Swallow the error, log it later
        }
    } else {
        args = new Class[1];
        Class[] typeVariants;
        if (valueType.equals(Float.class)) {
            typeVariants = FLOAT_VARIANTS;
        } else if (valueType.equals(Integer.class)) {
            typeVariants = INTEGER_VARIANTS;
        } else if (valueType.equals(Double.class)) {
            typeVariants = DOUBLE_VARIANTS;
        } else {
            typeVariants = new Class[1];
            typeVariants[0] = valueType;
        }
        for (Class typeVariant : typeVariants) {
            args[0] = typeVariant;
            try {
                returnVal = targetClass.getMethod(methodName, args);
                if (mConverter == null) {
                    // change the value type to suit
                    mValueType = typeVariant;
                }
                return returnVal;
            } catch (NoSuchMethodException e) {
            // Swallow the error and keep trying other variants
            }
        }
    // If we got here, then no appropriate function was found
    }
    if (returnVal == null) {
        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + valueType + " not found on target class " + targetClass);
    }
    return returnVal;
}
------------------------
Find a functionally equivalent code:android.media.SubtitleTrack.show:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mVisible) {
        return;
    }
    mVisible = true;
    getRenderingWidget().setVisible(true);
    if (mTimeProvider != null) {
        mTimeProvider.scheduleUpdate(this);
    }
}
Body of Second Method:
{
    if (mVisible) {
        return;
    }
    mVisible = true;
    RenderingWidget renderingWidget = getRenderingWidget();
    if (renderingWidget != null) {
        renderingWidget.setVisible(true);
    }
    if (mTimeProvider != null) {
        mTimeProvider.scheduleUpdate(this);
    }
}
------------------------
Find a functionally equivalent code:android.hardware.Camera.setPreviewDisplay:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets the {@link Surface} to be used for live preview.
 * Either a surface or surface texture is necessary for preview, and
 * preview is necessary to take pictures.  The same surface can be re-set
 * without harm.  Setting a preview surface will un-set any preview surface
 * texture that was set via {@link #setPreviewTexture}.
 *
 * <p>The {@link SurfaceHolder} must already contain a surface when this
 * method is called.  If you are using {@link android.view.SurfaceView},
 * you will need to register a {@link SurfaceHolder.Callback} with
 * {@link SurfaceHolder#addCallback(SurfaceHolder.Callback)} and wait for
 * {@link SurfaceHolder.Callback#surfaceCreated(SurfaceHolder)} before
 * calling setPreviewDisplay() or starting preview.
 *
 * <p>This method must be called before {@link #startPreview()}.  The
 * one exception is that if the preview surface is not set (or set to null)
 * before startPreview() is called, then this method may be called once
 * with a non-null parameter to set the preview surface.  (This allows
 * camera setup and surface creation to happen in parallel, saving time.)
 * The preview surface may not otherwise change while preview is running.
 *
 * @param holder containing the Surface on which to place the preview,
 * or null to remove the preview surface
 * @throws IOException if the method fails (for example, if the surface
 * is unavailable or unsuitable).
 */

Body of Frist Method:
{
    if (holder != null) {
        setPreviewDisplay(holder.getSurface());
    } else {
        setPreviewDisplay((Surface) null);
    }
}
Body of Second Method:
{
    if (holder != null) {
        setPreviewSurface(holder.getSurface());
    } else {
        setPreviewSurface((Surface) null);
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the background color for the selected week.
 *
 * @return The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

Body of Frist Method:
{
    return mSelectedWeekBackgroundColor;
}
Body of Second Method:
{
    return mDelegate.getSelectedWeekBackgroundColor();
}
------------------------
Find a functionally equivalent code:android.util.Patterns.concatGroups:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Convenience method to take all of the non-null matching groups in a
 * regex Matcher and return them as a concatenated string.
 *
 * @param matcher      The Matcher object from which grouped text will
 * be extracted
 *
 * @return             A String comprising all of the non-null matched
 * groups concatenated together
 */

Body of Frist Method:
{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        System.err.println("Group(" + i + ") : " + s);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}
Body of Second Method:
{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}
------------------------
Find a functionally equivalent code:android.os.PowerManager.WakeLock.setWorkSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */

Body of Frist Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource);
            } catch (RemoteException e) {
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.setSealed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets if this instance is sealed.
 *
 * @param sealed Whether is sealed.
 *
 * @hide
 */

Body of Frist Method:
{
    super.setSealed(sealed);
    List<AccessibilityRecord> records = mRecords;
    final int recordCount = records.size();
    for (int i = 0; i < recordCount; i++) {
        AccessibilityRecord record = records.get(i);
        record.setSealed(sealed);
    }
}
Body of Second Method:
{
    super.setSealed(sealed);
    final List<AccessibilityRecord> records = mRecords;
    if (records != null) {
        final int recordCount = records.size();
        for (int i = 0; i < recordCount; i++) {
            AccessibilityRecord record = records.get(i);
            record.setSealed(sealed);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.preloadClasses:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Performs Zygote process initialization. Loads and initializes
 * commonly used classes.
 *
 * Most classes only cause a few hundred bytes to be allocated, but
 * a few will allocate a dozen Kbytes (in one case, 500+K).
 */

Body of Frist Method:
{
    final VMRuntime runtime = VMRuntime.getRuntime();
    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(PRELOADED_CLASSES);
    if (is == null) {
        Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
    } else {
        Log.i(TAG, "Preloading classes...");
        long startTime = SystemClock.uptimeMillis();
        // Drop root perms while running static initializers.
        setEffectiveGroup(UNPRIVILEGED_GID);
        setEffectiveUser(UNPRIVILEGED_UID);
        // Alter the target heap utilization.  With explicit GCs this
        // is not likely to have any effect.
        float defaultUtilization = runtime.getTargetHeapUtilization();
        runtime.setTargetHeapUtilization(0.8f);
        // Start with a clean slate.
        System.gc();
        runtime.runFinalizationSync();
        Debug.startAllocCounting();
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(is), 256);
            int count = 0;
            String line;
            while ((line = br.readLine()) != null) {
                // Skip comments and blank lines.
                line = line.trim();
                if (line.startsWith("#") || line.equals("")) {
                    continue;
                }
                try {
                    if (false) {
                        Log.v(TAG, "Preloading " + line + "...");
                    }
                    Class.forName(line);
                    if (Debug.getGlobalAllocSize() > PRELOAD_GC_THRESHOLD) {
                        if (false) {
                            Log.v(TAG, " GC at " + Debug.getGlobalAllocSize());
                        }
                        System.gc();
                        runtime.runFinalizationSync();
                        Debug.resetGlobalAllocSize();
                    }
                    count++;
                } catch (ClassNotFoundException e) {
                    Log.w(TAG, "Class not found for preloading: " + line);
                } catch (Throwable t) {
                    Log.e(TAG, "Error preloading " + line + ".", t);
                    if (t instanceof Error) {
                        throw (Error) t;
                    }
                    if (t instanceof RuntimeException) {
                        throw (RuntimeException) t;
                    }
                    throw new RuntimeException(t);
                }
            }
            Log.i(TAG, "...preloaded " + count + " classes in " + (SystemClock.uptimeMillis() - startTime) + "ms.");
        } catch (IOException e) {
            Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
        } finally {
            IoUtils.closeQuietly(is);
            // Restore default.
            runtime.setTargetHeapUtilization(defaultUtilization);
            // Fill in dex caches with classes, fields, and methods brought in by preloading.
            runtime.preloadDexCaches();
            Debug.stopAllocCounting();
            // Bring back root. We'll need it later.
            setEffectiveUser(ROOT_UID);
            setEffectiveGroup(ROOT_GID);
        }
    }
}
Body of Second Method:
{
    final VMRuntime runtime = VMRuntime.getRuntime();
    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(PRELOADED_CLASSES);
    if (is == null) {
        Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
    } else {
        Log.i(TAG, "Preloading classes...");
        long startTime = SystemClock.uptimeMillis();
        // Drop root perms while running static initializers.
        setEffectiveGroup(UNPRIVILEGED_GID);
        setEffectiveUser(UNPRIVILEGED_UID);
        // Alter the target heap utilization.  With explicit GCs this
        // is not likely to have any effect.
        float defaultUtilization = runtime.getTargetHeapUtilization();
        runtime.setTargetHeapUtilization(0.8f);
        // Start with a clean slate.
        System.gc();
        runtime.runFinalizationSync();
        Debug.startAllocCounting();
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(is), 256);
            int count = 0;
            String line;
            while ((line = br.readLine()) != null) {
                // Skip comments and blank lines.
                line = line.trim();
                if (line.startsWith("#") || line.equals("")) {
                    continue;
                }
                try {
                    if (false) {
                        Log.v(TAG, "Preloading " + line + "...");
                    }
                    Class.forName(line);
                    if (Debug.getGlobalAllocSize() > PRELOAD_GC_THRESHOLD) {
                        if (false) {
                            Log.v(TAG, " GC at " + Debug.getGlobalAllocSize());
                        }
                        System.gc();
                        runtime.runFinalizationSync();
                        Debug.resetGlobalAllocSize();
                    }
                    count++;
                } catch (ClassNotFoundException e) {
                    Log.w(TAG, "Class not found for preloading: " + line);
                } catch (UnsatisfiedLinkError e) {
                    Log.w(TAG, "Problem preloading " + line + ": " + e);
                } catch (Throwable t) {
                    Log.e(TAG, "Error preloading " + line + ".", t);
                    if (t instanceof Error) {
                        throw (Error) t;
                    }
                    if (t instanceof RuntimeException) {
                        throw (RuntimeException) t;
                    }
                    throw new RuntimeException(t);
                }
            }
            Log.i(TAG, "...preloaded " + count + " classes in " + (SystemClock.uptimeMillis() - startTime) + "ms.");
        } catch (IOException e) {
            Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
        } finally {
            IoUtils.closeQuietly(is);
            // Restore default.
            runtime.setTargetHeapUtilization(defaultUtilization);
            // Fill in dex caches with classes, fields, and methods brought in by preloading.
            runtime.preloadDexCaches();
            Debug.stopAllocCounting();
            // Bring back root. We'll need it later.
            setEffectiveUser(ROOT_UID);
            setEffectiveGroup(ROOT_GID);
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientRadius:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the radius of the gradient. The radius is honored only when the
 * gradient type is set to {@link #RADIAL_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradientRadius The radius of the gradient in pixels
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

Body of Frist Method:
{
    mGradientState.setGradientRadius(gradientRadius);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientRadius(gradientRadius, TypedValue.COMPLEX_UNIT_PX);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.preConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified matrix.
 * M' = M * other
 */

Body of Frist Method:
{
    return native_preConcat(native_instance, other.native_instance);
}
Body of Second Method:
{
    native_preConcat(native_instance, other.native_instance);
    return true;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
    mMovementGranularities = 0;
    mChildNodeIds.clear();
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    mActions = 0;
    mTextSelectionStart = UNDEFINED;
    mTextSelectionEnd = UNDEFINED;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
Body of Second Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.ApplicationInfo.loadDefaultIcon:COMMENT
<android.content.pm.ApplicationInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if ((flags & FLAG_EXTERNAL_STORAGE) != 0 && isPackageUnavailable(pm)) {
        return Resources.getSystem().getDrawable(com.android.internal.R.drawable.sym_app_on_sd_unavailable_icon);
    }
    return pm.getDefaultActivityIcon();
}
Body of Second Method:
{
    if ((flags & FLAG_EXTERNAL_STORAGE) != 0 && isPackageUnavailable(pm)) {
        return Resources.getSystem().getDrawable(com.android.internal.R.drawable.sym_app_on_sd_unavailable_icon);
    }
    return pm.getDefaultActivityIcon();
}
------------------------
Find a functionally equivalent code:android.text.Layout.getLineMax:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent, but excluding trailing whitespace.
 */

Body of Frist Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}
Body of Second Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiManager.requestBatchedScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Request a batched scan for access points.  To end your requested batched scan,
 * call stopBatchedScan with the same Settings.
 *
 * If there are mulitple requests for batched scans, the more demanding settings will
 * take precidence.
 *
 * @param requested {@link BatchedScanSettings} the scan settings requested.
 * @return false on known error
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.requestBatchedScan(requested, new Binder());
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.requestBatchedScan(requested, new Binder(), null);
    } catch (RemoteException e) {
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.ColorMatrix.setConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Set this colormatrix to the concatenation of the two specified
 * colormatrices, such that the resulting colormatrix has the same effect
 * as applying matB and then applying matA. It is legal for either matA or
 * matB to be the same colormatrix as this.
 */

Body of Frist Method:
{
    float[] tmp = null;
    if (matA == this || matB == this) {
        tmp = new float[20];
    } else {
        tmp = mArray;
    }
    final float[] a = matA.mArray;
    final float[] b = matB.mArray;
    int index = 0;
    for (int j = 0; j < 20; j += 5) {
        for (int i = 0; i < 4; i++) {
            tmp[index++] = a[j + 0] * b[i + 0] + a[j + 1] * b[i + 5] + a[j + 2] * b[i + 10] + a[j + 3] * b[i + 15];
        }
        tmp[index++] = a[j + 0] * b[4] + a[j + 1] * b[9] + a[j + 2] * b[14] + a[j + 3] * b[19] + a[j + 4];
    }
    if (tmp != mArray) {
        System.arraycopy(tmp, 0, mArray, 0, 20);
    }
}
Body of Second Method:
{
    float[] tmp;
    if (matA == this || matB == this) {
        tmp = new float[20];
    } else {
        tmp = mArray;
    }
    final float[] a = matA.mArray;
    final float[] b = matB.mArray;
    int index = 0;
    for (int j = 0; j < 20; j += 5) {
        for (int i = 0; i < 4; i++) {
            tmp[index++] = a[j + 0] * b[i + 0] + a[j + 1] * b[i + 5] + a[j + 2] * b[i + 10] + a[j + 3] * b[i + 15];
        }
        tmp[index++] = a[j + 0] * b[4] + a[j + 1] * b[9] + a[j + 2] * b[14] + a[j + 3] * b[19] + a[j + 4];
    }
    if (tmp != mArray) {
        System.arraycopy(tmp, 0, mArray, 0, 20);
    }
}
------------------------
Find a functionally equivalent code:android.os.Parcel.writeArrayMapInternal:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
    }
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Write #" + i + ": key=0x" + (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
        writeValue(val.keyAt(i));
        writeValue(val.valueAt(i));
    }
}
Body of Second Method:
{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeString(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Write #" + i + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchDraw:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;
    if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
        final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
        final boolean buildCache = !isHardwareAccelerated();
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                final LayoutParams params = child.getLayoutParams();
                attachLayoutAnimationParameters(child, params, i, count);
                bindLayoutAnimation(child);
                if (cache) {
                    child.setDrawingCacheEnabled(true);
                    if (buildCache) {
                        child.buildDrawingCache(true);
                    }
                }
            }
        }
        final LayoutAnimationController controller = mLayoutAnimationController;
        if (controller.willOverlap()) {
            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
        }
        controller.start();
        mGroupFlags &= ~FLAG_RUN_ANIMATION;
        mGroupFlags &= ~FLAG_ANIMATION_DONE;
        if (cache) {
            mGroupFlags |= FLAG_CHILDREN_DRAWN_WITH_CACHE;
        }
        if (mAnimationListener != null) {
            mAnimationListener.onAnimationStart(controller.getAnimation());
        }
    }
    int saveCount = 0;
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        saveCount = canvas.save();
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
    }
    // We will draw our child's animation, let's reset the flag
    mPrivateFlags &= ~PFLAG_DRAW_ANIMATION;
    mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
    boolean more = false;
    final long drawingTime = getDrawingTime();
    if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    } else {
        for (int i = 0; i < count; i++) {
            final View child = children[getChildDrawingOrder(count, i)];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    }
    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (debugDraw()) {
        onDebugDraw(canvas);
    }
    if (clipToPadding) {
        canvas.restoreToCount(saveCount);
    }
    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;
    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }
    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {

            public void run() {
                notifyAnimationListener();
            }
        };
        post(end);
    }
}
Body of Second Method:
{
    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
    final int childrenCount = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;
    if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
        final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
        final boolean buildCache = !isHardwareAccelerated();
        for (int i = 0; i < childrenCount; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                final LayoutParams params = child.getLayoutParams();
                attachLayoutAnimationParameters(child, params, i, childrenCount);
                bindLayoutAnimation(child);
                if (cache) {
                    child.setDrawingCacheEnabled(true);
                    if (buildCache) {
                        child.buildDrawingCache(true);
                    }
                }
            }
        }
        final LayoutAnimationController controller = mLayoutAnimationController;
        if (controller.willOverlap()) {
            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
        }
        controller.start();
        mGroupFlags &= ~FLAG_RUN_ANIMATION;
        mGroupFlags &= ~FLAG_ANIMATION_DONE;
        if (cache) {
            mGroupFlags |= FLAG_CHILDREN_DRAWN_WITH_CACHE;
        }
        if (mAnimationListener != null) {
            mAnimationListener.onAnimationStart(controller.getAnimation());
        }
    }
    int clipSaveCount = 0;
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        clipSaveCount = canvas.save();
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
    }
    // We will draw our child's animation, let's reset the flag
    mPrivateFlags &= ~PFLAG_DRAW_ANIMATION;
    mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
    boolean more = false;
    final long drawingTime = getDrawingTime();
    if (usingRenderNodeProperties)
        canvas.insertReorderBarrier();
    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
    // draw reordering internally
    final ArrayList<View> preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList();
    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (preorderedList != null)
        preorderedList.clear();
    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (usingRenderNodeProperties)
        canvas.insertInorderBarrier();
    if (debugDraw()) {
        onDebugDraw(canvas);
    }
    if (clipToPadding) {
        canvas.restoreToCount(clipSaveCount);
    }
    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;
    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }
    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {

            public void run() {
                notifyAnimationListener();
            }
        };
        post(end);
    }
}
------------------------
Find a functionally equivalent code:android.media.AmrInputStream.GsmAmrEncoderNew:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.requestTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sensor == null)
        throw new IllegalArgumentException("sensor cannot be null");
    if (Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT)
        return false;
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue == null) {
            queue = new TriggerEventQueue(listener, mMainLooper, this);
            if (!queue.addSensor(sensor, 0, 0, 0)) {
                queue.dispose();
                return false;
            }
            mTriggerListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, 0, 0, 0);
        }
    }
}
Body of Second Method:
{
    if (sensor == null)
        throw new IllegalArgumentException("sensor cannot be null");
    if (sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT)
        return false;
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue == null) {
            queue = new TriggerEventQueue(listener, mMainLooper, this);
            if (!queue.addSensor(sensor, 0, 0, 0)) {
                queue.dispose();
                return false;
            }
            mTriggerListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, 0, 0, 0);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readMapXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashMap from an InputStream containing XML.  The stream can
 * previously have been written by writeMapXml().
 *
 * @param in The InputStream from which to read.
 *
 * @return HashMap The resulting map.
 *
 * @see #readListXml
 * @see #readValueXml
 * @see #readThisMapXml
 * #see #writeMapXml
 */

Body of Frist Method:
{
    XmlPullParser parser = Xml.newPullParser();
    parser.setInput(in, null);
    return (HashMap) readValueXml(parser, new String[1]);
}
Body of Second Method:
{
    XmlPullParser parser = Xml.newPullParser();
    parser.setInput(in, null);
    return (HashMap<String, ?>) readValueXml(parser, new String[1]);
}
------------------------
Find a functionally equivalent code:android.view.Window.setSoftInputMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specify an explicit soft input mode to use for the window, as per
 * {@link WindowManager.LayoutParams#softInputMode
 * WindowManager.LayoutParams.softInputMode}.  Providing anything besides
 * "unspecified" here will override the input mode the window would
 * normally retrieve from its theme.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (mode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        attrs.softInputMode = mode;
        mHasSoftInputMode = true;
    } else {
        mHasSoftInputMode = false;
    }
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (mode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        attrs.softInputMode = mode;
        mHasSoftInputMode = true;
    } else {
        mHasSoftInputMode = false;
    }
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.transition.TransitionSet.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resume();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).resume();
    }
}
Body of Second Method:
{
    super.resume(sceneRoot);
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).resume(sceneRoot);
    }
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.addPrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds a listener for observing the state of print jobs.
 *
 * @param listener The listener to add.
 * @hide
 */

Body of Frist Method:
{
    if (mPrintJobStateChangeListeners == null) {
        mPrintJobStateChangeListeners = new ArrayMap<PrintJobStateChangeListener, PrintJobStateChangeListenerWrapper>();
    }
    PrintJobStateChangeListenerWrapper wrappedListener = new PrintJobStateChangeListenerWrapper(listener, mHandler);
    try {
        mService.addPrintJobStateChangeListener(wrappedListener, mAppId, mUserId);
        mPrintJobStateChangeListeners.put(listener, wrappedListener);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error adding print job state change listener", re);
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return;
    }
    if (mPrintJobStateChangeListeners == null) {
        mPrintJobStateChangeListeners = new ArrayMap<PrintJobStateChangeListener, PrintJobStateChangeListenerWrapper>();
    }
    PrintJobStateChangeListenerWrapper wrappedListener = new PrintJobStateChangeListenerWrapper(listener, mHandler);
    try {
        mService.addPrintJobStateChangeListener(wrappedListener, mAppId, mUserId);
        mPrintJobStateChangeListeners.put(listener, wrappedListener);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error adding print job state change listener", re);
    }
}
------------------------
Find a functionally equivalent code:android.widget.TextView.onPreDraw:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return true;
}
Body of Second Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}
------------------------
Find a functionally equivalent code:androidx.media.filterfw.decoder.CpuVideoTrackDecoder.findDecoderCodec:COMMENT
Method Modifier: private     static      
Comment:/**
 * Looks for a codec with the specified requirements.
 *
 * The set of codecs will be filtered down to those that meet the following requirements:
 * <ol>
 * <li>The codec is a decoder.</li>
 * <li>The codec can decode a video of the specified format.</li>
 * <li>The codec can decode to one of the specified color formats.</li>
 * </ol>
 * If multiple codecs are found, the one with the preferred color-format is taken. Color format
 * preference is determined by the order of their appearance in the color format array.
 *
 * @param format The format the codec must decode.
 * @param requiredColorFormats Array of target color spaces ordered by preference.
 * @return A codec that meets the requirements, or null if no such codec was found.
 */

Body of Frist Method:
{
    TreeMap<Integer, String> candidateCodecs = new TreeMap<Integer, String>();
    SparseIntArray colorPriorities = intArrayToPriorityMap(requiredColorFormats);
    for (int i = 0; i < MediaCodecList.getCodecCount(); ++i) {
        // Get next codec
        MediaCodecInfo info = MediaCodecList.getCodecInfoAt(i);
        // Check that this is a decoder
        if (info.isEncoder()) {
            continue;
        }
        // Check if this codec can decode the video in question
        String requiredType = format.getString(MediaFormat.KEY_MIME);
        String[] supportedTypes = info.getSupportedTypes();
        Set<String> typeSet = new HashSet<String>(Arrays.asList(supportedTypes));
        // Check if it can decode to one of the required color formats
        if (typeSet.contains(requiredType)) {
            CodecCapabilities capabilities = info.getCapabilitiesForType(requiredType);
            for (int supportedColorFormat : capabilities.colorFormats) {
                if (colorPriorities.indexOfKey(supportedColorFormat) >= 0) {
                    int priority = colorPriorities.get(supportedColorFormat);
                    candidateCodecs.put(priority, info.getName());
                }
            }
        }
    }
    // Pick the best codec (with the highest color priority)
    if (candidateCodecs.isEmpty()) {
        return null;
    } else {
        String bestCodec = candidateCodecs.firstEntry().getValue();
        return MediaCodec.createByCodecName(bestCodec);
    }
}
Body of Second Method:
{
    TreeMap<Integer, String> candidateCodecs = new TreeMap<Integer, String>();
    SparseIntArray colorPriorities = intArrayToPriorityMap(requiredColorFormats);
    for (int i = 0; i < MediaCodecList.getCodecCount(); ++i) {
        // Get next codec
        MediaCodecInfo info = MediaCodecList.getCodecInfoAt(i);
        // Check that this is a decoder
        if (info.isEncoder()) {
            continue;
        }
        // Check if this codec can decode the video in question
        String requiredType = format.getString(MediaFormat.KEY_MIME);
        String[] supportedTypes = info.getSupportedTypes();
        Set<String> typeSet = new HashSet<String>(Arrays.asList(supportedTypes));
        // Check if it can decode to one of the required color formats
        if (typeSet.contains(requiredType)) {
            CodecCapabilities capabilities = info.getCapabilitiesForType(requiredType);
            for (int supportedColorFormat : capabilities.colorFormats) {
                if (colorPriorities.indexOfKey(supportedColorFormat) >= 0) {
                    int priority = colorPriorities.get(supportedColorFormat);
                    candidateCodecs.put(priority, info.getName());
                }
            }
        }
    }
    // Pick the best codec (with the highest color priority)
    if (candidateCodecs.isEmpty()) {
        return null;
    } else {
        String bestCodec = candidateCodecs.firstEntry().getValue();
        try {
            return MediaCodec.createByCodecName(bestCodec);
        } catch (IOException e) {
            throw new RuntimeException("failed to create codec for " + bestCodec, e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetManager.getInstalledProviders:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of the AppWidget providers that are currently installed.
 */

Body of Frist Method:
{
    return getInstalledProviders(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);
}
Body of Second Method:
{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null);
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getYear:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected year.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.YEAR);
}
Body of Second Method:
{
    return mDelegate.getYear();
}
------------------------
Find a functionally equivalent code:android.os.Parcel.writeValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class="caution">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */

Body of Frist Method:
{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof Object[]) {
        writeInt(VAL_OBJECTARRAY);
        writeArray((Object[]) v);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Serializable) {
        // Must be last
        writeInt(VAL_SERIALIZABLE);
        writeSerializable((Serializable) v);
    } else {
        throw new RuntimeException("Parcel: unable to marshal value " + v);
    }
}
Body of Second Method:
{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException("Parcel: unable to marshal value " + v);
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaCodecInfo.getCapabilitiesForType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Enumerates the capabilities of the codec component. Since a single
 * component can support data of a variety of types, the type has to be
 * specified to yield a meaningful result.
 * @param type The MIME type to query
 */

Body of Frist Method:
{
    return MediaCodecList.getCodecCapabilities(mIndex, type);
}
Body of Second Method:
{
    CodecCapabilities caps = mCaps.get(type);
    if (caps == null) {
        throw new IllegalArgumentException("codec does not support type");
    }
    // clone writable object
    return caps.dup();
}
------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.SensorEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

Body of Frist Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = mSensorsEvents.get(handle);
    if (t == null) {
        Log.e(TAG, "Error: Sensor Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    switch(t.sensor.getType()) {
        // Only report accuracy for sensors that support it.
        case Sensor.TYPE_MAGNETIC_FIELD:
        case Sensor.TYPE_ORIENTATION:
            // call onAccuracyChanged() only if the value changes
            final int accuracy = mSensorAccuracies.get(handle);
            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
                mSensorAccuracies.put(handle, t.accuracy);
                mListener.onAccuracyChanged(t.sensor, t.accuracy);
            }
            break;
        default:
            // For other sensors, just report the accuracy once
            if (mFirstEvent.get(handle) == false) {
                mFirstEvent.put(handle, true);
                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
            }
            break;
    }
    mListener.onSensorChanged(t);
}
Body of Second Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}
------------------------
Find a functionally equivalent code:android.util.Spline.createMonotoneCubicSpline:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a monotone cubic spline from a given set of control points.
 *
 * The spline is guaranteed to pass through each control point exactly.
 * Moreover, assuming the control points are monotonic (Y is non-decreasing or
 * non-increasing) then the interpolated values will also be monotonic.
 *
 * This function uses the Fritsch-Carlson method for computing the spline parameters.
 * http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 *
 * @param x The X component of the control points, strictly increasing.
 * @param y The Y component of the control points, monotonic.
 * @return
 *
 * @throws IllegalArgumentException if the X or Y arrays are null, have
 * different lengths or have fewer than 2 values.
 * @throws IllegalArgumentException if the control points are not monotonic.
 */

Body of Frist Method:
{
    if (x == null || y == null || x.length != y.length || x.length < 2) {
        throw new IllegalArgumentException("There must be at least two control " + "points and the arrays must be of equal length.");
    }
    final int n = x.length;
    // could optimize this out
    float[] d = new float[n - 1];
    float[] m = new float[n];
    // Compute slopes of secant lines between successive points.
    for (int i = 0; i < n - 1; i++) {
        float h = x[i + 1] - x[i];
        if (h <= 0f) {
            throw new IllegalArgumentException("The control points must all " + "have strictly increasing X values.");
        }
        d[i] = (y[i + 1] - y[i]) / h;
    }
    // Initialize the tangents as the average of the secants.
    m[0] = d[0];
    for (int i = 1; i < n - 1; i++) {
        m[i] = (d[i - 1] + d[i]) * 0.5f;
    }
    m[n - 1] = d[n - 2];
    // Update the tangents to preserve monotonicity.
    for (int i = 0; i < n - 1; i++) {
        if (d[i] == 0f) {
            // successive Y values are equal
            m[i] = 0f;
            m[i + 1] = 0f;
        } else {
            float a = m[i] / d[i];
            float b = m[i + 1] / d[i];
            if (a < 0f || b < 0f) {
                throw new IllegalArgumentException("The control points must have " + "monotonic Y values.");
            }
            float h = FloatMath.hypot(a, b);
            if (h > 9f) {
                float t = 3f / h;
                m[i] = t * a * d[i];
                m[i + 1] = t * b * d[i];
            }
        }
    }
    return new Spline(x, y, m);
}
Body of Second Method:
{
    return new MonotoneCubicSpline(x, y);
}
------------------------
Find a functionally equivalent code:android.content.res.XmlBlock.nativeGetName:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setKeyframes:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Keyframes.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    int numKeyframes = values.length;
    Keyframe[] keyframes = new Keyframe[Math.max(numKeyframes, 2)];
    mValueType = ((Keyframe) values[0]).getType();
    for (int i = 0; i < numKeyframes; ++i) {
        keyframes[i] = (Keyframe) values[i];
    }
    mKeyframeSet = new KeyframeSet(keyframes);
}
Body of Second Method:
{
    int numKeyframes = values.length;
    Keyframe[] keyframes = new Keyframe[Math.max(numKeyframes, 2)];
    mValueType = ((Keyframe) values[0]).getType();
    for (int i = 0; i < numKeyframes; ++i) {
        keyframes[i] = (Keyframe) values[i];
    }
    mKeyframes = new KeyframeSet(keyframes);
}
------------------------
Find a functionally equivalent code:android.view.textservice.TextInfo.getText:COMMENT
Method Modifier: public      
Comment:/**
 * @return the text which is an input of a text service
 */

Body of Frist Method:
{
    return mText;
}
Body of Second Method:
{
    if (mCharSequence == null) {
        return null;
    }
    return mCharSequence.toString();
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getCalendarView:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link CalendarView}.
 *
 * @return The calendar view.
 * @see #getCalendarViewShown()
 */

Body of Frist Method:
{
    return mCalendarView;
}
Body of Second Method:
{
    return mDelegate.getCalendarView();
}
------------------------
Find a functionally equivalent code:android.app.WallpaperManager.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Remove any currently set wallpaper, reverting to the system's built-in
 * wallpaper. On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

Body of Frist Method:
{
    setResource(com.android.internal.R.drawable.default_wallpaper);
}
Body of Second Method:
{
    setStream(openDefaultWallpaper(mContext));
}
------------------------
Find a functionally equivalent code:android.app.Instrumentation.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Terminate instrumentation of the application.  This will cause the
 * application process to exit, removing this instrumentation from the next
 * time the application is started.
 *
 * @param resultCode Overall success/failure of instrumentation.
 * @param results Any results to send back to the code that started the
 * instrumentation.
 */

Body of Frist Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        results.putAll(mPerfMetrics);
    }
    if (mUiAutomation != null) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
Body of Second Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        if (results == null) {
            results = new Bundle();
        }
        results.putAll(mPerfMetrics);
    }
    if (mUiAutomation != null) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.setLowProfile:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets View.SYSTEM_UI_FLAG_LOW_PROFILE on the content view.
 *
 * @param lowProfile True to set View.SYSTEM_UI_FLAG_LOW_PROFILE
 * @hide There is no reason to have this -- dreams can set this flag
 * on their own content view, and from there can actually do the
 * correct interactions with it (seeing when it is cleared etc).
 */

Body of Frist Method:
{
    mLowProfile = lowProfile;
    int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
    applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
}
Body of Second Method:
{
    if (mLowProfile != lowProfile) {
        mLowProfile = lowProfile;
        int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
        applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
    }
}
------------------------
Find a functionally equivalent code:android.os.StrictMode.conditionallyCheckInstanceCounts:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    VmPolicy policy = getVmPolicy();
    if (policy.classInstanceLimit.size() == 0) {
        return;
    }
    Runtime.getRuntime().gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
        Class klass = entry.getKey();
        int limit = entry.getValue();
        long instances = VMDebug.countInstancesOfClass(klass, false);
        if (instances <= limit) {
            continue;
        }
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
Body of Second Method:
{
    VmPolicy policy = getVmPolicy();
    if (policy.classInstanceLimit.size() == 0) {
        return;
    }
    System.gc();
    System.runFinalization();
    System.gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
        Class klass = entry.getKey();
        int limit = entry.getValue();
        long instances = VMDebug.countInstancesOfClass(klass, false);
        if (instances <= limit) {
            continue;
        }
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawRect:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified Rect using the specified paint. The rectangle will
 * be filled or framed based on the Style in the paint.
 *
 * @param left   The left side of the rectangle to be drawn
 * @param top    The top side of the rectangle to be drawn
 * @param right  The right side of the rectangle to be drawn
 * @param bottom The bottom side of the rectangle to be drawn
 * @param paint  The paint used to draw the rect
 */

Body of Frist Method:
{
    native_drawRect(mNativeCanvas, left, top, right, bottom, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

Body of Frist Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    return nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
}
Body of Second Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRingerModeChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRingerModeChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the ringer mode changes.
 * @param state the current ringer state, as defined in
 * {@link AudioManager#RINGER_MODE_CHANGED_ACTION}
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.util.ArrayMap.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

Body of Frist Method:
{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}
Body of Second Method:
{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}
------------------------
Find a functionally equivalent code:android.hardware.location.GeofenceHardware.addGeofence:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a circular geofence which is monitored by subsystems in the hardware.
 *
 * <p> When the device detects that is has entered, exited or is uncertain
 * about the area specified by the geofence, the given callback will be called.
 *
 * <p> If this call returns true, it means that the geofence has been sent to the hardware.
 * {@link GeofenceHardwareCallback#onGeofenceAdd} will be called with the result of the
 * add call from the hardware. The {@link GeofenceHardwareCallback#onGeofenceAdd} will be
 * called with the following parameters when a transition event occurs.
 * <ul>
 * <li> The geofence Id
 * <li> The location object indicating the last known location.
 * <li> The transition associated with the geofence. One of
 * {@link #GEOFENCE_ENTERED}, {@link #GEOFENCE_EXITED}, {@link #GEOFENCE_UNCERTAIN}
 * <li> The timestamp when the geofence transition occured.
 * <li> The monitoring type ({@link #MONITORING_TYPE_GPS_HARDWARE} is one such example)
 * that was used.
 * </ul>
 *
 * <p> The geofence will be monitored by the subsystem specified by monitoring_type parameter.
 * The application does not need to hold a wakelock when the monitoring
 * is being done by the underlying hardware subsystem. If the same geofence Id is being
 * monitored by two different monitoring systems, the same id can be used for both calls, as
 * long as the same callback object is used.
 *
 * <p> Requires {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission when
 * {@link #MONITORING_TYPE_GPS_HARDWARE} is used.
 *
 * <p> Requires {@link android.Manifest.permission#LOCATION_HARDWARE} permission to access
 * geofencing in hardware.
 *
 * <p>This API should not be called directly by the app developers. A higher level api
 * which abstracts the hardware should be used instead. All the checks are done by the higher
 * level public API. Any needed locking should be handled by the higher level API.
 *
 * <p> Create a geofence request object using the methods in {@link GeofenceHardwareRequest} to
 * set all the characteristics of the geofence. Use the created GeofenceHardwareRequest object
 * in this call.
 *
 * @param geofenceId The id associated with the geofence.
 * @param monitoringType The type of the hardware subsystem that should be used
 * to monitor the geofence.
 * @param geofenceRequest The {@link GeofenceHardwareRequest} object associated with the
 * geofence.
 * @param callback {@link GeofenceHardwareCallback} that will be use to notify the
 * transition.
 * @return true when the geofence is successfully sent to the hardware for addition.
 * @throws IllegalArgumentException when the geofence request type is not supported.
 */

Body of Frist Method:
{
    try {
        if (geofenceRequest.getType() == GeofenceHardwareRequest.GEOFENCE_TYPE_CIRCLE) {
            return mService.addCircularFence(geofenceId, monitoringType, geofenceRequest.getLatitude(), geofenceRequest.getLongitude(), geofenceRequest.getRadius(), geofenceRequest.getLastTransition(), geofenceRequest.getMonitorTransitions(), geofenceRequest.getNotificationResponsiveness(), geofenceRequest.getUnknownTimer(), getCallbackWrapper(callback));
        } else {
            throw new IllegalArgumentException("Geofence Request type not supported");
        }
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    try {
        if (geofenceRequest.getType() == GeofenceHardwareRequest.GEOFENCE_TYPE_CIRCLE) {
            return mService.addCircularFence(monitoringType, new GeofenceHardwareRequestParcelable(geofenceId, geofenceRequest), getCallbackWrapper(callback));
        } else {
            throw new IllegalArgumentException("Geofence Request type not supported");
        }
    } catch (RemoteException e) {
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.discardAudioFocusOwner:COMMENT
Method Modifier: protected   
Comment:/**
 * Discard the current audio focus owner.
 * Notify top of audio focus stack that it lost focus (regardless of possibility to reassign
 * focus), remove it from the stack, and clear the remote control display.
 */

Body of Frist Method:
{
    synchronized (mAudioFocusLock) {
        if (!mFocusStack.empty()) {
            // notify the current focus owner it lost focus after removing it from stack
            final FocusRequester exFocusOwner = mFocusStack.pop();
            exFocusOwner.handleFocusLoss(AudioManager.AUDIOFOCUS_LOSS);
            exFocusOwner.release();
            // clear RCD
            synchronized (mRCStack) {
                clearRemoteControlDisplay_syncAfRcs();
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mAudioFocusLock) {
        if (!mFocusStack.empty()) {
            // notify the current focus owner it lost focus after removing it from stack
            final FocusRequester exFocusOwner = mFocusStack.pop();
            exFocusOwner.handleFocusLoss(AudioManager.AUDIOFOCUS_LOSS);
            exFocusOwner.release();
        }
    }
}
------------------------
Find a functionally equivalent code:android.animation.AnimatorSet.Builder.after:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */

Body of Frist Method:
{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(node, Dependency.AFTER);
    mCurrentNode.addDependency(dependency);
    return this;
}
Body of Second Method:
{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(node, Dependency.AFTER);
    mCurrentNode.addDependency(dependency);
    return this;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.MyMethodVisitor.visitMethodInsn:COMMENT
Method Modifier: public      
Comment:// instruction that invokes a method

Body of Frist Method:
{
    // owner is the internal name of the method's owner class
    considerName(owner);
    // desc is the method's descriptor (see Type).
    considerDesc(desc);
}
Body of Second Method:
{
    // owner is the internal name of the method's owner class
    considerName(owner);
    // desc is the method's descriptor (see Type).
    considerDesc(desc);
    // Check if method needs to replaced by a call to a different method.
    if (ReplaceMethodCallsAdapter.isReplacementNeeded(owner, name, desc)) {
        mReplaceMethodCallClasses.add(mOwnerClass);
    }
}
------------------------
Find a functionally equivalent code:android.provider.Settings.Secure.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (MOVED_TO_GLOBAL.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System" + " to android.provider.Settings.Global");
        return Global.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
Body of Second Method:
{
    if (LOCATION_MODE.equals(name)) {
        // TODO: once b/10491283 fixed, remove this hack
        return setLocationModeForUser(resolver, Integer.parseInt(value), userHandle);
    }
    if (MOVED_TO_GLOBAL.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System" + " to android.provider.Settings.Global");
        return Global.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
------------------------
Find a functionally equivalent code:android.app.NotificationManager.notifyAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, user.getIdentifier());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, user.getIdentifier());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setPlaybackType:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether playback associated with this route is "local"
 * ({@link RouteInfo#PLAYBACK_TYPE_LOCAL}) or "remote"
 * ({@link RouteInfo#PLAYBACK_TYPE_REMOTE}).
 * @param type
 */

Body of Frist Method:
{
    if (mPlaybackType != type) {
        mPlaybackType = type;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE, type);
    }
}
Body of Second Method:
{
    if (mPlaybackType != type) {
        mPlaybackType = type;
        configureSessionVolume();
    }
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 */

Body of Frist Method:
{
    return mCalendarView.getMinDate();
}
Body of Second Method:
{
    return mDelegate.getMinDate().getTimeInMillis();
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setObjectValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Objects.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = values[0].getClass();
    mKeyframeSet = KeyframeSet.ofObject(values);
}
Body of Second Method:
{
    mValueType = values[0].getClass();
    mKeyframes = KeyframeSet.ofObject(values);
    if (mEvaluator != null) {
        mKeyframes.setEvaluator(mEvaluator);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.restoreToCount:COMMENT
<android.graphics.Canvas: void restoreToCount(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Efficient way to pop any calls to save() that happened after the save
 * count reached saveCount. It is an error for saveCount to be less than 1.
 *
 * Example:
 * int count = canvas.save();
 * ... // more calls potentially to save()
 * canvas.restoreToCount(count);
 * // now the canvas is back in the same state it was before the initial
 * // call to save().
 *
 * @param saveCount The save level to restore to.
 */

Body of Frist Method:

Body of Second Method:
{
    native_restoreToCount(mNativeCanvasWrapper, saveCount);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothSocket.flush:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
Body of Second Method:
{
    if (mSocketOS == null)
        throw new IOException("flush is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmGenerator.generate:COMMENT
Method Modifier: public      
Comment:/**
 * Generates the final JAR
 */

Body of Frist Method:
{
    TreeMap<String, byte[]> all = new TreeMap<String, byte[]>();
    for (Class<?> clazz : mInjectClasses) {
        String name = classToEntryPath(clazz);
        InputStream is = ClassLoader.getSystemResourceAsStream(name);
        ClassReader cr = new ClassReader(is);
        byte[] b = transform(cr, true);
        name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    for (Entry<String, ClassReader> entry : mDeps.entrySet()) {
        ClassReader cr = entry.getValue();
        byte[] b = transform(cr, true);
        String name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    for (Entry<String, ClassReader> entry : mKeep.entrySet()) {
        ClassReader cr = entry.getValue();
        byte[] b = transform(cr, true);
        String name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    mLog.info("# deps classes: %d", mDeps.size());
    mLog.info("# keep classes: %d", mKeep.size());
    mLog.info("# renamed     : %d", mRenameCount);
    createJar(new FileOutputStream(mOsDestJar), all);
    mLog.info("Created JAR file %s", mOsDestJar);
}
Body of Second Method:
{
    TreeMap<String, byte[]> all = new TreeMap<String, byte[]>();
    for (Class<?> clazz : mInjectClasses) {
        String name = classToEntryPath(clazz);
        InputStream is = ClassLoader.getSystemResourceAsStream(name);
        ClassReader cr = new ClassReader(is);
        byte[] b = transform(cr, true);
        name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    for (Entry<String, ClassReader> entry : mDeps.entrySet()) {
        ClassReader cr = entry.getValue();
        byte[] b = transform(cr, true);
        String name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    for (Entry<String, ClassReader> entry : mKeep.entrySet()) {
        ClassReader cr = entry.getValue();
        byte[] b = transform(cr, true);
        String name = classNameToEntryPath(transformName(cr.getClassName()));
        all.put(name, b);
    }
    for (Entry<String, InputStream> entry : mCopyFiles.entrySet()) {
        try {
            byte[] b = inputStreamToByteArray(entry.getValue());
            all.put(entry.getKey(), b);
        } catch (IOException e) {
        // Ignore.
        }
    }
    mLog.info("# deps classes: %d", mDeps.size());
    mLog.info("# keep classes: %d", mKeep.size());
    mLog.info("# renamed     : %d", mRenameCount);
    createJar(new FileOutputStream(mOsDestJar), all);
    mLog.info("Created JAR file %s", mOsDestJar);
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.querySoundEffectsEnabled:COMMENT
Method Modifier: private     
Comment:/**
 * Settings has an in memory cache, so this is fast.
 */

Body of Frist Method:
{
    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
}
Body of Second Method:
{
    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.dispatchGenericMotionEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on genericMotionEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on genericMotionEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.appendRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Appends an {@link AccessibilityRecord} to the end of event records.
 *
 * @param record The record to append.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */

Body of Frist Method:
{
    enforceNotSealed();
    mRecords.add(record);
}
Body of Second Method:
{
    enforceNotSealed();
    if (mRecords == null) {
        mRecords = new ArrayList<AccessibilityRecord>();
    }
    mRecords.add(record);
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.release:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Releases the relevant data.
 */

Body of Frist Method:
{
    mHandler.mQueryContext = null;
    mHandler.mQueryUri = null;
    mHandler.mCallerInfo = null;
    mHandler = null;
}
Body of Second Method:
{
    mHandler.mContext = null;
    mHandler.mQueryUri = null;
    mHandler.mCallerInfo = null;
    mHandler = null;
}
------------------------
Find a functionally equivalent code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
------------------------
Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPurgeActiveSync:COMMENT
Method Modifier: public      
Comment:// @SmallTest

Body of Frist Method:
{
    final Account account = new Account("a@example.com", "example.type");
    final String authority = "testprovider";
    MockContentResolver mockResolver = new MockContentResolver();
    SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
    long time0 = 1000;
    long historyId = engine.insertStartSyncEvent(account, 0, SyncOperation.REASON_PERIODIC, authority, time0, SyncStorageEngine.SOURCE_LOCAL, false, /* initialization */
    null);
    long time1 = time0 + SyncStorageEngine.MILLIS_IN_4WEEKS * 2;
    engine.stopSyncEvent(historyId, time1 - time0, "yay", 0, 0);
}
Body of Second Method:
{
    final Account account = new Account("a@example.com", "example.type");
    final String authority = "testprovider";
    MockContentResolver mockResolver = new MockContentResolver();
    SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
    long time0 = 1000;
    SyncOperation op = new SyncOperation(account, 0, SyncOperation.REASON_PERIODIC, SyncStorageEngine.SOURCE_LOCAL, authority, Bundle.EMPTY, time0, 0, /* flex*/
    0, 0, true);
    long historyId = engine.insertStartSyncEvent(op, time0);
    long time1 = time0 + SyncStorageEngine.MILLIS_IN_4WEEKS * 2;
    engine.stopSyncEvent(historyId, time1 - time0, "yay", 0, 0);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.prepareAddWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Preflight adding a window to the system.
 *
 * Currently enforces that three window types are singletons:
 * <ul>
 * <li>STATUS_BAR_TYPE</li>
 * <li>KEYGUARD_TYPE</li>
 * </ul>
 *
 * @param win The window to be added
 * @param attrs Information about the window to be added
 *
 * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons,
 * WindowManagerImpl.ADD_MULTIPLE_SINGLETON
 */

Body of Frist Method:
{
    switch(attrs.type) {
        case TYPE_STATUS_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mStatusBar != null) {
                if (mStatusBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mStatusBar = win;
            mStatusBarController.setWindow(win);
            break;
        case TYPE_NAVIGATION_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mNavigationBar != null) {
                if (mNavigationBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mNavigationBar = win;
            mNavigationBarController.setWindow(win);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
            break;
        case TYPE_NAVIGATION_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_SUB_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_KEYGUARD:
            if (mKeyguard != null) {
                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
            }
            mKeyguard = win;
            break;
        case TYPE_KEYGUARD_SCRIM:
            if (mKeyguardScrim != null) {
                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
            }
            mKeyguardScrim = win;
            break;
    }
    return WindowManagerGlobal.ADD_OKAY;
}
Body of Second Method:
{
    switch(attrs.type) {
        case TYPE_STATUS_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mStatusBar != null) {
                if (mStatusBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mStatusBar = win;
            mStatusBarController.setWindow(win);
            mKeyguardDelegate.hideScrim();
            break;
        case TYPE_NAVIGATION_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mNavigationBar != null) {
                if (mNavigationBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mNavigationBar = win;
            mNavigationBarController.setWindow(win);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
            break;
        case TYPE_NAVIGATION_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_SUB_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_KEYGUARD_SCRIM:
            if (mKeyguardScrim != null) {
                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
            }
            mKeyguardScrim = win;
            break;
    }
    return WindowManagerGlobal.ADD_OKAY;
}
------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.setValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method handles setting the property values directly in the View object's fields.
 * propertyConstant tells it which property should be set, value is the value to set
 * the property to.
 *
 * @param propertyConstant The property to be set
 * @param value The value to set the property to
 */

Body of Frist Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    final DisplayList displayList = mView.mDisplayList;
    switch(propertyConstant) {
        case TRANSLATION_X:
            info.mTranslationX = value;
            if (displayList != null)
                displayList.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            info.mTranslationY = value;
            if (displayList != null)
                displayList.setTranslationY(value);
            break;
        case ROTATION:
            info.mRotation = value;
            if (displayList != null)
                displayList.setRotation(value);
            break;
        case ROTATION_X:
            info.mRotationX = value;
            if (displayList != null)
                displayList.setRotationX(value);
            break;
        case ROTATION_Y:
            info.mRotationY = value;
            if (displayList != null)
                displayList.setRotationY(value);
            break;
        case SCALE_X:
            info.mScaleX = value;
            if (displayList != null)
                displayList.setScaleX(value);
            break;
        case SCALE_Y:
            info.mScaleY = value;
            if (displayList != null)
                displayList.setScaleY(value);
            break;
        case X:
            info.mTranslationX = value - mView.mLeft;
            if (displayList != null)
                displayList.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            info.mTranslationY = value - mView.mTop;
            if (displayList != null)
                displayList.setTranslationY(value - mView.mTop);
            break;
        case ALPHA:
            info.mAlpha = value;
            if (displayList != null)
                displayList.setAlpha(value);
            break;
    }
}
Body of Second Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    final RenderNode renderNode = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            renderNode.setTranslationY(value);
            break;
        case TRANSLATION_Z:
            renderNode.setTranslationZ(value);
            break;
        case ROTATION:
            renderNode.setRotation(value);
            break;
        case ROTATION_X:
            renderNode.setRotationX(value);
            break;
        case ROTATION_Y:
            renderNode.setRotationY(value);
            break;
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        case X:
            renderNode.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            renderNode.setTranslationY(value - mView.mTop);
            break;
        case Z:
            renderNode.setTranslationZ(value - renderNode.getElevation());
            break;
        case ALPHA:
            info.mAlpha = value;
            renderNode.setAlpha(value);
            break;
    }
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current selected state for an entry of type {@link #TYPE_BOOLEAN}.
 * @return the current selected state of the entry.
 */

Body of Frist Method:
{
    return Boolean.parseBoolean(currentValue);
}
Body of Second Method:
{
    return Boolean.parseBoolean(mCurrentValue);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findClassesDerivingFrom:COMMENT
Method Modifier: 
Comment:/**
 * Checks all the classes defined in the JarClassName instance and uses BCEL to
 * determine if they are derived from the given FQCN super class name.
 * Inserts the super class and all the class objects found in the map.
 */

Body of Frist Method:
{
    findClass(super_name, zipClasses, inOutFound);
    for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
        String className = entry.getKey();
        if (super_name.equals(className)) {
            continue;
        }
        ClassReader classReader = entry.getValue();
        ClassReader parent_cr = classReader;
        while (parent_cr != null) {
            String parent_name = internalToBinaryClassName(parent_cr.getSuperName());
            if (parent_name == null) {
                // not found
                break;
            } else if (super_name.equals(parent_name)) {
                inOutFound.put(className, classReader);
                break;
            }
            parent_cr = zipClasses.get(parent_name);
        }
    }
}
Body of Second Method:
{
    if (mExcludedClasses.contains(getOuterClassName(super_name))) {
        return;
    }
    findClass(super_name, zipClasses, inOutFound);
    for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
        String className = entry.getKey();
        if (super_name.equals(className)) {
            continue;
        }
        ClassReader classReader = entry.getValue();
        ClassReader parent_cr = classReader;
        while (parent_cr != null) {
            String parent_name = internalToBinaryClassName(parent_cr.getSuperName());
            if (parent_name == null) {
                // not found
                break;
            } else if (super_name.equals(parent_name)) {
                inOutFound.put(className, classReader);
                break;
            }
            parent_cr = zipClasses.get(parent_name);
        }
    }
}
------------------------
Find a functionally equivalent code:android.database.sqlite.SQLiteDatabase.deleteDatabase:COMMENT
Method Modifier: public      static      
Comment:/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */

Body of Frist Method:
{
    if (file == null) {
        throw new IllegalArgumentException("file must not be null");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + "-journal").delete();
    deleted |= new File(file.getPath() + "-shm").delete();
    deleted |= new File(file.getPath() + "-wal").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + "-mj";
        final FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        };
        for (File masterJournal : dir.listFiles(filter)) {
            deleted |= masterJournal.delete();
        }
    }
    return deleted;
}
Body of Second Method:
{
    if (file == null) {
        throw new IllegalArgumentException("file must not be null");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + "-journal").delete();
    deleted |= new File(file.getPath() + "-shm").delete();
    deleted |= new File(file.getPath() + "-wal").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + "-mj";
        File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        });
        if (files != null) {
            for (File masterJournal : files) {
                deleted |= masterJournal.delete();
            }
        }
    }
    return deleted;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.getProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else {
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getScreenBrightnessTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the screen has been on with
 * the given brightness
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.Matrix.postConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified matrix.
 * M' = other * M
 */

Body of Frist Method:
{
    return native_postConcat(native_instance, other.native_instance);
}
Body of Second Method:
{
    native_postConcat(native_instance, other.native_instance);
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Removes all elements from the mapping of this Bundle.
 */

Body of Frist Method:
{
    unparcel();
    mMap.clear();
    mHasFds = false;
    mFdsKnown = true;
}
Body of Second Method:
{
    super.clear();
    mHasFds = false;
    mFdsKnown = true;
}
------------------------
Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.processStillUp:COMMENT
Method Modifier: private     
Comment:/**
 * Determine if a given package is still running.
 *
 * @param packageName {@link String} package to look for
 * @return True if package is running, false otherwise.
 */

Body of Frist Method:
{
    try {
        PackageInfo packageInfo = mPackageManager.getPackageInfo(packageName, 0);
        String processName = packageInfo.applicationInfo.processName;
        List<RunningAppProcessInfo> runningApps = mActivityManager.getRunningAppProcesses();
        for (RunningAppProcessInfo app : runningApps) {
            if (app.processName.equalsIgnoreCase(processName)) {
                Log.d(TAG, "Found process " + app.processName);
                return true;
            }
        }
        Log.d(TAG, "Failed to find process " + processName + " with package name " + packageName);
    } catch (NameNotFoundException e) {
        Log.w(TAG, "Failed to find package " + packageName);
        return false;
    }
    return false;
}
Body of Second Method:
{
    String processName = getProcessName(packageName);
    List<RunningAppProcessInfo> runningApps = mActivityManager.getRunningAppProcesses();
    for (RunningAppProcessInfo app : runningApps) {
        if (app.processName.equalsIgnoreCase(processName)) {
            Log.d(TAG, "Found process " + app.processName);
            return true;
        }
        for (String relatedPackage : app.pkgList) {
            if (relatedPackage.equalsIgnoreCase(processName)) {
                Log.d(TAG, "Found process " + app.processName);
                return true;
            }
        }
    }
    Log.d(TAG, "Failed to find process " + processName + " with package name " + packageName);
    return false;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Return the ClassLoader currently associated with this Bundle.
 */

Body of Frist Method:
{
    return mClassLoader;
}
Body of Second Method:
{
    return super.getClassLoader();
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.getStatusCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mStatusCode;
}
Body of Second Method:
{
    return mResolvedStatusCode;
}
------------------------
Find a functionally equivalent code:android.graphics.Typeface.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a typeface object that best matches the specified existing
 * typeface and the specified Style. Use this call if you want to pick a new
 * style from the same family of an existing typeface object. If family is
 * null, this selects from the default font's family.
 *
 * @param family May be null. The name of the existing type face.
 * @param style  The style (normal, bold, italic) of the typeface.
 * e.g. NORMAL, BOLD, ITALIC, BOLD_ITALIC
 * @return The best matching typeface.
 */

Body of Frist Method:
{
    int ni = 0;
    if (family != null) {
        // Return early if we're asked for the same face/style
        if (family.mStyle == style) {
            return family;
        }
        ni = family.native_instance;
    }
    Typeface typeface;
    SparseArray<Typeface> styles = sTypefaceCache.get(ni);
    if (styles != null) {
        typeface = styles.get(style);
        if (typeface != null) {
            return typeface;
        }
    }
    typeface = new Typeface(nativeCreateFromTypeface(ni, style));
    if (styles == null) {
        styles = new SparseArray<Typeface>(4);
        sTypefaceCache.put(ni, styles);
    }
    styles.put(style, typeface);
    return typeface;
}
Body of Second Method:
{
    if (style < 0 || style > 3) {
        style = 0;
    }
    long ni = 0;
    if (family != null) {
        // Return early if we're asked for the same face/style
        if (family.mStyle == style) {
            return family;
        }
        ni = family.native_instance;
    }
    Typeface typeface;
    SparseArray<Typeface> styles = sTypefaceCache.get(ni);
    if (styles != null) {
        typeface = styles.get(style);
        if (typeface != null) {
            return typeface;
        }
    }
    typeface = new Typeface(nativeCreateFromTypeface(ni, style));
    if (styles == null) {
        styles = new SparseArray<Typeface>(4);
        sTypefaceCache.put(ni, styles);
    }
    styles.put(style, typeface);
    return typeface;
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.dispatchMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a simulated key event for a media button.
 * To simulate a key press, you must first send a KeyEvent built with a
 * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the current media key event consumer which registered with
 * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.dispatchMediaKeyEvent(keyEvent);
    } catch (RemoteException e) {
        Log.e(TAG, "dispatchMediaKeyEvent threw exception ", e);
    }
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.sendMediaButtonEvent(keyEvent, false);
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Associates all the metadata that has been set since the MetadataEditor instance was
 * created with {@link RemoteControlClient#editMetadata(boolean)}, or since
 * {@link #clear()} was called, with the RemoteControlClient. Once "applied",
 * this MetadataEditor cannot be reused to edit the RemoteControlClient's metadata.
 */

Body of Frist Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't apply a previously applied MetadataEditor");
        return;
    }
    synchronized (mCacheLock) {
        // assign the edited data
        mMetadata = new Bundle(mEditorMetadata);
        // add the information about editable keys
        mMetadata.putLong(String.valueOf(KEY_EDITABLE_MASK), mEditableKeys);
        if ((mOriginalArtwork != null) && (!mOriginalArtwork.equals(mEditorArtwork))) {
            mOriginalArtwork.recycle();
        }
        mOriginalArtwork = mEditorArtwork;
        mEditorArtwork = null;
        if (mMetadataChanged & mArtworkChanged) {
            // send to remote control display if conditions are met
            sendMetadataWithArtwork_syncCacheLock(null, 0, 0);
        } else if (mMetadataChanged) {
            // send to remote control display if conditions are met
            sendMetadata_syncCacheLock(null);
        } else if (mArtworkChanged) {
            // send to remote control display if conditions are met
            sendArtwork_syncCacheLock(null, 0, 0);
        }
        mApplied = true;
    }
}
Body of Second Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't apply a previously applied MetadataEditor");
        return;
    }
    synchronized (mCacheLock) {
        // Still build the old metadata so when creating a new editor
        // you get the expected values.
        // assign the edited data
        mMetadata = new Bundle(mEditorMetadata);
        // add the information about editable keys
        mMetadata.putLong(String.valueOf(KEY_EDITABLE_MASK), mEditableKeys);
        if ((mOriginalArtwork != null) && (!mOriginalArtwork.equals(mEditorArtwork))) {
            mOriginalArtwork.recycle();
        }
        mOriginalArtwork = mEditorArtwork;
        mEditorArtwork = null;
        // USE_SESSIONS
        if (mSession != null && mMetadataBuilder != null) {
            mMediaMetadata = mMetadataBuilder.build();
            mSession.setMetadata(mMediaMetadata);
        }
        mApplied = true;
    }
}
------------------------
Find a functionally equivalent code:android.text.TextUtils.getLayoutDirectionFromLocale:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */

Body of Frist Method:
{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
Body of Second Method:
{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.getEnabledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of enabled print services.
 *
 * @return The enabled service list or an empty list.
 * @hide
 */

Body of Frist Method:
{
    try {
        List<PrintServiceInfo> enabledServices = mService.getEnabledPrintServices(mUserId);
        if (enabledServices != null) {
            return enabledServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the enabled print services", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintServiceInfo> enabledServices = mService.getEnabledPrintServices(mUserId);
        if (enabledServices != null) {
            return enabledServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the enabled print services", re);
    }
    return Collections.emptyList();
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.runSelectLoop:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Runs the zygote process's select loop. Accepts new connections as
 * they happen, and reads commands from connections one spawn-request's
 * worth at a time.
 *
 * @throws MethodAndArgsCaller in a child process when a main() should
 * be executed.
 */

Body of Frist Method:
{
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
    FileDescriptor[] fdArray = new FileDescriptor[4];
    fds.add(sServerSocket.getFileDescriptor());
    peers.add(null);
    int loopCount = GC_LOOP_COUNT;
    while (true) {
        int index;
        /*
             * Call gc() before we block in select().
             * It's work that has to be done anyway, and it's better
             * to avoid making every child do it.  It will also
             * madvise() any free memory as a side-effect.
             *
             * Don't call it every time, because walking the entire
             * heap is a lot of overhead to free a few hundred bytes.
             */
        if (loopCount <= 0) {
            gc();
            loopCount = GC_LOOP_COUNT;
        } else {
            loopCount--;
        }
        try {
            fdArray = fds.toArray(fdArray);
            index = selectReadable(fdArray);
        } catch (IOException ex) {
            throw new RuntimeException("Error in select()", ex);
        }
        if (index < 0) {
            throw new RuntimeException("Error in select()");
        } else if (index == 0) {
            ZygoteConnection newPeer = acceptCommandPeer();
            peers.add(newPeer);
            fds.add(newPeer.getFileDesciptor());
        } else {
            boolean done;
            done = peers.get(index).runOnce();
            if (done) {
                peers.remove(index);
                fds.remove(index);
            }
        }
    }
}
Body of Second Method:
{
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
    FileDescriptor[] fdArray = new FileDescriptor[4];
    fds.add(sServerSocket.getFileDescriptor());
    peers.add(null);
    int loopCount = GC_LOOP_COUNT;
    while (true) {
        int index;
        /*
             * Call gc() before we block in select().
             * It's work that has to be done anyway, and it's better
             * to avoid making every child do it.  It will also
             * madvise() any free memory as a side-effect.
             *
             * Don't call it every time, because walking the entire
             * heap is a lot of overhead to free a few hundred bytes.
             */
        if (loopCount <= 0) {
            gc();
            loopCount = GC_LOOP_COUNT;
        } else {
            loopCount--;
        }
        try {
            fdArray = fds.toArray(fdArray);
            index = selectReadable(fdArray);
        } catch (IOException ex) {
            throw new RuntimeException("Error in select()", ex);
        }
        if (index < 0) {
            throw new RuntimeException("Error in select()");
        } else if (index == 0) {
            ZygoteConnection newPeer = acceptCommandPeer(abiList);
            peers.add(newPeer);
            fds.add(newPeer.getFileDescriptor());
        } else {
            boolean done;
            done = peers.get(index).runOnce();
            if (done) {
                peers.remove(index);
                fds.remove(index);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.verifyUnlock:COMMENT
<com.android.keyguard.KeyguardViewBase: void verifyUnlock()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Verify that the user can get past the keyguard securely.  This is called,
 * for example, when the phone disables the keyguard but then wants to launch
 * something else that requires secure access.
 *
 * The result will be propogated back via {@link KeyguardViewCallback#keyguardDone(boolean)}
 */

Body of Frist Method:

Body of Second Method:
{
    SecurityMode securityMode = mSecurityContainer.getSecurityMode();
    if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
        if (mViewMediatorCallback != null) {
            mViewMediatorCallback.keyguardDone(true);
        }
    } else if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
        // can only verify unlock when in pattern/password mode
        if (mViewMediatorCallback != null) {
            mViewMediatorCallback.keyguardDone(false);
        }
    } else {
        // otherwise, go to the unlock screen, see if they can verify it
        mSecurityContainer.verifyUnlock();
    }
}
------------------------
Find a functionally equivalent code:android.widget.QuickContactBadge.setImageToDefault:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the contact photo to the default state.
 */

Body of Frist Method:
{
    if (mDefaultAvatar == null) {
        mDefaultAvatar = getResources().getDrawable(R.drawable.ic_contact_picture);
    }
    setImageDrawable(mDefaultAvatar);
}
Body of Second Method:
{
    if (mDefaultAvatar == null) {
        mDefaultAvatar = mContext.getDrawable(R.drawable.ic_contact_picture);
    }
    setImageDrawable(mDefaultAvatar);
}
------------------------
Find a functionally equivalent code:android.provider.Browser.requestAllIcons:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Request all icons from the database.  This call must either be called
 * in the main thread or have had Looper.prepare() invoked in the calling
 * thread.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param  cr The ContentResolver used to access the database.
 * @param  where Clause to be used to limit the query from the database.
 * Must be an allowable string to be passed into a database query.
 * @param  listener IconListener that gets the icons once they are
 * retrieved.
 */

Body of Frist Method:
{
    WebIconDatabase.getInstance().bulkRequestIconForPageUrl(cr, where, listener);
}
Body of Second Method:
{
// Do nothing: this is no longer used.
}
------------------------
Find a functionally equivalent code:android.media.AudioService.getMasterStreamType:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#getMasterStreamType()
 */

Body of Frist Method:
{
    if (mVoiceCapable) {
        return AudioSystem.STREAM_RING;
    } else {
        return AudioSystem.STREAM_MUSIC;
    }
}
Body of Second Method:
{
    return mStreamVolumeAlias[AudioSystem.STREAM_SYSTEM];
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.openTypedAssetFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */

Body of Frist Method:
{
    if (opts != null && opts.containsKey(EXTRA_THUMBNAIL_SIZE)) {
        final Point sizeHint = opts.getParcelable(EXTRA_THUMBNAIL_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
    }
}
Body of Second Method:
{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
    }
}
------------------------
Find a functionally equivalent code:android.widget.GridLayout.measureChildrenWithMargins:COMMENT
Method Modifier: private     
Comment:// Note: padding has already been removed from the supplied specs

Body of Frist Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.alignment == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
Body of Second Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
            mHorizontalAxis.recordOriginalMeasurement(i);
            mVerticalAxis.recordOriginalMeasurement(i);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.alignment == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.preSkew:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified skew.
 * M' = M * K(kx, ky, px, py)
 */

Body of Frist Method:
{
    return native_preSkew(native_instance, kx, ky, px, py);
}
Body of Second Method:
{
    native_preSkew(native_instance, kx, ky, px, py);
    return true;
}
------------------------
Find a functionally equivalent code:android.util.LongSparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealLongArraySize(pos + 1);
        long[] nkeys = new long[n];
        Object[] nvalues = new Object[n];
        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:android.content.res.ColorStateList.createFromXml:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */

Body of Frist Method:
{
    AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException("No start tag found");
    }
    return createFromXmlInner(r, parser, attrs);
}
Body of Second Method:
{
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException("No start tag found");
    }
    return createFromXmlInner(r, parser, attrs);
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.setTransportControlFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the flags for the media transport control buttons that this client supports.
 * @param transportControlFlags A combination of the following flags:
 * {@link #FLAG_KEY_MEDIA_PREVIOUS},
 * {@link #FLAG_KEY_MEDIA_REWIND},
 * {@link #FLAG_KEY_MEDIA_PLAY},
 * {@link #FLAG_KEY_MEDIA_PLAY_PAUSE},
 * {@link #FLAG_KEY_MEDIA_PAUSE},
 * {@link #FLAG_KEY_MEDIA_STOP},
 * {@link #FLAG_KEY_MEDIA_FAST_FORWARD},
 * {@link #FLAG_KEY_MEDIA_NEXT},
 * {@link #FLAG_KEY_MEDIA_POSITION_UPDATE},
 * {@link #FLAG_KEY_MEDIA_RATING}.
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // send to remote control display if conditions are met
        sendTransportControlInfo_syncCacheLock(null);
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // USE_SESSIONS
        if (mSession != null) {
            PlaybackState.Builder bob = new PlaybackState.Builder(mSessionPlaybackState);
            bob.setActions(PlaybackState.getActionsFromRccControlFlags(transportControlFlags));
            mSessionPlaybackState = bob.build();
            mSession.setPlaybackState(mSessionPlaybackState);
        }
    }
}
------------------------
Find a functionally equivalent code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    return new BeamShareData(message, uris, flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, flags);
}
------------------------
Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.setSelection:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation changes the selection position in the
 * current editable text.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "setSelection " + start + ", " + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "setSelection " + start + ", " + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len || start < 0 || end < 0) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.addInternal:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Adds an item to the menu.  The other add methods funnel to this.
 */

Body of Frist Method:
{
    final int ordering = getOrdering(categoryOrder);
    final MenuItemImpl item = new MenuItemImpl(this, group, id, categoryOrder, ordering, title, mDefaultShowAsAction);
    if (mCurrentMenuInfo != null) {
        // Pass along the current menu info
        item.setMenuInfo(mCurrentMenuInfo);
    }
    mItems.add(findInsertIndex(mItems, ordering), item);
    onItemsChanged(true);
    return item;
}
Body of Second Method:
{
    final int ordering = getOrdering(categoryOrder);
    final MenuItemImpl item = createNewMenuItem(group, id, categoryOrder, ordering, title, mDefaultShowAsAction);
    if (mCurrentMenuInfo != null) {
        // Pass along the current menu info
        item.setMenuInfo(mCurrentMenuInfo);
    }
    mItems.add(findInsertIndex(mItems, ordering), item);
    onItemsChanged(true);
    return item;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getPhoneSignalScanningTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been trying to
 * acquire a signal.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.preference.PreferenceFragment.setPreferenceScreen:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the root of the preference hierarchy that this fragment is showing.
 *
 * @param preferenceScreen The root {@link PreferenceScreen} of the preference hierarchy.
 */

Body of Frist Method:
{
    if (mPreferenceManager.setPreferences(preferenceScreen) && preferenceScreen != null) {
        mHavePrefs = true;
        if (mInitDone) {
            postBindPreferences();
        }
    }
}
Body of Second Method:
{
    if (mPreferenceManager.setPreferences(preferenceScreen) && preferenceScreen != null) {
        onUnbindPreferences();
        mHavePrefs = true;
        if (mInitDone) {
            postBindPreferences();
        }
    }
}
------------------------
Find a functionally equivalent code:javax.obex.ObexHelper.createHeader:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates the header part of OBEX packet based on the header provided.
 * TODO: Could use getHeaderList() to get the array of headers to include
 * and then use the high two bits to determine the the type of the object
 * and construct the byte array from that. This will make the size smaller.
 * @param head the header used to construct the byte array
 * @param nullOut <code>true</code> if the header should be set to
 * <code>null</code> once it is added to the array or
 * <code>false</code> if it should not be nulled out
 * @return the header of an OBEX packet
 */

Body of Frist Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
Body of Second Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        } else if (headImpl.getEmptyNameHeader()) {
            out.write((byte) HeaderSet.NAME);
            lengthArray[0] = (byte) 0x00;
            lengthArray[1] = (byte) 0x03;
            out.write(lengthArray);
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
<android.os.SystemClock: boolean setCurrentTimeMillis(long)>
Method Modifier: public      static      native      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

Body of Frist Method:

Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);
    IAlarmManager mgr = IAlarmManager.Stub.asInterface(b);
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.dup:COMMENT
Method Modifier: public      
Comment:/**
 * Create a new ParcelFileDescriptor that is a dup of the existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.dup();
    } else {
        return dup(getFileDescriptor());
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.dup();
    } else {
        return dup(getFileDescriptor());
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      
Comment:/**
 * We have one child
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            InputStage syntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.unregisterMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.unregisterMediaButtonIntent(pi);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in unregisterMediaButtonIntent" + e);
    }
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.removeMediaButtonListener(pi);
}
------------------------
Find a functionally equivalent code:android.view.animation.Transformation.postCompose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #compose(Transformation)} but does this.postConcat(t) of
 * the transformation matrix.
 * @hide
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onSeekComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        scheduleNotification(NOTIFY_SEEK, 0);
    }
}
Body of Second Method:
{
    synchronized (this) {
        mStopped = false;
        mSeeking = true;
        scheduleNotification(NOTIFY_SEEK, 0);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserSwitchComplete:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitchComplete(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user change is complete.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setMaskFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the maskfilter object.
 * <p />
 * Pass null to clear any previous maskfilter.
 * As a convenience, the parameter passed is also returned.
 *
 * @param maskfilter May be null. The maskfilter to be installed in the
 * paint
 * @return           maskfilter
 */

Body of Frist Method:
{
    int maskfilterNative = 0;
    if (maskfilter != null) {
        maskfilterNative = maskfilter.native_instance;
    }
    native_setMaskFilter(mNativePaint, maskfilterNative);
    mMaskFilter = maskfilter;
    return maskfilter;
}
Body of Second Method:
{
    long maskfilterNative = 0;
    if (maskfilter != null) {
        maskfilterNative = maskfilter.native_instance;
    }
    native_setMaskFilter(mNativePaint, maskfilterNative);
    mMaskFilter = maskfilter;
    return maskfilter;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.clear:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Clears the state of this instance.
 *
 * @hide
 */

Body of Frist Method:
{
    super.clear();
    mEventType = 0;
    mMovementGranularity = 0;
    mAction = 0;
    mContentChangeTypes = 0;
    mPackageName = null;
    mEventTime = 0;
    while (!mRecords.isEmpty()) {
        AccessibilityRecord record = mRecords.remove(0);
        record.recycle();
    }
}
Body of Second Method:
{
    super.clear();
    mEventType = 0;
    mMovementGranularity = 0;
    mAction = 0;
    mContentChangeTypes = 0;
    mPackageName = null;
    mEventTime = 0;
    if (mRecords != null) {
        while (!mRecords.isEmpty()) {
            AccessibilityRecord record = mRecords.remove(0);
            record.recycle();
        }
    }
}
------------------------
Find a functionally equivalent code:android.animation.ObjectAnimator.ofPropertyValuesHolder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Constructs and returns an ObjectAnimator that animates between the sets of values specified
 * in <code>PropertyValueHolder</code> objects. This variant should be used when animating
 * several properties at once with the same ObjectAnimator, since PropertyValuesHolder allows
 * you to associate a set of animation values with a property name.
 *
 * @param target The object whose property is to be animated. Depending on how the
 * PropertyValuesObjects were constructed, the target object should either have the {@link
 * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
 * PropertyValuesHOlder objects were created with property names) the target object should have
 * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
 * the property passed in as the <code>propertyName</code> parameter for each of the
 * PropertyValuesHolder objects.
 * @param values A set of PropertyValuesHolder objects whose values will be animated between
 * over time.
 * @return An ObjectAnimator object that is set up to animate between the given values.
 */

Body of Frist Method:
{
    ObjectAnimator anim = new ObjectAnimator();
    anim.mTarget = target;
    anim.setValues(values);
    return anim;
}
Body of Second Method:
{
    ObjectAnimator anim = new ObjectAnimator();
    anim.setTarget(target);
    anim.setValues(values);
    return anim;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onTimeChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onTimeChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called once per minute or when the time changes.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.app.admin.DevicePolicyManager.isAdminActive:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.isAdminActive(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return false;
}
Body of Second Method:
{
    return isAdminActiveAsUser(who, UserHandle.myUserId());
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.getPixel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Color} at the specified location. Throws an exception
 * if x or y are out of bounds (negative or >= to the width or height
 * respectively). The returned color is a non-premultiplied ARGB value.
 *
 * @param x    The x coordinate (0...width-1) of the pixel to return
 * @param y    The y coordinate (0...height-1) of the pixel to return
 * @return     The argb {@link Color} at the specified coordinate
 * @throws IllegalArgumentException if x, y exceed the bitmap's bounds
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativeBitmap, x, y, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativeBitmap, x, y);
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.loadThemeAttributeValue:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.StatusBarIconView.set:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the set succeeded.
 */

Body of Frist Method:
{
    final boolean iconEquals = mIcon != null && streq(mIcon.iconPackage, icon.iconPackage) && mIcon.iconId == icon.iconId;
    final boolean levelEquals = iconEquals && mIcon.iconLevel == icon.iconLevel;
    final boolean visibilityEquals = mIcon != null && mIcon.visible == icon.visible;
    final boolean numberEquals = mIcon != null && mIcon.number == icon.number;
    mIcon = icon.clone();
    setContentDescription(icon.contentDescription);
    if (!iconEquals) {
        if (!updateDrawable(false))
            return false;
    }
    if (!levelEquals) {
        setImageLevel(icon.iconLevel);
    }
    if (!numberEquals) {
        if (icon.number > 0 && mContext.getResources().getBoolean(R.bool.config_statusBarShowNumber)) {
            if (mNumberBackground == null) {
                mNumberBackground = getContext().getResources().getDrawable(R.drawable.ic_notification_overlay);
            }
            placeNumber();
        } else {
            mNumberBackground = null;
            mNumberText = null;
        }
        invalidate();
    }
    if (!visibilityEquals) {
        setVisibility(icon.visible ? VISIBLE : GONE);
    }
    return true;
}
Body of Second Method:
{
    final boolean iconEquals = mIcon != null && streq(mIcon.iconPackage, icon.iconPackage) && mIcon.iconId == icon.iconId;
    final boolean levelEquals = iconEquals && mIcon.iconLevel == icon.iconLevel;
    final boolean visibilityEquals = mIcon != null && mIcon.visible == icon.visible;
    final boolean numberEquals = mIcon != null && mIcon.number == icon.number;
    mIcon = icon.clone();
    setContentDescription(icon.contentDescription);
    if (!iconEquals) {
        if (!updateDrawable(false))
            return false;
    }
    if (!levelEquals) {
        setImageLevel(icon.iconLevel);
    }
    if (!numberEquals) {
        if (icon.number > 0 && getContext().getResources().getBoolean(R.bool.config_statusBarShowNumber)) {
            if (mNumberBackground == null) {
                mNumberBackground = getContext().getResources().getDrawable(R.drawable.ic_notification_overlay);
            }
            placeNumber();
        } else {
            mNumberBackground = null;
            mNumberText = null;
        }
        invalidate();
    }
    if (!visibilityEquals) {
        setVisibility(icon.visible ? VISIBLE : GONE);
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

Body of Frist Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
    mNativeBufferSizeInFrames = audioBufferSize / frameSizeInBytes;
}
Body of Second Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes;
    if (AudioFormat.isEncodingLinearPcm(mAudioFormat)) {
        frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
    } else {
        frameSizeInBytes = 1;
    }
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
    mNativeBufferSizeInFrames = audioBufferSize / frameSizeInBytes;
}
------------------------
Find a functionally equivalent code:android.net.NetworkStats.findIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Find first stats index that matches the requested parameters.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a functionally equivalent code:android.view.Window.setFormat:COMMENT
Method Modifier: public      
Comment:/**
 * Set the format of window, as per the PixelFormat types.  This overrides
 * the default format that is selected by the Window based on its
 * window decorations.
 *
 * @param format The new window format (see PixelFormat).  Use
 * PixelFormat.UNKNOWN to allow the Window to select
 * the format.
 *
 * @see PixelFormat
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (format != PixelFormat.UNKNOWN) {
        attrs.format = format;
        mHaveWindowFormat = true;
    } else {
        attrs.format = mDefaultWindowFormat;
        mHaveWindowFormat = false;
    }
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (format != PixelFormat.UNKNOWN) {
        attrs.format = format;
        mHaveWindowFormat = true;
    } else {
        attrs.format = mDefaultWindowFormat;
        mHaveWindowFormat = false;
    }
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.animation.ObjectAnimator.initAnimation:COMMENT
Method Modifier: 
Comment:/**
 * This function is called immediately before processing the first animation
 * frame of an animation. If there is a nonzero <code>startDelay</code>, the
 * function is called after that delay ends.
 * It takes care of the final initialization steps for the
 * animation. This includes setting mEvaluator, if the user has not yet
 * set it up, and the setter/getter methods, if the user did not supply
 * them.
 *
 * <p>Overriders of this method should call the superclass method to cause
 * internal mechanisms to be set up correctly.</p>
 */

Body of Frist Method:
{
    if (!mInitialized) {
        // mValueType may change due to setter/getter setup; do this before calling super.init(),
        // which uses mValueType to set up the default type evaluator.
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].setupSetterAndGetter(mTarget);
        }
        super.initAnimation();
    }
}
Body of Second Method:
{
    if (!mInitialized) {
        // mValueType may change due to setter/getter setup; do this before calling super.init(),
        // which uses mValueType to set up the default type evaluator.
        final Object target = getTarget();
        if (target != null) {
            final int numValues = mValues.length;
            for (int i = 0; i < numValues; ++i) {
                mValues[i].setupSetterAndGetter(target);
            }
        }
        super.initAnimation();
    }
}
------------------------
Find a functionally equivalent code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

Body of Frist Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                // How much does the image differ from our preference?  The threshold
                // here is set to accept any image larger than our target, because
                // scaling down is acceptable; but to reject images that are deemed
                // "too small" to scale up attractively.  The value 1.33 is just barely
                // too low to pass Nexus 1 or Droid wallpapers for use on a Xoom, but
                // will pass anything relatively larger.
                double widthRatio = mDesiredMinWidth / options.outWidth;
                double heightRatio = mDesiredMinHeight / options.outHeight;
                if (widthRatio > 0 && widthRatio < 1.33 && heightRatio > 0 && heightRatio < 1.33) {
                    // sufficiently close to our resolution; go ahead and use it
                    if (DEBUG)
                        Slog.d(TAG, "wallpaper dimension match; using");
                    f.renameTo(new File(WALLPAPER_IMAGE));
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                } else {
                    if (DEBUG)
                        Slog.d(TAG, "dimensions too far off: wr=" + widthRatio + " hr=" + heightRatio);
                    f.delete();
                }
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
Body of Second Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.mediaframeworktest.functional.CodecTest.playMediaSamples:COMMENT
Method Modifier: public      static      
Comment:// For each media file, forward twice and backward once, then play to the end

Body of Frist Method:
{
    int duration = 0;
    int curPosition = 0;
    int nextPosition = 0;
    int waittime = 0;
    onCompleteSuccess = false;
    mMediaInfoUnknownCount = 0;
    mMediaInfoVideoTrackLaggingCount = 0;
    mMediaInfoBadInterleavingCount = 0;
    mMediaInfoNotSeekableCount = 0;
    mMediaInfoMetdataUpdateCount = 0;
    mPlaybackError = false;
    String testResult;
    initializeMessageLooper();
    synchronized (lock) {
        try {
            lock.wait(WAIT_FOR_COMMAND_TO_COMPLETE);
        } catch (Exception e) {
            Log.v(TAG, "looper was interrupted.");
            return false;
        }
    }
    try {
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mOnErrorListener);
        mMediaPlayer.setOnInfoListener(mInfoListener);
        Log.v(TAG, "playMediaSamples: sample file name " + filePath);
        mMediaPlayer.setDataSource(filePath);
        mMediaPlayer.setDisplay(MediaFrameworkTest.mSurfaceView.getHolder());
        mMediaPlayer.prepare();
        duration = mMediaPlayer.getDuration();
        // start to play
        mMediaPlayer.start();
        waittime = duration - mMediaPlayer.getCurrentPosition();
        synchronized (onCompletion) {
            try {
                onCompletion.wait(waittime + 2000);
            } catch (Exception e) {
                Log.v(TAG, "playMediaSamples are interrupted");
                return false;
            }
        }
        terminateMessageLooper();
    } catch (Exception e) {
        Log.v(TAG, "playMediaSamples:" + e.getMessage());
    }
    return onCompleteSuccess;
}
Body of Second Method:
{
    int duration = 0;
    int curPosition = 0;
    int nextPosition = 0;
    int waittime = 0;
    onCompleteSuccess = false;
    mMediaInfoUnknownCount = 0;
    mMediaInfoVideoTrackLaggingCount = 0;
    mMediaInfoBadInterleavingCount = 0;
    mMediaInfoNotSeekableCount = 0;
    mMediaInfoMetdataUpdateCount = 0;
    mPlaybackError = false;
    String testResult;
    initializeMessageLooper();
    synchronized (lock) {
        try {
            lock.wait(WAIT_FOR_COMMAND_TO_COMPLETE);
        } catch (Exception e) {
            Log.v(TAG, "looper was interrupted.");
            return false;
        }
    }
    try {
        mMediaPlayer.setOnCompletionListener(mCompletionListener);
        mMediaPlayer.setOnErrorListener(mOnErrorListener);
        mMediaPlayer.setOnInfoListener(mInfoListener);
        Log.v(TAG, "playMediaSamples: sample file name " + filePath);
        mMediaPlayer.setDataSource(filePath);
        mMediaPlayer.setDisplay(MediaFrameworkTest.mSurfaceView.getHolder());
        mMediaPlayer.prepare();
        duration = mMediaPlayer.getDuration();
        // start to play
        mMediaPlayer.start();
        waittime = duration - mMediaPlayer.getCurrentPosition();
        synchronized (onCompletion) {
            try {
                onCompletion.wait(waittime + buffertime);
            } catch (Exception e) {
                Log.v(TAG, "playMediaSamples are interrupted");
                return false;
            }
        }
        terminateMessageLooper();
    } catch (Exception e) {
        Log.v(TAG, "playMediaSamples:" + e.getMessage());
    }
    return onCompleteSuccess;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.testNoOp:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that a class not being modified still works.
 */

Body of Frist Method:
{
    // create an instance of the class that will be modified
    // (load the class in a distinct class loader so that we can trash its definition later)
    ClassLoader cl1 = new ClassLoader(this.getClass().getClassLoader()) {
    };
    Class<ClassWithNative> clazz1 = (Class<ClassWithNative>) cl1.loadClass(NATIVE_CLASS_NAME);
    ClassWithNative instance1 = clazz1.newInstance();
    assertEquals(42, instance1.add(20, 22));
    try {
        instance1.callNativeInstance(10, 3.1415, new Object[0]);
        fail("Test should have failed to invoke callTheNativeMethod [1]");
    } catch (UnsatisfiedLinkError e) {
    // This is expected to fail since the native method is not implemented.
    }
    // Now process it but tell the delegate to not modify any method
    ClassWriter cw = new ClassWriter(0);
    HashSet<String> delegateMethods = new HashSet<String>();
    String internalClassName = NATIVE_CLASS_NAME.replace('.', '/');
    DelegateClassAdapter cv = new DelegateClassAdapter(mLog, cw, internalClassName, delegateMethods);
    ClassReader cr = new ClassReader(NATIVE_CLASS_NAME);
    cr.accept(cv, 0);
    // Load the generated class in a different class loader and try it again
    ClassLoader2 cl2 = null;
    try {
        cl2 = new ClassLoader2() {

            @Override
            public void testModifiedInstance() throws Exception {
                Class<?> clazz2 = loadClass(NATIVE_CLASS_NAME);
                Object i2 = clazz2.newInstance();
                assertNotNull(i2);
                assertEquals(42, callAdd(i2, 20, 22));
                try {
                    callCallNativeInstance(i2, 10, 3.1415, new Object[0]);
                    fail("Test should have failed to invoke callTheNativeMethod [2]");
                } catch (InvocationTargetException e) {
                    // This is expected to fail since the native method has NOT been
                    // overridden here.
                    assertEquals(UnsatisfiedLinkError.class, e.getCause().getClass());
                }
                // Check that the native method does NOT have the new annotation
                Method[] m = clazz2.getDeclaredMethods();
                assertEquals("native_instance", m[2].getName());
                assertTrue(Modifier.isNative(m[2].getModifiers()));
                Annotation[] a = m[2].getAnnotations();
                assertEquals(0, a.length);
            }
        };
        cl2.add(NATIVE_CLASS_NAME, cw);
        cl2.testModifiedInstance();
    } catch (Throwable t) {
        throw dumpGeneratedClass(t, cl2);
    }
}
Body of Second Method:
{
    // create an instance of the class that will be modified
    // (load the class in a distinct class loader so that we can trash its definition later)
    ClassLoader cl1 = new ClassLoader(this.getClass().getClassLoader()) {
    };
    Class<ClassWithNative> clazz1 = (Class<ClassWithNative>) cl1.loadClass(NATIVE_CLASS_NAME);
    ClassWithNative instance1 = clazz1.newInstance();
    assertEquals(42, instance1.add(20, 22));
    try {
        instance1.callNativeInstance(10, 3.1415, new Object[0]);
        fail("Test should have failed to invoke callTheNativeMethod [1]");
    } catch (UnsatisfiedLinkError e) {
    // This is expected to fail since the native method is not implemented.
    }
    // Now process it but tell the delegate to not modify any method
    ClassWriter cw = new ClassWriter(0);
    HashSet<String> delegateMethods = new HashSet<String>();
    String internalClassName = NATIVE_CLASS_NAME.replace('.', '/');
    DelegateClassAdapter cv = new DelegateClassAdapter(mLog, cw, internalClassName, delegateMethods);
    ClassReader cr = new ClassReader(NATIVE_CLASS_NAME);
    cr.accept(cv, 0);
    // Load the generated class in a different class loader and try it again
    ClassLoader2 cl2 = null;
    try {
        cl2 = new ClassLoader2() {

            @Override
            public void testModifiedInstance() throws Exception {
                Class<?> clazz2 = loadClass(NATIVE_CLASS_NAME);
                Object i2 = clazz2.newInstance();
                assertNotNull(i2);
                assertEquals(42, callAdd(i2, 20, 22));
                try {
                    callCallNativeInstance(i2, 10, 3.1415, new Object[0]);
                    fail("Test should have failed to invoke callTheNativeMethod [2]");
                } catch (InvocationTargetException e) {
                    // This is expected to fail since the native method has NOT been
                    // overridden here.
                    assertEquals(UnsatisfiedLinkError.class, e.getCause().getClass());
                }
                // Check that the native method does NOT have the new annotation
                Method[] m = clazz2.getDeclaredMethods();
                Method nativeInstanceMethod = null;
                for (Method method : m) {
                    if ("native_instance".equals(method.getName())) {
                        nativeInstanceMethod = method;
                        break;
                    }
                }
                assertNotNull(nativeInstanceMethod);
                assertTrue(Modifier.isNative(nativeInstanceMethod.getModifiers()));
                Annotation[] a = nativeInstanceMethod.getAnnotations();
                assertEquals(0, a.length);
            }
        };
        cl2.add(NATIVE_CLASS_NAME, cw);
        cl2.testModifiedInstance();
    } catch (Throwable t) {
        throw dumpGeneratedClass(t, cl2);
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.getMenuInflater:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link MenuInflater} with this context.
 */

Body of Frist Method:
{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}
Body of Second Method:
{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}
------------------------
Find a functionally equivalent code:com.android.internal.util.AsyncChannel.disconnect:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Disconnect
 */

Body of Frist Method:
{
    if ((mConnection != null) && (mSrcContext != null)) {
        mSrcContext.unbindService(mConnection);
    }
    try {
        // Send the DISCONNECTED, although it may not be received
        // but its the best we can do.
        Message msg = Message.obtain();
        msg.what = CMD_CHANNEL_DISCONNECTED;
        msg.replyTo = mSrcMessenger;
        mDstMessenger.send(msg);
    } catch (Exception e) {
    }
    // Tell source we're disconnected.
    if (mSrcHandler != null) {
        replyDisconnected(STATUS_SUCCESSFUL);
    }
    // Unlink only when bindService isn't used
    if (mConnection == null && mDstMessenger != null && mDeathMonitor != null) {
        mDstMessenger.getBinder().unlinkToDeath(mDeathMonitor, 0);
    }
}
Body of Second Method:
{
    if ((mConnection != null) && (mSrcContext != null)) {
        mSrcContext.unbindService(mConnection);
        mConnection = null;
    }
    try {
        // Send the DISCONNECTED, although it may not be received
        // but its the best we can do.
        Message msg = Message.obtain();
        msg.what = CMD_CHANNEL_DISCONNECTED;
        msg.replyTo = mSrcMessenger;
        mDstMessenger.send(msg);
    } catch (Exception e) {
    }
    // Tell source we're disconnected.
    if (mSrcHandler != null) {
        replyDisconnected(STATUS_SUCCESSFUL);
        mSrcHandler = null;
    }
    // Unlink only when bindService isn't used
    if (mConnection == null && mDstMessenger != null && mDeathMonitor != null) {
        mDstMessenger.getBinder().unlinkToDeath(mDeathMonitor, 0);
        mDeathMonitor = null;
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */

Body of Frist Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    SparseLongArray childIds = mChildNodeIds;
    final int childIdsSize = childIds.size();
    parcel.writeInt(childIdsSize);
    for (int i = 0; i < childIdsSize; i++) {
        parcel.writeLong(childIds.valueAt(i));
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    parcel.writeInt(mActions);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
Body of Second Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.applyStyle:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.CalendarView.setUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of a not focused month.
 *
 * @param color A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

Body of Frist Method:
{
    if (mUnfocusedMonthDateColor != color) {
        mUnfocusedMonthDateColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasUnfocusedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setUnfocusedMonthDateColor(color);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getSelectedDateVerticalBar:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable for the vertical bar shown at the beginning and at
 * the end of the selected date.
 *
 * @return The vertical bar drawable.
 */

Body of Frist Method:
{
    return mSelectedDateVerticalBar;
}
Body of Second Method:
{
    return mDelegate.getSelectedDateVerticalBar();
}
------------------------
Find a functionally equivalent code:android.graphics.pdf.PdfDocument.finishPage:COMMENT
Method Modifier: public      
Comment:/**
 * Finishes a started page. You should always finish the last started page.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * You should not finish the same page more than once.
 * </p>
 *
 * @param page The page. Cannot be null.
 *
 * @see #startPage(PageInfo)
 */

Body of Frist Method:
{
    throwIfClosed();
    if (page == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    if (page != mCurrentPage) {
        throw new IllegalStateException("invalid page");
    }
    if (page.isFinished()) {
        throw new IllegalStateException("page already finished");
    }
    mPages.add(page.getInfo());
    mCurrentPage = null;
    nativeAppendPage(mNativeDocument, page.mCanvas.mNativeCanvas);
    page.finish();
}
Body of Second Method:
{
    throwIfClosed();
    if (page == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    if (page != mCurrentPage) {
        throw new IllegalStateException("invalid page");
    }
    if (page.isFinished()) {
        throw new IllegalStateException("page already finished");
    }
    mPages.add(page.getInfo());
    mCurrentPage = null;
    nativeFinishPage(mNativeDocument);
    page.finish();
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.GsmAlphabet.gsm8BitUnpackedToString:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Convert a GSM alphabet string that's stored in 8-bit unpacked
 * format (as it often appears in SIM records) into a String
 *
 * Field may be padded with trailing 0xff's. The decode stops
 * at the first 0xff encountered.
 *
 * Additionally, in some country(ex. Korea), there are non-ASCII or MBCS characters.
 * If a character set is given, characters in data are treat as MBCS.
 */

Body of Frist Method:
{
    boolean isMbcs = false;
    Charset charset = null;
    ByteBuffer mbcsBuffer = null;
    if (!TextUtils.isEmpty(characterset) && !characterset.equalsIgnoreCase("us-ascii") && Charset.isSupported(characterset)) {
        isMbcs = true;
        charset = Charset.forName(characterset);
        mbcsBuffer = ByteBuffer.allocate(2);
    }
    // Always use GSM 7 bit default alphabet table for this method
    String languageTableToChar = sLanguageTables[0];
    String shiftTableToChar = sLanguageShiftTables[0];
    StringBuilder ret = new StringBuilder(length);
    boolean prevWasEscape = false;
    for (int i = offset; i < offset + length; i++) {
        // Never underestimate the pain that can be caused
        // by signed bytes
        int c = data[i] & 0xff;
        if (c == 0xff) {
            break;
        } else if (c == GSM_EXTENDED_ESCAPE) {
            if (prevWasEscape) {
                // Two escape chars in a row
                // We treat this as a space
                // See Note 1 in table 6.2.1.1 of TS 23.038 v7.00
                ret.append(' ');
                prevWasEscape = false;
            } else {
                prevWasEscape = true;
            }
        } else {
            if (prevWasEscape) {
                char shiftChar = shiftTableToChar.charAt(c);
                if (shiftChar == ' ') {
                    // display character from main table if not present in shift table
                    ret.append(languageTableToChar.charAt(c));
                } else {
                    ret.append(shiftChar);
                }
            } else {
                if (!isMbcs || c < 0x80 || i + 1 >= offset + length) {
                    ret.append(languageTableToChar.charAt(c));
                } else {
                    // isMbcs must be true. So both mbcsBuffer and charset are initialized.
                    mbcsBuffer.clear();
                    mbcsBuffer.put(data, i++, 2);
                    mbcsBuffer.flip();
                    ret.append(charset.decode(mbcsBuffer).toString());
                }
            }
            prevWasEscape = false;
        }
    }
    return ret.toString();
}
Body of Second Method:
{
    boolean isMbcs = false;
    Charset charset = null;
    ByteBuffer mbcsBuffer = null;
    if (!TextUtils.isEmpty(characterset) && !characterset.equalsIgnoreCase("us-ascii") && Charset.isSupported(characterset)) {
        isMbcs = true;
        charset = Charset.forName(characterset);
        mbcsBuffer = ByteBuffer.allocate(2);
    }
    // Always use GSM 7 bit default alphabet table for this method
    String languageTableToChar = sLanguageTables[0];
    String shiftTableToChar = sLanguageShiftTables[0];
    StringBuilder ret = new StringBuilder(length);
    boolean prevWasEscape = false;
    for (int i = offset; i < offset + length; i++) {
        // Never underestimate the pain that can be caused
        // by signed bytes
        int c = data[i] & 0xff;
        if (c == 0xff) {
            break;
        } else if (c == GSM_EXTENDED_ESCAPE) {
            if (prevWasEscape) {
                // Two escape chars in a row
                // We treat this as a space
                // See Note 1 in table 6.2.1.1 of TS 23.038 v7.00
                ret.append(' ');
                prevWasEscape = false;
            } else {
                prevWasEscape = true;
            }
        } else {
            if (prevWasEscape) {
                char shiftChar = c < shiftTableToChar.length() ? shiftTableToChar.charAt(c) : ' ';
                if (shiftChar == ' ') {
                    // display character from main table if not present in shift table
                    if (c < languageTableToChar.length()) {
                        ret.append(languageTableToChar.charAt(c));
                    } else {
                        ret.append(' ');
                    }
                } else {
                    ret.append(shiftChar);
                }
            } else {
                if (!isMbcs || c < 0x80 || i + 1 >= offset + length) {
                    if (c < languageTableToChar.length()) {
                        ret.append(languageTableToChar.charAt(c));
                    } else {
                        ret.append(' ');
                    }
                } else {
                    // isMbcs must be true. So both mbcsBuffer and charset are initialized.
                    mbcsBuffer.clear();
                    mbcsBuffer.put(data, i++, 2);
                    mbcsBuffer.flip();
                    ret.append(charset.decode(mbcsBuffer).toString());
                }
            }
            prevWasEscape = false;
        }
    }
    return ret.toString();
}
------------------------
Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.handleNiNotification:COMMENT
Method Modifier: public      internal    
Comment:// Handles NI events from HAL

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "handleNiNotification" + " notificationId: " + notif.notificationId + " requestorId: " + notif.requestorId + " text: " + notif.text);
    // Notify and verify with immediate pop-up
    if (notif.needNotify && notif.needVerify && mPopupImmediately) {
        // Popup the dialog box now
        openNiDialog(notif);
    }
    // Notify only, or delayed pop-up (change mPopupImmediately to FALSE)
    if (notif.needNotify && !notif.needVerify || notif.needNotify && notif.needVerify && !mPopupImmediately) {
        // Show the notification
        // if mPopupImmediately == FALSE and needVerify == TRUE, a dialog will be opened
        // when the user opens the notification message
        setNiNotification(notif);
    }
    // ACCEPT cases: 1. Notify, no verify; 2. no notify, no verify; 3. privacy override.
    if (notif.needNotify && !notif.needVerify || !notif.needNotify && !notif.needVerify || notif.privacyOverride) {
        mLocationManager.sendNiResponse(notif.notificationId, GPS_NI_RESPONSE_ACCEPT);
    }
// ////////////////////////////////////////////////////////////////////////
// A note about timeout
// According to the protocol, in the need_notify and need_verify case,
// a default response should be sent when time out.
// 
// In some GPS hardware, the GPS driver (under HAL) can handle the timeout case
// and this class GpsNetInitiatedHandler does not need to do anything.
// 
// However, the UI should at least close the dialog when timeout. Further,
// for more general handling, timeout response should be added to the Handler here.
// 
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "in handleNiNotification () :" + " notificationId: " + notif.notificationId + " requestorId: " + notif.requestorId + " text: " + notif.text + " mIsSuplEsEnabled" + getSuplEsEnabled() + " mIsLocationEnabled" + getLocationEnabled());
    if (getSuplEsEnabled()) {
        handleNiInEs(notif);
    } else {
        handleNi(notif);
    }
// ////////////////////////////////////////////////////////////////////////
// A note about timeout
// According to the protocol, in the need_notify and need_verify case,
// a default response should be sent when time out.
// 
// In some GPS hardware, the GPS driver (under HAL) can handle the timeout case
// and this class GpsNetInitiatedHandler does not need to do anything.
// 
// However, the UI should at least close the dialog when timeout. Further,
// for more general handling, timeout response should be added to the Handler here.
// 
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.addSubtitleSource:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final InputStream fIs = is;
    final MediaFormat fFormat = format;
    // way to implement timeouts in the future.
    synchronized (mOpenSubtitleSources) {
        mOpenSubtitleSources.add(is);
    }
    // process each subtitle in its own thread
    final HandlerThread thread = new HandlerThread("SubtitleReadThread", Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE);
    thread.start();
    Handler handler = new Handler(thread.getLooper());
    handler.post(new Runnable() {

        private int addTrack() {
            if (fIs == null || mSubtitleController == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            SubtitleTrack track = mSubtitleController.addTrack(fFormat);
            if (track == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            // TODO: do the conversion in the subtitle track
            Scanner scanner = new Scanner(fIs, "UTF-8");
            String contents = scanner.useDelimiter("\\A").next();
            synchronized (mOpenSubtitleSources) {
                mOpenSubtitleSources.remove(fIs);
            }
            scanner.close();
            mOutOfBandSubtitleTracks.add(track);
            track.onData(contents, true, /* eos */
            ~0);
            return MEDIA_INFO_EXTERNAL_METADATA_UPDATE;
        }

        public void run() {
            int res = addTrack();
            if (mEventHandler != null) {
                Message m = mEventHandler.obtainMessage(MEDIA_INFO, res, 0, null);
                mEventHandler.sendMessage(m);
            }
            thread.getLooper().quitSafely();
        }
    });
}
Body of Second Method:
{
    final InputStream fIs = is;
    final MediaFormat fFormat = format;
    // way to implement timeouts in the future.
    synchronized (mOpenSubtitleSources) {
        mOpenSubtitleSources.add(is);
    }
    // process each subtitle in its own thread
    final HandlerThread thread = new HandlerThread("SubtitleReadThread", Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE);
    thread.start();
    Handler handler = new Handler(thread.getLooper());
    handler.post(new Runnable() {

        private int addTrack() {
            if (fIs == null || mSubtitleController == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            SubtitleTrack track = mSubtitleController.addTrack(fFormat);
            if (track == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            // TODO: do the conversion in the subtitle track
            Scanner scanner = new Scanner(fIs, "UTF-8");
            String contents = scanner.useDelimiter("\\A").next();
            synchronized (mOpenSubtitleSources) {
                mOpenSubtitleSources.remove(fIs);
            }
            scanner.close();
            mOutOfBandSubtitleTracks.add(track);
            track.onData(contents.getBytes(), true, /* eos */
            ~0);
            return MEDIA_INFO_EXTERNAL_METADATA_UPDATE;
        }

        public void run() {
            int res = addTrack();
            if (mEventHandler != null) {
                Message m = mEventHandler.obtainMessage(MEDIA_INFO, res, 0, null);
                mEventHandler.sendMessage(m);
            }
            thread.getLooper().quitSafely();
        }
    });
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.isNetworkTypeMobile:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given type uses the cellular data connection.
 * This should be replaced in the future by a network property.
 * @param networkType the type to check
 * @return a boolean - {@code true} if uses cellular network, else {@code false}
 * {@hide}
 */

Body of Frist Method:
{
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
        case TYPE_MOBILE_EMERGENCY:
            return true;
        default:
            return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.smspush.WapPushManager.WapPushManDBHelper.queryLastApp:COMMENT
Method Modifier: protected   
Comment:/**
 * Query the latest receiver application info with supplied application ID and
 * content type.
 * @param app_id    application ID to look up
 * @param content_type    content type to look up
 */

Body of Frist Method:
{
    String sql = "select install_order, package_name, class_name, " + " app_type, need_signature, further_processing" + " from " + APPID_TABLE_NAME + " where x_wap_application=\'" + app_id + "\'" + " and content_type=\'" + content_type + "\'" + " order by install_order desc";
    if (DEBUG_SQL)
        Log.v(LOG_TAG, "sql: " + sql);
    Cursor cur = db.rawQuery(sql, null);
    queryData ret = null;
    if (cur.moveToNext()) {
        ret = new queryData();
        ret.installOrder = cur.getInt(cur.getColumnIndex("install_order"));
        ret.packageName = cur.getString(cur.getColumnIndex("package_name"));
        ret.className = cur.getString(cur.getColumnIndex("class_name"));
        ret.appType = cur.getInt(cur.getColumnIndex("app_type"));
        ret.needSignature = cur.getInt(cur.getColumnIndex("need_signature"));
        ret.furtherProcessing = cur.getInt(cur.getColumnIndex("further_processing"));
    }
    cur.close();
    return ret;
}
Body of Second Method:
{
    if (LOCAL_LOGV)
        Log.v(LOG_TAG, "queryLastApp app_id: " + app_id + " content_type: " + content_type);
    Cursor cur = db.query(APPID_TABLE_NAME, new String[] { "install_order", "package_name", "class_name", "app_type", "need_signature", "further_processing" }, "x_wap_application=? and content_type=?", new String[] { app_id, content_type }, null, /* groupBy */
    null, /* having */
    "install_order desc");
    queryData ret = null;
    if (cur.moveToNext()) {
        ret = new queryData();
        ret.installOrder = cur.getInt(cur.getColumnIndex("install_order"));
        ret.packageName = cur.getString(cur.getColumnIndex("package_name"));
        ret.className = cur.getString(cur.getColumnIndex("class_name"));
        ret.appType = cur.getInt(cur.getColumnIndex("app_type"));
        ret.needSignature = cur.getInt(cur.getColumnIndex("need_signature"));
        ret.furtherProcessing = cur.getInt(cur.getColumnIndex("further_processing"));
    }
    cur.close();
    return ret;
}
------------------------
Find a functionally equivalent code:android.os.Parcel.readArrayMapSafelyInternal:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading safely " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        Object key = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read safe #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.put(key, value);
        N--;
    }
}
Body of Second Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading safely " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        String key = readString();
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read safe #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.put(key, value);
        N--;
    }
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.createReliableSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.selectRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Select the specified route to use for output of the given media types.
 * <p class="note">
 * As API version 18, this function may be used to select any route.
 * In prior versions, this function could only be used to select user
 * routes and would ignore any attempt to select a system route.
 * </p>
 *
 * @param types type flags indicating which types this route should be used for.
 * The route must support at least a subset.
 * @param route Route to select
 */

Body of Frist Method:
{
    selectRouteStatic(types, route);
}
Body of Second Method:
{
    selectRouteStatic(types, route, true);
}
------------------------
Find a functionally equivalent code:android.transition.TransitionSet.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    for (Transition childTransition : mTransitions) {
        childTransition.createAnimators(sceneRoot, startValues, endValues);
    }
}
Body of Second Method:
{
    long startDelay = getStartDelay();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; i++) {
        Transition childTransition = mTransitions.get(i);
        // the transitions sequentially.
        if (startDelay > 0 && (mPlayTogether || i == 0)) {
            long childStartDelay = childTransition.getStartDelay();
            if (childStartDelay > 0) {
                childTransition.setStartDelay(startDelay + childStartDelay);
            } else {
                childTransition.setStartDelay(startDelay);
            }
        }
        childTransition.createAnimators(sceneRoot, startValues, endValues, startValuesList, endValuesList);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.onRegisterVolumeObserverForRcc:COMMENT
Method Modifier: private     
Comment:// handler for MSG_RCC_NEW_VOLUME_OBS

Body of Frist Method:
{
    synchronized (mRCStack) {
        // start iterating from the top.
        try {
            for (int index = mRCStack.size() - 1; index >= 0; index--) {
                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                if (rcse.mRccId == rccId) {
                    rcse.mRemoteVolumeObs = rvo;
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        // start iterating from the top.
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if (prse.getRccId() == rccId) {
                    prse.mRemoteVolumeObs = rvo;
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.text.SpannableStringBuilder.getTextRunAdvances:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Paint to use internally.
 * {@hide}
 */

Body of Frist Method:
{
    float ret;
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (end <= mGapStart) {
        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, flags, advances, advancesPos);
    } else if (start >= mGapStart) {
        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, flags, advances, advancesPos);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, flags, advances, advancesPos);
        TextUtils.recycle(buf);
    }
    return ret;
}
Body of Second Method:
{
    float ret;
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (end <= mGapStart) {
        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, isRtl, advances, advancesPos);
    } else if (start >= mGapStart) {
        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, isRtl, advances, advancesPos);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, isRtl, advances, advancesPos);
        TextUtils.recycle(buf);
    }
    return ret;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the calendar dates.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

Body of Frist Method:
{
    if (mDateTextAppearanceResId != resourceId) {
        mDateTextAppearanceResId = resourceId;
        updateDateTextSize();
        invalidateAllWeekViews();
    }
}
Body of Second Method:
{
    mDelegate.setDateTextAppearance(resourceId);
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.setProvisioningNotificationVisible:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set sign in error notification to visible or in visible
 *
 * @param visible
 * @param networkType
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, extraInfo, url);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, action);
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_VocabularyDestroy:COMMENT
Method Modifier: private     static      native      
Comment:// ESR_Locale* locale);

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.finishPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        if (mForceStatusBar || mForceStatusBarFromKeyguard) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(lp.flags));
            }
            topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    mTopIsFullscreen = topIsFullscreen;
    // displayed when the screen is locked.
    if (mKeyguard != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardDelegate.isSecure()) {
            if (mKeyguard.hideLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            if (mKeyguard.hideLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (!mShowingDream) {
                mKeyguardDelegate.setHidden(true);
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            // This is the case of keyguard isSecure() and not mHideLockScreen.
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                if (mKeyguard.showLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
                mKeyguardDelegate.setHidden(false);
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            if (mKeyguard.showLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            mKeyguardDelegate.setHidden(false);
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
Body of Second Method:
{
    if (mWinShowWhenLocked != null && mWinShowWhenLocked != mTopFullscreenOpaqueWindowState) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        if (mForceStatusBar || mForceStatusBarFromKeyguard) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !isKeyguardSecure()) {
            mKeyguardHidden = true;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            // This is the case of keyguard isSecure() and not mHideLockScreen.
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                mKeyguardHidden = false;
                if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            mKeyguardHidden = false;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiInfo.getHiddenSSID:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@code true} if this network does not broadcast its SSID, so an
 * SSID-specific probe request must be used for scans.
 */

Body of Frist Method:
{
    return mHiddenSSID;
}
Body of Second Method:
{
    if (mWifiSsid == null)
        return false;
    return mWifiSsid.isHidden();
}
------------------------
Find a functionally equivalent code:android.os.Parcel.writeException:COMMENT
Method Modifier: public      final       
Comment:/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */

Body of Frist Method:
{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}
Body of Second Method:
{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}
------------------------
Find a functionally equivalent code:android.graphics.BidiRenderer.getScriptRuns:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    LinkedList<ScriptRun> scriptRuns = new LinkedList<ScriptRun>();
    int count = limit - start;
    UScriptRun uScriptRun = new UScriptRun(text, start, count);
    while (uScriptRun.next()) {
        int scriptStart = uScriptRun.getScriptStart();
        int scriptLimit = uScriptRun.getScriptLimit();
        ScriptRun run = new ScriptRun(scriptStart, scriptLimit, isRtl);
        run.scriptCode = uScriptRun.getScriptCode();
        setScriptFont(text, run, fonts);
        scriptRuns.add(run);
    }
    return scriptRuns;
}
Body of Second Method:
{
    LinkedList<ScriptRun> scriptRuns = new LinkedList<ScriptRun>();
    int count = limit - start;
    UScriptRun uScriptRun = new UScriptRun(text, start, count);
    while (uScriptRun.next()) {
        int scriptStart = uScriptRun.getScriptStart();
        int scriptLimit = uScriptRun.getScriptLimit();
        ScriptRun run = new ScriptRun(scriptStart, scriptLimit, isRtl);
        run.scriptCode = uScriptRun.getScriptCode();
        setScriptFont(text, run, fonts);
        scriptRuns.add(run);
    }
    return scriptRuns;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return false;
    }
    if (mResourceData[index] == null) {
        return false;
    }
    String s = mResourceData[index].getValue();
    return ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
}
Body of Second Method:
{
    String s = getString(index);
    return s != null && ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.updateOrientationListenerLp:COMMENT
Method Modifier: internal    
Comment:/*
     * Various use cases for invoking this function
     * screen turning off, should always disable listeners if already enabled
     * screen turned on and current app has sensor based orientation, enable listeners
     * if not already enabled
     * screen turned on and current app does not have sensor orientation, disable listeners if
     * already enabled
     * screen turning on and current app has sensor based orientation, enable listeners if needed
     * screen turning on and current app has nosensor based orientation, do nothing
     */

Body of Frist Method:
{
    if (!mOrientationListener.canDetectOrientation()) {
        // If sensor is turned off or nonexistent for some reason
        return;
    }
    // change of the currently visible window's orientation
    if (localLOGV)
        Slog.v(TAG, "Screen status=" + mScreenOnEarly + ", current orientation=" + mCurrentAppOrientation + ", SensorEnabled=" + mOrientationSensorEnabled);
    boolean disable = true;
    if (mScreenOnEarly) {
        if (needSensorRunningLp()) {
            disable = false;
            // enable listener if not already enabled
            if (!mOrientationSensorEnabled) {
                mOrientationListener.enable();
                if (localLOGV)
                    Slog.v(TAG, "Enabling listeners");
                mOrientationSensorEnabled = true;
            }
        }
    }
    // check if sensors need to be disabled
    if (disable && mOrientationSensorEnabled) {
        mOrientationListener.disable();
        if (localLOGV)
            Slog.v(TAG, "Disabling listeners");
        mOrientationSensorEnabled = false;
    }
}
Body of Second Method:
{
    if (!mOrientationListener.canDetectOrientation()) {
        // If sensor is turned off or nonexistent for some reason
        return;
    }
    // change of the currently visible window's orientation
    if (localLOGV)
        Slog.v(TAG, "mScreenOnEarly=" + mScreenOnEarly + ", mAwake=" + mAwake + ", mCurrentAppOrientation=" + mCurrentAppOrientation + ", mOrientationSensorEnabled=" + mOrientationSensorEnabled);
    boolean disable = true;
    if (mScreenOnEarly && mAwake) {
        if (needSensorRunningLp()) {
            disable = false;
            // enable listener if not already enabled
            if (!mOrientationSensorEnabled) {
                mOrientationListener.enable();
                if (localLOGV)
                    Slog.v(TAG, "Enabling listeners");
                mOrientationSensorEnabled = true;
            }
        }
    }
    // check if sensors need to be disabled
    if (disable && mOrientationSensorEnabled) {
        mOrientationListener.disable();
        if (localLOGV)
            Slog.v(TAG, "Disabling listeners");
        mOrientationSensorEnabled = false;
    }
}
------------------------
Find a functionally equivalent code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: 
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = heightSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.registerZygoteSocket:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Registers a server socket for zygote command connections
 *
 * @throws RuntimeException when open fails
 */

Body of Frist Method:
{
    if (sServerSocket == null) {
        int fileDesc;
        try {
            String env = System.getenv(ANDROID_SOCKET_ENV);
            fileDesc = Integer.parseInt(env);
        } catch (RuntimeException ex) {
            throw new RuntimeException(ANDROID_SOCKET_ENV + " unset or invalid", ex);
        }
        try {
            sServerSocket = new LocalServerSocket(createFileDescriptor(fileDesc));
        } catch (IOException ex) {
            throw new RuntimeException("Error binding to local socket '" + fileDesc + "'", ex);
        }
    }
}
Body of Second Method:
{
    if (sServerSocket == null) {
        int fileDesc;
        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
        try {
            String env = System.getenv(fullSocketName);
            fileDesc = Integer.parseInt(env);
        } catch (RuntimeException ex) {
            throw new RuntimeException(fullSocketName + " unset or invalid", ex);
        }
        try {
            sServerSocket = new LocalServerSocket(createFileDescriptor(fileDesc));
        } catch (IOException ex) {
            throw new RuntimeException("Error binding to local socket '" + fileDesc + "'", ex);
        }
    }
}
------------------------
Find a functionally equivalent code:android.test.ServiceTestCase.shutdownService:COMMENT
Method Modifier: protected   
Comment:/**
 * Makes the necessary calls to stop (or unbind) the service under test, and
 * calls onDestroy().  Ordinarily this is called automatically (by {@link #tearDown}, but
 * you can call it directly from your test in order to check for proper shutdown behavior.
 */

Body of Frist Method:
{
    if (mServiceStarted) {
        mService.stopSelf();
        mServiceStarted = false;
    } else if (mServiceBound) {
        mService.onUnbind(mServiceIntent);
        mServiceBound = false;
    }
    if (mServiceCreated) {
        mService.onDestroy();
    }
}
Body of Second Method:
{
    if (mServiceStarted) {
        mService.stopSelf();
        mServiceStarted = false;
    } else if (mServiceBound) {
        mService.onUnbind(mServiceIntent);
        mServiceBound = false;
    }
    if (mServiceCreated) {
        mService.onDestroy();
        mServiceCreated = false;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Paint_Delegate.updateFontObject:COMMENT
Method Modifier: private     
Comment:/**
 * Update the {@link Font} object from the typeface, text size and scaling
 */

Body of Frist Method:
{
    if (mTypeface != null) {
        // Get the fonts from the TypeFace object.
        List<Font> fonts = mTypeface.getFonts();
        // create new font objects as well as FontMetrics, based on the current text size
        // and skew info.
        ArrayList<FontInfo> infoList = new ArrayList<FontInfo>(fonts.size());
        for (Font font : fonts) {
            FontInfo info = new FontInfo();
            info.mFont = font.deriveFont(mTextSize);
            if (mTextScaleX != 1.0 || mTextSkewX != 0) {
                // TODO: support skew
                info.mFont = info.mFont.deriveFont(new AffineTransform(mTextScaleX, mTextSkewX, 0, 1, 0, 0));
            }
            // The metrics here don't have anti-aliasing set.
            info.mMetrics = Toolkit.getDefaultToolkit().getFontMetrics(info.mFont);
            infoList.add(info);
        }
        mFonts = Collections.unmodifiableList(infoList);
    }
}
Body of Second Method:
{
    if (mTypeface != null) {
        // Get the fonts from the TypeFace object.
        List<Font> fonts = mTypeface.getFonts(mFontVariant);
        // create new font objects as well as FontMetrics, based on the current text size
        // and skew info.
        ArrayList<FontInfo> infoList = new ArrayList<FontInfo>(fonts.size());
        for (Font font : fonts) {
            if (font == null) {
                // If the font is null, add null to infoList. When rendering the text, if this
                // null is reached, a warning will be logged.
                infoList.add(null);
                continue;
            }
            FontInfo info = new FontInfo();
            info.mFont = font.deriveFont(mTextSize);
            if (mTextScaleX != 1.0 || mTextSkewX != 0) {
                // TODO: support skew
                info.mFont = info.mFont.deriveFont(new AffineTransform(mTextScaleX, mTextSkewX, 0, 1, 0, 0));
            }
            // The metrics here don't have anti-aliasing set.
            info.mMetrics = Toolkit.getDefaultToolkit().getFontMetrics(info.mFont);
            infoList.add(info);
        }
        mFonts = Collections.unmodifiableList(infoList);
    }
}
------------------------
Find a functionally equivalent code:android.net.http.CertificateChainValidator.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * @return The singleton instance of the certificates chain validator
 */

Body of Frist Method:
{
    return sInstance;
}
Body of Second Method:
{
    return NoPreloadHolder.sInstance;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.getDelegate:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the delegate from the given native int.
 * <p>
 * If the int is zero, then this will always return null.
 * <p>
 * If the int is non zero and the delegate is not found, this will throw an assert.
 *
 * @param native_object the native int.
 * @return the delegate or null if not found.
 */

Body of Frist Method:
{
    if (native_object > 0) {
        T delegate = mDelegates.get(native_object);
        if (Debug.DEBUG) {
            if (delegate == null) {
                System.out.println("Unknown " + mClass.getSimpleName() + " with int " + native_object);
            }
        }
        assert delegate != null;
        return delegate;
    }
    return null;
}
Body of Second Method:
{
    if (native_object > 0) {
        T delegate = mDelegates.get(native_object);
        if (Debug.DEBUG) {
            if (delegate == null) {
                System.out.println("Unknown " + mClass.getSimpleName() + " with int " + native_object);
            }
        }
        assert delegate != null;
        return delegate;
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.widget.EdgeEffect.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */

Body of Frist Method:
{
    update();
    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
    int glowBottom = (int) Math.min(mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f, mGlowHeight * MAX_GLOW_HEIGHT);
    if (mWidth < mMinWidth) {
        // Center the glow and clip it.
        int glowLeft = (mWidth - mMinWidth) / 2;
        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
    } else {
        // Stretch the glow to fit.
        mGlow.setBounds(0, 0, mWidth, glowBottom);
    }
    mGlow.draw(canvas);
    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
    int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
    if (mWidth < mMinWidth) {
        // Center the edge and clip it.
        int edgeLeft = (mWidth - mMinWidth) / 2;
        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
    } else {
        // Stretch the edge to fit.
        mEdge.setBounds(0, 0, mWidth, edgeBottom);
    }
    mEdge.draw(canvas);
    if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
        mState = STATE_IDLE;
    }
    return mState != STATE_IDLE;
}
Body of Second Method:
{
    update();
    final int count = canvas.save();
    final float centerX = mBounds.centerX();
    final float centerY = mBounds.height() - mRadius;
    canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
    final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
    float translateX = mBounds.width() * displacement / 2;
    canvas.clipRect(mBounds);
    canvas.translate(translateX, 0);
    mPaint.setAlpha((int) (0xff * mGlowAlpha));
    canvas.drawCircle(centerX, centerY, mRadius, mPaint);
    canvas.restoreToCount(count);
    boolean oneLastFrame = false;
    if (mState == STATE_RECEDE && mGlowScaleY == 0) {
        mState = STATE_IDLE;
        oneLastFrame = true;
    }
    return mState != STATE_IDLE || oneLastFrame;
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setShader:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the shader object.
 * <p />
 * Pass null to clear any previous shader.
 * As a convenience, the parameter passed is also returned.
 *
 * @param shader May be null. the new shader to be installed in the paint
 * @return       shader
 */

Body of Frist Method:
{
    int shaderNative = 0;
    if (shader != null)
        shaderNative = shader.native_instance;
    native_setShader(mNativePaint, shaderNative);
    mShader = shader;
    return shader;
}
Body of Second Method:
{
    long shaderNative = 0;
    if (shader != null)
        shaderNative = shader.getNativeInstance();
    native_setShader(mNativePaint, shaderNative);
    mShader = shader;
    return shader;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the week day abbreviation of the calendar header.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

Body of Frist Method:
{
    return mWeekDayTextAppearanceResId;
}
Body of Second Method:
{
    return mDelegate.getWeekDayTextAppearance();
}
------------------------
Find a functionally equivalent code:android.os.Binder.execTransact:COMMENT
Method Modifier: private     
Comment:// Entry point from android_util_Binder.cpp's onTransact

Body of Frist Method:
{
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we'll just call it directly.
    boolean res;
    // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.
    try {
        res = onTransact(code, data, reply, flags);
    } catch (RemoteException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Binder call failed.", e);
        }
        reply.setDataPosition(0);
        reply.writeException(e);
        res = true;
    } catch (RuntimeException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
        }
        reply.setDataPosition(0);
        reply.writeException(e);
        res = true;
    } catch (OutOfMemoryError e) {
        // Unconditionally log this, since this is generally unrecoverable.
        Log.e(TAG, "Caught an OutOfMemoryError from the binder stub implementation.", e);
        RuntimeException re = new RuntimeException("Out of memory", e);
        reply.setDataPosition(0);
        reply.writeException(re);
        res = true;
    }
    reply.recycle();
    data.recycle();
    return res;
}
Body of Second Method:
{
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we'll just call it directly.
    boolean res;
    // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.
    try {
        res = onTransact(code, data, reply, flags);
    } catch (RemoteException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Binder call failed.", e);
        } else {
            reply.setDataPosition(0);
            reply.writeException(e);
        }
        res = true;
    } catch (RuntimeException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
        } else {
            reply.setDataPosition(0);
            reply.writeException(e);
        }
        res = true;
    } catch (OutOfMemoryError e) {
        // Unconditionally log this, since this is generally unrecoverable.
        Log.e(TAG, "Caught an OutOfMemoryError from the binder stub implementation.", e);
        RuntimeException re = new RuntimeException("Out of memory", e);
        reply.setDataPosition(0);
        reply.writeException(re);
        res = true;
    }
    checkParcel(this, code, reply, "Unreasonably large binder reply buffer");
    reply.recycle();
    data.recycle();
    // Just in case -- we are done with the IPC, so there should be no more strict
    // mode violations that have gathered for this thread.  Either they have been
    // parceled and are now in transport off to the caller, or we are returning back
    // to the main transaction loop to wait for another incoming transaction.  Either
    // way, strict mode begone!
    StrictMode.clearGatheredViolations();
    return res;
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.acceptCommandPeer:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Waits for and accepts a single command connection. Throws
 * RuntimeException on failure.
 */

Body of Frist Method:
{
    try {
        return new ZygoteConnection(sServerSocket.accept());
    } catch (IOException ex) {
        throw new RuntimeException("IOException during accept()", ex);
    }
}
Body of Second Method:
{
    try {
        return new ZygoteConnection(sServerSocket.accept(), abiList);
    } catch (IOException ex) {
        throw new RuntimeException("IOException during accept()", ex);
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.getRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the record at a given index.
 *
 * @param index The index.
 * @return The record at the specified index.
 */

Body of Frist Method:
{
    return mRecords.get(index);
}
Body of Second Method:
{
    if (mRecords == null) {
        throw new IndexOutOfBoundsException("Invalid index " + index + ", size is 0");
    }
    return mRecords.get(index);
}
------------------------
Find a functionally equivalent code:android.animation.AnimatorSet.playSequentially:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up this AnimatorSet to play each of the supplied animations when the
 * previous animation ends.
 *
 * @param items The animations that will be started one after another.
 */

Body of Frist Method:
{
    if (items != null && items.size() > 0) {
        mNeedsSort = true;
        if (items.size() == 1) {
            play(items.get(0));
        } else {
            for (int i = 0; i < items.size() - 1; ++i) {
                play(items.get(i)).before(items.get(i + 1));
            }
        }
    }
}
Body of Second Method:
{
    if (items != null) {
        mNeedsSort = true;
        if (items.length == 1) {
            play(items[0]);
        } else {
            mReversible = false;
            for (int i = 0; i < items.length - 1; ++i) {
                play(items[i]).before(items[i + 1]);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.net.NetworkTemplate.matchesWifi:COMMENT
Method Modifier: private     
Comment:/**
 * Check if matches Wi-Fi network template.
 */

Body of Frist Method:
{
    switch(ident.mType) {
        case TYPE_WIFI:
            return Objects.equal(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(ident.mType) {
        case TYPE_WIFI:
            return Objects.equals(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
        default:
            return false;
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getChild:COMMENT
Method Modifier: public      
Comment:/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}
Body of Second Method:
{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}
------------------------
Find a functionally equivalent code:android.content.pm.ResolveInfo.getIconResource:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */

Body of Frist Method:
{
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null)
        return ci.getIconResource();
    return 0;
}
Body of Second Method:
{
    if (noResourceId)
        return 0;
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null) {
        return ci.getIconResource();
    }
    return 0;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamMute(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        mStreamStates[streamType].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                if (streamType == AudioSystem.STREAM_MUSIC && mHdmiTvClient != null) {
                    synchronized (mHdmiTvClient) {
                        if (mHdmiSystemAudioSupported) {
                            mHdmiTvClient.setSystemAudioMute(state);
                        }
                    }
                }
            }
        }
        mStreamStates[streamType].mute(cb, state);
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.ResourceHelper.getDrawable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,
 * or an hexadecimal color
 * @param context the current context
 */

Body of Frist Method:
{
    String stringValue = value.getValue();
    if (RenderResources.REFERENCE_NULL.equals(stringValue)) {
        return null;
    }
    String lowerCaseValue = stringValue.toLowerCase();
    Density density = Density.MEDIUM;
    if (value instanceof DensityBasedResourceValue) {
        density = ((DensityBasedResourceValue) value).getResourceDensity();
    }
    if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
        File file = new File(stringValue);
        if (file.isFile()) {
            try {
                return getNinePatchDrawable(new FileInputStream(file), density, value.isFramework(), stringValue, context);
            } catch (IOException e) {
                // failed to read the file, we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + file.getAbsolutePath(), e, null);
            }
        }
        return null;
    } else if (lowerCaseValue.endsWith(".xml")) {
        // create a block parser for the file
        File f = new File(stringValue);
        if (f.isFile()) {
            try {
                // let the framework inflate the Drawable from the XML file.
                XmlPullParser parser = ParserFactory.create(f);
                BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, context, value.isFramework());
                try {
                    return Drawable.createFromXml(context.getResources(), blockParser);
                } finally {
                    blockParser.ensurePopped();
                }
            } catch (Exception e) {
                // this is an error and not warning since the file existence is checked before
                // attempting to parse it.
                Bridge.getLog().error(null, "Failed to parse file " + stringValue, e, null);
            }
        } else {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, String.format("File %s does not exist (or is not a file)", stringValue), null);
        }
        return null;
    } else {
        File bmpFile = new File(stringValue);
        if (bmpFile.isFile()) {
            try {
                Bitmap bitmap = Bridge.getCachedBitmap(stringValue, value.isFramework() ? null : context.getProjectKey());
                if (bitmap == null) {
                    bitmap = Bitmap_Delegate.createBitmap(bmpFile, false, /*isMutable*/
                    density);
                    Bridge.setCachedBitmap(stringValue, bitmap, value.isFramework() ? null : context.getProjectKey());
                }
                return new BitmapDrawable(context.getResources(), bitmap);
            } catch (IOException e) {
                // we'll return null below
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + bmpFile.getAbsolutePath(), e, null);
            }
        } else {
            // attempt to get a color from the value
            try {
                int color = getColor(stringValue);
                return new ColorDrawable(color);
            } catch (NumberFormatException e) {
                // we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, "Failed to convert " + stringValue + " into a drawable", e, null);
            }
        }
    }
    return null;
}
Body of Second Method:
{
    if (value == null) {
        return null;
    }
    String stringValue = value.getValue();
    if (RenderResources.REFERENCE_NULL.equals(stringValue)) {
        return null;
    }
    String lowerCaseValue = stringValue.toLowerCase();
    Density density = Density.MEDIUM;
    if (value instanceof DensityBasedResourceValue) {
        density = ((DensityBasedResourceValue) value).getResourceDensity();
    }
    if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
        File file = new File(stringValue);
        if (file.isFile()) {
            try {
                return getNinePatchDrawable(new FileInputStream(file), density, value.isFramework(), stringValue, context);
            } catch (IOException e) {
                // failed to read the file, we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + file.getAbsolutePath(), e, null);
            }
        }
        return null;
    } else if (lowerCaseValue.endsWith(".xml")) {
        // create a block parser for the file
        File f = new File(stringValue);
        if (f.isFile()) {
            try {
                // let the framework inflate the Drawable from the XML file.
                XmlPullParser parser = ParserFactory.create(f);
                BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, context, value.isFramework());
                try {
                    return Drawable.createFromXml(context.getResources(), blockParser);
                } finally {
                    blockParser.ensurePopped();
                }
            } catch (Exception e) {
                // this is an error and not warning since the file existence is checked before
                // attempting to parse it.
                Bridge.getLog().error(null, "Failed to parse file " + stringValue, e, null);
            }
        } else {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, String.format("File %s does not exist (or is not a file)", stringValue), null);
        }
        return null;
    } else {
        File bmpFile = new File(stringValue);
        if (bmpFile.isFile()) {
            try {
                Bitmap bitmap = Bridge.getCachedBitmap(stringValue, value.isFramework() ? null : context.getProjectKey());
                if (bitmap == null) {
                    bitmap = Bitmap_Delegate.createBitmap(bmpFile, false, /*isMutable*/
                    density);
                    Bridge.setCachedBitmap(stringValue, bitmap, value.isFramework() ? null : context.getProjectKey());
                }
                return new BitmapDrawable(context.getResources(), bitmap);
            } catch (IOException e) {
                // we'll return null below
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + bmpFile.getAbsolutePath(), e, null);
            }
        } else {
            // attempt to get a color from the value
            try {
                int color = getColor(stringValue);
                return new ColorDrawable(color);
            } catch (NumberFormatException e) {
                // we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, "Failed to convert " + stringValue + " into a drawable", e, null);
            }
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.isConnectedToMobile:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToMobile()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Return true if device is currently connected to mobile network

Body of Frist Method:
{
    return (mNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE);
}
Body of Second Method:
{
    return (mCm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_MOBILE);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.makeA2dpDeviceUnavailableNow:COMMENT
Method Modifier: private     
Comment:// must be called synchronized on mConnectedDevices

Body of Frist Method:
{
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
}
Body of Second Method:
{
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    synchronized (mCurAudioRoutes) {
        // Remove A2DP routes as well
        if (mCurAudioRoutes.mBluetoothName != null) {
            mCurAudioRoutes.mBluetoothName = null;
            sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES, SENDMSG_NOOP, 0, 0, null, 0);
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default maximal date is 01/01/2100.
 * <p>
 *
 * @return The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

Body of Frist Method:
{
    return mMaxDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getMaxDate();
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayClear:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_CLEAR event
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Clear remote control display");
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            mCurrentRcClientGen++;
            // synchronously update the displays and clients with the new client generation
            setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, null, /*newMediaIntent*/
            true);
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Clear remote control display");
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            mCurrentRcClientGen++;
            // synchronously update the displays and clients with the new client generation
            setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, null, /*newMediaIntent*/
            true);
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.RecoverySystem.rebootWipeCache:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboot into the recovery system to wipe the /cache partition.
 * @throws IOException if something goes wrong.
 */

Body of Frist Method:
{
    bootCommand(context, "--wipe_cache\n--locale=" + Locale.getDefault().toString());
}
Body of Second Method:
{
    rebootWipeCache(context, context.getPackageName());
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.restoreHierarchyState:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mContentParent == null) {
        return;
    }
    SparseArray<Parcelable> savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
    // restore the focused view
    int focusedViewId = savedInstanceState.getInt(FOCUSED_ID_TAG, View.NO_ID);
    if (focusedViewId != View.NO_ID) {
        View needsFocus = mContentParent.findViewById(focusedViewId);
        if (needsFocus != null) {
            needsFocus.requestFocus();
        } else {
            Log.w(TAG, "Previously focused view reported id " + focusedViewId + " during save, but can't be found during restore.");
        }
    }
    // restore the panels
    SparseArray<Parcelable> panelStates = savedInstanceState.getSparseParcelableArray(PANELS_TAG);
    if (panelStates != null) {
        restorePanelState(panelStates);
    }
    if (mActionBar != null) {
        SparseArray<Parcelable> actionBarStates = savedInstanceState.getSparseParcelableArray(ACTION_BAR_TAG);
        if (actionBarStates != null) {
            mActionBar.restoreHierarchyState(actionBarStates);
        } else {
            Log.w(TAG, "Missing saved instance states for action bar views! " + "State will not be restored.");
        }
    }
}
Body of Second Method:
{
    if (mContentParent == null) {
        return;
    }
    SparseArray<Parcelable> savedStates = savedInstanceState.getSparseParcelableArray(VIEWS_TAG);
    if (savedStates != null) {
        mContentParent.restoreHierarchyState(savedStates);
    }
    // restore the focused view
    int focusedViewId = savedInstanceState.getInt(FOCUSED_ID_TAG, View.NO_ID);
    if (focusedViewId != View.NO_ID) {
        View needsFocus = mContentParent.findViewById(focusedViewId);
        if (needsFocus != null) {
            needsFocus.requestFocus();
        } else {
            Log.w(TAG, "Previously focused view reported id " + focusedViewId + " during save, but can't be found during restore.");
        }
    }
    // restore the panels
    SparseArray<Parcelable> panelStates = savedInstanceState.getSparseParcelableArray(PANELS_TAG);
    if (panelStates != null) {
        restorePanelState(panelStates);
    }
    if (mDecorContentParent != null) {
        SparseArray<Parcelable> actionBarStates = savedInstanceState.getSparseParcelableArray(ACTION_BAR_TAG);
        if (actionBarStates != null) {
            doPendingInvalidatePanelMenu();
            mDecorContentParent.restoreToolbarHierarchyState(actionBarStates);
        } else {
            Log.w(TAG, "Missing saved instance states for action bar views! " + "State will not be restored.");
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.setSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the spinners are shown.
 *
 * @param shown True if the spinners are to be shown.
 */

Body of Frist Method:
{
    mSpinners.setVisibility(shown ? VISIBLE : GONE);
}
Body of Second Method:
{
    mDelegate.setSpinnersShown(shown);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.initializePanelDecor:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Perform initial setup of a panel. This should at the very least set the
 * style information in the PanelFeatureState and must set
 * PanelFeatureState.decor to the panel's window decor view.
 *
 * @param st The panel being initialized.
 */

Body of Frist Method:
{
    st.decorView = new DecorView(getContext(), st.featureId);
    st.gravity = Gravity.CENTER | Gravity.BOTTOM;
    st.setStyle(getContext());
    return true;
}
Body of Second Method:
{
    st.decorView = new DecorView(getContext(), st.featureId);
    st.gravity = Gravity.CENTER | Gravity.BOTTOM;
    st.setStyle(getContext());
    TypedArray a = getContext().obtainStyledAttributes(null, R.styleable.Window, 0, st.listPresenterTheme);
    final float elevation = a.getDimension(R.styleable.Window_windowElevation, 0);
    if (elevation != 0) {
        st.decorView.setElevation(elevation);
    }
    a.recycle();
    return true;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserSwitching:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitching(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user change begins.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:com.android.internal.os.RuntimeInit.wtf:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Report a serious error in the current process.  May or may not cause
 * the process to terminate (depends on system settings).
 *
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */

Body of Frist Method:
{
    try {
        if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject, tag, new ApplicationErrorReport.CrashInfo(t))) {
            // The Activity Manager has already written us off -- now exit.
            Process.killProcess(Process.myPid());
            System.exit(10);
        }
    } catch (Throwable t2) {
        Slog.e(TAG, "Error reporting WTF", t2);
        Slog.e(TAG, "Original WTF:", t);
    }
}
Body of Second Method:
{
    try {
        if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject, tag, system, new ApplicationErrorReport.CrashInfo(t))) {
            // The Activity Manager has already written us off -- now exit.
            Process.killProcess(Process.myPid());
            System.exit(10);
        }
    } catch (Throwable t2) {
        Slog.e(TAG, "Error reporting WTF", t2);
        Slog.e(TAG, "Original WTF:", t);
    }
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current list of selected values for an entry of type {@link #TYPE_MULTI_SELECT}.
 * These values will be persisted by the system for later use by the application.
 * @param allSelectedStrings the current list of selected values.
 */

Body of Frist Method:
{
    currentValues = allSelectedStrings;
}
Body of Second Method:
{
    mCurrentValues = allSelectedStrings;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromResourceStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream, using the given resources and
 * value to determine density information.
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(res, value, is, srcName, null);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(res, value, is, srcName, null);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
------------------------
Find a functionally equivalent code:android.app.WallpaperManager.getCropAndSetWallpaperIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to "image/*"
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not "image/*"
 */

Body of Frist Method:
{
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage("com.android.wallpapercropper");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
Body of Second Method:
{
    if (imageUri == null) {
        throw new IllegalArgumentException("Image URI must not be null");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage("com.android.wallpapercropper");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.postRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified rotation.
 * M' = R(degrees) * M
 */

Body of Frist Method:
{
    return native_postRotate(native_instance, degrees);
}
Body of Second Method:
{
    native_postRotate(native_instance, degrees);
    return true;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.resetTouchState:COMMENT
Method Modifier: private     
Comment:/**
 * Resets all touch state in preparation for a new cycle.
 */

Body of Frist Method:
{
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
}
Body of Second Method:
{
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    mNestedScrollAxes = SCROLL_AXIS_NONE;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.getClipBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Return the bounds of the current clip (in local coordinates) in the
 * bounds parameter, and return true if it is non-empty. This can be useful
 * in a way similar to quickReject, in that it tells you that drawing
 * outside of these bounds will be clipped out.
 *
 * @param bounds Return the clip bounds here. If it is null, ignore it but
 * still return true if the current clip is non-empty.
 * @return true if the current clip is non-empty.
 */

Body of Frist Method:
{
    return native_getClipBounds(mNativeCanvas, bounds);
}
Body of Second Method:
{
    return native_getClipBounds(mNativeCanvasWrapper, bounds);
}
------------------------
Find a functionally equivalent code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     
Comment:/**
 * Check if mobile network with matching IMSI.
 */

Body of Frist Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equal(mSubscriberId, ident.mSubscriberId));
    }
}
Body of Second Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equals(mSubscriberId, ident.mSubscriberId));
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (CharSequence[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "CharSequence[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharSequenceArray(key);
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TLS:
        case Eap.TTLS:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.removeAllViewsInLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may "have" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
------------------------
Find a functionally equivalent code:android.net.nsd.NsdServiceInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeString(mServiceName);
    dest.writeString(mServiceType);
    dest.writeParcelable(mTxtRecord, flags);
    if (mHost != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mHost.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    dest.writeInt(mPort);
}
Body of Second Method:
{
    dest.writeString(mServiceName);
    dest.writeString(mServiceType);
    if (mHost != null) {
        dest.writeInt(1);
        dest.writeByteArray(mHost.getAddress());
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mPort);
    // TXT record key/value pairs.
    dest.writeInt(mTxtRecord.size());
    for (String key : mTxtRecord.keySet()) {
        byte[] value = mTxtRecord.get(key);
        if (value != null) {
            dest.writeInt(1);
            dest.writeInt(value.length);
            dest.writeByteArray(value);
        } else {
            dest.writeInt(0);
        }
        dest.writeString(key);
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetProvider.onReceive:COMMENT
Method Modifier: public      
Comment:// BEGIN_INCLUDE(onReceive)

Body of Frist Method:
{
    // Protect against rogue update broadcasts (not really a security issue,
    // just filter bad broacasts out so subclasses are less likely to crash).
    String action = intent.getAction();
    if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (appWidgetIds != null && appWidgetIds.length > 0) {
                this.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);
            }
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) {
            final int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            this.onDeleted(context, new int[] { appWidgetId });
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID) && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) {
            int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);
            this.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context), appWidgetId, widgetExtras);
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
        this.onEnabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        this.onDisabled(context);
    }
}
Body of Second Method:
{
    // Protect against rogue update broadcasts (not really a security issue,
    // just filter bad broacasts out so subclasses are less likely to crash).
    String action = intent.getAction();
    if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (appWidgetIds != null && appWidgetIds.length > 0) {
                this.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);
            }
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) {
            final int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            this.onDeleted(context, new int[] { appWidgetId });
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID) && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) {
            int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);
            this.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context), appWidgetId, widgetExtras);
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
        this.onEnabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        this.onDisabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_RESTORED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] oldIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS);
            int[] newIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (oldIds != null && oldIds.length > 0) {
                this.onRestored(context, oldIds, newIds);
                this.onUpdate(context, AppWidgetManager.getInstance(context), newIds);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    try {
        return getDimension(index);
    } catch (RuntimeException e) {
        if (mResourceData[index] != null) {
            String s = mResourceData[index].getValue();
            if (s != null) {
                // looks like we were unable to resolve the dimension value
                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
            }
        }
        return defValue;
    }
}
Body of Second Method:
{
    try {
        return getDimension(index);
    } catch (RuntimeException e) {
        String s = getString(index);
        if (s != null) {
            // looks like we were unable to resolve the dimension value
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
        }
        return defValue;
    }
}
------------------------
Find a functionally equivalent code:android.view.LayoutInflater.setFactory2:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #setFactory}, but allows you to set a {@link Factory2}
 * interface.
 */

Body of Frist Method:
{
    if (mFactorySet) {
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");
    }
    if (factory == null) {
        throw new NullPointerException("Given factory can not be null");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
Body of Second Method:
{
    if (mFactorySet) {
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");
    }
    if (factory == null) {
        throw new NullPointerException("Given factory can not be null");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.isPlaystateActive:COMMENT
<android.media.MediaFocusControl: boolean isPlaystateActive(int)>
Method Modifier: protected   private     static      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Returns true if the given playback state is considered "active", i.e. it describes a state
 * where playback is happening, or about to
 * @param playState the playback state to evaluate
 * @return true if active, false otherwise (inactive or unknown)
 */

Body of Frist Method:
{
    switch(playState) {
        case RemoteControlClient.PLAYSTATE_PLAYING:
        case RemoteControlClient.PLAYSTATE_BUFFERING:
        case RemoteControlClient.PLAYSTATE_FAST_FORWARDING:
        case RemoteControlClient.PLAYSTATE_REWINDING:
        case RemoteControlClient.PLAYSTATE_SKIPPING_BACKWARDS:
        case RemoteControlClient.PLAYSTATE_SKIPPING_FORWARDS:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(playState) {
        case RemoteControlClient.PLAYSTATE_PLAYING:
        case RemoteControlClient.PLAYSTATE_BUFFERING:
        case RemoteControlClient.PLAYSTATE_FAST_FORWARDING:
        case RemoteControlClient.PLAYSTATE_REWINDING:
        case RemoteControlClient.PLAYSTATE_SKIPPING_BACKWARDS:
        case RemoteControlClient.PLAYSTATE_SKIPPING_FORWARDS:
            return true;
        default:
            return false;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawArc:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Draw the specified arc, which will be scaled to fit inside the
 * specified oval.</p>
 *
 * <p>If the start angle is negative or >= 360, the start angle is treated
 * as start angle modulo 360.</p>
 *
 * <p>If the sweep angle is >= 360, then the oval is drawn
 * completely. Note that this differs slightly from SkPath::arcTo, which
 * treats the sweep angle modulo 360. If the sweep angle is negative,
 * the sweep angle is treated as sweep angle modulo 360</p>
 *
 * <p>The arc is drawn clockwise. An angle of 0 degrees correspond to the
 * geometric angle of 0 degrees (3 o'clock on a watch.)</p>
 *
 * @param oval       The bounds of oval used to define the shape and size
 * of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 * @param useCenter If true, include the center of the oval in the arc, and
 * close it if it is being stroked. This will draw a wedge
 * @param paint      The paint used to draw the arc
 */

Body of Frist Method:
{
    if (oval == null) {
        throw new NullPointerException();
    }
    native_drawArc(mNativeCanvas, oval, startAngle, sweepAngle, useCenter, paint.mNativePaint);
}
Body of Second Method:
{
    drawArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter, paint);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCDList:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the list of remote control displays
 */

Body of Frist Method:
{
    pw.println("\nRemote Control Display list entries:");
    synchronized (mRCStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            pw.println("  IRCD: " + di.mRcDisplay + "  -- w:" + di.mArtworkExpectedWidth + "  -- h:" + di.mArtworkExpectedHeight + "  -- wantsPosSync:" + di.mWantsPositionSync + "  -- " + (di.mEnabled ? "enabled" : "disabled"));
        }
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control Display list entries:");
    synchronized (mPRStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = displayIterator.next();
            pw.println("  IRCD: " + di.mRcDisplay + "  -- w:" + di.mArtworkExpectedWidth + "  -- h:" + di.mArtworkExpectedHeight + "  -- wantsPosSync:" + di.mWantsPositionSync + "  -- " + (di.mEnabled ? "enabled" : "disabled"));
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a float array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putFloatArray(key, value);
}
------------------------
Find a functionally equivalent code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

Body of Frist Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // channel config
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_IN_DEFAULT:
        case AudioFormat.CHANNEL_IN_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannelMask = AudioFormat.CHANNEL_IN_MONO;
            break;
        case AudioFormat.CHANNEL_IN_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannelMask = AudioFormat.CHANNEL_IN_STEREO;
            break;
        case (AudioFormat.CHANNEL_IN_FRONT | AudioFormat.CHANNEL_IN_BACK):
            mChannelCount = 2;
            mChannelMask = channelConfig;
            break;
        default:
            throw new IllegalArgumentException("Unsupported channel configuration.");
    }
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
Body of Second Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */

Body of Frist Method:
{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, "Finishing self: token=" + mToken);
        try {
            if (resultData != null) {
                resultData.prepareToLeaveProcess();
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}
Body of Second Method:
{
    finish(false);
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.getPreloadedDrawables:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return sPreloadedDrawables[0];
}
Body of Second Method:
{
    return sPreloadedDrawables[0];
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.animate:COMMENT
Method Modifier: public      
Comment:/**
 * Animate an object
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#animate(Object, String, boolean, IAnimationListener)
 */

Body of Frist Method:
{
    checkLock();
    BridgeContext context = getContext();
    // find the animation file.
    ResourceValue animationResource = null;
    int animationId = 0;
    if (isFrameworkAnimation) {
        animationResource = context.getRenderResources().getFrameworkResource(ResourceType.ANIMATOR, animationName);
        if (animationResource != null) {
            animationId = Bridge.getResourceId(ResourceType.ANIMATOR, animationName);
        }
    } else {
        animationResource = context.getRenderResources().getProjectResource(ResourceType.ANIMATOR, animationName);
        if (animationResource != null) {
            animationId = context.getProjectCallback().getResourceId(ResourceType.ANIMATOR, animationName);
        }
    }
    if (animationResource != null) {
        try {
            Animator anim = AnimatorInflater.loadAnimator(context, animationId);
            if (anim != null) {
                anim.setTarget(targetObject);
                new PlayAnimationThread(anim, this, animationName, listener).start();
                return SUCCESS.createResult();
            }
        } catch (Exception e) {
            // get the real cause of the exception.
            Throwable t = e;
            while (t.getCause() != null) {
                t = t.getCause();
            }
            return ERROR_UNKNOWN.createResult(t.getMessage(), t);
        }
    }
    return ERROR_ANIM_NOT_FOUND.createResult();
}
Body of Second Method:
{
    checkLock();
    BridgeContext context = getContext();
    // find the animation file.
    ResourceValue animationResource;
    int animationId = 0;
    if (isFrameworkAnimation) {
        animationResource = context.getRenderResources().getFrameworkResource(ResourceType.ANIMATOR, animationName);
        if (animationResource != null) {
            animationId = Bridge.getResourceId(ResourceType.ANIMATOR, animationName);
        }
    } else {
        animationResource = context.getRenderResources().getProjectResource(ResourceType.ANIMATOR, animationName);
        if (animationResource != null) {
            animationId = context.getProjectCallback().getResourceId(ResourceType.ANIMATOR, animationName);
        }
    }
    if (animationResource != null) {
        try {
            Animator anim = AnimatorInflater.loadAnimator(context, animationId);
            if (anim != null) {
                anim.setTarget(targetObject);
                new PlayAnimationThread(anim, this, animationName, listener).start();
                return SUCCESS.createResult();
            }
        } catch (Exception e) {
            // get the real cause of the exception.
            Throwable t = e;
            while (t.getCause() != null) {
                t = t.getCause();
            }
            return ERROR_UNKNOWN.createResult(t.getMessage(), t);
        }
    }
    return ERROR_ANIM_NOT_FOUND.createResult();
}
------------------------
Find a functionally equivalent code:android.content.res.ColorStateList.inflate:COMMENT
Method Modifier: private     
Comment:/**
 * Fill in this object based on the contents of an XML "selector" element.
 */

Body of Frist Method:
{
    int type;
    final int innerDepth = parser.getDepth() + 1;
    int depth;
    int listAllocated = 20;
    int listSize = 0;
    int[] colorList = new int[listAllocated];
    int[][] stateSpecList = new int[listAllocated][];
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        int colorRes = 0;
        int color = 0xffff0000;
        boolean haveColor = false;
        int i;
        int j = 0;
        final int numAttrs = attrs.getAttributeCount();
        int[] stateSpec = new int[numAttrs];
        for (i = 0; i < numAttrs; i++) {
            final int stateResId = attrs.getAttributeNameResource(i);
            if (stateResId == 0)
                break;
            if (stateResId == com.android.internal.R.attr.color) {
                colorRes = attrs.getAttributeResourceValue(i, 0);
                if (colorRes == 0) {
                    color = attrs.getAttributeIntValue(i, color);
                    haveColor = true;
                }
            } else {
                stateSpec[j++] = attrs.getAttributeBooleanValue(i, false) ? stateResId : -stateResId;
            }
        }
        stateSpec = StateSet.trimStateSet(stateSpec, j);
        if (colorRes != 0) {
            color = r.getColor(colorRes);
        } else if (!haveColor) {
            throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'android:color' attribute.");
        }
        if (listSize == 0 || stateSpec.length == 0) {
            mDefaultColor = color;
        }
        if (listSize + 1 >= listAllocated) {
            listAllocated = ArrayUtils.idealIntArraySize(listSize + 1);
            int[] ncolor = new int[listAllocated];
            System.arraycopy(colorList, 0, ncolor, 0, listSize);
            int[][] nstate = new int[listAllocated][];
            System.arraycopy(stateSpecList, 0, nstate, 0, listSize);
            colorList = ncolor;
            stateSpecList = nstate;
        }
        colorList[listSize] = color;
        stateSpecList[listSize] = stateSpec;
        listSize++;
    }
    mColors = new int[listSize];
    mStateSpecs = new int[listSize][];
    System.arraycopy(colorList, 0, mColors, 0, listSize);
    System.arraycopy(stateSpecList, 0, mStateSpecs, 0, listSize);
}
Body of Second Method:
{
    int type;
    final int innerDepth = parser.getDepth() + 1;
    int depth;
    int[][] stateSpecList = ArrayUtils.newUnpaddedArray(int[].class, 20);
    int[] colorList = new int[stateSpecList.length];
    int listSize = 0;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        int alphaRes = 0;
        float alpha = 1.0f;
        int colorRes = 0;
        int color = 0xffff0000;
        boolean haveColor = false;
        int i;
        int j = 0;
        final int numAttrs = attrs.getAttributeCount();
        int[] stateSpec = new int[numAttrs];
        for (i = 0; i < numAttrs; i++) {
            final int stateResId = attrs.getAttributeNameResource(i);
            if (stateResId == 0)
                break;
            if (stateResId == com.android.internal.R.attr.alpha) {
                alphaRes = attrs.getAttributeResourceValue(i, 0);
                if (alphaRes == 0) {
                    alpha = attrs.getAttributeFloatValue(i, 1.0f);
                }
            } else if (stateResId == com.android.internal.R.attr.color) {
                colorRes = attrs.getAttributeResourceValue(i, 0);
                if (colorRes == 0) {
                    color = attrs.getAttributeIntValue(i, color);
                    haveColor = true;
                }
            } else {
                stateSpec[j++] = attrs.getAttributeBooleanValue(i, false) ? stateResId : -stateResId;
            }
        }
        stateSpec = StateSet.trimStateSet(stateSpec, j);
        if (colorRes != 0) {
            color = r.getColor(colorRes);
        } else if (!haveColor) {
            throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'android:color' attribute.");
        }
        if (alphaRes != 0) {
            alpha = r.getFloat(alphaRes);
        }
        // Apply alpha modulation.
        final int alphaMod = MathUtils.constrain((int) (Color.alpha(color) * alpha), 0, 255);
        color = (color & 0xFFFFFF) | (alphaMod << 24);
        if (listSize == 0 || stateSpec.length == 0) {
            mDefaultColor = color;
        }
        colorList = GrowingArrayUtils.append(colorList, listSize, color);
        stateSpecList = GrowingArrayUtils.append(stateSpecList, listSize, stateSpec);
        listSize++;
    }
    mColors = new int[listSize];
    mStateSpecs = new int[listSize][];
    System.arraycopy(colorList, 0, mColors, 0, listSize);
    System.arraycopy(stateSpecList, 0, mStateSpecs, 0, listSize);
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.dispatchTrackballEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on trackballEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on trackballEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}
------------------------
Find a functionally equivalent code:android.app.Notification.Builder.buildUnstyled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Apply the unstyled operations and return a new {@link Notification} object.
 * @hide
 */

Body of Frist Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.contentView = makeContentView();
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    n.bigContentView = makeBigContentView();
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if (mKindList.size() > 0) {
        n.kind = new String[mKindList.size()];
        mKindList.toArray(n.kind);
    } else {
        n.kind = null;
    }
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    return n;
}
Body of Second Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.color = sanitizeColor();
    setBuilderContentView(n, makeContentView());
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.audioAttributes = mAudioAttributes;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    setBuilderBigContentView(n, makeBigContentView());
    setBuilderHeadsUpContentView(n, makeHeadsUpContentView());
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    n.category = mCategory;
    n.mGroupKey = mGroupKey;
    n.mSortKey = mSortKey;
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    n.visibility = mVisibility;
    if (mPublicVersion != null) {
        n.publicVersion = new Notification();
        mPublicVersion.cloneInto(n.publicVersion, true);
    }
    // Note: If you're adding new fields, also update restoreFromNotitification().
    return n;
}
------------------------
Find a functionally equivalent code:android.view.HardwareLayer.setTransform:COMMENT
<android.view.HardwareLayer: void setTransform(Matrix)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Sets an optional transform on this layer.
 *
 * @param matrix The transform to apply to the layer.
 */

Body of Frist Method:

Body of Second Method:
{
    nSetTransform(mFinalizer.get(), matrix.native_instance);
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.getPixels:COMMENT
Method Modifier: public      
Comment:/**
 * Returns in pixels[] a copy of the data in the bitmap. Each value is
 * a packed int representing a {@link Color}. The stride parameter allows
 * the caller to allow for gaps in the returned pixels array between
 * rows. For normal packed results, just pass width for the stride value.
 * The returned colors are non-premultiplied ARGB values.
 *
 * @param pixels   The array to receive the bitmap's colors
 * @param offset   The first index to write into pixels[]
 * @param stride   The number of entries in pixels[] to skip between
 * rows (must be >= bitmap's width). Can be negative.
 * @param x        The x coordinate of the first pixel to read from
 * the bitmap
 * @param y        The y coordinate of the first pixel to read from
 * the bitmap
 * @param width    The number of pixels to read from each row
 * @param height   The number of rows to read
 *
 * @throws IllegalArgumentException if x, y, width, height exceed the
 * bounds of the bitmap, or if abs(stride) < width.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockPatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether the lock pattern is enabled, or if it is set as a backup for biometric weak
 */

Body of Frist Method:
{
    final boolean backupEnabled = getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
    return getBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, false) && (getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING || (usingBiometricWeak() && backupEnabled));
}
Body of Second Method:
{
    final boolean backupEnabled = getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
    return getBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, false) && (getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING || (usingBiometricWeak() && backupEnabled));
}
------------------------
Find a functionally equivalent code:android.media.MediaCodecInfo.isEncoder:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query if the codec is an encoder.
 */

Body of Frist Method:
{
    return MediaCodecList.isEncoder(mIndex);
}
Body of Second Method:
{
    return mIsEncoder;
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.query:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */

Body of Frist Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current selected state for an entry of type {@link #TYPE_BOOLEAN}. This value will
 * be persisted by the system for later use by the application.
 * @param state the current selected state
 */

Body of Frist Method:
{
    currentValue = Boolean.toString(state);
}
Body of Second Method:
{
    mCurrentValue = Boolean.toString(state);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.getAccessibilityServiceList:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */

Body of Frist Method:
{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<ServiceInfo>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}
Body of Second Method:
{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}
------------------------
Find a functionally equivalent code:android.graphics.Picture.nativeConstructor:COMMENT
Method Modifier: private     static      native      
Comment:// return empty picture if src is 0, or a copy of the native src

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.QuickContactBadge.assignContactFromEmail:COMMENT
Method Modifier: public      
Comment:/**
 * Assign a contact based on an email address. This should only be used when
 * the contact's URI is not available, as an extra query will have to be
 * performed to lookup the URI based on the email.
 *
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performed
 * until this view is clicked.
 */

Body of Frist Method:
{
    assignContactFromEmail(emailAddress, lazyLookup, null);
}
Body of Second Method:
{
    assignContactFromEmail(emailAddress, lazyLookup, null);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.beginLayoutLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & View.NAVIGATION_BAR_TRANSLUCENT) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        navTranslucent &= areTranslucentBarsAllowed();
        // bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mHideNavFakeWindow != null) {
                mHideNavFakeWindow.dismiss();
                mHideNavFakeWindow = null;
            }
        } else if (mHideNavFakeWindow == null) {
            mHideNavFakeWindow = mWindowManagerFuncs.addFakeWindow(mHandler.getLooper(), mHideNavInputEventReceiverFactory, "hidden nav", WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER, 0, 0, false, false, true);
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = false;
        if (mNavigationBar != null) {
            boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
            // Force the navigation bar to its appropriate place and
            // size.  We need to do this directly, instead of relying on
            // it to bubble up from the nav bar, because this needs to
            // change atomically with screen rotations.
            mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
            if (mNavigationBarOnBottom) {
                // It's a system nav bar or a portrait screen; nav bar goes on bottom.
                int top = displayHeight - overscanBottom - mNavigationBarHeightForRotation[displayRotation];
                mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
                mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockBottom = mTmpNavigationFrame.top;
                    mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                    mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the opaque nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemBottom = mTmpNavigationFrame.top;
                }
            } else {
                // Landscape screen; nav bar goes to the right.
                int left = displayWidth - overscanRight - mNavigationBarWidthForRotation[displayRotation];
                mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
                mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockRight = mTmpNavigationFrame.left;
                    mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                    mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemRight = mTmpNavigationFrame.left;
                }
            }
            // Make sure the content and current rectangles are updated to
            // account for the restrictions from the navigation bar.
            mContentTop = mCurTop = mDockTop;
            mContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mCurLeft = mDockLeft;
            mContentRight = mCurRight = mDockRight;
            mStatusBarLayer = mNavigationBar.getSurfaceLayer();
            // And compute the final frame.
            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
            if (mNavigationBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            // apply any navigation bar insets
            pf.left = df.left = of.left = mUnrestrictedScreenLeft;
            pf.top = df.top = of.top = mUnrestrictedScreenTop;
            pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
            pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
            vf.left = mStableLeft;
            vf.top = mStableTop;
            vf.right = mStableRight;
            vf.bottom = mStableBottom;
            mStatusBarLayer = mStatusBar.getSurfaceLayer();
            // Let the status bar determine its size.
            mStatusBar.computeFrameLw(pf, df, vf, vf, vf, dcf);
            // For layout, the status bar is always at the top with our fixed height.
            mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
            boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
            boolean statusBarTranslucent = (sysui & View.STATUS_BAR_TRANSLUCENT) != 0;
            statusBarTranslucent &= areTranslucentBarsAllowed();
            // windows behind it to scroll.
            if (mStatusBar.isVisibleLw() && !statusBarTransient) {
                // Status bar may go away, so the screen area it occupies
                // is available to apps but just covering them when the
                // status bar is visible.
                mDockTop = mUnrestrictedScreenTop + mStatusBarHeight;
                mContentTop = mCurTop = mDockTop;
                mContentBottom = mCurBottom = mDockBottom;
                mContentLeft = mCurLeft = mDockLeft;
                mContentRight = mCurRight = mDockRight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
            }
            if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
                // If the opaque status bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemTop = mUnrestrictedScreenTop + mStatusBarHeight;
            }
            if (mStatusBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
Body of Second Method:
{
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        // bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mHideNavFakeWindow != null) {
                mHideNavFakeWindow.dismiss();
                mHideNavFakeWindow = null;
            }
        } else if (mHideNavFakeWindow == null) {
            mHideNavFakeWindow = mWindowManagerFuncs.addFakeWindow(mHandler.getLooper(), mHideNavInputEventReceiverFactory, "hidden nav", WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER, 0, 0, false, false, true);
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = false;
        if (mNavigationBar != null) {
            boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
            // Force the navigation bar to its appropriate place and
            // size.  We need to do this directly, instead of relying on
            // it to bubble up from the nav bar, because this needs to
            // change atomically with screen rotations.
            mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
            if (mNavigationBarOnBottom) {
                // It's a system nav bar or a portrait screen; nav bar goes on bottom.
                int top = displayHeight - overscanBottom - mNavigationBarHeightForRotation[displayRotation];
                mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
                mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockBottom = mTmpNavigationFrame.top;
                    mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                    mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the opaque nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemBottom = mTmpNavigationFrame.top;
                }
            } else {
                // Landscape screen; nav bar goes to the right.
                int left = displayWidth - overscanRight - mNavigationBarWidthForRotation[displayRotation];
                mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
                mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockRight = mTmpNavigationFrame.left;
                    mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                    mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemRight = mTmpNavigationFrame.left;
                }
            }
            // Make sure the content and current rectangles are updated to
            // account for the restrictions from the navigation bar.
            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
            mStatusBarLayer = mNavigationBar.getSurfaceLayer();
            // And compute the final frame.
            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
            if (mNavigationBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            // apply any navigation bar insets
            pf.left = df.left = of.left = mUnrestrictedScreenLeft;
            pf.top = df.top = of.top = mUnrestrictedScreenTop;
            pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
            pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
            vf.left = mStableLeft;
            vf.top = mStableTop;
            vf.right = mStableRight;
            vf.bottom = mStableBottom;
            mStatusBarLayer = mStatusBar.getSurfaceLayer();
            // Let the status bar determine its size.
            mStatusBar.computeFrameLw(pf, df, vf, vf, vf, dcf, vf);
            // For layout, the status bar is always at the top with our fixed height.
            mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
            boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
            boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
            if (!isKeyguardShowing) {
                statusBarTranslucent &= areTranslucentBarsAllowed();
            }
            // windows behind it to scroll.
            if (mStatusBar.isVisibleLw() && !statusBarTransient) {
                // Status bar may go away, so the screen area it occupies
                // is available to apps but just covering them when the
                // status bar is visible.
                mDockTop = mUnrestrictedScreenTop + mStatusBarHeight;
                mContentTop = mVoiceContentTop = mCurTop = mDockTop;
                mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
                mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
                mContentRight = mVoiceContentRight = mCurRight = mDockRight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
            }
            if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
                // If the opaque status bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemTop = mUnrestrictedScreenTop + mStatusBarHeight;
            }
            if (mStatusBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeAssetManager.initSystem:COMMENT
Method Modifier: public      static      
Comment:/**
 * This initializes the static field {@link AssetManager#mSystem} which is used
 * by methods who get a global asset manager using {@link AssetManager#getSystem()}.
 * <p/>
 * They will end up using our bridge asset manager.
 * <p/>
 * {@link Bridge} calls this method after setting up a new bridge.
 */

Body of Frist Method:
{
    if (!(AssetManager.sSystem instanceof BridgeAssetManager)) {
        // Note that AssetManager() creates a system AssetManager and we override it
        // with our BridgeAssetManager.
        AssetManager.sSystem = new BridgeAssetManager();
        AssetManager.sSystem.makeStringBlocks(false);
    }
    return AssetManager.sSystem;
}
Body of Second Method:
{
    if (!(AssetManager.sSystem instanceof BridgeAssetManager)) {
        // Note that AssetManager() creates a system AssetManager and we override it
        // with our BridgeAssetManager.
        AssetManager.sSystem = new BridgeAssetManager();
        AssetManager.sSystem.makeStringBlocks(null);
    }
    return AssetManager.sSystem;
}
------------------------
Find a functionally equivalent code:android.widget.AbsSeekBar.setThumb:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the thumb that will be drawn at the end of the progress meter within the SeekBar.
 * <p>
 * If the thumb is a valid drawable (i.e. not null), half its width will be
 * used as the new thumb offset (@see #setThumbOffset(int)).
 *
 * @param thumb Drawable representing the thumb
 */

Body of Frist Method:
{
    boolean needUpdate;
    // drawable changed)
    if (mThumb != null && thumb != mThumb) {
        mThumb.setCallback(null);
        needUpdate = true;
    } else {
        needUpdate = false;
    }
    if (thumb != null) {
        thumb.setCallback(this);
        if (canResolveLayoutDirection()) {
            thumb.setLayoutDirection(getLayoutDirection());
        }
        // Assuming the thumb drawable is symmetric, set the thumb offset
        // such that the thumb will hang halfway off either edge of the
        // progress bar.
        mThumbOffset = thumb.getIntrinsicWidth() / 2;
        // If we're updating get the new states
        if (needUpdate && (thumb.getIntrinsicWidth() != mThumb.getIntrinsicWidth() || thumb.getIntrinsicHeight() != mThumb.getIntrinsicHeight())) {
            requestLayout();
        }
    }
    mThumb = thumb;
    invalidate();
    if (needUpdate) {
        updateThumbPos(getWidth(), getHeight());
        if (thumb != null && thumb.isStateful()) {
            // Note that if the states are different this won't work.
            // For now, let's consider that an app bug.
            int[] state = getDrawableState();
            thumb.setState(state);
        }
    }
}
Body of Second Method:
{
    final boolean needUpdate;
    // drawable changed)
    if (mThumb != null && thumb != mThumb) {
        mThumb.setCallback(null);
        needUpdate = true;
    } else {
        needUpdate = false;
    }
    if (thumb != null) {
        thumb.setCallback(this);
        if (canResolveLayoutDirection()) {
            thumb.setLayoutDirection(getLayoutDirection());
        }
        // Assuming the thumb drawable is symmetric, set the thumb offset
        // such that the thumb will hang halfway off either edge of the
        // progress bar.
        mThumbOffset = thumb.getIntrinsicWidth() / 2;
        // If we're updating get the new states
        if (needUpdate && (thumb.getIntrinsicWidth() != mThumb.getIntrinsicWidth() || thumb.getIntrinsicHeight() != mThumb.getIntrinsicHeight())) {
            requestLayout();
        }
    }
    mThumb = thumb;
    applyThumbTint();
    invalidate();
    if (needUpdate) {
        updateThumbAndTrackPos(getWidth(), getHeight());
        if (thumb != null && thumb.isStateful()) {
            // Note that if the states are different this won't work.
            // For now, let's consider that an app bug.
            int[] state = getDrawableState();
            thumb.setState(state);
        }
    }
}
------------------------
Find a functionally equivalent code:android.transition.TransitionManager.changeScene:COMMENT
Method Modifier: private     static      
Comment:/**
 * This is where all of the work of a transition/scene-change is
 * orchestrated. This method captures the start values for the given
 * transition, exits the current Scene, enters the new scene, captures
 * the end values for the transition, and finally plays the
 * resulting values-populated transition.
 *
 * @param scene The scene being entered
 * @param transition The transition to play for this scene change
 */

Body of Frist Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    Transition transitionClone = transition.clone();
    transitionClone.setSceneRoot(sceneRoot);
    Scene oldScene = Scene.getCurrentScene(sceneRoot);
    if (oldScene != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
    }
    sceneChangeSetup(sceneRoot, transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot, transitionClone);
}
Body of Second Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    Transition transitionClone = null;
    if (transition != null) {
        transitionClone = transition.clone();
        transitionClone.setSceneRoot(sceneRoot);
    }
    Scene oldScene = Scene.getCurrentScene(sceneRoot);
    if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
    }
    sceneChangeSetup(sceneRoot, transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot, transitionClone);
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilVoiceRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
------------------------
Find a functionally equivalent code:android.graphics.Path.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clear any lines and curves from the path, making it empty.
 * This does NOT change the fill-type setting.
 */

Body of Frist Method:
{
    isSimplePath = true;
    if (mDetectSimplePaths) {
        mLastDirection = null;
        if (rects != null)
            rects.setEmpty();
    }
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    native_reset(mNativePath);
    setFillType(fillType);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    native_reset(mNativePath);
    setFillType(fillType);
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_VocabularyLoad:COMMENT
Method Modifier: private     static      native      
Comment:// private static native int SR_VocabularyCreate();

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.removeChild:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a child from its current parent.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#removeChild(Object, IAnimationListener)
 */

Body of Frist Method:
{
    checkLock();
    invalidateRenderingSize();
    final ViewGroup parent = (ViewGroup) childView.getParent();
    if (listener != null) {
        new AnimationThread(this, "moveChild", listener) {

            @Override
            public Result preAnimation() {
                parent.setLayoutTransition(new LayoutTransition());
                return removeView(parent, childView);
            }

            @Override
            public void postAnimation() {
                parent.setLayoutTransition(null);
            }
        }.start();
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult();
    }
    Result result = removeView(parent, childView);
    if (result.isSuccess() == false) {
        return result;
    }
    return render(false);
}
Body of Second Method:
{
    checkLock();
    invalidateRenderingSize();
    final ViewGroup parent = (ViewGroup) childView.getParent();
    if (listener != null) {
        new AnimationThread(this, "moveChild", listener) {

            @Override
            public Result preAnimation() {
                parent.setLayoutTransition(new LayoutTransition());
                return removeView(parent, childView);
            }

            @Override
            public void postAnimation() {
                parent.setLayoutTransition(null);
            }
        }.start();
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult();
    }
    Result result = removeView(parent, childView);
    if (!result.isSuccess()) {
        return result;
    }
    return render(false);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param minDate The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(minDate);
    if (isSameDate(mTempDate, mMinDate)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    // make sure the current date is not earlier than
    // the new min date since the latter is used for
    // calculating the indices in the adapter thus
    // avoiding out of bounds error
    Calendar date = mAdapter.mSelectedDate;
    if (date.before(mMinDate)) {
        mAdapter.setSelectedDay(mMinDate);
    }
    // reinitialize the adapter since its range depends on min date
    mAdapter.init();
    if (date.before(mMinDate)) {
        setDate(mTempDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}
Body of Second Method:
{
    mDelegate.setMinDate(minDate);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.loadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Loads samples into the soundpool.
 * This method must be called at first when sound effects are enabled
 */

Body of Frist Method:
{
    int attempts = 3;
    LoadSoundEffectReply reply = new LoadSoundEffectReply();
    synchronized (reply) {
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
        while ((reply.mStatus == 1) && (attempts-- > 0)) {
            try {
                reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "loadSoundEffects Interrupted while waiting sound pool loaded.");
            }
        }
    }
    return (reply.mStatus == 0);
}
Body of Second Method:
{
    int attempts = 3;
    LoadSoundEffectReply reply = new LoadSoundEffectReply();
    synchronized (reply) {
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
        while ((reply.mStatus == 1) && (attempts-- > 0)) {
            try {
                reply.wait(SOUND_EFFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "loadSoundEffects Interrupted while waiting sound pool loaded.");
            }
        }
    }
    return (reply.mStatus == 0);
}
------------------------
Find a functionally equivalent code:android.widget.RelativeLayout.LayoutParams.resolveRules:COMMENT
Method Modifier: private     
Comment:// only the "left"/"right" rules at the end.

Body of Frist Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_RIGHT] == 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
}
Body of Second Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
}
------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.TriggerEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

Body of Frist Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = mTriggerEvents.get(handle);
    if (t == null) {
        Log.e(TAG, "Error: Trigger Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}
Body of Second Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, "Error: Trigger Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}
------------------------
Find a functionally equivalent code:android.app.Notification.Style.buildStyled:COMMENT
<android.app.Notification.Style: Notification buildStyled(Notification)>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    populateTickerView(wip);
    populateContentView(wip);
    populateBigContentView(wip);
    populateHeadsUpContentView(wip);
    return wip;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.systemBooted:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mKeyguardDelegate != null) {
        mKeyguardDelegate.onBootCompleted();
    }
    synchronized (mLock) {
        mSystemBooted = true;
    }
}
Body of Second Method:
{
    if (mKeyguardDelegate != null) {
        mKeyguardDelegate.bindService(mContext);
        mKeyguardDelegate.onBootCompleted();
    }
    synchronized (mLock) {
        mSystemBooted = true;
    }
    wakingUp();
    screenTurningOn(null);
}
------------------------
Find a functionally equivalent code:android.text.TextLine.set:COMMENT
Method Modifier: 
Comment:/**
 * Initializes a TextLine and prepares it for use.
 *
 * @param paint the base paint for the line
 * @param text the text, can be Styled
 * @param start the start of the line relative to the text
 * @param limit the limit of the line relative to the text
 * @param dir the paragraph direction of this line
 * @param directions the directions information of this line
 * @param hasTabs true if the line might contain tabs or emoji
 * @param tabStops the tabStops. Can be null.
 */

Body of Frist Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = new char[ArrayUtils.idealCharArraySize(mLen)];
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
}
Body of Second Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientCenter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the center location of the gradient. The radius is honored only when
 * the gradient type is set to {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param x The x coordinate of the gradient's center
 * @param y The y coordinate of the gradient's center
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

Body of Frist Method:
{
    mGradientState.setGradientCenter(x, y);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientCenter(x, y);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.os.Environment.getExternalStorageState:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the current state of the primary "external" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */

Body of Frist Method:
{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getStorageState(externalDir);
}
Body of Second Method:
{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getExternalStorageState(externalDir);
}
------------------------
Find a functionally equivalent code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mAnimationType = otherOptions.mAnimationType;
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mAnimationType = otherOptions.mAnimationType;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mStartWidth = otherOptions.mStartWidth;
            mStartHeight = otherOptions.mStartHeight;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            mAnimationType = otherOptions.mAnimationType;
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
------------------------
Find a functionally equivalent code:javax.obex.ClientOperation.startProcessing:COMMENT
Method Modifier: private     
Comment:/**
 * This method starts the processing thread results. It will send the
 * initial request. If the response takes more then one packet, a thread
 * will be started to handle additional requests
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x03);
            }
            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
        }
    } else {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
Body of Second Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            if (!mGetFinalFlag) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                    more = sendRequest(0x03);
                }
                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
                }
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            } else {
                more = sendRequest(0x83);
                if (more) {
                    throw new IOException("FINAL_GET forced but data did not fit into single packet!");
                }
                mOperationDone = true;
            }
        }
    } else {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    }
    throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardTransportControlView.populateMetadata:COMMENT
Method Modifier: private     
Comment:/**
 * Populates the given metadata into the view
 */

Body of Frist Method:
{
    if (ANIMATE_TRANSITIONS && isLaidOut() && mMetadataContainer.getVisibility() == VISIBLE) {
        TransitionManager.beginDelayedTransition(mMetadataContainer, mMetadataChangeTransition);
    }
    final String remoteClientPackage = mRemoteController.getRemoteControlClientPackageName();
    Drawable badgeIcon = null;
    try {
        badgeIcon = getContext().getPackageManager().getApplicationIcon(remoteClientPackage);
    } catch (PackageManager.NameNotFoundException e) {
        Log.e(TAG, "Couldn't get remote control client package icon", e);
    }
    setBadgeIcon(badgeIcon);
    if (!TextUtils.isEmpty(mMetadata.trackTitle)) {
        mTrackTitle.setText(mMetadata.trackTitle);
    }
    StringBuilder sb = new StringBuilder();
    if (!TextUtils.isEmpty(mMetadata.artist)) {
        if (sb.length() != 0) {
            sb.append(" - ");
        }
        sb.append(mMetadata.artist);
    }
    if (!TextUtils.isEmpty(mMetadata.albumTitle)) {
        if (sb.length() != 0) {
            sb.append(" - ");
        }
        sb.append(mMetadata.albumTitle);
    }
    mTrackArtistAlbum.setText(sb.toString());
    if (mMetadata.duration >= 0) {
        setSeekBarsEnabled(true);
        setSeekBarDuration(mMetadata.duration);
        final String skeleton;
        if (mMetadata.duration >= 86400000) {
            skeleton = "DDD kk mm ss";
        } else if (mMetadata.duration >= 3600000) {
            skeleton = "kk mm ss";
        } else {
            skeleton = "mm ss";
        }
        mFormat = new SimpleDateFormat(DateFormat.getBestDateTimePattern(getContext().getResources().getConfiguration().locale, skeleton));
        mFormat.setTimeZone(TimeZone.getTimeZone("GMT+0"));
    } else {
        setSeekBarsEnabled(false);
    }
    KeyguardUpdateMonitor.getInstance(getContext()).dispatchSetBackground(mMetadata.bitmap);
    final int flags = mTransportControlFlags;
    setVisibilityBasedOnFlag(mBtnPrev, flags, RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS);
    setVisibilityBasedOnFlag(mBtnNext, flags, RemoteControlClient.FLAG_KEY_MEDIA_NEXT);
    setVisibilityBasedOnFlag(mBtnPlay, flags, RemoteControlClient.FLAG_KEY_MEDIA_PLAY | RemoteControlClient.FLAG_KEY_MEDIA_PAUSE | RemoteControlClient.FLAG_KEY_MEDIA_PLAY_PAUSE | RemoteControlClient.FLAG_KEY_MEDIA_STOP);
    updatePlayPauseState(mCurrentPlayState);
}
Body of Second Method:
{
    if (ANIMATE_TRANSITIONS && isLaidOut() && mMetadataContainer.getVisibility() == VISIBLE) {
        TransitionManager.beginDelayedTransition(mMetadataContainer, mMetadataChangeTransition);
    }
    final String remoteClientPackage = mRemoteController.getRemoteControlClientPackageName();
    Drawable badgeIcon = null;
    try {
        badgeIcon = getContext().getPackageManager().getApplicationIcon(remoteClientPackage);
    } catch (PackageManager.NameNotFoundException e) {
        Log.e(TAG, "Couldn't get remote control client package icon", e);
    }
    setBadgeIcon(badgeIcon);
    mTrackTitle.setText(!TextUtils.isEmpty(mMetadata.trackTitle) ? mMetadata.trackTitle : null);
    final StringBuilder sb = new StringBuilder();
    if (!TextUtils.isEmpty(mMetadata.artist)) {
        if (sb.length() != 0) {
            sb.append(" - ");
        }
        sb.append(mMetadata.artist);
    }
    if (!TextUtils.isEmpty(mMetadata.albumTitle)) {
        if (sb.length() != 0) {
            sb.append(" - ");
        }
        sb.append(mMetadata.albumTitle);
    }
    final String trackArtistAlbum = sb.toString();
    mTrackArtistAlbum.setText(!TextUtils.isEmpty(trackArtistAlbum) ? trackArtistAlbum : null);
    if (mMetadata.duration >= 0) {
        setSeekBarsEnabled(true);
        setSeekBarDuration(mMetadata.duration);
        final String skeleton;
        if (mMetadata.duration >= 86400000) {
            skeleton = "DDD kk mm ss";
        } else if (mMetadata.duration >= 3600000) {
            skeleton = "kk mm ss";
        } else {
            skeleton = "mm ss";
        }
        mFormat = new SimpleDateFormat(DateFormat.getBestDateTimePattern(getContext().getResources().getConfiguration().locale, skeleton));
        mFormat.setTimeZone(TimeZone.getTimeZone("GMT+0"));
    } else {
        setSeekBarsEnabled(false);
    }
    KeyguardUpdateMonitor.getInstance(getContext()).dispatchSetBackground(mMetadata.bitmap);
    final int flags = mTransportControlFlags;
    setVisibilityBasedOnFlag(mBtnPrev, flags, RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS);
    setVisibilityBasedOnFlag(mBtnNext, flags, RemoteControlClient.FLAG_KEY_MEDIA_NEXT);
    setVisibilityBasedOnFlag(mBtnPlay, flags, RemoteControlClient.FLAG_KEY_MEDIA_PLAY | RemoteControlClient.FLAG_KEY_MEDIA_PAUSE | RemoteControlClient.FLAG_KEY_MEDIA_PLAY_PAUSE | RemoteControlClient.FLAG_KEY_MEDIA_STOP);
    updatePlayPauseState(mCurrentPlayState);
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the provided user-visible description of the entry, if any.
 * @return the user-visible description, null if none was set earlier.
 */

Body of Frist Method:
{
    return description;
}
Body of Second Method:
{
    return mDescription;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callAdd:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link ClassWithNative#add(int, int)} via reflection.
 */

Body of Frist Method:
{
    Method m = instance.getClass().getMethod("add", new Class<?>[] { int.class, int.class });
    Object result = m.invoke(instance, new Object[] { a, b });
    return ((Integer) result).intValue();
}
Body of Second Method:
{
    Method m = instance.getClass().getMethod("add", int.class, int.class);
    Object result = m.invoke(instance, a, b);
    return (Integer) result;
}
------------------------
Find a functionally equivalent code:android.content.Intent.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    StringBuilder b = new StringBuilder(128);
    toShortString(b, secure, comp, extras, clip);
    return b.toString();
}
Body of Second Method:
{
    boolean first = true;
    if (mAction != null) {
        b.append("act=").append(mAction);
        first = false;
    }
    if (mCategories != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cat=[");
        for (int i = 0; i < mCategories.size(); i++) {
            if (i > 0)
                b.append(',');
            b.append(mCategories.valueAt(i));
        }
        b.append("]");
    }
    if (mData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("dat=");
        if (secure) {
            b.append(mData.toSafeString());
        } else {
            b.append(mData);
        }
    }
    if (mType != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("typ=").append(mType);
    }
    if (mFlags != 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("flg=0x").append(Integer.toHexString(mFlags));
    }
    if (mPackage != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("pkg=").append(mPackage);
    }
    if (comp && mComponent != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cmp=").append(mComponent.flattenToShortString());
    }
    if (mSourceBounds != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("bnds=").append(mSourceBounds.toShortString());
    }
    if (mClipData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        if (clip) {
            b.append("clip={");
            mClipData.toShortString(b);
            b.append('}');
        } else {
            b.append("(has clip)");
        }
    }
    if (extras && mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("(has extras)");
    }
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("u=").append(mContentUserHint);
    }
    if (mSelector != null) {
        b.append(" sel=");
        mSelector.toShortString(b, secure, comp, extras, clip);
        b.append("}");
    }
}
------------------------
Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.launchActivity:COMMENT
Method Modifier: private     
Comment:/**
 * Launches and activity and queries for errors.
 *
 * @param packageName {@link String} the package name of the application to
 * launch.
 * @return {@link Collection} of {@link ProcessErrorStateInfo} detected
 * during the app launch.
 */

Body of Frist Method:
{
    Intent homeIntent = new Intent(Intent.ACTION_MAIN);
    homeIntent.addCategory(Intent.CATEGORY_HOME);
    homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Intent intent = mPackageManager.getLaunchIntentForPackage(packageName);
    // Skip if the apk does not have a launch intent.
    if (intent == null) {
        Log.d(TAG, "Skipping " + packageName + "; missing launch intent");
        return null;
    }
    // We check for any Crash or ANR dialogs that are already up, and we
    // ignore them. This is
    // so that we don't report crashes that were caused by prior apps (which
    // those particular
    // tests should have caught and reported already). Otherwise, test
    // failures would cascade
    // from the initial broken app to many/all of the tests following that
    // app's launch.
    final Collection<ProcessErrorStateInfo> preErr = mActivityManager.getProcessesInErrorState();
    // Launch Activity
    mContext.startActivity(intent);
    try {
        Thread.sleep(mAppLaunchTimeout);
    } catch (InterruptedException e) {
    // ignore
    }
    // Send the "home" intent and wait 2 seconds for us to get there
    mContext.startActivity(homeIntent);
    try {
        Thread.sleep(mWorkspaceLaunchTimeout);
    } catch (InterruptedException e) {
    // ignore
    }
    // See if there are any errors. We wait until down here to give ANRs as
    // much time as
    // possible to occur.
    final Collection<ProcessErrorStateInfo> postErr = mActivityManager.getProcessesInErrorState();
    // present when we started
    if (preErr != null && postErr != null) {
        postErr.removeAll(preErr);
    }
    return postErr;
}
Body of Second Method:
{
    // the recommended way to see if this is a tv or not.
    boolean isleanback = !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN) && !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
    Intent homeIntent = new Intent(Intent.ACTION_MAIN);
    homeIntent.addCategory(Intent.CATEGORY_HOME);
    homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    Intent intent;
    if (isleanback) {
        Log.d(TAG, "Leanback and relax! " + packageName);
        intent = mPackageManager.getLeanbackLaunchIntentForPackage(packageName);
    } else {
        intent = mPackageManager.getLaunchIntentForPackage(packageName);
    }
    assertNotNull("Skipping " + packageName + "; missing launch intent", intent);
    String processName = getProcessName(packageName);
    // Launch Activity
    mContext.startActivity(intent);
    try {
        Thread.sleep(mAppLaunchTimeout);
    } catch (InterruptedException e) {
    // ignore
    }
    // Send the "home" intent and wait 2 seconds for us to get there
    mContext.startActivity(homeIntent);
    try {
        Thread.sleep(mWorkspaceLaunchTimeout);
    } catch (InterruptedException e) {
    // ignore
    }
    // See if there are any errors. We wait until down here to give ANRs as
    // much time as
    // possible to occur.
    final Collection<ProcessErrorStateInfo> postErr = mActivityManager.getProcessesInErrorState();
    if (postErr == null) {
        return null;
    }
    for (ProcessErrorStateInfo error : postErr) {
        if (error.processName.equals(processName)) {
            return error;
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.widget.SuggestionsAdapter.newView:COMMENT
Method Modifier: public      
Comment:/**
 * Tags the view with cached child view look-ups.
 */

Body of Frist Method:
{
    View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    return v;
}
Body of Second Method:
{
    final View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    // Set up icon.
    final ImageView iconRefine = (ImageView) v.findViewById(R.id.edit_query);
    iconRefine.setImageResource(mCommitIconResId);
    return v;
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putString:COMMENT
Method Modifier: public      
Comment:/**
 * Adds textual information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key The identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUM},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUMARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_AUTHOR},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPILATION},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPOSER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DATE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_GENRE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_WRITER}.
 * @param value The text for the given key, or {@code null} to signify there is no valid
 * information for the field.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 */

Body of Frist Method:
{
    super.putString(key, value);
    return this;
}
Body of Second Method:
{
    super.putString(key, value);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putText(metadataKey, value);
        }
    }
    return this;
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupStartValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the start values for an animation.
 * The start values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    setupValue(target, mKeyframeSet.mKeyframes.get(0));
}
Body of Second Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.startActivityFromFragment:COMMENT
Method Modifier: public      
Comment:/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */

Body of Frist Method:
{
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, fragment, intent, requestCode, options);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, fragment.mWho, requestCode, ar.getResultCode(), ar.getResultData());
    }
}
Body of Second Method:
{
    if (options != null) {
        mActivityTransitionState.startExitOutTransition(this, options);
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, fragment, intent, requestCode, options);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, fragment.mWho, requestCode, ar.getResultCode(), ar.getResultData());
    }
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.MetadataEditor.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies all of the metadata changes that have been set since the MediaMetadataEditor
 * instance was created with {@link RemoteController#editMetadata()}
 * or since {@link #clear()} was called.
 */

Body of Frist Method:
{
    // editable key we support: RATING_KEY_BY_USER
    if (!mMetadataChanged) {
        return;
    }
    final int genId;
    synchronized (mGenLock) {
        genId = mClientGenerationIdCurrent;
    }
    synchronized (mInfoLock) {
        if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
            Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
            mAudioManager.updateRemoteControlClientMetadata(genId, MediaMetadataEditor.RATING_KEY_BY_USER, rating);
        } else {
            Log.e(TAG, "no metadata to apply");
        }
        // NOT setting mApplied to true as this type of MetadataEditor will be applied
        // multiple times, whenever the user of a RemoteController needs to change the
        // metadata (e.g. user changes the rating of a song more than once during playback)
        mApplied = false;
    }
}
Body of Second Method:
{
    // editable key we support: RATING_KEY_BY_USER
    if (!mMetadataChanged) {
        return;
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
                Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
                if (rating != null) {
                    mCurrentSession.getTransportControls().setRating(rating);
                }
            }
        }
    }
    // NOT setting mApplied to true as this type of MetadataEditor will be applied
    // multiple times, whenever the user of a RemoteController needs to change the
    // metadata (e.g. user changes the rating of a song more than once during playback)
    mApplied = false;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (s != null) {
        return XmlUtils.convertValueToBoolean(s, defValue);
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    return s == null ? defValue : XmlUtils.convertValueToBoolean(s, defValue);
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.retrieveAttributes:COMMENT
Method Modifier: default     final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.Notification.lightenPayload:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Removes heavyweight parts of the Notification object for archival or for sending to
 * listeners when the full contents are not necessary.
 * @hide
 */

Body of Frist Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    largeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
    }
}
Body of Second Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    headsUpContentView = null;
    largeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
        extras.remove(Notification.EXTRA_BIG_TEXT);
        // Prevent light notifications from being rebuilt.
        extras.remove(Builder.EXTRA_NEEDS_REBUILD);
    }
}
------------------------
Find a functionally equivalent code:android.app.SharedPreferencesImpl.writeToFile:COMMENT
Method Modifier: private     
Comment:// Note: must hold mWritingToDiskLock

Body of Frist Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) {
        if (!mcr.changesMade) {
            // If the file already exists, but no changes were
            // made to the underlying map, it's wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        }
        if (!mBackupFile.exists()) {
            if (!mFile.renameTo(mBackupFile)) {
                Log.e(TAG, "Couldn't rename file " + mFile + " to backup file " + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            }
        } else {
            mFile.delete();
        }
    }
    // from the backup.
    try {
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) {
            mcr.setDiskWriteResult(false);
            return;
        }
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try {
            final StructStat stat = Libcore.os.stat(mFile.getPath());
            synchronized (this) {
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            }
        } catch (ErrnoException e) {
        // Do nothing
        }
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    } catch (XmlPullParserException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    } catch (IOException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    }
    // Clean up an unsuccessfully written file
    if (mFile.exists()) {
        if (!mFile.delete()) {
            Log.e(TAG, "Couldn't clean up partially-written file " + mFile);
        }
    }
    mcr.setDiskWriteResult(false);
}
Body of Second Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) {
        if (!mcr.changesMade) {
            // If the file already exists, but no changes were
            // made to the underlying map, it's wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        }
        if (!mBackupFile.exists()) {
            if (!mFile.renameTo(mBackupFile)) {
                Log.e(TAG, "Couldn't rename file " + mFile + " to backup file " + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            }
        } else {
            mFile.delete();
        }
    }
    // from the backup.
    try {
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) {
            mcr.setDiskWriteResult(false);
            return;
        }
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try {
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) {
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            }
        } catch (ErrnoException e) {
        // Do nothing
        }
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    } catch (XmlPullParserException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    } catch (IOException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    }
    // Clean up an unsuccessfully written file
    if (mFile.exists()) {
        if (!mFile.delete()) {
            Log.e(TAG, "Couldn't clean up partially-written file " + mFile);
        }
    }
    mcr.setDiskWriteResult(false);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.sendMasterVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumePanel.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
Body of Second Method:
{
    mVolumeController.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.markAsVoiceMail:COMMENT
Method Modifier: internal    
Comment:/* package */

Body of Frist Method:
{
    mIsVoiceMail = true;
    try {
        String voiceMailLabel = TelephonyManager.getDefault().getVoiceMailAlphaTag();
        phoneNumber = voiceMailLabel;
    } catch (SecurityException se) {
        // Should never happen: if this process does not have
        // permission to retrieve VM tag, it should not have
        // permission to retrieve VM number and would not call
        // this method.
        // Leave phoneNumber untouched.
        Rlog.e(TAG, "Cannot access VoiceMail.", se);
    }
    // photoResource = android.R.drawable.badge_voicemail;
    return this;
}
Body of Second Method:
{
    mIsVoiceMail = true;
    try {
        String voiceMailLabel = TelephonyManager.getDefault().getVoiceMailAlphaTag(subId);
        phoneNumber = voiceMailLabel;
    } catch (SecurityException se) {
        // Should never happen: if this process does not have
        // permission to retrieve VM tag, it should not have
        // permission to retrieve VM number and would not call
        // this method.
        // Leave phoneNumber untouched.
        Rlog.e(TAG, "Cannot access VoiceMail.", se);
    }
    // photoResource = android.R.drawable.badge_voicemail;
    return this;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getByte:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */

Body of Frist Method:
{
    unparcel();
    return getByte(key, (byte) 0);
}
Body of Second Method:
{
    return super.getByte(key);
}
------------------------
Find a functionally equivalent code:android.view.Window.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity of the window, as per the Gravity constants.  This
 * controls how the window manager is positioned in the overall window; it
 * is only useful when using WRAP_CONTENT for the layout width or height.
 *
 * @param gravity The desired gravity constant.
 *
 * @see Gravity
 * @see #setLayout
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.gravity = gravity;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.gravity = gravity;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.widget.ActivityChooserView.Callbacks.onItemClick:COMMENT
Method Modifier: public      
Comment:// AdapterView#OnItemClickListener

Body of Frist Method:
{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        mContext.startActivity(launchIntent);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}
Body of Second Method:
{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        ResolveInfo resolveInfo = mAdapter.getDataModel().getActivity(position);
                        startActivity(launchIntent, resolveInfo);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}
------------------------
Find a functionally equivalent code:android.widget.ProgressBar.tileify:COMMENT
Method Modifier: private     
Comment:/**
 * Converts a drawable to a tiled version of itself. It will recursively
 * traverse layer and state list drawables.
 */

Body of Frist Method:
{
    if (drawable instanceof LayerDrawable) {
        LayerDrawable background = (LayerDrawable) drawable;
        final int N = background.getNumberOfLayers();
        Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            int id = background.getId(i);
            outDrawables[i] = tileify(background.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        LayerDrawable newBg = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            newBg.setId(i, background.getId(i));
        }
        return newBg;
    } else if (drawable instanceof StateListDrawable) {
        StateListDrawable in = (StateListDrawable) drawable;
        StateListDrawable out = new StateListDrawable();
        int numStates = in.getStateCount();
        for (int i = 0; i < numStates; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    } else if (drawable instanceof BitmapDrawable) {
        final Bitmap tileBitmap = ((BitmapDrawable) drawable).getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
        final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        shapeDrawable.getPaint().setShader(bitmapShader);
        return (clip) ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
    }
    return drawable;
}
Body of Second Method:
{
    if (drawable instanceof LayerDrawable) {
        LayerDrawable background = (LayerDrawable) drawable;
        final int N = background.getNumberOfLayers();
        Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            int id = background.getId(i);
            outDrawables[i] = tileify(background.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        LayerDrawable newBg = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            newBg.setId(i, background.getId(i));
        }
        return newBg;
    } else if (drawable instanceof StateListDrawable) {
        StateListDrawable in = (StateListDrawable) drawable;
        StateListDrawable out = new StateListDrawable();
        int numStates = in.getStateCount();
        for (int i = 0; i < numStates; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    } else if (drawable instanceof BitmapDrawable) {
        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
        final Bitmap tileBitmap = bitmap.getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
        final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        shapeDrawable.getPaint().setShader(bitmapShader);
        // Ensure the tint and filter are propagated in the correct order.
        shapeDrawable.setTintList(bitmap.getTint());
        shapeDrawable.setTintMode(bitmap.getTintMode());
        shapeDrawable.setColorFilter(bitmap.getColorFilter());
        return clip ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
    }
    return drawable;
}
------------------------
Find a functionally equivalent code:android.widget.ActivityChooserView.Callbacks.onClick:COMMENT
Method Modifier: public      
Comment:// View.OnClickListener

Body of Frist Method:
{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            mContext.startActivity(launchIntent);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}
Body of Second Method:
{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            startActivity(launchIntent, defaultActivity);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Picture.beginRecording:COMMENT
Method Modifier: public      
Comment:/**
 * To record a picture, call beginRecording() and then draw into the Canvas
 * that is returned. Nothing we appear on screen, but all of the draw
 * commands (e.g. {@link Canvas#drawRect(Rect, Paint)}) will be recorded.
 * To stop recording, call endRecording(). After endRecording() the Canvas
 * that was returned must no longer be used, and nothing should be drawn
 * into it.
 */

Body of Frist Method:
{
    int ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new RecordingCanvas(this, ni);
    return mRecordingCanvas;
}
Body of Second Method:
{
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new RecordingCanvas(this, ni);
    return mRecordingCanvas;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getScreenOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the screen has been on while the device was
 * running on battery.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.RemoteController.getRemoteControlClientPackageName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
}
Body of Second Method:
{
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            return mCurrentSession != null ? mCurrentSession.getPackageName() : null;
        }
    } else {
        return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
    }
}
------------------------
Find a functionally equivalent code:android.hardware.SensorManager.getQuaternionFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a normalized quaternion.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
 * quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
 * @param rv the rotation vector to convert
 * @param Q an array of floats in which to store the computed quaternion
 */

Body of Frist Method:
{
    if (rv.length == 4) {
        Q[0] = rv[3];
    } else {
        Q[0] = 1 - rv[0] * rv[0] - rv[1] * rv[1] - rv[2] * rv[2];
        Q[0] = (Q[0] > 0) ? (float) Math.sqrt(Q[0]) : 0;
    }
    Q[1] = rv[0];
    Q[2] = rv[1];
    Q[3] = rv[2];
}
Body of Second Method:
{
    if (rv.length >= 4) {
        Q[0] = rv[3];
    } else {
        Q[0] = 1 - rv[0] * rv[0] - rv[1] * rv[1] - rv[2] * rv[2];
        Q[0] = (Q[0] > 0) ? (float) Math.sqrt(Q[0]) : 0;
    }
    Q[1] = rv[0];
    Q[2] = rv[1];
    Q[3] = rv[2];
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return false;
    }
    return mResourceData[index] != null;
}
Body of Second Method:
{
    return index >= 0 && index < mResourceData.length && mResourceData[index] != null;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onPhoneStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onPhoneStateChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the phone state changes. String will be one of:
 * {@link TelephonyManager#EXTRA_STATE_IDLE}
 * {@link TelephonyManager@EXTRA_STATE_RINGING}
 * {@link TelephonyManager#EXTRA_STATE_OFFHOOK
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.dispatchKeyShortcutEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on keyShortcutEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on keyShortcutEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}
------------------------
Find a functionally equivalent code:android.widget.TextView.sendAfterTextChanged:COMMENT
Method Modifier: 
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
}
Body of Second Method:
{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    hideErrorIfUnchanged();
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setMode:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setMode(int)
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("setMode()")) {
        return;
    }
    if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
        return;
    }
    int newModeOwnerPid = 0;
    synchronized (mSetModeDeathHandlers) {
        if (mode == AudioSystem.MODE_CURRENT) {
            mode = mMode;
        }
        newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
    }
    // SCO connections not started by the application changing the mode
    if (newModeOwnerPid != 0) {
        disconnectBluetoothSco(newModeOwnerPid);
    }
}
Body of Second Method:
{
    if (DEBUG_MODE) {
        Log.v(TAG, "setMode(mode=" + mode + ")");
    }
    if (!checkAudioSettingsPermission("setMode()")) {
        return;
    }
    if ((mode == AudioSystem.MODE_IN_CALL) && (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE) != PackageManager.PERMISSION_GRANTED)) {
        Log.w(TAG, "MODIFY_PHONE_STATE Permission Denial: setMode(MODE_IN_CALL) from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
        return;
    }
    int newModeOwnerPid = 0;
    synchronized (mSetModeDeathHandlers) {
        if (mode == AudioSystem.MODE_CURRENT) {
            mode = mMode;
        }
        newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
    }
    // SCO connections not started by the application changing the mode
    if (newModeOwnerPid != 0) {
        disconnectBluetoothSco(newModeOwnerPid);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolumeHandling:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether volume for the playback associated with this route is fixed
 * ({@link RouteInfo#PLAYBACK_VOLUME_FIXED}) or can modified
 * ({@link RouteInfo#PLAYBACK_VOLUME_VARIABLE}).
 * @param volumeHandling
 */

Body of Frist Method:
{
    if (mVolumeHandling != volumeHandling) {
        mVolumeHandling = volumeHandling;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING, volumeHandling);
    }
}
Body of Second Method:
{
    if (mVolumeHandling != volumeHandling) {
        mVolumeHandling = volumeHandling;
        configureSessionVolume();
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.createPipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.windowTypeToLayerLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
        return 2;
    }
    switch(type) {
        case TYPE_UNIVERSE_BACKGROUND:
            return 1;
        case TYPE_PRIVATE_PRESENTATION:
            return 2;
        case TYPE_WALLPAPER:
            // wallpaper is at the bottom, though the window manager may move it.
            return 2;
        case TYPE_PHONE:
            return 3;
        case TYPE_SEARCH_BAR:
            return 4;
        case TYPE_RECENTS_OVERLAY:
        case TYPE_SYSTEM_DIALOG:
            return 5;
        case TYPE_TOAST:
            // toasts and the plugged-in battery thing
            return 6;
        case TYPE_PRIORITY_PHONE:
            // SIM errors and unlock.  Not sure if this really should be in a high layer.
            return 7;
        case TYPE_DREAM:
            // used for Dreams (screensavers with TYPE_DREAM windows)
            return 8;
        case TYPE_SYSTEM_ALERT:
            // like the ANR / app crashed dialogs
            return 9;
        case TYPE_INPUT_METHOD:
            // on-screen keyboards and other such input method user interfaces go here.
            return 10;
        case TYPE_INPUT_METHOD_DIALOG:
            // on-screen keyboards and other such input method user interfaces go here.
            return 11;
        case TYPE_KEYGUARD_SCRIM:
            // the safety window that shows behind keyguard while keyguard is starting
            return 12;
        case TYPE_KEYGUARD:
            // responsible for power management when displayed.
            return 13;
        case TYPE_KEYGUARD_DIALOG:
            return 14;
        case TYPE_STATUS_BAR_SUB_PANEL:
            return 15;
        case TYPE_STATUS_BAR:
            return 16;
        case TYPE_STATUS_BAR_PANEL:
            return 17;
        case TYPE_VOLUME_OVERLAY:
            // changes the device volume
            return 18;
        case TYPE_SYSTEM_OVERLAY:
            // changes the device volume
            return 19;
        case TYPE_NAVIGATION_BAR:
            // the navigation bar, if available, shows atop most things
            return 20;
        case TYPE_NAVIGATION_BAR_PANEL:
            // some panels (e.g. search) need to show on top of the navigation bar
            return 21;
        case TYPE_SYSTEM_ERROR:
            // system-level error dialogs
            return 22;
        case TYPE_MAGNIFICATION_OVERLAY:
            // used to highlight the magnified portion of a display
            return 23;
        case TYPE_DISPLAY_OVERLAY:
            // used to simulate secondary display devices
            return 24;
        case TYPE_DRAG:
            // which sits above all other focusable windows
            return 25;
        case TYPE_SECURE_SYSTEM_OVERLAY:
            return 26;
        case TYPE_BOOT_PROGRESS:
            return 27;
        case TYPE_POINTER:
            // the (mouse) pointer layer
            return 28;
        case TYPE_HIDDEN_NAV_CONSUMER:
            return 29;
    }
    Log.e(TAG, "Unknown window type: " + type);
    return 2;
}
Body of Second Method:
{
    if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
        return 2;
    }
    switch(type) {
        case TYPE_UNIVERSE_BACKGROUND:
            return 1;
        case TYPE_PRIVATE_PRESENTATION:
            return 2;
        case TYPE_WALLPAPER:
            // wallpaper is at the bottom, though the window manager may move it.
            return 2;
        case TYPE_PHONE:
            return 3;
        case TYPE_SEARCH_BAR:
            return 4;
        case TYPE_VOICE_INTERACTION:
            // voice interaction layer is almost immediately above apps.
            return 5;
        case TYPE_RECENTS_OVERLAY:
        case TYPE_SYSTEM_DIALOG:
            return 6;
        case TYPE_TOAST:
            // toasts and the plugged-in battery thing
            return 7;
        case TYPE_PRIORITY_PHONE:
            // SIM errors and unlock.  Not sure if this really should be in a high layer.
            return 8;
        case TYPE_DREAM:
            // used for Dreams (screensavers with TYPE_DREAM windows)
            return 9;
        case TYPE_SYSTEM_ALERT:
            // like the ANR / app crashed dialogs
            return 10;
        case TYPE_INPUT_METHOD:
            // on-screen keyboards and other such input method user interfaces go here.
            return 11;
        case TYPE_INPUT_METHOD_DIALOG:
            // on-screen keyboards and other such input method user interfaces go here.
            return 12;
        case TYPE_KEYGUARD_SCRIM:
            // the safety window that shows behind keyguard while keyguard is starting
            return 13;
        case TYPE_STATUS_BAR_SUB_PANEL:
            return 14;
        case TYPE_STATUS_BAR:
            return 15;
        case TYPE_STATUS_BAR_PANEL:
            return 16;
        case TYPE_KEYGUARD_DIALOG:
            return 17;
        case TYPE_VOLUME_OVERLAY:
            // changes the device volume
            return 18;
        case TYPE_SYSTEM_OVERLAY:
            // changes the device volume
            return 19;
        case TYPE_NAVIGATION_BAR:
            // the navigation bar, if available, shows atop most things
            return 20;
        case TYPE_NAVIGATION_BAR_PANEL:
            // some panels (e.g. search) need to show on top of the navigation bar
            return 21;
        case TYPE_SYSTEM_ERROR:
            // system-level error dialogs
            return 22;
        case TYPE_MAGNIFICATION_OVERLAY:
            // used to highlight the magnified portion of a display
            return 23;
        case TYPE_DISPLAY_OVERLAY:
            // used to simulate secondary display devices
            return 24;
        case TYPE_DRAG:
            // which sits above all other focusable windows
            return 25;
        case TYPE_SECURE_SYSTEM_OVERLAY:
            return 26;
        case TYPE_BOOT_PROGRESS:
            return 27;
        case TYPE_POINTER:
            // the (mouse) pointer layer
            return 28;
        case TYPE_HIDDEN_NAV_CONSUMER:
            return 29;
    }
    Log.e(TAG, "Unknown window type: " + type);
    return 2;
}
------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.registerListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (listener == null || sensor == null) {
        Log.e(TAG, "sensor or listener is null");
        return false;
    }
    // Trigger Sensors should use the requestTriggerSensor call.
    if (Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
        Log.e(TAG, "Trigger Sensors should use the requestTriggerSensor.");
        return false;
    }
    if (maxBatchReportLatencyUs < 0 || delayUs < 0) {
        Log.e(TAG, "maxBatchReportLatencyUs and delayUs should be non-negative");
        return false;
    }
    // We map SensorEventListener to a SensorEventQueue, which holds the looper
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue == null) {
            Looper looper = (handler != null) ? handler.getLooper() : mMainLooper;
            queue = new SensorEventQueue(listener, looper, this);
            if (!queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)) {
                queue.dispose();
                return false;
            }
            mSensorListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags);
        }
    }
}
Body of Second Method:
{
    if (listener == null || sensor == null) {
        Log.e(TAG, "sensor or listener is null");
        return false;
    }
    // Trigger Sensors should use the requestTriggerSensor call.
    if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
        Log.e(TAG, "Trigger Sensors should use the requestTriggerSensor.");
        return false;
    }
    if (maxBatchReportLatencyUs < 0 || delayUs < 0) {
        Log.e(TAG, "maxBatchReportLatencyUs and delayUs should be non-negative");
        return false;
    }
    // We map SensorEventListener to a SensorEventQueue, which holds the looper
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue == null) {
            Looper looper = (handler != null) ? handler.getLooper() : mMainLooper;
            queue = new SensorEventQueue(listener, looper, this);
            if (!queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)) {
                queue.dispose();
                return false;
            }
            mSensorListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags);
        }
    }
}
------------------------
Find a functionally equivalent code:android.provider.Browser.deleteHistoryWhere:COMMENT
Method Modifier: private     static      final       
Comment:/**
 * Helper function to delete all history items and release the icons for them in the
 * {@link WebIconDatabase}.
 *
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr   The ContentResolver used to access the database.
 * @param whereClause   String to limit the items affected.
 * null means all items.
 */

Body of Frist Method:
{
    Cursor cursor = null;
    try {
        cursor = cr.query(History.CONTENT_URI, new String[] { History.URL }, whereClause, null, null);
        if (cursor.moveToFirst()) {
            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
            do {
                // Delete favicons
                // TODO don't release if the URL is bookmarked
                iconDb.releaseIconForPageUrl(cursor.getString(0));
            } while (cursor.moveToNext());
            cr.delete(History.CONTENT_URI, whereClause, null);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "deleteHistoryWhere", e);
        return;
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
Body of Second Method:
{
    Cursor cursor = null;
    try {
        cursor = cr.query(History.CONTENT_URI, new String[] { History.URL }, whereClause, null, null);
        if (cursor.moveToFirst()) {
            cr.delete(History.CONTENT_URI, whereClause, null);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "deleteHistoryWhere", e);
        return;
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
------------------------
Find a functionally equivalent code:android.util.SparseBooleanArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            boolean[] nvalues = new boolean[n];
            // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseBooleanArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleMPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method Profiling w/Streaming Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    if (false) {
        Log.v("ddm-heap", "Method prof stream start: size=" + bufferSize + ", flags=" + flags);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, false, 0);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    if (DEBUG) {
        Log.v("ddm-heap", "Method prof stream start: size=" + bufferSize + ", flags=" + flags);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, false, 0);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.setOnGetPlaybackPositionListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be called whenever the media current playback position is needed.
 * Queries will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the listener to be called to retrieve the playback position
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        int oldCapa = mPlaybackPositionCapabilities;
        if (l != null) {
            mPlaybackPositionCapabilities |= MEDIA_POSITION_READABLE;
        } else {
            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_READABLE;
        }
        mPositionProvider = l;
        if (oldCapa != mPlaybackPositionCapabilities) {
            // tell RCDs that this RCC's playback position capabilities have changed
            sendTransportControlInfo_syncCacheLock(null);
        }
        if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
            // playback position is already moving, but now we have a position provider,
            // so schedule a drift check right now
            mEventHandler.sendMessageDelayed(mEventHandler.obtainMessage(MSG_POSITION_DRIFT_CHECK), 0);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        mPositionProvider = l;
        if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
            // playback position is already moving, but now we have a position provider,
            // so schedule a drift check right now
            mEventHandler.sendMessageDelayed(mEventHandler.obtainMessage(MSG_POSITION_DRIFT_CHECK), 0);
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.RecoverySystem.verifyPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently "/system/etc/security/otacerts.zip").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */

Body of Frist Method:
{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, "r");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException("no signature in file (no footer)");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException("no signature in file (bad footer)");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException("EOCD marker found after start of EOCD");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException("signedData is null");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException("encCerts is empty");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException("signature contains no certificates");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException("no signer infos!");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException("signature doesn't match any trusted key");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // "SHA256withRSA" cert -> "SHA256withRSA" signature
        // "SHA1withRSA" cert   -> "SHA1withRSA" signature
        // "MD5withRSA" cert    -> "SHA1withRSA" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + "with" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException("verification was interrupted");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException("signature digest verification failed");
        }
    } finally {
        raf.close();
    }
}
Body of Second Method:
{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, "r");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException("no signature in file (no footer)");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException("no signature in file (bad footer)");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException("EOCD marker found after start of EOCD");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException("signedData is null");
        }
        List<Certificate> encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException("encCerts is empty");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator<Certificate> it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            InputStream is = new ByteArrayInputStream(it.next().getEncoded());
            cert = (X509Certificate) cf.generateCertificate(is);
        } else {
            throw new SignatureException("signature contains no certificates");
        }
        List<SignerInfo> sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException("no signer infos!");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException("signature doesn't match any trusted key");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // "SHA256withRSA" cert -> "SHA256withRSA" signature
        // "SHA1withRSA" cert   -> "SHA1withRSA" signature
        // "MD5withRSA" cert    -> "SHA1withRSA" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + "with" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException("verification was interrupted");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException("signature digest verification failed");
        }
    } finally {
        raf.close();
    }
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.turnScreenOff:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOff()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Turn screen off

Body of Frist Method:
{
    log("Turn screen off");
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    pm.goToSleep(SystemClock.uptimeMillis());
}
Body of Second Method:
{
    logv("Turn screen off");
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    pm.goToSleep(SystemClock.uptimeMillis());
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param maxDate The maximal supported date.
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    mCalendarView.setMaxDate(maxDate);
    if (mCurrentDate.after(mMaxDate)) {
        mCurrentDate.setTimeInMillis(mMaxDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}
Body of Second Method:
{
    mDelegate.setMaxDate(maxDate);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.createBitmap:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns an immutable bitmap from the source bitmap. The new bitmap may
 * be the same object as source, or a copy may have been made.  It is
 * initialized with the same density as the original bitmap.
 */

Body of Frist Method:
{
    return createBitmap(src, 0, 0, src.getWidth(), src.getHeight());
}
Body of Second Method:
{
    return createBitmap(src, 0, 0, src.getWidth(), src.getHeight());
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleMPRS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method PRofiling Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int len = in.getInt();
    String fileName = getString(in, len);
    if (false)
        Log.v("ddm-heap", "Method profiling start: filename='" + fileName + "', size=" + bufferSize + ", flags=" + flags);
    try {
        Debug.startMethodTracing(fileName, bufferSize, flags);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int len = in.getInt();
    String fileName = getString(in, len);
    if (DEBUG)
        Log.v("ddm-heap", "Method profiling start: filename='" + fileName + "', size=" + bufferSize + ", flags=" + flags);
    try {
        Debug.startMethodTracing(fileName, bufferSize, flags);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetter:COMMENT
Method Modifier: 
Comment:/**
 * Utility function to get the setter from targetClass
 * @param targetClass The Class on which the requested method should exist.
 */

Body of Frist Method:
{
    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
}
Body of Second Method:
{
    Class<?> propertyType = mConverter == null ? mValueType : mConverter.getTargetType();
    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", propertyType);
}
------------------------
Find a functionally equivalent code:android.app.ContextImpl.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    startActivityAsUser(intent, null, user);
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().startActivityAsUser(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, null, 0, Intent.FLAG_ACTIVITY_NEW_TASK, null, options, user.getIdentifier());
    } catch (RemoteException re) {
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.init:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mHeadless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
    mHandler = new PolicyHandler();
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    readConfigurationDependentBehaviors();
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (mPowerManager.isScreenOn()) {
        screenTurningOn(null);
    } else {
        screenTurnedOff(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
}
Body of Second Method:
{
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.RuntimeInit.zygoteInit:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * The main function called when started through the zygote process. This
 * could be unified with main(), if the native code in nativeFinishInit()
 * were rationalized with Zygote startup.<p>
 *
 * Current recognized args:
 * <ul>
 * <li> <code> [--] &lt;start class name&gt;  &lt;args&gt;
 * </ul>
 *
 * @param targetSdkVersion target SDK version
 * @param argv arg strings
 */

Body of Frist Method:
{
    if (DEBUG)
        Slog.d(TAG, "RuntimeInit: Starting application from zygote");
    redirectLogStreams();
    commonInit();
    nativeZygoteInit();
    applicationInit(targetSdkVersion, argv);
}
Body of Second Method:
{
    if (DEBUG)
        Slog.d(TAG, "RuntimeInit: Starting application from zygote");
    redirectLogStreams();
    commonInit();
    nativeZygoteInit();
    applicationInit(targetSdkVersion, argv, classLoader);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawLine:COMMENT
Method Modifier: public      
Comment:/**
 * Draw a line segment with the specified start and stop x,y coordinates,
 * using the specified paint.
 *
 * <p>Note that since a line is always "framed", the Style is ignored in the paint.</p>
 *
 * <p>Degenerate lines (length is 0) will not be drawn.</p>
 *
 * @param startX The x-coordinate of the start point of the line
 * @param startY The y-coordinate of the start point of the line
 * @param paint  The paint used to draw the line
 */

Body of Frist Method:
{
    native_drawLine(mNativeCanvas, startX, startY, stopX, stopY, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.isSyncPending:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return true if the pending status is true of any matching authorities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if there is a pending sync with the matching account and authority
 */

Body of Frist Method:
{
    try {
        return getContentService().isSyncPending(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    return isSyncPendingAsUser(account, authority, UserHandle.myUserId());
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGattServer.sendResponse:COMMENT
Method Modifier: public      
Comment:/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "sendResponse() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "sendResponse() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.runOnce:COMMENT
Method Modifier: internal    
Comment:/**
 * Reads one start command from the command socket. If successful,
 * a child is forked and a {@link ZygoteInit.MethodAndArgsCaller}
 * exception is thrown in that child while in the parent process,
 * the method returns normally. On failure, the child is not
 * spawned and messages are printed to the log and stderr. Returns
 * a boolean status value indicating whether an end-of-file on the command
 * socket has been encountered.
 *
 * @return false if command socket should continue to be read from, or
 * true if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()
 * method in child process
 */

Body of Frist Method:
{
    String[] args;
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;
    try {
        args = readArgumentList();
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        Log.w(TAG, "IOException on command socket " + ex.getMessage());
        closeSocket();
        return true;
    }
    if (args == null) {
        // EOF reached.
        closeSocket();
        return true;
    }
    /**
     * the stderr of the most recent request, if avail
     */
    PrintStream newStderr = null;
    if (descriptors != null && descriptors.length >= 3) {
        newStderr = new PrintStream(new FileOutputStream(descriptors[2]));
    }
    int pid = -1;
    FileDescriptor childPipeFd = null;
    FileDescriptor serverPipeFd = null;
    try {
        parsedArgs = new Arguments(args);
        applyUidSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyRlimitSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyCapabilitiesSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyInvokeWithSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyseInfoSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyDebuggerSystemProperty(parsedArgs);
        applyInvokeWithSystemProperty(parsedArgs);
        int[][] rlimits = null;
        if (parsedArgs.rlimits != null) {
            rlimits = parsedArgs.rlimits.toArray(intArray2d);
        }
        if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
            FileDescriptor[] pipeFds = Libcore.os.pipe();
            childPipeFd = pipeFds[1];
            serverPipeFd = pipeFds[0];
            ZygoteInit.setCloseOnExec(serverPipeFd, true);
        }
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);
    } catch (IOException ex) {
        logAndPrintError(newStderr, "Exception creating pipe", ex);
    } catch (ErrnoException ex) {
        logAndPrintError(newStderr, "Exception creating pipe", ex);
    } catch (IllegalArgumentException ex) {
        logAndPrintError(newStderr, "Invalid zygote arguments", ex);
    } catch (ZygoteSecurityException ex) {
        logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex);
    }
    try {
        if (pid == 0) {
            // in child
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);
            // throw ZygoteInit.MethodAndArgsCaller or exec().
            return true;
        } else {
            // in parent...pid of < 0 means failure
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
Body of Second Method:
{
    String[] args;
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;
    long startTime = SystemClock.elapsedRealtime();
    try {
        args = readArgumentList();
        descriptors = mSocket.getAncillaryFileDescriptors();
    } catch (IOException ex) {
        Log.w(TAG, "IOException on command socket " + ex.getMessage());
        closeSocket();
        return true;
    }
    checkTime(startTime, "zygoteConnection.runOnce: readArgumentList");
    if (args == null) {
        // EOF reached.
        closeSocket();
        return true;
    }
    /**
     * the stderr of the most recent request, if avail
     */
    PrintStream newStderr = null;
    if (descriptors != null && descriptors.length >= 3) {
        newStderr = new PrintStream(new FileOutputStream(descriptors[2]));
    }
    int pid = -1;
    FileDescriptor childPipeFd = null;
    FileDescriptor serverPipeFd = null;
    try {
        parsedArgs = new Arguments(args);
        if (parsedArgs.abiListQuery) {
            return handleAbiListQuery();
        }
        if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
            throw new ZygoteSecurityException("Client may not specify capabilities: " + "permitted=0x" + Long.toHexString(parsedArgs.permittedCapabilities) + ", effective=0x" + Long.toHexString(parsedArgs.effectiveCapabilities));
        }
        applyUidSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyRlimitSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyInvokeWithSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        applyseInfoSecurityPolicy(parsedArgs, peer, peerSecurityContext);
        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
        applyDebuggerSystemProperty(parsedArgs);
        applyInvokeWithSystemProperty(parsedArgs);
        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
        int[][] rlimits = null;
        if (parsedArgs.rlimits != null) {
            rlimits = parsedArgs.rlimits.toArray(intArray2d);
        }
        if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
            FileDescriptor[] pipeFds = Os.pipe();
            childPipeFd = pipeFds[1];
            serverPipeFd = pipeFds[0];
            ZygoteInit.setCloseOnExec(serverPipeFd, true);
        }
        /**
         * In order to avoid leaking descriptors to the Zygote child,
         * the native code must close the two Zygote socket descriptors
         * in the child process before it switches from Zygote-root to
         * the UID and privileges of the application being launched.
         *
         * In order to avoid "bad file descriptor" errors when the
         * two LocalSocket objects are closed, the Posix file
         * descriptors are released via a dup2() call which closes
         * the socket and substitutes an open descriptor to /dev/null.
         */
        int[] fdsToClose = { -1, -1 };
        FileDescriptor fd = mSocket.getFileDescriptor();
        if (fd != null) {
            fdsToClose[0] = fd.getInt$();
        }
        fd = ZygoteInit.getServerSocketFileDescriptor();
        if (fd != null) {
            fdsToClose[1] = fd.getInt$();
        }
        fd = null;
        checkTime(startTime, "zygoteConnection.runOnce: preForkAndSpecialize");
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir);
        checkTime(startTime, "zygoteConnection.runOnce: postForkAndSpecialize");
    } catch (IOException ex) {
        logAndPrintError(newStderr, "Exception creating pipe", ex);
    } catch (ErrnoException ex) {
        logAndPrintError(newStderr, "Exception creating pipe", ex);
    } catch (IllegalArgumentException ex) {
        logAndPrintError(newStderr, "Invalid zygote arguments", ex);
    } catch (ZygoteSecurityException ex) {
        logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex);
    }
    try {
        if (pid == 0) {
            // in child
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);
            // throw ZygoteInit.MethodAndArgsCaller or exec().
            return true;
        } else {
            // in parent...pid of < 0 means failure
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.sendVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    if (!mVoiceCapable && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    mVolumePanel.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
Body of Second Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    // only when TV receives volume notification from Audio Receiver.
    if (mHdmiTvClient != null && streamType == AudioSystem.STREAM_MUSIC) {
        synchronized (mHdmiTvClient) {
            if (mHdmiSystemAudioSupported && ((flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) == 0)) {
                flags &= ~AudioManager.FLAG_SHOW_UI;
            }
        }
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Picture.getWidth:COMMENT
<android.graphics.Picture: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the width of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:

Body of Second Method:
{
    return nativeGetWidth(mNativePicture);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.registerMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.registerMediaButtonEventReceiverForCalls(ComponentName c)
 * precondition: c != null
 */

Body of Frist Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to register media button receiver for calls");
        return;
    }
    synchronized (mRCStack) {
        mMediaReceiverForCalls = c;
    }
}
Body of Second Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to register media button receiver for calls");
        return;
    }
    synchronized (mPRStack) {
        mMediaReceiverForCalls = c;
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.requestUpdateVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request an incremental volume update for this route.
 * @param direction Delta to apply to the current volume
 */

Body of Frist Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            final int volume = Math.max(0, Math.min(getVolume() + direction, getVolumeMax()));
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        Log.e(TAG, getClass().getSimpleName() + ".requestChangeVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
    }
}
Body of Second Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            final int volume = Math.max(0, Math.min(getVolume() + direction, getVolumeMax()));
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        sStatic.requestUpdateVolume(this, direction);
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.offsetChildrenTopAndBottom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Offset the vertical location of all children of this view by the specified number of pixels.
 *
 * @param offset the number of pixels to offset
 *
 * @hide
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    boolean invalidate = false;
    for (int i = 0; i < count; i++) {
        final View v = children[i];
        v.mTop += offset;
        v.mBottom += offset;
        if (v.mDisplayList != null) {
            invalidate = true;
            v.mDisplayList.offsetTopAndBottom(offset);
        }
    }
    if (invalidate) {
        invalidateViewProperty(false, false);
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    boolean invalidate = false;
    for (int i = 0; i < count; i++) {
        final View v = children[i];
        v.mTop += offset;
        v.mBottom += offset;
        if (v.mRenderNode != null) {
            invalidate = true;
            v.mRenderNode.offsetTopAndBottom(offset);
        }
    }
    if (invalidate) {
        invalidateViewProperty(false, false);
    }
    notifySubtreeAccessibilityStateChangedIfNeeded();
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.removeConfiguredNetworksAndDisableWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean removeConfiguredNetworksAndDisableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Remove configured networks and disable wifi
 */

Body of Frist Method:
{
    if (!disconnectAP()) {
        return false;
    }
    sleep(SHORT_TIMEOUT);
    if (!mWifiManager.setWifiEnabled(false)) {
        return false;
    }
    sleep(SHORT_TIMEOUT);
    return true;
}
Body of Second Method:
{
    if (!disconnectAP()) {
        return false;
    }
    SystemClock.sleep(SHORT_TIMEOUT);
    if (!mWifiManager.setWifiEnabled(false)) {
        return false;
    }
    SystemClock.sleep(SHORT_TIMEOUT);
    return true;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.isOpaque:COMMENT
<android.graphics.Canvas: boolean isOpaque()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return true if the device that the current layer draws into is opaque
 * (i.e. does not support per-pixel alpha).
 *
 * @return true if the device that the current layer draws into is opaque
 */

Body of Frist Method:

Body of Second Method:
{
    return native_isOpaque(mNativeCanvasWrapper);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.notifyLidSwitchChanged:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // do nothing if headless
    if (mHeadless)
        return;
    // lid changed state
    final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
    if (newLidState == mLidState) {
        return;
    }
    mLidState = newLidState;
    applyLidSwitchState();
    updateRotation(true);
    if (lidOpen) {
        mPowerManager.wakeUp(SystemClock.uptimeMillis());
    } else if (!mLidControlsSleep) {
        mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
    }
}
Body of Second Method:
{
    // lid changed state
    final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
    if (newLidState == mLidState) {
        return;
    }
    mLidState = newLidState;
    applyLidSwitchState();
    updateRotation(true);
    if (lidOpen) {
        mPowerManager.wakeUp(SystemClock.uptimeMillis());
    } else if (!mLidControlsSleep) {
        mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchDetachedFromWindow:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // If we still have a touch target, we are still in the process of
    // dispatching motion events to a child; we need to get rid of that
    // child to avoid dispatching events to it after the window is torn
    // down. To make sure we keep the child in a consistent state, we
    // first send it an ACTION_CANCEL motion event.
    cancelAndClearTouchTargets(null);
    // Similarly, set ACTION_EXIT to all hover targets and clear them.
    exitHoverTargets();
    // In case view is detached while transition is running
    mLayoutCalledWhileSuppressed = false;
    // Tear down our drag tracking
    mDragNotifiedChildren = null;
    if (mCurrentDrag != null) {
        mCurrentDrag.recycle();
        mCurrentDrag = null;
    }
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        children[i].dispatchDetachedFromWindow();
    }
    super.dispatchDetachedFromWindow();
}
Body of Second Method:
{
    // If we still have a touch target, we are still in the process of
    // dispatching motion events to a child; we need to get rid of that
    // child to avoid dispatching events to it after the window is torn
    // down. To make sure we keep the child in a consistent state, we
    // first send it an ACTION_CANCEL motion event.
    cancelAndClearTouchTargets(null);
    // Similarly, set ACTION_EXIT to all hover targets and clear them.
    exitHoverTargets();
    // In case view is detached while transition is running
    mLayoutCalledWhileSuppressed = false;
    // Tear down our drag tracking
    mDragNotifiedChildren = null;
    if (mCurrentDrag != null) {
        mCurrentDrag.recycle();
        mCurrentDrag = null;
    }
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        children[i].dispatchDetachedFromWindow();
    }
    clearDisappearingChildren();
    super.dispatchDetachedFromWindow();
}
------------------------
Find a functionally equivalent code:android.os.Parcel.readSerializable:COMMENT
Method Modifier: public      final       
Comment:/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 */

Body of Frist Method:
{
    String name = readString();
    if (name == null) {
        // return null, which indicates that the name wasn't found in the parcel.
        return null;
    }
    byte[] serializedData = createByteArray();
    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
    try {
        ObjectInputStream ois = new ObjectInputStream(bais);
        return (Serializable) ois.readObject();
    } catch (IOException ioe) {
        throw new RuntimeException("Parcelable encountered " + "IOException reading a Serializable object (name = " + name + ")", ioe);
    } catch (ClassNotFoundException cnfe) {
        throw new RuntimeException("Parcelable encountered" + "ClassNotFoundException reading a Serializable object (name = " + name + ")", cnfe);
    }
}
Body of Second Method:
{
    return readSerializable(null);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DependencyFinder.DependencyVisitor.MyMethodVisitor.visitFieldInsn:COMMENT
Method Modifier: public      
Comment:// field instruction

Body of Frist Method:
{
    // name is the field's name.
    // desc is the field's descriptor (see Type).
    considerDesc(desc);
}
Body of Second Method:
{
    // owner is the class that declares the field.
    considerName(owner);
    // desc is the field's descriptor (see Type).
    considerDesc(desc);
}
------------------------
Find a functionally equivalent code:android.os.storage.IMountService.changeEncryptionPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Changes the encryption password.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.launchHomeFromHotKey:COMMENT
Method Modifier: internal    
Comment:/**
 * A home key -> launch home action was detected.  Take the appropriate action
 * given the situation with the keyguard.
 */

Body of Frist Method:
{
    if (mKeyguardDelegate != null && mKeyguardDelegate.isShowingAndNotHidden()) {
    // don't launch home if keyguard showing
    } else if (!mHideLockScreen && mKeyguardDelegate.isInputRestricted()) {
        // when in keyguard restricted mode, must first verify unlock
        // before launching home
        mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

            public void onKeyguardExitResult(boolean success) {
                if (success) {
                    try {
                        ActivityManagerNative.getDefault().stopAppSwitches();
                    } catch (RemoteException e) {
                    }
                    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
                    startDockOrHome();
                }
            }
        });
    } else {
        // no keyguard stuff to worry about, just launch home!
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
        startDockOrHome();
    }
}
Body of Second Method:
{
    if (mKeyguardDelegate != null && mKeyguardDelegate.isShowingAndNotOccluded()) {
    // don't launch home if keyguard showing
    } else if (!mHideLockScreen && mKeyguardDelegate.isInputRestricted()) {
        // when in keyguard restricted mode, must first verify unlock
        // before launching home
        mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

            @Override
            public void onKeyguardExitResult(boolean success) {
                if (success) {
                    try {
                        ActivityManagerNative.getDefault().stopAppSwitches();
                    } catch (RemoteException e) {
                    }
                    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
                    startDockOrHome();
                }
            }
        });
    } else {
        // no keyguard stuff to worry about, just launch home!
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        if (mRecentsVisible) {
            // Hide Recents and notify it to launch Home
            awakenDreams();
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            hideRecentApps(false, true);
        } else {
            // Otherwise, just launch Home
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            startDockOrHome();
        }
    }
}
------------------------
Find a functionally equivalent code:android.text.SpannableStringInternal.setSpan:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    int nstart = start;
    int nend = end;
    checkRange("setSpan", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must start at paragraph boundary" + " (" + start + " follows " + c + ")");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must end at paragraph boundary" + " (" + end + " follows " + c + ")");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        int newsize = ArrayUtils.idealIntArraySize(mSpanCount + 1);
        Object[] newtags = new Object[newsize];
        int[] newdata = new int[newsize * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}
Body of Second Method:
{
    int nstart = start;
    int nend = end;
    checkRange("setSpan", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must start at paragraph boundary" + " (" + start + " follows " + c + ")");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must end at paragraph boundary" + " (" + end + " follows " + c + ")");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        Object[] newtags = ArrayUtils.newUnpaddedObjectArray(GrowingArrayUtils.growSize(mSpanCount));
        int[] newdata = new int[newtags.length * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setStroke:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Set the stroke width and color for the drawable. If width is zero,
 * then no stroke is drawn. This method can also be used to dash the stroke.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param width The width in pixels of the stroke
 * @param color The color of the stroke
 * @param dashWidth The length in pixels of the dashes, set to 0 to disable dashes
 * @param dashGap The gap in pixels between dashes
 *
 * @see #mutate()
 * @see #setStroke(int, int)
 */

Body of Frist Method:
{
    mGradientState.setStroke(width, color, dashWidth, dashGap);
    if (mStrokePaint == null) {
        mStrokePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mStrokePaint.setStyle(Paint.Style.STROKE);
    }
    mStrokePaint.setStrokeWidth(width);
    mStrokePaint.setColor(color);
    DashPathEffect e = null;
    if (dashWidth > 0) {
        e = new DashPathEffect(new float[] { dashWidth, dashGap }, 0);
    }
    mStrokePaint.setPathEffect(e);
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setStroke(width, ColorStateList.valueOf(color), dashWidth, dashGap);
    setStrokeInternal(width, color, dashWidth, dashGap);
}
------------------------
Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateSupplicantDetails:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Only updates details fetched from the supplicant @hide
 */

Body of Frist Method:
{
    validateDevice(device);
    WifiP2pDevice d = mDevices.get(device.deviceAddress);
    if (d != null) {
        d.deviceName = device.deviceName;
        d.primaryDeviceType = device.primaryDeviceType;
        d.secondaryDeviceType = device.secondaryDeviceType;
        d.wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;
        d.deviceCapability = device.deviceCapability;
        d.groupCapability = device.groupCapability;
        d.wfdInfo = device.wfdInfo;
        return;
    }
    // Not found, add a new one
    mDevices.put(device.deviceAddress, device);
}
Body of Second Method:
{
    validateDevice(device);
    WifiP2pDevice d = mDevices.get(device.deviceAddress);
    if (d != null) {
        d.deviceName = device.deviceName;
        d.primaryDeviceType = device.primaryDeviceType;
        d.secondaryDeviceType = device.secondaryDeviceType;
        d.wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;
        d.deviceCapability = device.deviceCapability;
        d.groupCapability = device.groupCapability;
        d.wfdInfo = device.wfdInfo;
        return;
    }
    // Not found, add a new one
    mDevices.put(device.deviceAddress, device);
}
------------------------
Find a functionally equivalent code:javax.obex.HeaderSet.setHeader:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the value of the header identifier to the value provided. The type
 * of object must correspond to the Java type defined in the description of
 * this interface. If <code>null</code> is passed as the
 * <code>headerValue</code> then the header will be removed from the set of
 * headers to include in the next request.
 * @param headerID the identifier to include in the message
 * @param headerValue the value of the header identifier
 * @throws IllegalArgumentException if the header identifier provided is not
 * one defined in this interface or a user-defined header; if the
 * type of <code>headerValue</code> is not the correct Java type as
 * defined in the description of this interface\
 */

Body of Frist Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
Body of Second Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mEmptyName = false;
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromXmlInner:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create from inside an XML document.  Called on a parser positioned at
 * a tag in an XML document, tries to create a Drawable from that tag.
 * Returns null if the tag is not a valid drawable.
 */

Body of Frist Method:
{
    Drawable drawable;
    final String name = parser.getName();
    if (name.equals("selector")) {
        drawable = new StateListDrawable();
    } else if (name.equals("level-list")) {
        drawable = new LevelListDrawable();
    } else if (name.equals("layer-list")) {
        drawable = new LayerDrawable();
    } else if (name.equals("transition")) {
        drawable = new TransitionDrawable();
    } else if (name.equals("color")) {
        drawable = new ColorDrawable();
    } else if (name.equals("shape")) {
        drawable = new GradientDrawable();
    } else if (name.equals("scale")) {
        drawable = new ScaleDrawable();
    } else if (name.equals("clip")) {
        drawable = new ClipDrawable();
    } else if (name.equals("rotate")) {
        drawable = new RotateDrawable();
    } else if (name.equals("animated-rotate")) {
        drawable = new AnimatedRotateDrawable();
    } else if (name.equals("animation-list")) {
        drawable = new AnimationDrawable();
    } else if (name.equals("inset")) {
        drawable = new InsetDrawable();
    } else if (name.equals("bitmap")) {
        // noinspection deprecation
        drawable = new BitmapDrawable(r);
        if (r != null) {
            ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
        }
    } else if (name.equals("nine-patch")) {
        drawable = new NinePatchDrawable();
        if (r != null) {
            ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
        }
    } else {
        throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
    }
    drawable.inflate(r, parser, attrs);
    return drawable;
}
Body of Second Method:
{
    return createFromXmlInner(r, parser, attrs, null);
}
------------------------
Find a functionally equivalent code:android.widget.RemoteViews.reapply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies all of the actions to the provided view.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param v The view to apply the actions to.  This should be the result of
 * the {@link #apply(Context,ViewGroup)} call.
 */

Body of Frist Method:
{
    reapply(context, v, null);
}
Body of Second Method:
{
    reapply(context, v, null);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onDeviceProvisioned:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDeviceProvisioned()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the device becomes provisioned
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.widget.TextView.getShadowColor:COMMENT
Method Modifier: public      
Comment:/**
 * @return the color of the shadow layer
 *
 * @see #setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 */

Body of Frist Method:
{
    return mTextPaint.shadowColor;
}
Body of Second Method:
{
    return mShadowColor;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.addStartingWindow:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!SHOW_STARTING_ANIMATIONS) {
        return null;
    }
    if (packageName == null) {
        return null;
    }
    WindowManager wm = null;
    View view = null;
    try {
        Context context = mContext;
        if (DEBUG_STARTING_WINDOW)
            Slog.d(TAG, "addStartingWindow " + packageName + ": nonLocalizedLabel=" + nonLocalizedLabel + " theme=" + Integer.toHexString(theme));
        if (theme != context.getThemeResId() || labelRes != 0) {
            try {
                context = context.createPackageContext(packageName, 0);
                context.setTheme(theme);
            } catch (PackageManager.NameNotFoundException e) {
            // Ignore
            }
        }
        Window win = PolicyManager.makeNewWindow(context);
        final TypedArray ta = win.getWindowStyle();
        if (ta.getBoolean(com.android.internal.R.styleable.Window_windowDisablePreview, false) || ta.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper, false)) {
            return null;
        }
        Resources r = context.getResources();
        win.setTitle(r.getText(labelRes, nonLocalizedLabel));
        win.setType(WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
        // Force the window flags: this is a fake window, so it is not really
        // touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM
        // flag because we do know that the next window will take input
        // focus, so we want to get the IME window up on top of us right away.
        win.setFlags(windowFlags | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, windowFlags | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
        win.setDefaultIcon(icon);
        win.setDefaultLogo(logo);
        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
        final WindowManager.LayoutParams params = win.getAttributes();
        params.token = appToken;
        params.packageName = packageName;
        params.windowAnimations = win.getWindowStyle().getResourceId(com.android.internal.R.styleable.Window_windowAnimationStyle, 0);
        params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;
        params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
        if (!compatInfo.supportsScreen()) {
            params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
        }
        params.setTitle("Starting " + packageName);
        wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        view = win.getDecorView();
        if (win.isFloating()) {
            // earlier.)
            return null;
        }
        if (DEBUG_STARTING_WINDOW)
            Slog.d(TAG, "Adding starting window for " + packageName + " / " + appToken + ": " + (view.getParent() != null ? view : null));
        wm.addView(view, params);
        // window manager... which we can tell by it having a parent.
        return view.getParent() != null ? view : null;
    } catch (WindowManager.BadTokenException e) {
        // ignore
        Log.w(TAG, appToken + " already running, starting window not displayed");
    } catch (RuntimeException e) {
        // don't crash if something else bad happens, for example a
        // failure loading resources because we are loading from an app
        // on external storage that has been unmounted.
        Log.w(TAG, appToken + " failed creating starting window", e);
    } finally {
        if (view != null && view.getParent() == null) {
            Log.w(TAG, "view not successfully added to wm, removing view");
            wm.removeViewImmediate(view);
        }
    }
    return null;
}
Body of Second Method:
{
    if (!SHOW_STARTING_ANIMATIONS) {
        return null;
    }
    if (packageName == null) {
        return null;
    }
    WindowManager wm = null;
    View view = null;
    try {
        Context context = mContext;
        if (DEBUG_STARTING_WINDOW)
            Slog.d(TAG, "addStartingWindow " + packageName + ": nonLocalizedLabel=" + nonLocalizedLabel + " theme=" + Integer.toHexString(theme));
        if (theme != context.getThemeResId() || labelRes != 0) {
            try {
                context = context.createPackageContext(packageName, 0);
                context.setTheme(theme);
            } catch (PackageManager.NameNotFoundException e) {
            // Ignore
            }
        }
        Window win = PolicyManager.makeNewWindow(context);
        final TypedArray ta = win.getWindowStyle();
        if (ta.getBoolean(com.android.internal.R.styleable.Window_windowDisablePreview, false) || ta.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper, false)) {
            return null;
        }
        Resources r = context.getResources();
        win.setTitle(r.getText(labelRes, nonLocalizedLabel));
        win.setType(WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
        // Force the window flags: this is a fake window, so it is not really
        // touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM
        // flag because we do know that the next window will take input
        // focus, so we want to get the IME window up on top of us right away.
        win.setFlags(windowFlags | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, windowFlags | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
        win.setDefaultIcon(icon);
        win.setDefaultLogo(logo);
        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT);
        final WindowManager.LayoutParams params = win.getAttributes();
        params.token = appToken;
        params.packageName = packageName;
        params.windowAnimations = win.getWindowStyle().getResourceId(com.android.internal.R.styleable.Window_windowAnimationStyle, 0);
        params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;
        params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
        if (!compatInfo.supportsScreen()) {
            params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
        }
        params.setTitle("Starting " + packageName);
        wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        view = win.getDecorView();
        if (win.isFloating()) {
            // earlier.)
            return null;
        }
        if (DEBUG_STARTING_WINDOW)
            Slog.d(TAG, "Adding starting window for " + packageName + " / " + appToken + ": " + (view.getParent() != null ? view : null));
        wm.addView(view, params);
        // window manager... which we can tell by it having a parent.
        return view.getParent() != null ? view : null;
    } catch (WindowManager.BadTokenException e) {
        // ignore
        Log.w(TAG, appToken + " already running, starting window not displayed. " + e.getMessage());
    } catch (RuntimeException e) {
        // don't crash if something else bad happens, for example a
        // failure loading resources because we are loading from an app
        // on external storage that has been unmounted.
        Log.w(TAG, appToken + " failed creating starting window", e);
    } finally {
        if (view != null && view.getParent() == null) {
            Log.w(TAG, "view not successfully added to wm, removing view");
            wm.removeViewImmediate(view);
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.CameraMetadata.getKeysStatic:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    ArrayList<Key<?>> keyList = new ArrayList<Key<?>>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(Key.class) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            Key<?> key;
            try {
                key = (Key<?>) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.get(key) != null) {
                keyList.add(key);
            }
        }
    }
    return keyList;
}
Body of Second Method:
{
    if (VERBOSE)
        Log.v(TAG, "getKeysStatic for " + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (VERBOSE) {
                        Log.v(TAG, "getKeysStatic - key was added - " + key);
                    }
                } else if (VERBOSE) {
                    Log.v(TAG, "getKeysStatic - key was filtered - " + key);
                }
            }
        }
    }
    return keyList;
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsContract.createDocument:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Bundle in = new Bundle();
    in.putString(Document.COLUMN_DOCUMENT_ID, getDocumentId(parentDocumentUri));
    in.putString(Document.COLUMN_MIME_TYPE, mimeType);
    in.putString(Document.COLUMN_DISPLAY_NAME, displayName);
    final Bundle out = client.call(METHOD_CREATE_DOCUMENT, null, in);
    return buildDocumentUri(parentDocumentUri.getAuthority(), out.getString(Document.COLUMN_DOCUMENT_ID));
}
Body of Second Method:
{
    final Bundle in = new Bundle();
    in.putParcelable(DocumentsContract.EXTRA_URI, parentDocumentUri);
    in.putString(Document.COLUMN_MIME_TYPE, mimeType);
    in.putString(Document.COLUMN_DISPLAY_NAME, displayName);
    final Bundle out = client.call(METHOD_CREATE_DOCUMENT, null, in);
    return out.getParcelable(DocumentsContract.EXTRA_URI);
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureResultKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */

Body of Frist Method:
{
    if (mAvailableResultKeys == null) {
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class);
    }
    return mAvailableResultKeys;
}
Body of Second Method:
{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableResultKeys must be non-null " + "in the characteristics");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags);
    }
    return mAvailableResultKeys;
}
------------------------
Find a functionally equivalent code:android.hardware.input.InputManager.InputDeviceVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    vibrate(pattern, repeat);
}
Body of Second Method:
{
    if (repeat >= pattern.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    try {
        mIm.vibrate(mDeviceId, pattern, repeat, mToken);
    } catch (RemoteException ex) {
        Log.w(TAG, "Failed to vibrate.", ex);
    }
}
------------------------
Find a functionally equivalent code:android.animation.AnimatorSet.start:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
 * it is responsible. The details of when exactly those animations are started depends on
 * the dependency relationships that have been set up between the animations.
 */

Body of Frist Method:
{
    mTerminated = false;
    mStarted = true;
    mPaused = false;
    if (mDuration >= 0) {
        // If the duration was set on this AnimatorSet, pass it along to all child animations
        for (Node node : mNodes) {
            // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
            // insert "play-after" delays
            node.animation.setDuration(mDuration);
        }
    }
    if (mInterpolator != null) {
        for (Node node : mNodes) {
            node.animation.setInterpolator(mInterpolator);
        }
    }
    // First, sort the nodes (if necessary). This will ensure that sortedNodes
    // contains the animation nodes in the correct order.
    sortNodes();
    int numSortedNodes = mSortedNodes.size();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        // First, clear out the old listeners
        ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
        if (oldListeners != null && oldListeners.size() > 0) {
            final ArrayList<AnimatorListener> clonedListeners = new ArrayList<AnimatorListener>(oldListeners);
            for (AnimatorListener listener : clonedListeners) {
                if (listener instanceof DependencyListener || listener instanceof AnimatorSetListener) {
                    node.animation.removeListener(listener);
                }
            }
        }
    }
    // nodesToStart holds the list of nodes to be started immediately. We don't want to
    // start the animations in the loop directly because we first need to set up
    // dependencies on all of the nodes. For example, we don't want to start an animation
    // when some other animation also wants to start when the first animation begins.
    final ArrayList<Node> nodesToStart = new ArrayList<Node>();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        if (mSetListener == null) {
            mSetListener = new AnimatorSetListener(this);
        }
        if (node.dependencies == null || node.dependencies.size() == 0) {
            nodesToStart.add(node);
        } else {
            int numDependencies = node.dependencies.size();
            for (int j = 0; j < numDependencies; ++j) {
                Dependency dependency = node.dependencies.get(j);
                dependency.node.animation.addListener(new DependencyListener(this, node, dependency.rule));
            }
            node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
        }
        node.animation.addListener(mSetListener);
    }
    // Now that all dependencies are set up, start the animations that should be started.
    if (mStartDelay <= 0) {
        for (Node node : nodesToStart) {
            node.animation.start();
            mPlayingSet.add(node.animation);
        }
    } else {
        mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
        mDelayAnim.setDuration(mStartDelay);
        mDelayAnim.addListener(new AnimatorListenerAdapter() {

            boolean canceled = false;

            public void onAnimationCancel(Animator anim) {
                canceled = true;
            }

            public void onAnimationEnd(Animator anim) {
                if (!canceled) {
                    int numNodes = nodesToStart.size();
                    for (int i = 0; i < numNodes; ++i) {
                        Node node = nodesToStart.get(i);
                        node.animation.start();
                        mPlayingSet.add(node.animation);
                    }
                }
                mDelayAnim = null;
            }
        });
        mDelayAnim.start();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationStart(this);
        }
    }
    if (mNodes.size() == 0 && mStartDelay == 0) {
        // Handle unusual case where empty AnimatorSet is started - should send out
        // end event immediately since the event will not be sent out at all otherwise
        mStarted = false;
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationEnd(this);
            }
        }
    }
}
Body of Second Method:
{
    mTerminated = false;
    mStarted = true;
    mPaused = false;
    for (Node node : mNodes) {
        node.animation.setAllowRunningAsynchronously(false);
    }
    if (mDuration >= 0) {
        // If the duration was set on this AnimatorSet, pass it along to all child animations
        for (Node node : mNodes) {
            // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
            // insert "play-after" delays
            node.animation.setDuration(mDuration);
        }
    }
    if (mInterpolator != null) {
        for (Node node : mNodes) {
            node.animation.setInterpolator(mInterpolator);
        }
    }
    // First, sort the nodes (if necessary). This will ensure that sortedNodes
    // contains the animation nodes in the correct order.
    sortNodes();
    int numSortedNodes = mSortedNodes.size();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        // First, clear out the old listeners
        ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
        if (oldListeners != null && oldListeners.size() > 0) {
            final ArrayList<AnimatorListener> clonedListeners = new ArrayList<AnimatorListener>(oldListeners);
            for (AnimatorListener listener : clonedListeners) {
                if (listener instanceof DependencyListener || listener instanceof AnimatorSetListener) {
                    node.animation.removeListener(listener);
                }
            }
        }
    }
    // nodesToStart holds the list of nodes to be started immediately. We don't want to
    // start the animations in the loop directly because we first need to set up
    // dependencies on all of the nodes. For example, we don't want to start an animation
    // when some other animation also wants to start when the first animation begins.
    final ArrayList<Node> nodesToStart = new ArrayList<Node>();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        if (mSetListener == null) {
            mSetListener = new AnimatorSetListener(this);
        }
        if (node.dependencies == null || node.dependencies.size() == 0) {
            nodesToStart.add(node);
        } else {
            int numDependencies = node.dependencies.size();
            for (int j = 0; j < numDependencies; ++j) {
                Dependency dependency = node.dependencies.get(j);
                dependency.node.animation.addListener(new DependencyListener(this, node, dependency.rule));
            }
            node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
        }
        node.animation.addListener(mSetListener);
    }
    // Now that all dependencies are set up, start the animations that should be started.
    if (mStartDelay <= 0) {
        for (Node node : nodesToStart) {
            node.animation.start();
            mPlayingSet.add(node.animation);
        }
    } else {
        mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
        mDelayAnim.setDuration(mStartDelay);
        mDelayAnim.addListener(new AnimatorListenerAdapter() {

            boolean canceled = false;

            public void onAnimationCancel(Animator anim) {
                canceled = true;
            }

            public void onAnimationEnd(Animator anim) {
                if (!canceled) {
                    int numNodes = nodesToStart.size();
                    for (int i = 0; i < numNodes; ++i) {
                        Node node = nodesToStart.get(i);
                        node.animation.start();
                        mPlayingSet.add(node.animation);
                    }
                }
                mDelayAnim = null;
            }
        });
        mDelayAnim.start();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationStart(this);
        }
    }
    if (mNodes.size() == 0 && mStartDelay == 0) {
        // Handle unusual case where empty AnimatorSet is started - should send out
        // end event immediately since the event will not be sent out at all otherwise
        mStarted = false;
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationEnd(this);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserRemoved:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserRemoved(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when a user is removed.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: 
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = PROPERTY_IMPORTANT_FOR_ACCESSIBILITY;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(UNDEFINED, UNDEFINED);
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(UNDEFINED, UNDEFINED);
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
------------------------
Find a functionally equivalent code:android.widget.ActivityChooserModel.loadActivitiesIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * Loads the activities for the current intent if needed which is
 * if they are not already loaded for the current intent.
 *
 * @return Whether loading was performed.
 */

Body of Frist Method:
{
    if (mReloadActivities && mIntent != null) {
        mReloadActivities = false;
        mActivities.clear();
        List<ResolveInfo> resolveInfos = mContext.getPackageManager().queryIntentActivities(mIntent, 0);
        final int resolveInfoCount = resolveInfos.size();
        for (int i = 0; i < resolveInfoCount; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            mActivities.add(new ActivityResolveInfo(resolveInfo));
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (mReloadActivities && mIntent != null) {
        mReloadActivities = false;
        mActivities.clear();
        List<ResolveInfo> resolveInfos = mContext.getPackageManager().queryIntentActivities(mIntent, 0);
        final int resolveInfoCount = resolveInfos.size();
        for (int i = 0; i < resolveInfoCount; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            ActivityInfo activityInfo = resolveInfo.activityInfo;
            if (ActivityManager.checkComponentPermission(activityInfo.permission, android.os.Process.myUid(), activityInfo.applicationInfo.uid, activityInfo.exported) == PackageManager.PERMISSION_GRANTED) {
                mActivities.add(new ActivityResolveInfo(resolveInfo));
            }
        }
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.setAlwaysShow:COMMENT
Method Modifier: public      
Comment:/**
 * @param alwaysShow Whether the fast scroll thumb should always be shown
 */

Body of Frist Method:
{
    if (mAlwaysShow != alwaysShow) {
        mAlwaysShow = alwaysShow;
        onStateDependencyChanged();
    }
}
Body of Second Method:
{
    if (mAlwaysShow != alwaysShow) {
        mAlwaysShow = alwaysShow;
        onStateDependencyChanged(false);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.dispatchMediaKeyEvent:COMMENT
Method Modifier: private     
Comment:/**
 * Handles the dispatching of the media button events to one of the registered listeners,
 * or if there was none, broadcast an ACTION_MEDIA_BUTTON intent to the rest of the system.
 * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
 * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
 * is dispatched.
 */

Body of Frist Method:
{
    if (needWakeLock) {
        mMediaEventWakeLock.acquire();
    }
    Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
    keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
    synchronized (mRCStack) {
        if (!mRCStack.empty()) {
            // send the intent that was registered by the client
            try {
                mRCStack.peek().mMediaIntent.send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
                keyIntent, this, mEventHandler);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending pending intent " + mRCStack.peek());
                e.printStackTrace();
            }
        } else {
            // through AudioManager
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            final long ident = Binder.clearCallingIdentity();
            try {
                mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL, null, mKeyEventDone, mEventHandler, Activity.RESULT_OK, null, null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }
}
Body of Second Method:
{
    if (needWakeLock) {
        mMediaEventWakeLock.acquire();
    }
    Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
    keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
    synchronized (mPRStack) {
        if (!mPRStack.empty()) {
            // send the intent that was registered by the client
            try {
                mPRStack.peek().getMediaButtonIntent().send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
                keyIntent, this, mEventHandler);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending pending intent " + mPRStack.peek());
                e.printStackTrace();
            }
        } else {
            // through AudioManager
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            final long ident = Binder.clearCallingIdentity();
            try {
                mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL, null, mKeyEventDone, mEventHandler, Activity.RESULT_OK, null, null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.EdgeEffect.onRelease:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the object is released after being pulled.
 * This will begin the "decay" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */

Body of Frist Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mEdgeAlphaStart = mEdgeAlpha;
    mEdgeScaleYStart = mEdgeScaleY;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mEdgeAlphaFinish = 0.f;
    mEdgeScaleYFinish = 0.f;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
Body of Second Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the first day of week.
 *
 * @return The first day of the week conforming to the {@link CalendarView}
 * APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

Body of Frist Method:
{
    return mFirstDayOfWeek;
}
Body of Second Method:
{
    return mDelegate.getFirstDayOfWeek();
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.turnScreenOn:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOn()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Turn screen on

Body of Frist Method:
{
    log("Turn screen on");
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    pm.wakeUp(SystemClock.uptimeMillis());
    // disable lock screen
    KeyguardManager km = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    if (km.inKeyguardRestrictedInputMode()) {
        sendKeys(KeyEvent.KEYCODE_MENU);
    }
}
Body of Second Method:
{
    logv("Turn screen on");
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    pm.wakeUp(SystemClock.uptimeMillis());
    // disable lock screen
    KeyguardManager km = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
    if (km.inKeyguardRestrictedInputMode()) {
        sendKeys(KeyEvent.KEYCODE_MENU);
    }
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.isPointInside:COMMENT
Method Modifier: private     
Comment:/**
 * Returns whether a coordinate is inside the scroller's activation area. If
 * there is a track image, touching anywhere within the thumb-width of the
 * track activates scrolling. Otherwise, the user has to touch inside thumb
 * itself.
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return Whether the coordinate is inside the scroller's activation area.
 */

Body of Frist Method:
{
    return isPointInsideX(x) && (mHasTrackImage || isPointInsideY(y));
}
Body of Second Method:
{
    return isPointInsideX(x) && (mTrackDrawable != null || isPointInsideY(y));
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.setArtworkConfiguration:COMMENT
Method Modifier: public      
Comment:/**
 * Set the maximum artwork image dimensions to be received in the metadata.
 * No bitmaps will be received unless this has been specified.
 * @param width the maximum width in pixels
 * @param height  the maximum height in pixels
 * @return true if the artwork dimension was successfully set.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    return setArtworkConfiguration(true, width, height);
}
Body of Second Method:
{
    return setArtworkConfiguration(true, width, height);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    ensureValidStreamType(streamType);
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamType);
    int oldIndex;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    if (mAppOps.noteOp(STEAM_VOLUME_OPS[streamTypeAlias], Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    synchronized (mSafeMediaVolumeState) {
        // reset any pending volume command
        mPendingVolumeCommand = null;
        oldIndex = streamState.getIndex(device);
        index = rescaleIndex(index * 10, streamType, streamTypeAlias);
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.setAvrcpAbsoluteVolume(index);
                }
            }
        }
        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
        if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
            flags |= AudioManager.FLAG_FIXED_VOLUME;
            // volume is either 0 or max allowed for fixed volume devices
            if (index != 0) {
                if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
                    index = mSafeMediaVolumeIndex;
                } else {
                    index = streamState.getMaxIndex();
                }
            }
        }
        if (!checkSafeMediaVolume(streamTypeAlias, index, device)) {
            mVolumePanel.postDisplaySafeVolumeWarning(flags);
            mPendingVolumeCommand = new StreamVolumeCommand(streamType, index, flags, device);
        } else {
            onSetStreamVolume(streamType, index, flags, device);
            index = mStreamStates[streamType].getIndex(device);
        }
    }
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
Body of Second Method:
{
    setStreamVolume(streamType, index, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.checkPasswordHistory:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Check to see if a password matches any of the passwords stored in the
 * password history.
 *
 * @param password The password to check.
 * @return Whether the password matches any in the history.
 */

Body of Frist Method:
{
    String passwordHashString = new String(passwordToHash(password));
    String passwordHistory = getString(PASSWORD_HISTORY_KEY);
    if (passwordHistory == null) {
        return false;
    }
    // Password History may be too long...
    int passwordHashLength = passwordHashString.length();
    int passwordHistoryLength = getRequestedPasswordHistoryLength();
    if (passwordHistoryLength == 0) {
        return false;
    }
    int neededPasswordHistoryLength = passwordHashLength * passwordHistoryLength + passwordHistoryLength - 1;
    if (passwordHistory.length() > neededPasswordHistoryLength) {
        passwordHistory = passwordHistory.substring(0, neededPasswordHistoryLength);
    }
    return passwordHistory.contains(passwordHashString);
}
Body of Second Method:
{
    String passwordHashString = new String(passwordToHash(password, getCurrentOrCallingUserId()));
    String passwordHistory = getString(PASSWORD_HISTORY_KEY);
    if (passwordHistory == null) {
        return false;
    }
    // Password History may be too long...
    int passwordHashLength = passwordHashString.length();
    int passwordHistoryLength = getRequestedPasswordHistoryLength();
    if (passwordHistoryLength == 0) {
        return false;
    }
    int neededPasswordHistoryLength = passwordHashLength * passwordHistoryLength + passwordHistoryLength - 1;
    if (passwordHistory.length() > neededPasswordHistoryLength) {
        passwordHistory = passwordHistory.substring(0, neededPasswordHistoryLength);
    }
    return passwordHistory.contains(passwordHashString);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.setNewRcClientOnDisplays_syncRcsCurrc:COMMENT
Method Modifier: private     
Comment:/**
 * Update the remote control displays with the new "focused" client generation
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        if (mRcDisplays.size() > 0) {
            final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
            while (displayIterator.hasNext()) {
                final DisplayInfoForServer di = displayIterator.next();
                try {
                    di.mRcDisplay.setCurrentClientId(newClientGeneration, newMediaIntent, clearing);
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc()", e);
                    di.release();
                    displayIterator.remove();
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        if (mRcDisplays.size() > 0) {
            final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
            while (displayIterator.hasNext()) {
                final DisplayInfoForServer di = displayIterator.next();
                try {
                    di.mRcDisplay.setCurrentClientId(newClientGeneration, newMediaIntent, clearing);
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc()", e);
                    di.release();
                    displayIterator.remove();
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

Body of Frist Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        constructor.setAccessible(true);
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.length:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of values in this array.
 */

Body of Frist Method:
{
    return mLength;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mLength;
}
------------------------
Find a functionally equivalent code:android.text.GraphicsOperations.getTextRunAdvances:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Paint#getTextRunAdvances}.
 * @hide
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.print.PrintManager.getGlobalPrintManagerForUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates an instance that can access all print jobs.
 *
 * @param userId The user id for which to get all print jobs.
 * @return An instance if the caller has the permission to access all print
 * jobs, null otherwise.
 * @hide
 */

Body of Frist Method:
{
    return new PrintManager(mContext, mService, userId, APP_ID_ANY);
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    return new PrintManager(mContext, mService, userId, APP_ID_ANY);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.RotarySelector.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

Body of Frist Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration);
    }
}
Body of Second Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
    }
}
------------------------
Find a functionally equivalent code:android.widget.Switch.setThumbResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param resId Resource ID of a thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

Body of Frist Method:
{
    setThumbDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setThumbDrawable(getContext().getDrawable(resId));
}
------------------------
Find a functionally equivalent code:android.content.res.ColorStateList.withAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new ColorStateList that has the same states and
 * colors as this one but where each color has the specified alpha value
 * (0-255).
 */

Body of Frist Method:
{
    int[] colors = new int[mColors.length];
    int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}
Body of Second Method:
{
    final int[] colors = new int[mColors.length];
    final int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}
------------------------
Find a functionally equivalent code:android.content.Intent.parseIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parses the "intent" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named "intent"), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name="xxx"> tags to add categories and
 * <extra android:name="xxx" android:value="yyy"> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an "intent" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */

Body of Frist Method:
{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals("category")) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals("extra")) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra("extra", attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}
Body of Second Method:
{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(TAG_CATEGORIES)) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(TAG_EXTRA)) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleSwitching:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching back and forth from having connectivity to
 * having no connectivity using both WiFi and airplane mode.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_5MB_FILENAME;
    long filesize = DOWNLOAD_5MB_FILESIZE;
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_MOBILE | Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // make sure we're starting to download some data...
        waitForFileToGrow(downloadedFile);
        // download disable
        setWiFiStateOn(false);
        // download disable
        Log.i(LOG_TAG, "Turning on airplane mode...");
        setAirplaneModeOn(true);
        // wait 30 secs
        Thread.sleep(30 * 1000);
        // download disable
        setWiFiStateOn(true);
        // wait 30 secs
        Thread.sleep(30 * 1000);
        // download enable
        Log.i(LOG_TAG, "Turning off airplane mode...");
        setAirplaneModeOn(false);
        // wait 5 seconds
        Thread.sleep(5 * 1000);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 30 secs
        Thread.sleep(30 * 1000);
        // finally, turn WiFi back on and finish up the download
        Log.i(LOG_TAG, "Turning on WiFi...");
        setWiFiStateOn(true);
        Log.i(LOG_TAG, "Waiting up to 3 minutes for download to complete...");
        waitForDownloadsOrTimeout(dlRequest, 3 * 60 * 1000);
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    long filesize = DOWNLOAD_FILESIZE;
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_MOBILE | Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // make sure we're starting to download some data...
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download disable
        setWiFiStateOn(false);
        // download disable
        Log.i(LOG_TAG, "Turning on airplane mode...");
        setAirplaneModeOn(true);
        // wait 5 secs
        Thread.sleep(5 * 1000);
        // download disable
        setWiFiStateOn(true);
        // wait 5 secs
        Thread.sleep(5 * 1000);
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download enable
        Log.i(LOG_TAG, "Turning off airplane mode...");
        setAirplaneModeOn(false);
        // wait 5 seconds
        Thread.sleep(5 * 1000);
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 5 secs
        Thread.sleep(5 * 1000);
        // finally, turn WiFi back on and finish up the download
        Log.i(LOG_TAG, "Turning on WiFi...");
        setWiFiStateOn(true);
        Log.i(LOG_TAG, "Waiting up to 10 minutes for download to complete...");
        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default maximal date is 12/31/2100.
 * <p>
 *
 * @return The maximal supported date.
 */

Body of Frist Method:
{
    return mCalendarView.getMaxDate();
}
Body of Second Method:
{
    return mDelegate.getMaxDate().getTimeInMillis();
}
------------------------
Find a functionally equivalent code:android.view.Window.setDimAmount:COMMENT
Method Modifier: public      
Comment:/**
 * Set the amount of dim behind the window when using
 * {@link WindowManager.LayoutParams#FLAG_DIM_BEHIND}.  This overrides
 * the default dim amount of that is selected by the Window based on
 * its theme.
 *
 * @param amount The new dim amount, from 0 for no dim to 1 for full dim.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.dimAmount = amount;
    mHaveDimAmount = true;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.dimAmount = amount;
    mHaveDimAmount = true;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHostView.updateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */

Body of Frist Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycled existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, "updateAppWidget couldn't find any view, using error view", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}
Body of Second Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycled existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, "updateAppWidget couldn't find any view, using error view", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getIndexCount:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of indices in the array that actually have data.
 */

Body of Frist Method:
{
    return mIndices[0];
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mIndices[0];
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.handleKeyguardVisibilityChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Handle {@link #MSG_KEYGUARD_VISIBILITY_CHANGED}
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "handleKeyguardVisibilityChanged(" + showing + ")");
    boolean isShowing = (showing == 1);
    mKeyguardIsVisible = isShowing;
    for (int i = 0; i < mCallbacks.size(); i++) {
        KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
        if (cb != null) {
            cb.onKeyguardVisibilityChanged(isShowing);
        }
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "handleKeyguardVisibilityChanged(" + showing + ")");
    boolean isShowing = (showing == 1);
    mKeyguardIsVisible = isShowing;
    for (int i = 0; i < mCallbacks.size(); i++) {
        KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
        if (cb != null) {
            cb.onKeyguardVisibilityChangedRaw(isShowing);
        }
    }
}
------------------------
Find a functionally equivalent code:android.util.EventLog.Event.getData:COMMENT
Method Modifier: public      
Comment:/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */

Body of Frist Method:
{
    try {
        mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(DATA_START);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        return null;
    }
}
Body of Second Method:
{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.app.SearchDialog.updateSearchBadge:COMMENT
Method Modifier: private     
Comment:/**
 * Setup the search "Badge" if requested by mode flags.
 */

Body of Frist Method:
{
    // assume both hidden
    int visibility = View.GONE;
    Drawable icon = null;
    CharSequence text = null;
    // optionally show one or the other.
    if (mSearchable.useBadgeIcon()) {
        icon = mActivityContext.getResources().getDrawable(mSearchable.getIconId());
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());
    } else if (mSearchable.useBadgeLabel()) {
        text = mActivityContext.getResources().getText(mSearchable.getLabelId()).toString();
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge label: " + mSearchable.getLabelId());
    }
    mBadgeLabel.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
    mBadgeLabel.setText(text);
    mBadgeLabel.setVisibility(visibility);
}
Body of Second Method:
{
    // assume both hidden
    int visibility = View.GONE;
    Drawable icon = null;
    CharSequence text = null;
    // optionally show one or the other.
    if (mSearchable.useBadgeIcon()) {
        icon = mActivityContext.getDrawable(mSearchable.getIconId());
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());
    } else if (mSearchable.useBadgeLabel()) {
        text = mActivityContext.getResources().getText(mSearchable.getLabelId()).toString();
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge label: " + mSearchable.getLabelId());
    }
    mBadgeLabel.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
    mBadgeLabel.setText(text);
    mBadgeLabel.setVisibility(visibility);
}
------------------------
Find a functionally equivalent code:android.content.Intent.migrateExtraStreamToClipData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
 * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
 * intents in {@link #ACTION_CHOOSER}.
 *
 * @return Whether any contents were migrated.
 * @hide
 */

Body of Frist Method:
{
    // Refuse to touch if extras already parcelled
    if (mExtras != null && mExtras.isParcelled())
        return false;
    // Bail when someone already gave us ClipData
    if (getClipData() != null)
        return false;
    final String action = getAction();
    if (ACTION_CHOOSER.equals(action)) {
        try {
            // Inspect target intent to see if we need to migrate
            final Intent target = getParcelableExtra(EXTRA_INTENT);
            if (target != null && target.migrateExtraStreamToClipData()) {
                // Since we migrated in child, we need to promote ClipData
                // and flags to ourselves to grant.
                setClipData(target.getClipData());
                addFlags(target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION));
                return true;
            } else {
                return false;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND.equals(action)) {
        try {
            final Uri stream = getParcelableExtra(EXTRA_STREAM);
            final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
            final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
            if (stream != null || text != null || htmlText != null) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, new ClipData.Item(text, htmlText, null, stream));
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND_MULTIPLE.equals(action)) {
        try {
            final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
            final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
            final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
            int num = -1;
            if (streams != null) {
                num = streams.size();
            }
            if (texts != null) {
                if (num >= 0 && num != texts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = texts.size();
            }
            if (htmlTexts != null) {
                if (num >= 0 && num != htmlTexts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = htmlTexts.size();
            }
            if (num > 0) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, makeClipItem(streams, texts, htmlTexts, 0));
                for (int i = 1; i < num; i++) {
                    clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
                }
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    }
    return false;
}
Body of Second Method:
{
    // Refuse to touch if extras already parcelled
    if (mExtras != null && mExtras.isParcelled())
        return false;
    // Bail when someone already gave us ClipData
    if (getClipData() != null)
        return false;
    final String action = getAction();
    if (ACTION_CHOOSER.equals(action)) {
        // Inspect contained intents to see if we need to migrate extras. We
        // don't promote ClipData to the parent, since ChooserActivity will
        // already start the picked item as the caller, and we can't combine
        // the flags in a safe way.
        boolean migrated = false;
        try {
            final Intent intent = getParcelableExtra(EXTRA_INTENT);
            if (intent != null) {
                migrated |= intent.migrateExtraStreamToClipData();
            }
        } catch (ClassCastException e) {
        }
        try {
            final Parcelable[] intents = getParcelableArrayExtra(EXTRA_INITIAL_INTENTS);
            if (intents != null) {
                for (int i = 0; i < intents.length; i++) {
                    final Intent intent = (Intent) intents[i];
                    if (intent != null) {
                        migrated |= intent.migrateExtraStreamToClipData();
                    }
                }
            }
        } catch (ClassCastException e) {
        }
        return migrated;
    } else if (ACTION_SEND.equals(action)) {
        try {
            final Uri stream = getParcelableExtra(EXTRA_STREAM);
            final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
            final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
            if (stream != null || text != null || htmlText != null) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, new ClipData.Item(text, htmlText, null, stream));
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND_MULTIPLE.equals(action)) {
        try {
            final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
            final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
            final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
            int num = -1;
            if (streams != null) {
                num = streams.size();
            }
            if (texts != null) {
                if (num >= 0 && num != texts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = texts.size();
            }
            if (htmlTexts != null) {
                if (num >= 0 && num != htmlTexts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = htmlTexts.size();
            }
            if (num > 0) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, makeClipItem(streams, texts, htmlTexts, 0));
                for (int i = 1; i < num; i++) {
                    clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
                }
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (MediaStore.ACTION_IMAGE_CAPTURE.equals(action) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(action) || MediaStore.ACTION_VIDEO_CAPTURE.equals(action)) {
        final Uri output;
        try {
            output = getParcelableExtra(MediaStore.EXTRA_OUTPUT);
        } catch (ClassCastException e) {
            return false;
        }
        if (output != null) {
            setClipData(ClipData.newRawUri("", output));
            addFlags(FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_READ_URI_PERMISSION);
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.setScreenBright:COMMENT
Method Modifier: public      
Comment:/**
 * Marks this dream as keeping the screen bright while dreaming.
 *
 * @param screenBright True to keep the screen bright while dreaming.
 */

Body of Frist Method:
{
    mScreenBright = screenBright;
    int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
    applyWindowFlags(mScreenBright ? flag : 0, flag);
}
Body of Second Method:
{
    if (mScreenBright != screenBright) {
        mScreenBright = screenBright;
        int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        applyWindowFlags(mScreenBright ? flag : 0, flag);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.preparePanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Prepares the panel to either be opened or chorded. This creates the Menu
 * instance for the panel and populates it via the Activity callbacks.
 *
 * @param st The panel state to prepare.
 * @param event The event that triggered the preparing of the panel.
 * @return Whether the panel was prepared. If the panel should not be shown,
 * returns false.
 */

Body of Frist Method:
{
    if (isDestroyed()) {
        return false;
    }
    // Already prepared (isPrepared will be reset to false later)
    if (st.isPrepared) {
        return true;
    }
    if ((mPreparedPanel != null) && (mPreparedPanel != st)) {
        // Another Panel is prepared and possibly open, so close it
        closePanel(mPreparedPanel, false);
    }
    final Callback cb = getCallback();
    if (cb != null) {
        st.createdPanelView = cb.onCreatePanelView(st.featureId);
    }
    final boolean isActionBarMenu = (st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR);
    if (isActionBarMenu && mActionBar != null) {
        // Enforce ordering guarantees around events so that the action bar never
        // dispatches menu-related events before the panel is prepared.
        mActionBar.setMenuPrepared();
    }
    if (st.createdPanelView == null) {
        // Init the panel state's menu--return false if init failed
        if (st.menu == null || st.refreshMenuContent) {
            if (st.menu == null) {
                if (!initializePanelMenu(st) || (st.menu == null)) {
                    return false;
                }
            }
            if (isActionBarMenu && mActionBar != null) {
                if (mActionMenuPresenterCallback == null) {
                    mActionMenuPresenterCallback = new ActionMenuPresenterCallback();
                }
                mActionBar.setMenu(st.menu, mActionMenuPresenterCallback);
            }
            // Call callback, and return if it doesn't want to display menu.
            // Creating the panel menu will involve a lot of manipulation;
            // don't dispatch change events to presenters until we're done.
            st.menu.stopDispatchingItemsChanged();
            if ((cb == null) || !cb.onCreatePanelMenu(st.featureId, st.menu)) {
                // Ditch the menu created above
                st.setMenu(null);
                if (isActionBarMenu && mActionBar != null) {
                    // Don't show it in the action bar either
                    mActionBar.setMenu(null, mActionMenuPresenterCallback);
                }
                return false;
            }
            st.refreshMenuContent = false;
        }
        // Callback and return if the callback does not want to show the menu
        // Preparing the panel menu can involve a lot of manipulation;
        // don't dispatch change events to presenters until we're done.
        st.menu.stopDispatchingItemsChanged();
        // an opportunity to override frozen/restored state in onPrepare.
        if (st.frozenActionViewState != null) {
            st.menu.restoreActionViewStates(st.frozenActionViewState);
            st.frozenActionViewState = null;
        }
        if (!cb.onPreparePanel(st.featureId, st.createdPanelView, st.menu)) {
            if (isActionBarMenu && mActionBar != null) {
                // The app didn't want to show the menu for now but it still exists.
                // Clear it out of the action bar.
                mActionBar.setMenu(null, mActionMenuPresenterCallback);
            }
            st.menu.startDispatchingItemsChanged();
            return false;
        }
        // Set the proper keymap
        KeyCharacterMap kmap = KeyCharacterMap.load(event != null ? event.getDeviceId() : KeyCharacterMap.VIRTUAL_KEYBOARD);
        st.qwertyMode = kmap.getKeyboardType() != KeyCharacterMap.NUMERIC;
        st.menu.setQwertyMode(st.qwertyMode);
        st.menu.startDispatchingItemsChanged();
    }
    // Set other state
    st.isPrepared = true;
    st.isHandled = false;
    mPreparedPanel = st;
    return true;
}
Body of Second Method:
{
    if (isDestroyed()) {
        return false;
    }
    // Already prepared (isPrepared will be reset to false later)
    if (st.isPrepared) {
        return true;
    }
    if ((mPreparedPanel != null) && (mPreparedPanel != st)) {
        // Another Panel is prepared and possibly open, so close it
        closePanel(mPreparedPanel, false);
    }
    final Callback cb = getCallback();
    if (cb != null) {
        st.createdPanelView = cb.onCreatePanelView(st.featureId);
    }
    final boolean isActionBarMenu = (st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR);
    if (isActionBarMenu && mDecorContentParent != null) {
        // Enforce ordering guarantees around events so that the action bar never
        // dispatches menu-related events before the panel is prepared.
        mDecorContentParent.setMenuPrepared();
    }
    if (st.createdPanelView == null) {
        // Init the panel state's menu--return false if init failed
        if (st.menu == null || st.refreshMenuContent) {
            if (st.menu == null) {
                if (!initializePanelMenu(st) || (st.menu == null)) {
                    return false;
                }
            }
            if (isActionBarMenu && mDecorContentParent != null) {
                if (mActionMenuPresenterCallback == null) {
                    mActionMenuPresenterCallback = new ActionMenuPresenterCallback();
                }
                mDecorContentParent.setMenu(st.menu, mActionMenuPresenterCallback);
            }
            // Call callback, and return if it doesn't want to display menu.
            // Creating the panel menu will involve a lot of manipulation;
            // don't dispatch change events to presenters until we're done.
            st.menu.stopDispatchingItemsChanged();
            if ((cb == null) || !cb.onCreatePanelMenu(st.featureId, st.menu)) {
                // Ditch the menu created above
                st.setMenu(null);
                if (isActionBarMenu && mDecorContentParent != null) {
                    // Don't show it in the action bar either
                    mDecorContentParent.setMenu(null, mActionMenuPresenterCallback);
                }
                return false;
            }
            st.refreshMenuContent = false;
        }
        // Callback and return if the callback does not want to show the menu
        // Preparing the panel menu can involve a lot of manipulation;
        // don't dispatch change events to presenters until we're done.
        st.menu.stopDispatchingItemsChanged();
        // an opportunity to override frozen/restored state in onPrepare.
        if (st.frozenActionViewState != null) {
            st.menu.restoreActionViewStates(st.frozenActionViewState);
            st.frozenActionViewState = null;
        }
        if (!cb.onPreparePanel(st.featureId, st.createdPanelView, st.menu)) {
            if (isActionBarMenu && mDecorContentParent != null) {
                // The app didn't want to show the menu for now but it still exists.
                // Clear it out of the action bar.
                mDecorContentParent.setMenu(null, mActionMenuPresenterCallback);
            }
            st.menu.startDispatchingItemsChanged();
            return false;
        }
        // Set the proper keymap
        KeyCharacterMap kmap = KeyCharacterMap.load(event != null ? event.getDeviceId() : KeyCharacterMap.VIRTUAL_KEYBOARD);
        st.qwertyMode = kmap.getKeyboardType() != KeyCharacterMap.NUMERIC;
        st.menu.setQwertyMode(st.qwertyMode);
        st.menu.startDispatchingItemsChanged();
    }
    // Set other state
    st.isPrepared = true;
    st.isHandled = false;
    mPreparedPanel = st;
    return true;
}
------------------------
Find a functionally equivalent code:android.speech.tts.TextToSpeech.addEarcon:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>"[tick]"</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>"com.google.marvin.compass"</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */

Body of Frist Method:
{
    synchronized (mStartLock) {
        mEarcons.put(earcon, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}
Body of Second Method:
{
    synchronized (mStartLock) {
        mEarcons.put(earcon, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on touchEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}
Body of Second Method:
{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on touchEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}
------------------------
Find a functionally equivalent code:android.os.Parcel.readValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */

Body of Frist Method:
{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable();
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException("Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);
    }
}
Body of Second Method:
{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException("Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.onItemsChanged:COMMENT
<com.android.internal.view.menu.MenuBuilder: void onItemsChanged(boolean)>
Method Modifier: public      internal    
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Called when an item is added or removed.
 *
 * @param structureChanged true if the menu structure changed,
 * false if only item properties changed.
 * (Visibility is a structural property since it affects layout.)
 */

Body of Frist Method:
{
    if (!mPreventDispatchingItemsChanged) {
        if (structureChanged) {
            mIsVisibleItemsStale = true;
            mIsActionItemsStale = true;
        }
        dispatchPresenterUpdate(structureChanged);
    } else {
        mItemsChangedWhileDispatchPrevented = true;
    }
}
Body of Second Method:
{
    if (!mPreventDispatchingItemsChanged) {
        if (structureChanged) {
            mIsVisibleItemsStale = true;
            mIsActionItemsStale = true;
        }
        dispatchPresenterUpdate(structureChanged);
    } else {
        mItemsChangedWhileDispatchPrevented = true;
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the view for which the view represented by this info serves as a
 * label for accessibility purposes.
 *
 * @param labeled The view for which this info serves as a label.
 */

Body of Frist Method:
{
    setLabelFor(labeled, UNDEFINED);
}
Body of Second Method:
{
    setLabelFor(labeled, UNDEFINED_ITEM_ID);
}
------------------------
Find a functionally equivalent code:android.text.Layout.drawBackground:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // They are evaluated at each line.
    if (mSpannedText) {
        if (mLineBackgroundSpans == null) {
            mLineBackgroundSpans = new SpanSet<LineBackgroundSpan>(LineBackgroundSpan.class);
        }
        Spanned buffer = (Spanned) mText;
        int textLength = buffer.length();
        mLineBackgroundSpans.init(buffer, 0, textLength);
        if (mLineBackgroundSpans.numberOfSpans > 0) {
            int previousLineBottom = getLineTop(firstLine);
            int previousLineEnd = getLineStart(firstLine);
            ParagraphStyle[] spans = NO_PARA_SPANS;
            int spansLength = 0;
            TextPaint paint = mPaint;
            int spanEnd = 0;
            final int width = mWidth;
            for (int i = firstLine; i <= lastLine; i++) {
                int start = previousLineEnd;
                int end = getLineStart(i + 1);
                previousLineEnd = end;
                int ltop = previousLineBottom;
                int lbottom = getLineTop(i + 1);
                previousLineBottom = lbottom;
                int lbaseline = lbottom - getLineDescent(i);
                if (start >= spanEnd) {
                    // These should be infrequent, so we'll use this so that
                    // we don't have to check as often.
                    spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength);
                    // All LineBackgroundSpans on a line contribute to its background.
                    spansLength = 0;
                    // Duplication of the logic of getParagraphSpans
                    if (start != end || start == 0) {
                        // array instead to reduce memory allocation
                        for (int j = 0; j < mLineBackgroundSpans.numberOfSpans; j++) {
                            // construction
                            if (mLineBackgroundSpans.spanStarts[j] >= end || mLineBackgroundSpans.spanEnds[j] <= start)
                                continue;
                            if (spansLength == spans.length) {
                                // The spans array needs to be expanded
                                int newSize = ArrayUtils.idealObjectArraySize(2 * spansLength);
                                ParagraphStyle[] newSpans = new ParagraphStyle[newSize];
                                System.arraycopy(spans, 0, newSpans, 0, spansLength);
                                spans = newSpans;
                            }
                            spans[spansLength++] = mLineBackgroundSpans.spans[j];
                        }
                    }
                }
                for (int n = 0; n < spansLength; n++) {
                    LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n];
                    lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                }
            }
        }
        mLineBackgroundSpans.recycle();
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0)
            canvas.translate(0, cursorOffsetVertical);
        canvas.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0)
            canvas.translate(0, -cursorOffsetVertical);
    }
}
Body of Second Method:
{
    // They are evaluated at each line.
    if (mSpannedText) {
        if (mLineBackgroundSpans == null) {
            mLineBackgroundSpans = new SpanSet<LineBackgroundSpan>(LineBackgroundSpan.class);
        }
        Spanned buffer = (Spanned) mText;
        int textLength = buffer.length();
        mLineBackgroundSpans.init(buffer, 0, textLength);
        if (mLineBackgroundSpans.numberOfSpans > 0) {
            int previousLineBottom = getLineTop(firstLine);
            int previousLineEnd = getLineStart(firstLine);
            ParagraphStyle[] spans = NO_PARA_SPANS;
            int spansLength = 0;
            TextPaint paint = mPaint;
            int spanEnd = 0;
            final int width = mWidth;
            for (int i = firstLine; i <= lastLine; i++) {
                int start = previousLineEnd;
                int end = getLineStart(i + 1);
                previousLineEnd = end;
                int ltop = previousLineBottom;
                int lbottom = getLineTop(i + 1);
                previousLineBottom = lbottom;
                int lbaseline = lbottom - getLineDescent(i);
                if (start >= spanEnd) {
                    // These should be infrequent, so we'll use this so that
                    // we don't have to check as often.
                    spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength);
                    // All LineBackgroundSpans on a line contribute to its background.
                    spansLength = 0;
                    // Duplication of the logic of getParagraphSpans
                    if (start != end || start == 0) {
                        // array instead to reduce memory allocation
                        for (int j = 0; j < mLineBackgroundSpans.numberOfSpans; j++) {
                            // construction
                            if (mLineBackgroundSpans.spanStarts[j] >= end || mLineBackgroundSpans.spanEnds[j] <= start)
                                continue;
                            spans = GrowingArrayUtils.append(spans, spansLength, mLineBackgroundSpans.spans[j]);
                            spansLength++;
                        }
                    }
                }
                for (int n = 0; n < spansLength; n++) {
                    LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n];
                    lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                }
            }
        }
        mLineBackgroundSpans.recycle();
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0)
            canvas.translate(0, cursorOffsetVertical);
        canvas.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0)
            canvas.translate(0, -cursorOffsetVertical);
    }
}
------------------------
Find a functionally equivalent code:android.widget.ShareActionProvider.setActivityChooserPolicyIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * Set the activity chooser policy of the model backed by the current
 * share history file if needed which is if there is a registered callback.
 */

Body of Frist Method:
{
    if (mOnShareTargetSelectedListener == null) {
        return;
    }
    if (mOnChooseActivityListener == null) {
        mOnChooseActivityListener = new ShareAcitivityChooserModelPolicy();
    }
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    dataModel.setOnChooseActivityListener(mOnChooseActivityListener);
}
Body of Second Method:
{
    if (mOnShareTargetSelectedListener == null) {
        return;
    }
    if (mOnChooseActivityListener == null) {
        mOnChooseActivityListener = new ShareActivityChooserModelPolicy();
    }
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    dataModel.setOnChooseActivityListener(mOnChooseActivityListener);
}
------------------------
Find a functionally equivalent code:android.util.SparseLongArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            growKeyAndValueArrays(mSize + 1);
        }
        if (mSize - i != 0) {
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.computePasswordQuality:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Compute the password quality from the given password string.
 */

Body of Frist Method:
{
    boolean hasDigit = false;
    boolean hasNonDigit = false;
    final int len = password.length();
    for (int i = 0; i < len; i++) {
        if (Character.isDigit(password.charAt(i))) {
            hasDigit = true;
        } else {
            hasNonDigit = true;
        }
    }
    if (hasNonDigit && hasDigit) {
        return DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;
    }
    if (hasNonDigit) {
        return DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;
    }
    if (hasDigit) {
        return DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
    }
    return DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
}
Body of Second Method:
{
    boolean hasDigit = false;
    boolean hasNonDigit = false;
    final int len = password.length();
    for (int i = 0; i < len; i++) {
        if (Character.isDigit(password.charAt(i))) {
            hasDigit = true;
        } else {
            hasNonDigit = true;
        }
    }
    if (hasNonDigit && hasDigit) {
        return DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC;
    }
    if (hasNonDigit) {
        return DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;
    }
    if (hasDigit) {
        return maxLengthSequence(password) > MAX_ALLOWED_SEQUENCE ? DevicePolicyManager.PASSWORD_QUALITY_NUMERIC : DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;
    }
    return DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
}
------------------------
Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.setNiNotification:COMMENT
Method Modifier: private     internal    
Comment:// Sets the NI notification.

Body of Frist Method:
{
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    String title = getNotifTitle(notif, mContext);
    String message = getNotifMessage(notif, mContext);
    if (DEBUG)
        Log.d(TAG, "setNiNotification, notifyId: " + notif.notificationId + ", title: " + title + ", message: " + message);
    // Construct Notification
    if (mNiNotification == null) {
        mNiNotification = new Notification();
        mNiNotification.icon = com.android.internal.R.drawable.stat_sys_gps_on;
        /* Change notification icon here */
        mNiNotification.when = 0;
    }
    if (mPlaySounds) {
        mNiNotification.defaults |= Notification.DEFAULT_SOUND;
    } else {
        mNiNotification.defaults &= ~Notification.DEFAULT_SOUND;
    }
    mNiNotification.flags = Notification.FLAG_ONGOING_EVENT | Notification.FLAG_AUTO_CANCEL;
    mNiNotification.tickerText = getNotifTicker(notif, mContext);
    // if not to popup dialog immediately, pending intent will open the dialog
    Intent intent = !mPopupImmediately ? getDlgIntent(notif) : new Intent();
    PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, intent, 0);
    mNiNotification.setLatestEventInfo(mContext, title, message, pi);
    notificationManager.notifyAsUser(null, notif.notificationId, mNiNotification, UserHandle.ALL);
}
Body of Second Method:
{
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    String title = getNotifTitle(notif, mContext);
    String message = getNotifMessage(notif, mContext);
    if (DEBUG)
        Log.d(TAG, "setNiNotification, notifyId: " + notif.notificationId + ", title: " + title + ", message: " + message);
    // Construct Notification
    if (mNiNotification == null) {
        mNiNotification = new Notification();
        mNiNotification.icon = com.android.internal.R.drawable.stat_sys_gps_on;
        /* Change notification icon here */
        mNiNotification.when = 0;
    }
    if (mPlaySounds) {
        mNiNotification.defaults |= Notification.DEFAULT_SOUND;
    } else {
        mNiNotification.defaults &= ~Notification.DEFAULT_SOUND;
    }
    mNiNotification.flags = Notification.FLAG_ONGOING_EVENT | Notification.FLAG_AUTO_CANCEL;
    mNiNotification.tickerText = getNotifTicker(notif, mContext);
    // if not to popup dialog immediately, pending intent will open the dialog
    Intent intent = !mPopupImmediately ? getDlgIntent(notif) : new Intent();
    PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, intent, 0);
    mNiNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
    mNiNotification.setLatestEventInfo(mContext, title, message, pi);
    notificationManager.notifyAsUser(null, notif.notificationId, mNiNotification, UserHandle.ALL);
}
------------------------
Find a functionally equivalent code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int i = firstLine; i <= lastLine; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    boolean useFirstLineMargin = isFirstParaLine;
                    if (margin instanceof LeadingMarginSpan2) {
                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                        int startLine = getLineForOffset(sp.getSpanStart(margin));
                        useFirstLineMargin = i < startLine + count;
                    }
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}
Body of Second Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int i = firstLine; i <= lastLine; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (i < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}
------------------------
Find a functionally equivalent code:android.view.Window.setBackgroundDrawableResource:COMMENT
Method Modifier: public      
Comment:/**
 * Change the background of this window to a Drawable resource. Setting the
 * background to null will make the window be opaque. To make the window
 * transparent, you can use an empty drawable (for instance a ColorDrawable
 * with the color 0 or the system drawable android:drawable/empty.)
 *
 * @param resid The resource identifier of a drawable resource which will be
 * installed as the new background.
 */

Body of Frist Method:
{
    setBackgroundDrawable(mContext.getResources().getDrawable(resid));
}
Body of Second Method:
{
    setBackgroundDrawable(mContext.getDrawable(resid));
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.setFullscreen:COMMENT
Method Modifier: public      
Comment:/**
 * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}
 * on the dream's window.
 *
 * @param fullscreen If true, the fullscreen flag will be set; else it
 * will be cleared.
 */

Body of Frist Method:
{
    mFullscreen = fullscreen;
    int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
    applyWindowFlags(mFullscreen ? flag : 0, flag);
}
Body of Second Method:
{
    if (mFullscreen != fullscreen) {
        mFullscreen = fullscreen;
        int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
        applyWindowFlags(mFullscreen ? flag : 0, flag);
    }
}
------------------------
Find a functionally equivalent code:android.text.Layout.getLineWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent and trailing whitespace.
 */

Body of Frist Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}
Body of Second Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in a not focused month.
 *
 * @return A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

Body of Frist Method:
{
    return mFocusedMonthDateColor;
}
Body of Second Method:
{
    return mDelegate.getUnfocusedMonthDateColor();
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_AcousticStateReset:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.print.PrintManager.getInstalledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of installed print services.
 *
 * @return The installed service list or an empty list.
 * @hide
 */

Body of Frist Method:
{
    try {
        List<PrintServiceInfo> installedServices = mService.getInstalledPrintServices(mUserId);
        if (installedServices != null) {
            return installedServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the installed print services", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintServiceInfo> installedServices = mService.getInstalledPrintServices(mUserId);
        if (installedServices != null) {
            return installedServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the installed print services", re);
    }
    return Collections.emptyList();
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Defines at what volume the playback associated with this route is performed (for user
 * feedback purposes). This information is only used when the playback is not local.
 * @param volume
 */

Body of Frist Method:
{
    volume = Math.max(0, Math.min(volume, getVolumeMax()));
    if (mVolume != volume) {
        mVolume = volume;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME, volume);
        dispatchRouteVolumeChanged(this);
        if (mGroup != null) {
            mGroup.memberVolumeChanged(this);
        }
    }
}
Body of Second Method:
{
    volume = Math.max(0, Math.min(volume, getVolumeMax()));
    if (mVolume != volume) {
        mVolume = volume;
        if (mSvp != null) {
            mSvp.setCurrentVolume(mVolume);
        }
        dispatchRouteVolumeChanged(this);
        if (mGroup != null) {
            mGroup.memberVolumeChanged(this);
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.unregisterRemoteControlDisplay:COMMENT
Method Modifier: protected   
Comment:/**
 * Unregister an IRemoteControlDisplay.
 * No effect if the IRemoteControlDisplay hasn't been successfully registered.
 * @see android.media.IAudioService#unregisterRemoteControlDisplay(android.media.IRemoteControlDisplay)
 * @param rcd the IRemoteControlDisplay to unregister. No effect if null.
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.d(TAG, "<<< unregisterRemoteControlDisplay(" + rcd + ")");
    synchronized (mRCStack) {
        if (rcd == null) {
            return;
        }
        boolean displayWasPluggedIn = false;
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext() && !displayWasPluggedIn) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                displayWasPluggedIn = true;
                di.release();
                displayIterator.remove();
            }
        }
        if (displayWasPluggedIn) {
            // disconnect this remote control display from all the clients, so the remote
            // control stack traversal order doesn't matter
            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                final RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.unplugRemoteControlDisplay(rcd);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error disconnecting remote control display to client: ", e);
                    }
                }
            }
        } else {
            if (DEBUG_RC)
                Log.w(TAG, "  trying to unregister unregistered RCD");
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.d(TAG, "<<< unregisterRemoteControlDisplay(" + rcd + ")");
    synchronized (mPRStack) {
        if (rcd == null) {
            return;
        }
        boolean displayWasPluggedIn = false;
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext() && !displayWasPluggedIn) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                displayWasPluggedIn = true;
                di.release();
                displayIterator.remove();
            }
        }
        if (displayWasPluggedIn) {
            // disconnect this remote control display from all the clients, so the remote
            // control stack traversal order doesn't matter
            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                final PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().unplugRemoteControlDisplay(rcd);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error disconnecting remote control display to client: ", e);
                    }
                }
            }
        } else {
            if (DEBUG_RC)
                Log.w(TAG, "  trying to unregister unregistered RCD");
        }
    }
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.impl.CameraMetadataNative.set:COMMENT
Method Modifier: public      
Comment:/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */

Body of Frist Method:
{
    if (setOverride(key, value)) {
        return;
    }
    setBase(key, value);
}
Body of Second Method:
{
    SetCommand s = sSetCommandMap.get(key);
    if (s != null) {
        s.setValue(this, value);
        return;
    }
    setBase(key, value);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.copy:COMMENT
Method Modifier: public      
Comment:/**
 * Tries to make a new bitmap based on the dimensions of this bitmap,
 * setting the new bitmap's config to the one specified, and then copying
 * this bitmap's pixels into the new bitmap. If the conversion is not
 * supported, or the allocator fails, then this returns NULL.  The returned
 * bitmap initially has the same density as the original.
 *
 * @param config    The desired config for the resulting bitmap
 * @param isMutable True if the resulting bitmap should be mutable (i.e.
 * its pixels can be modified)
 * @return the new bitmap, or null if the copy could not be made.
 */

Body of Frist Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.mIsPremultiplied = mIsPremultiplied;
        b.mDensity = mDensity;
    }
    return b;
}
Body of Second Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
------------------------
Find a functionally equivalent code:android.text.format.Time.compare:COMMENT
Method Modifier: public      static      
Comment:/**
 * Compare two {@code Time} objects and return a negative number if {@code
 * a} is less than {@code b}, a positive number if {@code a} is greater than
 * {@code b}, or 0 if they are equal.
 *
 * @param a first {@code Time} instance to compare
 * @param b second {@code Time} instance to compare
 * @throws NullPointerException if either argument is {@code null}
 * @throws IllegalArgumentException if {@link #allDay} is true but {@code
 * hour}, {@code minute}, and {@code second} are not 0.
 * @return a negative result if {@code a} is earlier, a positive result if
 * {@code a} is earlier, or 0 if they are equal.
 */

Body of Frist Method:
{
    if (a == null) {
        throw new NullPointerException("a == null");
    } else if (b == null) {
        throw new NullPointerException("b == null");
    }
    return nativeCompare(a, b);
}
Body of Second Method:
{
    if (a == null) {
        throw new NullPointerException("a == null");
    } else if (b == null) {
        throw new NullPointerException("b == null");
    }
    a.calculator.copyFieldsFromTime(a);
    b.calculator.copyFieldsFromTime(b);
    return TimeCalculator.compare(a.calculator, b.calculator);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.sendMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send a simulated key event for a media button to be received by the current client.
 * To simulate a key press, you must first send a KeyEvent built with
 * a {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the registered receiver
 * (see {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}) whose associated
 * {@link RemoteControlClient}'s metadata and playback state is published (there may be
 * none under some circumstances).
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 * @return true if the event was successfully sent, false otherwise.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!MediaFocusControl.isMediaKeyCode(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    final PendingIntent pi;
    synchronized (mInfoLock) {
        if (!mIsRegistered) {
            Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
            return false;
        }
        if (!mEnabled) {
            Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
            return false;
        }
        pi = mClientPendingIntentCurrent;
    }
    if (pi != null) {
        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
        intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
        try {
            pi.send(mContext, 0, intent);
        } catch (CanceledException e) {
            Log.e(TAG, "Error sending intent for media button down: ", e);
            return false;
        }
    } else {
        Log.i(TAG, "No-op when sending key click, no receiver right now");
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
            }
            return false;
        }
    } else {
        final PendingIntent pi;
        synchronized (mInfoLock) {
            if (!mIsRegistered) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
                return false;
            }
            if (!mEnabled) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
                return false;
            }
            pi = mClientPendingIntentCurrent;
        }
        if (pi != null) {
            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                pi.send(mContext, 0, intent);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending intent for media button down: ", e);
                return false;
            }
        } else {
            Log.i(TAG, "No-op when sending key click, no receiver right now");
            return false;
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleWiFiEnableDisable:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching on/off WiFi at various intervals.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_5MB_FILENAME;
    long filesize = DOWNLOAD_5MB_FILESIZE;
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // are we making any progress?
        waitForFileToGrow(downloadedFile);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 40 seconds
        Thread.sleep(40 * 1000);
        // enable download...
        Log.i(LOG_TAG, "Turning on WiFi again...");
        setWiFiStateOn(true);
        waitForFileToGrow(downloadedFile);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 20 seconds
        Thread.sleep(20 * 1000);
        // enable download...
        Log.i(LOG_TAG, "Turning on WiFi again...");
        setWiFiStateOn(true);
        Log.i(LOG_TAG, "Waiting up to 3 minutes for download to complete...");
        waitForDownloadsOrTimeout(dlRequest, 3 * 60 * 1000);
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    long filesize = DOWNLOAD_FILESIZE;
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // are we making any progress?
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 40 seconds
        Thread.sleep(40 * 1000);
        // enable download...
        Log.i(LOG_TAG, "Turning on WiFi again...");
        setWiFiStateOn(true);
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download disable
        Log.i(LOG_TAG, "Turning off WiFi...");
        setWiFiStateOn(false);
        // wait 20 seconds
        Thread.sleep(20 * 1000);
        // enable download...
        Log.i(LOG_TAG, "Turning on WiFi again...");
        setWiFiStateOn(true);
        Log.i(LOG_TAG, "Waiting up to 10 minutes for download to complete...");
        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the separator line between weeks.
 *
 * @return The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

Body of Frist Method:
{
    return mWeekSeparatorLineColor;
}
Body of Second Method:
{
    return mDelegate.getWeekSeparatorLineColor();
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawVertices:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the array of vertices, interpreted as triangles (based on mode). The
 * verts array is required, and specifies the x,y pairs for each vertex. If
 * texs is non-null, then it is used to specify the coordinate in shader
 * coordinates to use at each vertex (the paint must have a shader in this
 * case). If there is no texs array, but there is a color array, then each
 * color is interpolated across its corresponding triangle in a gradient. If
 * both texs and colors arrays are present, then they behave as before, but
 * the resulting color at each pixels is the result of multiplying the
 * colors from the shader and the color-gradient together. The indices array
 * is optional, but if it is present, then it is used to specify the index
 * of each triangle, rather than just walking through the arrays in order.
 *
 * @param mode How to interpret the array of vertices
 * @param vertexCount The number of values in the vertices array (and
 * corresponding texs and colors arrays if non-null). Each logical
 * vertex is two values (x, y), vertexCount must be a multiple of 2.
 * @param verts Array of vertices for the mesh
 * @param vertOffset Number of values in the verts to skip before drawing.
 * @param texs May be null. If not null, specifies the coordinates to sample
 * into the current shader (e.g. bitmap tile or gradient)
 * @param texOffset Number of values in texs to skip before drawing.
 * @param colors May be null. If not null, specifies a color for each
 * vertex, to be interpolated across the triangle.
 * @param colorOffset Number of values in colors to skip before drawing.
 * @param indices If not null, array of indices to reference into the
 * vertex (texs, colors) array.
 * @param indexCount number of entries in the indices array (if not null).
 * @param paint Specifies the shader to use if the texs array is non-null.
 */

Body of Frist Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvas, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
}
Body of Second Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvasWrapper, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.measurePreview:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the preview text bounds, taking preview image padding into
 * account. This method should only be called after {@link #layoutThumb()}
 * and {@link #layoutTrack()} have both been called at least once.
 *
 * @param v The preview text view to measure.
 * @param out Rectangle into which measured bounds are placed.
 */

Body of Frist Method:
{
    // Apply the preview image's padding as layout margins.
    final Rect margins = mTempMargins;
    margins.left = mPreviewImage.getPaddingLeft();
    margins.top = mPreviewImage.getPaddingTop();
    margins.right = mPreviewImage.getPaddingRight();
    margins.bottom = mPreviewImage.getPaddingBottom();
    if (mOverlayPosition == OVERLAY_AT_THUMB) {
        measureViewToSide(v, mThumbImage, margins, out);
    } else {
        measureFloating(v, margins, out);
    }
}
Body of Second Method:
{
    // Apply the preview image's padding as layout margins.
    final Rect margins = mTempMargins;
    margins.left = mPreviewImage.getPaddingLeft();
    margins.top = mPreviewImage.getPaddingTop();
    margins.right = mPreviewImage.getPaddingRight();
    margins.bottom = mPreviewImage.getPaddingBottom();
    if (mOverlayPosition == OVERLAY_FLOATING) {
        measureFloating(v, margins, out);
    } else {
        measureViewToSide(v, mThumbImage, margins, out);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

Body of Frist Method:
{
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.stress.WifiStressTest.testWifiScanning:COMMENT
Method Modifier: public      
Comment:/**
 * Stress Wifi Scanning
 * TODO: test the scanning quality for each frequency band
 */

Body of Frist Method:
{
    int scanTimeSum = 0;
    int i;
    // count times of given ssid appear in scan results.
    int ssidAppearInScanResultsCount = 0;
    for (i = 0; i < mScanIterations; i++) {
        log("testWifiScanning: iteration: " + i);
        int averageScanTime = 0;
        if (i > 0) {
            averageScanTime = scanTimeSum / i;
        }
        writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
        writeOutput(String.format("average scanning time is %d", averageScanTime));
        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, i));
        long startTime = System.currentTimeMillis();
        scanResultAvailable = false;
        assertTrue("start scan failed", mWifiManager.startScan());
        while (true) {
            if ((System.currentTimeMillis() - startTime) > WIFI_SCAN_TIMEOUT) {
                fail("Wifi scanning takes more than " + WIFI_SCAN_TIMEOUT + " ms");
            }
            synchronized (this) {
                try {
                    wait(WAIT_FOR_SCAN_RESULT);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (scanResultAvailable) {
                    long scanTime = (System.currentTimeMillis() - startTime);
                    scanTimeSum += scanTime;
                    break;
                }
            }
        }
        if ((mWifiManager.getScanResults() == null) || (mWifiManager.getScanResults().size() <= 0)) {
            fail("Scan results are empty ");
        }
        List<ScanResult> netList = mWifiManager.getScanResults();
        if (netList != null) {
            log("size of scan result list: " + netList.size());
            for (int s = 0; s < netList.size(); s++) {
                ScanResult sr = netList.get(s);
                log(String.format("scan result for %s is: %s", sr.SSID, sr.toString()));
                log(String.format("signal level for %s is %d ", sr.SSID, sr.level));
                if (sr.SSID.equals(mSsid)) {
                    ssidAppearInScanResultsCount += 1;
                    log("Number of times " + mSsid + " appear in the scan list: " + ssidAppearInScanResultsCount);
                    break;
                }
            }
        }
    }
    if (i == mScanIterations) {
        writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
        writeOutput(String.format("average scanning time is %d", scanTimeSum / mScanIterations));
        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, mScanIterations));
    }
}
Body of Second Method:
{
    long scanTimeSum = 0, i, averageScanTime = -1;
    // count times of given ssid appear in scan results.
    int ssidAppearInScanResultsCount = 0;
    for (i = 1; i <= mScanIterations; i++) {
        logv("testWifiScanning: iteration: " + i);
        averageScanTime = scanTimeSum / i;
        writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
        writeOutput(String.format("average scanning time is %d", averageScanTime));
        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, i));
        List<ScanResult> scanResultLocal = null;
        // wait for a scan result
        long start = 0;
        synchronized (mWifiScanResultLock) {
            start = SystemClock.uptimeMillis();
            assertTrue("start scan failed", mWifiManager.startScan());
            try {
                mWifiScanResultLock.wait(WAIT_FOR_SCAN_RESULT);
            } catch (InterruptedException e) {
            // ignore
            }
            scanTimeSum += SystemClock.uptimeMillis() - start;
            // save the scan result while in lock
            scanResultLocal = mLastScanResult;
        }
        if (scanResultLocal == null || scanResultLocal.isEmpty()) {
            fail("Scan results are empty ");
        }
        logv("size of scan result list: " + scanResultLocal.size());
        for (ScanResult sr : scanResultLocal) {
            logv(String.format("scan result: " + sr.toString()));
            if (mSsid.equals(sr.SSID)) {
                ssidAppearInScanResultsCount += 1;
                break;
            }
        }
    }
    Bundle result = new Bundle();
    result.putLong("actual-iterations", i - 1);
    result.putLong("avg-scan-time", averageScanTime);
    result.putInt("ap-discovered", ssidAppearInScanResultsCount);
    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
    if (i == mScanIterations + 1) {
        writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
        writeOutput(String.format("average scanning time is %d", scanTimeSum / (i - 1)));
        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, i));
    }
}
------------------------
Find a functionally equivalent code:android.os.SELinux.native_restorecon:COMMENT
Method Modifier: private     static      native      
Comment:/**
 * Restores a file to its default SELinux security context.
 * If the system is not compiled with SELinux, then {@code true}
 * is automatically returned.
 * If SELinux is compiled in, but disabled, then {@code true} is
 * returned.
 *
 * @param pathname The pathname of the file to be relabeled.
 * @return a boolean indicating whether the relabeling succeeded.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayInitInfo:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_INIT_INFO event
 * Causes the current RemoteControlClient to send its info (metadata, playstate...) to
 * a single RemoteControlDisplay, NOT all of them, as with MSG_RCDISPLAY_UPDATE.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            if (mCurrentRcClient != null) {
                if (DEBUG_RC) {
                    Log.i(TAG, "Init RCD with current info");
                }
                try {
                    // synchronously update the new RCD with the current client generation
                    // and matching PendingIntent
                    newRcd.setCurrentClientId(mCurrentRcClientGen, mCurrentRcClientIntent, false);
                    // tell the current RCC that it needs to send info, but only to the new RCD
                    try {
                        mCurrentRcClient.informationRequestForDisplay(newRcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Current valid remote client is dead: ", e);
                        mCurrentRcClient = null;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in onRcDisplayInitInfo()", e);
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            if (mCurrentRcClient != null) {
                if (DEBUG_RC) {
                    Log.i(TAG, "Init RCD with current info");
                }
                try {
                    // synchronously update the new RCD with the current client generation
                    // and matching PendingIntent
                    newRcd.setCurrentClientId(mCurrentRcClientGen, mCurrentRcClientIntent, false);
                    // tell the current RCC that it needs to send info, but only to the new RCD
                    try {
                        mCurrentRcClient.informationRequestForDisplay(newRcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Current valid remote client is dead: ", e);
                        mCurrentRcClient = null;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in onRcDisplayInitInfo()", e);
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.speech.tts.FileSynthesisCallback.closeFile:COMMENT
Method Modifier: private     
Comment:/**
 * Must be called while holding the monitor on {@link #mStateLock}.
 */

Body of Frist Method:
{
    try {
        if (mFileChannel != null) {
            mFileChannel.close();
            mFileChannel = null;
        }
    } catch (IOException ex) {
        Log.e(TAG, "Failed to close output file descriptor", ex);
    }
}
Body of Second Method:
{
    // File will be closed by the SpeechItem in the speech service.
    mFileChannel = null;
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsContract.getDocumentThumbnail:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Bundle openOpts = new Bundle();
    openOpts.putParcelable(DocumentsContract.EXTRA_THUMBNAIL_SIZE, size);
    AssetFileDescriptor afd = null;
    Bitmap bitmap = null;
    try {
        afd = client.openTypedAssetFileDescriptor(documentUri, "image/*", openOpts, signal);
        final FileDescriptor fd = afd.getFileDescriptor();
        final long offset = afd.getStartOffset();
        // Try seeking on the returned FD, since it gives us the most
        // optimal decode path; otherwise fall back to buffering.
        BufferedInputStream is = null;
        try {
            Libcore.os.lseek(fd, offset, SEEK_SET);
        } catch (ErrnoException e) {
            is = new BufferedInputStream(new FileInputStream(fd), THUMBNAIL_BUFFER_SIZE);
            is.mark(THUMBNAIL_BUFFER_SIZE);
        }
        // We requested a rough thumbnail size, but the remote size may have
        // returned something giant, so defensively scale down as needed.
        final BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inJustDecodeBounds = true;
        if (is != null) {
            BitmapFactory.decodeStream(is, null, opts);
        } else {
            BitmapFactory.decodeFileDescriptor(fd, null, opts);
        }
        final int widthSample = opts.outWidth / size.x;
        final int heightSample = opts.outHeight / size.y;
        opts.inJustDecodeBounds = false;
        opts.inSampleSize = Math.min(widthSample, heightSample);
        if (is != null) {
            is.reset();
            bitmap = BitmapFactory.decodeStream(is, null, opts);
        } else {
            try {
                Libcore.os.lseek(fd, offset, SEEK_SET);
            } catch (ErrnoException e) {
                e.rethrowAsIOException();
            }
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, opts);
        }
        // Transform the bitmap if requested. We use a side-channel to
        // communicate the orientation, since EXIF thumbnails don't contain
        // the rotation flags of the original image.
        final Bundle extras = afd.getExtras();
        final int orientation = (extras != null) ? extras.getInt(EXTRA_ORIENTATION, 0) : 0;
        if (orientation != 0) {
            final int width = bitmap.getWidth();
            final int height = bitmap.getHeight();
            final Matrix m = new Matrix();
            m.setRotate(orientation, width / 2, height / 2);
            bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, m, false);
        }
    } finally {
        IoUtils.closeQuietly(afd);
    }
    return bitmap;
}
Body of Second Method:
{
    final Bundle openOpts = new Bundle();
    openOpts.putParcelable(ContentResolver.EXTRA_SIZE, size);
    AssetFileDescriptor afd = null;
    Bitmap bitmap = null;
    try {
        afd = client.openTypedAssetFileDescriptor(documentUri, "image/*", openOpts, signal);
        final FileDescriptor fd = afd.getFileDescriptor();
        final long offset = afd.getStartOffset();
        // Try seeking on the returned FD, since it gives us the most
        // optimal decode path; otherwise fall back to buffering.
        BufferedInputStream is = null;
        try {
            Os.lseek(fd, offset, SEEK_SET);
        } catch (ErrnoException e) {
            is = new BufferedInputStream(new FileInputStream(fd), THUMBNAIL_BUFFER_SIZE);
            is.mark(THUMBNAIL_BUFFER_SIZE);
        }
        // We requested a rough thumbnail size, but the remote size may have
        // returned something giant, so defensively scale down as needed.
        final BitmapFactory.Options opts = new BitmapFactory.Options();
        opts.inJustDecodeBounds = true;
        if (is != null) {
            BitmapFactory.decodeStream(is, null, opts);
        } else {
            BitmapFactory.decodeFileDescriptor(fd, null, opts);
        }
        final int widthSample = opts.outWidth / size.x;
        final int heightSample = opts.outHeight / size.y;
        opts.inJustDecodeBounds = false;
        opts.inSampleSize = Math.min(widthSample, heightSample);
        if (is != null) {
            is.reset();
            bitmap = BitmapFactory.decodeStream(is, null, opts);
        } else {
            try {
                Os.lseek(fd, offset, SEEK_SET);
            } catch (ErrnoException e) {
                e.rethrowAsIOException();
            }
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, opts);
        }
        // Transform the bitmap if requested. We use a side-channel to
        // communicate the orientation, since EXIF thumbnails don't contain
        // the rotation flags of the original image.
        final Bundle extras = afd.getExtras();
        final int orientation = (extras != null) ? extras.getInt(EXTRA_ORIENTATION, 0) : 0;
        if (orientation != 0) {
            final int width = bitmap.getWidth();
            final int height = bitmap.getHeight();
            final Matrix m = new Matrix();
            m.setRotate(orientation, width / 2, height / 2);
            bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height, m, false);
        }
    } finally {
        IoUtils.closeQuietly(afd);
    }
    return bitmap;
}
------------------------
Find a functionally equivalent code:android.text.BoringLayout.init:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    if (spacingmult != 1 || spacingadd != 0) {
        spacing = (int) (spacing * spacingmult + spacingadd + 0.5f);
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) FloatMath.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) FloatMath.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.stopBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#stopBluetoothSco()
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mBootCompleted) {
        return;
    }
    ScoClient client = getScoClient(cb, false);
    // The calling identity must be cleared before calling ScoClient.decCount().
    // decCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    final long ident = Binder.clearCallingIdentity();
    if (client != null) {
        client.decCount();
    }
    Binder.restoreCallingIdentity(ident);
}
Body of Second Method:
{
    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mSystemReady) {
        return;
    }
    ScoClient client = getScoClient(cb, false);
    // The calling identity must be cleared before calling ScoClient.decCount().
    // decCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    final long ident = Binder.clearCallingIdentity();
    if (client != null) {
        client.decCount();
    }
    Binder.restoreCallingIdentity(ident);
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.clear:COMMENT
Method Modifier: 
Comment:/**
 * Clears the scrap heap.
 */

Body of Frist Method:
{
    if (mViewTypeCount == 1) {
        final ArrayList<View> scrap = mCurrentScrap;
        final int scrapCount = scrap.size();
        for (int i = 0; i < scrapCount; i++) {
            removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
        }
    } else {
        final int typeCount = mViewTypeCount;
        for (int i = 0; i < typeCount; i++) {
            final ArrayList<View> scrap = mScrapViews[i];
            final int scrapCount = scrap.size();
            for (int j = 0; j < scrapCount; j++) {
                removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
            }
        }
    }
    if (mTransientStateViews != null) {
        mTransientStateViews.clear();
    }
    if (mTransientStateViewsById != null) {
        mTransientStateViewsById.clear();
    }
}
Body of Second Method:
{
    if (mViewTypeCount == 1) {
        final ArrayList<View> scrap = mCurrentScrap;
        clearScrap(scrap);
    } else {
        final int typeCount = mViewTypeCount;
        for (int i = 0; i < typeCount; i++) {
            final ArrayList<View> scrap = mScrapViews[i];
            clearScrap(scrap);
        }
    }
    clearTransientStateViews();
}
------------------------
Find a functionally equivalent code:android.animation.AnimatorSet.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */

Body of Frist Method:
{
    mStartDelay = startDelay;
}
Body of Second Method:
{
    if (mStartDelay > 0) {
        mReversible = false;
    }
    mStartDelay = startDelay;
}
------------------------
Find a functionally equivalent code:android.net.nsd.NsdServiceInfo.getTxtRecord:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mTxtRecord;
}
Body of Second Method:
{
    int txtRecordSize = getTxtRecordSize();
    if (txtRecordSize == 0) {
        return null;
    }
    byte[] txtRecord = new byte[txtRecordSize];
    int ptr = 0;
    for (Map.Entry<String, byte[]> entry : mTxtRecord.entrySet()) {
        String key = entry.getKey();
        byte[] value = entry.getValue();
        // One byte to record the length of this key/value pair.
        txtRecord[ptr++] = (byte) (key.length() + (value == null ? 0 : value.length) + 1);
        // The key, in US-ASCII.
        // Note: use the StandardCharsets const here because it doesn't raise exceptions and we
        // already know the key is ASCII at this point.
        System.arraycopy(key.getBytes(StandardCharsets.US_ASCII), 0, txtRecord, ptr, key.length());
        ptr += key.length();
        // US-ASCII '=' character.
        txtRecord[ptr++] = (byte) '=';
        // The value, as any raw bytes.
        if (value != null) {
            System.arraycopy(value, 0, txtRecord, ptr, value.length);
            ptr += value.length;
        }
    }
    return txtRecord;
}
------------------------
Find a functionally equivalent code:android.os.Environment.initForCurrentUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final int userId = UserHandle.myUserId();
    sCurrentUser = new UserEnvironment(userId);
    synchronized (sLock) {
        sPrimaryVolume = null;
    }
}
Body of Second Method:
{
    final int userId = UserHandle.myUserId();
    sCurrentUser = new UserEnvironment(userId);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.hideBootMessages:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog != null) {
                mBootMsgDialog.dismiss();
                mBootMsgDialog = null;
            }
        }
    });
}
Body of Second Method:
{
    mHandler.sendEmptyMessage(MSG_HIDE_BOOT_MESSAGE);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.passwordToHash:COMMENT
Method Modifier: public      internal    
Comment:/*
     * Generate a hash for the given password. To avoid brute force attacks, we use a salted hash.
     * Not the most secure, but it is at least a second level of protection. First level is that
     * the file is in a location only readable by the system process.
     * @param password the gesture pattern.
     * @return the hash of the pattern in a byte array.
     */

Body of Frist Method:
{
    if (password == null) {
        return null;
    }
    String algo = null;
    byte[] hashed = null;
    try {
        byte[] saltedPassword = (password + getSalt()).getBytes();
        byte[] sha1 = MessageDigest.getInstance(algo = "SHA-1").digest(saltedPassword);
        byte[] md5 = MessageDigest.getInstance(algo = "MD5").digest(saltedPassword);
        hashed = (toHex(sha1) + toHex(md5)).getBytes();
    } catch (NoSuchAlgorithmException e) {
        Log.w(TAG, "Failed to encode string because of missing algorithm: " + algo);
    }
    return hashed;
}
Body of Second Method:
{
    if (password == null) {
        return null;
    }
    String algo = null;
    byte[] hashed = null;
    try {
        byte[] saltedPassword = (password + getSalt(userId)).getBytes();
        byte[] sha1 = MessageDigest.getInstance(algo = "SHA-1").digest(saltedPassword);
        byte[] md5 = MessageDigest.getInstance(algo = "MD5").digest(saltedPassword);
        hashed = (toHex(sha1) + toHex(md5)).getBytes();
    } catch (NoSuchAlgorithmException e) {
        Log.w(TAG, "Failed to encode string because of missing algorithm: " + algo);
    }
    return hashed;
}
------------------------
Find a functionally equivalent code:android.app.Activity.onResume:COMMENT
Method Modifier: protected   
Comment:/**
 * Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or
 * {@link #onPause}, for your activity to start interacting with the user.
 * This is a good place to begin animations, open exclusive-access devices
 * (such as the camera), etc.
 *
 * <p>Keep in mind that onResume is not the best indicator that your activity
 * is visible to the user; a system window such as the keyguard may be in
 * front.  Use {@link #onWindowFocusChanged} to know for certain that your
 * activity is visible to the user (for example, to resume a game).
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestoreInstanceState
 * @see #onRestart
 * @see #onPostResume
 * @see #onPause
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mActivityTransitionState.onResume();
    mCalled = true;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.BitmapDrawable.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity used to position/stretch the bitmap within its bounds.
 * See android.view.Gravity
 * @param gravity the gravity
 */

Body of Frist Method:
{
    if (mBitmapState.mGravity != gravity) {
        mBitmapState.mGravity = gravity;
        mApplyGravity = true;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mBitmapState.mGravity != gravity) {
        mBitmapState.mGravity = gravity;
        mDstRectAndInsetsDirty = true;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.startSystemServer:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Prepare the arguments and fork for the system server process.
 */

Body of Frist Method:
{
    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG);
    /* Hardcoded command line to start the system server */
    String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007", "--capabilities=" + capabilities + "," + capabilities, "--runtime-init", "--nice-name=system_server", "com.android.server.SystemServer" };
    ZygoteConnection.Arguments parsedArgs = null;
    int pid;
    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }
    /* For child process */
    if (pid == 0) {
        handleSystemServerProcess(parsedArgs);
    }
    return true;
}
Body of Second Method:
{
    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG);
    /* Hardcoded command line to start the system server */
    String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007", "--capabilities=" + capabilities + "," + capabilities, "--runtime-init", "--nice-name=system_server", "com.android.server.SystemServer" };
    ZygoteConnection.Arguments parsedArgs = null;
    int pid;
    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }
    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }
        handleSystemServerProcess(parsedArgs);
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.database.sqlite.SQLiteConnection.dumpUnsafe:COMMENT
Method Modifier: 
Comment:/**
 * Dumps debugging information about this connection, in the case where the
 * caller might not actually own the connection.
 *
 * This function is written so that it may be called by a thread that does not
 * own the connection.  We need to be very careful because the connection state is
 * not synchronized.
 *
 * At worst, the method may return stale or slightly wrong data, however
 * it should not crash.  This is ok as it is only used for diagnostic purposes.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    printer.println("Connection #" + mConnectionId + ":");
    if (verbose) {
        printer.println("  connectionPtr: 0x" + Integer.toHexString(mConnectionPtr));
    }
    printer.println("  isPrimaryConnection: " + mIsPrimaryConnection);
    printer.println("  onlyAllowReadOnlyOperations: " + mOnlyAllowReadOnlyOperations);
    mRecentOperations.dump(printer, verbose);
    if (verbose) {
        mPreparedStatementCache.dump(printer);
    }
}
Body of Second Method:
{
    printer.println("Connection #" + mConnectionId + ":");
    if (verbose) {
        printer.println("  connectionPtr: 0x" + Long.toHexString(mConnectionPtr));
    }
    printer.println("  isPrimaryConnection: " + mIsPrimaryConnection);
    printer.println("  onlyAllowReadOnlyOperations: " + mOnlyAllowReadOnlyOperations);
    mRecentOperations.dump(printer, verbose);
    if (verbose) {
        mPreparedStatementCache.dump(printer);
    }
}
------------------------
Find a functionally equivalent code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: 
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(freeSpec, freeSpec);
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = widthSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(freeSpec, freeSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = widthSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a functionally equivalent code:android.nfc.cardemulation.CardEmulation.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */

Body of Frist Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
Body of Second Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, "This device does not implement the INfcCardEmulation interface.");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initialize the state. If the provided values designate an inconsistent
 * date the values are normalized before updating the spinners.
 *
 * @param year The initial year.
 * @param monthOfYear The initial month <strong>starting from zero</strong>.
 * @param dayOfMonth The initial day of the month.
 * @param onDateChangedListener How user is notified date is changed by
 * user, can be null.
 */

Body of Frist Method:
{
    setDate(year, monthOfYear, dayOfMonth);
    updateSpinners();
    updateCalendarView();
    mOnDateChangedListener = onDateChangedListener;
}
Body of Second Method:
{
    mDelegate.init(year, monthOfYear, dayOfMonth, onDateChangedListener);
}
------------------------
Find a functionally equivalent code:android.view.InputQueue.getNativePtr:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mPtr;
}
Body of Second Method:
{
    return mPtr;
}
------------------------
Find a functionally equivalent code:android.util.SparseLongArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        growKeyAndValueArrays(pos + 1);
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:android.content.res.ColorStateList.valueOf:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */

Body of Frist Method:
{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}
Body of Second Method:
{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        final WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}
------------------------
Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.commitText:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    sendCurrentText();
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    mIMM.notifyUserAction();
    sendCurrentText();
    return true;
}
------------------------
Find a functionally equivalent code:com.android.systemui.power.PowerUI.findBatteryLevelBucket:COMMENT
Method Modifier: private     
Comment:/**
 * Buckets the battery level.
 *
 * The code in this function is a little weird because I couldn't comprehend
 * the bucket going up when the battery level was going down. --joeo
 *
 * 1 means that the battery is "ok"
 * 0 means that the battery is between "ok" and what we should warn about.
 * less than 0 means that the battery is low
 */

Body of Frist Method:
{
    if (level >= mLowBatteryAlertCloseLevel) {
        return 1;
    }
    if (level >= mLowBatteryReminderLevels[0]) {
        return 0;
    }
    final int N = mLowBatteryReminderLevels.length;
    for (int i = N - 1; i >= 0; i--) {
        if (level <= mLowBatteryReminderLevels[i]) {
            return -1 - i;
        }
    }
    throw new RuntimeException("not possible!");
}
Body of Second Method:
{
    if (level >= mLowBatteryAlertCloseLevel) {
        return 1;
    }
    if (level > mLowBatteryReminderLevels[0]) {
        return 0;
    }
    final int N = mLowBatteryReminderLevels.length;
    for (int i = N - 1; i >= 0; i--) {
        if (level <= mLowBatteryReminderLevels[i]) {
            return -1 - i;
        }
    }
    throw new RuntimeException("not possible!");
}
------------------------
Find a functionally equivalent code:android.transition.Transition.getTransitionValues:COMMENT
Method Modifier: public      
Comment:/**
 * This method can be called by transitions to get the TransitionValues for
 * any particular view during the transition-playing process. This might be
 * necessary, for example, to query the before/after state of related views
 * for a given transition.
 */

Body of Frist Method:
{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    TransitionValues values = valuesMaps.viewValues.get(view);
    if (values == null) {
        int id = view.getId();
        if (id >= 0) {
            values = valuesMaps.idValues.get(id);
        }
        if (values == null && view.getParent() instanceof ListView) {
            ListView listview = (ListView) view.getParent();
            int position = listview.getPositionForView(view);
            long itemId = listview.getItemIdAtPosition(position);
            values = valuesMaps.itemIdValues.get(itemId);
        }
    // TODO: Doesn't handle the case where a view was parented to a
    // ListView (with an itemId), but no longer is
    }
    return values;
}
Body of Second Method:
{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    return valuesMaps.viewValues.get(view);
}
------------------------
Find a functionally equivalent code:android.graphics.Path.addArc:COMMENT
Method Modifier: public      
Comment:/**
 * Add the specified arc to the path as a new contour.
 *
 * @param oval The bounds of oval defining the shape and size of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 */

Body of Frist Method:
{
    if (oval == null) {
        throw new NullPointerException("need oval parameter");
    }
    isSimplePath = false;
    native_addArc(mNativePath, oval, startAngle, sweepAngle);
}
Body of Second Method:
{
    addArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle);
}
------------------------
Find a functionally equivalent code:android.preference.Preference.onBindView:COMMENT
Method Modifier: protected   
Comment:/**
 * Binds the created View to the data for this Preference.
 * <p>
 * This is a good place to grab references to custom Views in the layout and
 * set properties on them.
 * <p>
 * Make sure to call through to the superclass's implementation.
 *
 * @param view The View that shows this Preference.
 * @see #onCreateView(ViewGroup)
 */

Body of Frist Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getResources().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
Body of Second Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    final ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    final View imageFrame = view.findViewById(com.android.internal.R.id.icon_frame);
    if (imageFrame != null) {
        imageFrame.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.shouldUpRecreateTask:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */

Body of Frist Method:
{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return !ActivityManagerNative.getDefault().targetTaskAffinityMatchesActivity(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.removeJavaReferenceFor:COMMENT
Method Modifier: public      
Comment:/**
 * Removes the main reference on the given delegate.
 * @param native_object the native integer representing the delegate.
 */

Body of Frist Method:
{
    T delegate = getDelegate(native_object);
    if (Debug.DEBUG) {
        System.out.println("Removing main Java ref on " + mClass.getSimpleName() + " with int " + native_object);
    }
    mJavaReferences.remove(delegate);
}
Body of Second Method:
{
    T delegate = getDelegate(native_object);
    if (Debug.DEBUG) {
        System.out.println("Removing main Java ref on " + mClass.getSimpleName() + " with int " + native_object);
    }
    mJavaReferences.remove(delegate);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<Integer>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<Integer>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getIntegerArrayList(key);
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderAction.tearDown:COMMENT
Method Modifier: private     
Comment:/**
 * Tear down the session after rendering.
 * <p/>
 * The counterpart is {@link #setUp()}.
 */

Body of Frist Method:
{
    // The context may be null, if there was an error during init().
    if (mContext != null) {
        // Make sure to remove static references, otherwise we could not unload the lib
        mContext.disposeResources();
    }
    if (sCurrentContext != null) {
        // quit HandlerThread created during this session.
        HandlerThread_Delegate.cleanUp(sCurrentContext);
    }
    // clear the stored ViewConfiguration since the map is per density and not per context.
    ViewConfiguration_Accessor.clearConfigurations();
    // remove the InputMethodManager
    InputMethodManager_Accessor.resetInstance();
    sCurrentContext = null;
    Bridge.setLog(null);
    if (mContext != null) {
        mContext.getRenderResources().setFrameworkResourceIdProvider(null);
        mContext.getRenderResources().setLogger(null);
    }
    mContext = null;
}
Body of Second Method:
{
    // The context may be null, if there was an error during init().
    if (mContext != null) {
        // Make sure to remove static references, otherwise we could not unload the lib
        mContext.disposeResources();
    }
    if (sCurrentContext != null) {
        // quit HandlerThread created during this session.
        HandlerThread_Delegate.cleanUp(sCurrentContext);
    }
    // clear the stored ViewConfiguration since the map is per density and not per context.
    ViewConfiguration_Accessor.clearConfigurations();
    // remove the InputMethodManager
    InputMethodManager_Accessor.resetInstance();
    sCurrentContext = null;
    Bridge.setLog(null);
    if (mContext != null) {
        mContext.getRenderResources().setFrameworkResourceIdProvider(null);
        mContext.getRenderResources().setLogger(null);
    }
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.os.CountDownTimer.cancel:COMMENT
Method Modifier: public      final       
Comment:/**
 * Cancel the countdown.
 */

Body of Frist Method:
{
    mHandler.removeMessages(MSG);
}
Body of Second Method:
{
    mCancelled = true;
    mHandler.removeMessages(MSG);
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */

Body of Frist Method:
{
    return (mCalendarView.getVisibility() == View.VISIBLE);
}
Body of Second Method:
{
    return mDelegate.getCalendarViewShown();
}
------------------------
Find a functionally equivalent code:android.media.AudioService.checkForRingerModeChange:COMMENT
Method Modifier: private     
Comment:/**
 * Checks if the adjustment should change ringer mode instead of just
 * adjusting volume. If so, this will set the proper ringer mode and volume
 * indices on the stream states.
 */

Body of Frist Method:
{
    boolean adjustVolumeIndex = true;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            adjustVolumeIndex = false;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (mHasVibrator) {
                    ringerMode = RINGER_MODE_VIBRATE;
                } else {
                    ringerMode = RINGER_MODE_NORMAL;
                }
            }
            adjustVolumeIndex = false;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode);
    mPrevVolDirection = direction;
    return adjustVolumeIndex;
}
Body of Second Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, false);
    mPrevVolDirection = direction;
    return result;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayUpdate:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_UPDATE event
 */

Body of Frist Method:
/* USED ?*/
{
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(rcse.mRcClient))) {
                if (DEBUG_RC)
                    Log.i(TAG, "Display/update remote control ");
                mCurrentRcClientGen++;
                // synchronously update the displays and clients with
                // the new client generation
                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, rcse.mMediaIntent, /*newMediaIntent*/
                false);
                // tell the current client that it needs to send info
                try {
                    // TODO change name to informationRequestForAllDisplays()
                    mCurrentRcClient.onInformationRequested(mCurrentRcClientGen, flags);
                } catch (RemoteException e) {
                    Log.e(TAG, "Current valid remote client is dead: " + e);
                    mCurrentRcClient = null;
                }
            } else {
            // the remote control display owner has changed between the
            // the message to update the display was sent, and the time it
            // gets to be processed (now)
            }
        }
    }
}
Body of Second Method:
/* USED ?*/
{
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(prse.getRcc()))) {
                if (DEBUG_RC)
                    Log.i(TAG, "Display/update remote control ");
                mCurrentRcClientGen++;
                // synchronously update the displays and clients with
                // the new client generation
                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, prse.getMediaButtonIntent(), /*newMediaIntent*/
                false);
                // tell the current client that it needs to send info
                try {
                    // TODO change name to informationRequestForAllDisplays()
                    mCurrentRcClient.onInformationRequested(mCurrentRcClientGen, flags);
                } catch (RemoteException e) {
                    Log.e(TAG, "Current valid remote client is dead: " + e);
                    mCurrentRcClient = null;
                }
            } else {
            // the remote control display owner has changed between the
            // the message to update the display was sent, and the time it
            // gets to be processed (now)
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the calendar dates.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

Body of Frist Method:
{
    return mDateTextAppearanceResId;
}
Body of Second Method:
{
    return mDelegate.getDateTextAppearance();
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.DrawableContainer.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return (mCurrDrawable == null) ? Insets.NONE : mCurrDrawable.getOpticalInsets();
}
Body of Second Method:
{
    if (mCurrDrawable != null) {
        return mCurrDrawable.getOpticalInsets();
    }
    return Insets.NONE;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.measureViewToSide:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the bounds for a view that should be laid out against the edge
 * of an adjacent view. If no adjacent view is provided, lays out against
 * the list edge.
 *
 * @param view The view to measure for layout.
 * @param adjacent (Optional) The adjacent view, may be null to align to the
 * list edge.
 * @param margins Layout margins to apply to the view.
 * @param out Rectangle into which measured bounds are placed.
 */

Body of Frist Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxWidth = maxWidth - marginLeft - marginRight;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = view.getMeasuredWidth();
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
Body of Second Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxWidth = maxWidth - marginLeft - marginRight;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = Math.min(adjMaxWidth, view.getMeasuredWidth());
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
------------------------
Find a functionally equivalent code:android.app.Fragment.initState:COMMENT
Method Modifier: 
Comment:/**
 * Called by the fragment manager once this fragment has been removed,
 * so that we don't have any left-over state if the application decides
 * to re-use the instance.  This only clears state that the framework
 * internally manages, not things the application sets.
 */

Body of Frist Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mActivity = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
Body of Second Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mActivity = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.SlidingTab.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

Body of Frist Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration);
    }
}
Body of Second Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
    }
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putCharSequence:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequence(key, value);
}
------------------------
Find a functionally equivalent code:android.graphics.NinePatch.validateNinePatchChunk:COMMENT
Method Modifier: private     static      native      
Comment:/**
 * Validates the 9-patch chunk and throws an exception if the chunk is invalid.
 * If validation is successful, this method returns a native Res_png_9patch*
 * object used by the renderers.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.allocateAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */

Body of Frist Method:
{
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        return sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.screenshot.GlobalScreenshot.saveScreenshotInWorkerThread:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new worker thread and saves the screenshot to the media store.
 */

Body of Frist Method:
{
    SaveImageInBackgroundData data = new SaveImageInBackgroundData();
    data.context = mContext;
    data.image = mScreenBitmap;
    data.iconSize = mNotificationIconSize;
    data.finisher = finisher;
    if (mSaveInBgTask != null) {
        mSaveInBgTask.cancel(false);
    }
    mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, SCREENSHOT_NOTIFICATION_ID).execute(data);
}
Body of Second Method:
{
    SaveImageInBackgroundData data = new SaveImageInBackgroundData();
    data.context = mContext;
    data.image = mScreenBitmap;
    data.iconSize = mNotificationIconSize;
    data.finisher = finisher;
    data.previewWidth = mPreviewWidth;
    data.previewheight = mPreviewHeight;
    if (mSaveInBgTask != null) {
        mSaveInBgTask.cancel(false);
    }
    mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, SCREENSHOT_NOTIFICATION_ID).execute(data);
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getDayOfMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected day of month.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.DAY_OF_MONTH);
}
Body of Second Method:
{
    return mDelegate.getDayOfMonth();
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawCircle:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified circle using the specified paint. If radius is <= 0,
 * then nothing will be drawn. The circle will be filled or framed based
 * on the Style in the paint.
 *
 * @param cx     The x-coordinate of the center of the cirle to be drawn
 * @param cy     The y-coordinate of the center of the cirle to be drawn
 * @param radius The radius of the cirle to be drawn
 * @param paint  The paint used to draw the circle
 */

Body of Frist Method:
{
    native_drawCircle(mNativeCanvas, cx, cy, radius, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

Body of Frist Method:
{
    if (startAlpha == endAlpha) {
        // run listener if we're noop'ing the animation, to get the end-state results now
        if (listener != null) {
            listener.onAnimationEnd(null);
        }
        return null;
    }
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", startAlpha, endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    if (listener != null) {
        anim.addListener(listener);
        anim.addPauseListener(listener);
    }
    return anim;
}
Body of Second Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    return anim;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onIntChanged:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Called when an int feature changes, for the window to update its
 * graphics.
 *
 * @param featureId The feature being changed.
 * @param value The new integer value.
 */

Body of Frist Method:
{
    if (featureId == FEATURE_PROGRESS || featureId == FEATURE_INDETERMINATE_PROGRESS) {
        updateProgressBars(value);
    } else if (featureId == FEATURE_CUSTOM_TITLE) {
        FrameLayout titleContainer = (FrameLayout) findViewById(com.android.internal.R.id.title_container);
        if (titleContainer != null) {
            mLayoutInflater.inflate(value, titleContainer);
        }
    }
}
Body of Second Method:
{
    if (featureId == FEATURE_PROGRESS || featureId == FEATURE_INDETERMINATE_PROGRESS) {
        updateProgressBars(value);
    } else if (featureId == FEATURE_CUSTOM_TITLE) {
        FrameLayout titleContainer = (FrameLayout) findViewById(R.id.title_container);
        if (titleContainer != null) {
            mLayoutInflater.inflate(value, titleContainer);
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setPathEffect:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the patheffect object.
 * <p />
 * Pass null to clear any previous patheffect.
 * As a convenience, the parameter passed is also returned.
 *
 * @param effect May be null. The patheffect to be installed in the paint
 * @return       effect
 */

Body of Frist Method:
{
    int effectNative = 0;
    if (effect != null) {
        effectNative = effect.native_instance;
    }
    native_setPathEffect(mNativePaint, effectNative);
    mPathEffect = effect;
    return effect;
}
Body of Second Method:
{
    long effectNative = 0;
    if (effect != null) {
        effectNative = effect.native_instance;
    }
    native_setPathEffect(mNativePaint, effectNative);
    mPathEffect = effect;
    return effect;
}
------------------------
Find a functionally equivalent code:android.transition.Transition.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Pauses this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    if (!mEnded) {
        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
        int numOldAnims = runningAnimators.size();
        for (int i = numOldAnims - 1; i >= 0; i--) {
            Animator anim = runningAnimators.keyAt(i);
            anim.pause();
        }
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionPause(this);
            }
        }
        mPaused = true;
    }
}
Body of Second Method:
{
    if (!mEnded) {
        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
        int numOldAnims = runningAnimators.size();
        if (sceneRoot != null) {
            WindowId windowId = sceneRoot.getWindowId();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                AnimationInfo info = runningAnimators.valueAt(i);
                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
                    Animator anim = runningAnimators.keyAt(i);
                    anim.pause();
                }
            }
        }
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionPause(this);
            }
        }
        mPaused = true;
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] != null) {
        return mResourceData[index].getValue();
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    // As unfortunate as it is, it's possible to use enums with all attribute formats,
    // not just integers/enums. So, we need to search the enums always. In case
    // enums are used, the returned value is an integer.
    Integer v = resolveEnumAttribute(index);
    return v == null ? mResourceData[index].getValue() : String.valueOf((int) v);
}
------------------------
Find a functionally equivalent code:android.view.Window.setLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Set the width and height layout parameters of the window.  The default
 * for both of these is MATCH_PARENT; you can change them to WRAP_CONTENT
 * or an absolute value to make a window that is not full-screen.
 *
 * @param width The desired layout width of the window.
 * @param height The desired layout height of the window.
 *
 * @see ViewGroup.LayoutParams#height
 * @see ViewGroup.LayoutParams#width
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.width = width;
    attrs.height = height;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.width = width;
    attrs.height = height;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.goHome:COMMENT
Method Modifier: internal    
Comment:/**
 * goes to the home screen
 * @return whether it did anything
 */

Body of Frist Method:
{
    if (false) {
        // This code always brings home to the front.
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        sendCloseSystemWindows();
        startDockOrHome();
    } else {
        // at the front, puts the device to sleep.
        try {
            if (SystemProperties.getInt("persist.sys.uts-test-mode", 0) == 1) {
                // / Roll back EndcallBehavior as the cupcake design to pass P1 lab entry.
                Log.d(TAG, "UTS-TEST-MODE");
            } else {
                ActivityManagerNative.getDefault().stopAppSwitches();
                sendCloseSystemWindows();
                Intent dock = createHomeDockIntent();
                if (dock != null) {
                    int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, dock, dock.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, null, UserHandle.USER_CURRENT);
                    if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                        return false;
                    }
                }
            }
            int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, mHomeIntent, mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, null, UserHandle.USER_CURRENT);
            if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                return false;
            }
        } catch (RemoteException ex) {
        // bummer, the activity manager, which is in this process, is dead
        }
    }
    return true;
}
Body of Second Method:
{
    if (false) {
        // This code always brings home to the front.
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        sendCloseSystemWindows();
        startDockOrHome();
    } else {
        // at the front, puts the device to sleep.
        try {
            if (SystemProperties.getInt("persist.sys.uts-test-mode", 0) == 1) {
                // / Roll back EndcallBehavior as the cupcake design to pass P1 lab entry.
                Log.d(TAG, "UTS-TEST-MODE");
            } else {
                ActivityManagerNative.getDefault().stopAppSwitches();
                sendCloseSystemWindows();
                Intent dock = createHomeDockIntent();
                if (dock != null) {
                    int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, dock, dock.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, UserHandle.USER_CURRENT);
                    if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                        return false;
                    }
                }
            }
            int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, mHomeIntent, mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, UserHandle.USER_CURRENT);
            if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                return false;
            }
        } catch (RemoteException ex) {
        // bummer, the activity manager, which is in this process, is dead
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.app.ApplicationPackageManager.getResourcesForApplicationAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (userId < 0) {
        throw new IllegalArgumentException("Call does not support special user #" + userId);
    }
    if ("system".equals(appPackageName)) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, 0, userId);
        if (ai != null) {
            return getResourcesForApplication(ai);
        }
    } catch (RemoteException e) {
        throw new RuntimeException("Package manager has died", e);
    }
    throw new NameNotFoundException("Package " + appPackageName + " doesn't exist");
}
Body of Second Method:
{
    if (userId < 0) {
        throw new IllegalArgumentException("Call does not support special user #" + userId);
    }
    if ("system".equals(appPackageName)) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, sDefaultFlags, userId);
        if (ai != null) {
            return getResourcesForApplication(ai);
        }
    } catch (RemoteException e) {
        throw new RuntimeException("Package manager has died", e);
    }
    throw new NameNotFoundException("Package " + appPackageName + " doesn't exist");
}
------------------------
Find a functionally equivalent code:android.animation.ObjectAnimator.getTarget:COMMENT
Method Modifier: public      
Comment:/**
 * The target object whose property will be animated by this animation
 *
 * @return The object being animated
 */

Body of Frist Method:
{
    return mTarget;
}
Body of Second Method:
{
    return mTarget == null ? null : mTarget.get();
}
------------------------
Find a functionally equivalent code:android.graphics.pdf.PdfDocument.startPage:COMMENT
Method Modifier: public      
Comment:/**
 * Starts a page using the provided {@link PageInfo}. After the page
 * is created you can draw arbitrary content on the page's canvas which
 * you can get by calling {@link Page#getCanvas()}. After you are done
 * drawing the content you should finish the page by calling
 * {@link #finishPage(Page)}. After the page is finished you should
 * no longer access the page or its canvas.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * Also do not call this method if the last page returned by this method
 * is not finished by calling {@link #finishPage(Page)}.
 * </p>
 *
 * @param pageInfo The page info. Cannot be null.
 * @return A blank page.
 *
 * @see #finishPage(Page)
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfCurrentPageNotFinished();
    if (pageInfo == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    Canvas canvas = new PdfCanvas(nativeCreatePage(pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
    mCurrentPage = new Page(canvas, pageInfo);
    return mCurrentPage;
}
Body of Second Method:
{
    throwIfClosed();
    throwIfCurrentPageNotFinished();
    if (pageInfo == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    Canvas canvas = new PdfCanvas(nativeStartPage(mNativeDocument, pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
    mCurrentPage = new Page(canvas, pageInfo);
    return mCurrentPage;
}
------------------------
Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.insertForUser:COMMENT
Method Modifier: private     
Comment:// policy around permission to write settings for other users.

Body of Frist Method:
{
    final int callingUser = UserHandle.getCallingUserId();
    if (callingUser != desiredUserHandle) {
        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "Not permitted to access settings for other users");
    }
    if (LOCAL_LOGV)
        Slog.v(TAG, "insert(" + url + ") for user " + desiredUserHandle + " by " + callingUser);
    SqlArguments args = new SqlArguments(url);
    if (TABLE_FAVORITES.equals(args.table)) {
        return null;
    }
    // Special case LOCATION_PROVIDERS_ALLOWED.
    // Support enabling/disabling a single provider (using "+" or "-" prefix)
    String name = initialValues.getAsString(Settings.Secure.NAME);
    if (Settings.Secure.LOCATION_PROVIDERS_ALLOWED.equals(name)) {
        if (!parseProviderList(url, initialValues, desiredUserHandle))
            return null;
    }
    // redirect the operation to that store
    if (name != null) {
        if (sSecureGlobalKeys.contains(name) || sSystemGlobalKeys.contains(name)) {
            if (!TABLE_GLOBAL.equals(args.table)) {
                if (LOCAL_LOGV)
                    Slog.i(TAG, "Rewrite of insert() of now-global key " + name);
            }
            // next condition will rewrite the user handle
            args.table = TABLE_GLOBAL;
        }
    }
    // Check write permissions only after determining which table the insert will touch
    checkWritePermissions(args);
    // The global table is stored under the owner, always
    if (TABLE_GLOBAL.equals(args.table)) {
        desiredUserHandle = UserHandle.USER_OWNER;
    }
    SettingsCache cache = cacheForTable(desiredUserHandle, args.table);
    String value = initialValues.getAsString(Settings.NameValueTable.VALUE);
    if (SettingsCache.isRedundantSetValue(cache, name, value)) {
        return Uri.withAppendedPath(url, name);
    }
    final AtomicInteger mutationCount = sKnownMutationsInFlight.get(desiredUserHandle);
    mutationCount.incrementAndGet();
    DatabaseHelper dbH = getOrEstablishDatabase(desiredUserHandle);
    SQLiteDatabase db = dbH.getWritableDatabase();
    final long rowId = db.insert(args.table, null, initialValues);
    mutationCount.decrementAndGet();
    if (rowId <= 0)
        return null;
    // before we notify
    SettingsCache.populate(cache, initialValues);
    if (LOCAL_LOGV)
        Log.v(TAG, args.table + " <- " + initialValues + " for user " + desiredUserHandle);
    // Note that we use the original url here, not the potentially-rewritten table name
    url = getUriFor(url, initialValues, rowId);
    sendNotify(url, desiredUserHandle);
    return url;
}
Body of Second Method:
{
    final int callingUser = UserHandle.getCallingUserId();
    if (callingUser != desiredUserHandle) {
        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "Not permitted to access settings for other users");
    }
    if (LOCAL_LOGV)
        Slog.v(TAG, "insert(" + url + ") for user " + desiredUserHandle + " by " + callingUser);
    SqlArguments args = new SqlArguments(url);
    if (TABLE_FAVORITES.equals(args.table)) {
        return null;
    }
    // Special case LOCATION_PROVIDERS_ALLOWED.
    // Support enabling/disabling a single provider (using "+" or "-" prefix)
    String name = initialValues.getAsString(Settings.Secure.NAME);
    if (Settings.Secure.LOCATION_PROVIDERS_ALLOWED.equals(name)) {
        if (!parseProviderList(url, initialValues, desiredUserHandle))
            return null;
    }
    // redirect the operation to that store
    if (name != null) {
        if (sSecureGlobalKeys.contains(name) || sSystemGlobalKeys.contains(name)) {
            if (!TABLE_GLOBAL.equals(args.table)) {
                if (LOCAL_LOGV)
                    Slog.i(TAG, "Rewrite of insert() of now-global key " + name);
            }
            // next condition will rewrite the user handle
            args.table = TABLE_GLOBAL;
        }
    }
    // Check write permissions only after determining which table the insert will touch
    checkWritePermissions(args);
    checkUserRestrictions(name, desiredUserHandle);
    // The global table is stored under the owner, always
    if (TABLE_GLOBAL.equals(args.table)) {
        desiredUserHandle = UserHandle.USER_OWNER;
    }
    SettingsCache cache = cacheForTable(desiredUserHandle, args.table);
    String value = initialValues.getAsString(Settings.NameValueTable.VALUE);
    if (SettingsCache.isRedundantSetValue(cache, name, value)) {
        return Uri.withAppendedPath(url, name);
    }
    final AtomicInteger mutationCount;
    synchronized (this) {
        mutationCount = sKnownMutationsInFlight.get(callingUser);
    }
    if (mutationCount != null) {
        mutationCount.incrementAndGet();
    }
    DatabaseHelper dbH = getOrEstablishDatabase(desiredUserHandle);
    SQLiteDatabase db = dbH.getWritableDatabase();
    final long rowId = db.insert(args.table, null, initialValues);
    if (mutationCount != null) {
        mutationCount.decrementAndGet();
    }
    if (rowId <= 0)
        return null;
    // before we notify
    SettingsCache.populate(cache, initialValues);
    if (LOCAL_LOGV)
        Log.v(TAG, args.table + " <- " + initialValues + " for user " + desiredUserHandle);
    // Note that we use the original url here, not the potentially-rewritten table name
    url = getUriFor(url, initialValues, rowId);
    sendNotify(url, desiredUserHandle);
    return url;
}
------------------------
Find a functionally equivalent code:android.transition.Transition.isValidTarget:COMMENT
Method Modifier: 
Comment:/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where "valid" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */

Body of Frist Method:
{
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0) {
        return true;
    }
    if (mTargetIds.size() > 0) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            if (mTargetIds.get(i) == targetId) {
                return true;
            }
        }
    }
    if (target != null && mTargets.size() > 0) {
        for (int i = 0; i < mTargets.size(); ++i) {
            if (mTargets.get(i) == target) {
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.addFocusables:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                child.addFocusables(views, direction, focusableMode);
            }
        }
    }
    // among the focusable children would be more interesting.
    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
    (focusableCount == views.size())) {
        super.addFocusables(views, direction, focusableMode);
    }
}
Body of Second Method:
{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        if (shouldBlockFocusForTouchscreen()) {
            focusableMode |= FOCUSABLES_TOUCH_MODE;
        }
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                child.addFocusables(views, direction, focusableMode);
            }
        }
    }
    // among the focusable children would be more interesting.
    if ((descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
    (focusableCount == views.size())) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen())) {
        super.addFocusables(views, direction, focusableMode);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.removeWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mStatusBar == win) {
        mStatusBar = null;
        mStatusBarController.setWindow(null);
    } else if (mKeyguard == win) {
        Log.v(TAG, "Removing keyguard window (Did it crash?)");
        mKeyguard = null;
        mKeyguardDelegate.showScrim();
    } else if (mKeyguardScrim == win) {
        Log.v(TAG, "Removing keyguard scrim");
        mKeyguardScrim = null;
    }
    if (mNavigationBar == win) {
        mNavigationBar = null;
        mNavigationBarController.setWindow(null);
    }
}
Body of Second Method:
{
    if (mStatusBar == win) {
        mStatusBar = null;
        mStatusBarController.setWindow(null);
        mKeyguardDelegate.showScrim();
    } else if (mKeyguardScrim == win) {
        Log.v(TAG, "Removing keyguard scrim");
        mKeyguardScrim = null;
    }
    if (mNavigationBar == win) {
        mNavigationBar = null;
        mNavigationBarController.setWindow(null);
    }
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.considerName:COMMENT
Method Modifier: public      
Comment:/**
 * Considers the given class name as a dependency.
 * If it does, add to the mOutDeps map.
 */

Body of Frist Method:
{
    if (className == null) {
        return;
    }
    className = internalToBinaryClassName(className);
    // exclude classes that have already been found or are marked to be excluded
    if (mInKeep.containsKey(className) || mOutKeep.containsKey(className) || mInDeps.containsKey(className) || mOutDeps.containsKey(className) || mExcludedClasses.contains(getBaseName(className))) {
        return;
    }
    // exclude classes that are not part of the JAR file being examined
    ClassReader cr = mZipClasses.get(className);
    if (cr == null) {
        return;
    }
    try {
        // exclude classes that are part of the default JRE (the one executing this program)
        if (getClass().getClassLoader().loadClass(className) != null) {
            return;
        }
    } catch (ClassNotFoundException e) {
    // ignore
    }
    // to be stubbed).
    if (className.indexOf("android") >= 0) {
        // TODO make configurable
        mOutDeps.put(className, cr);
    } else {
        mOutKeep.put(className, cr);
    }
}
Body of Second Method:
{
    if (className == null) {
        return;
    }
    className = internalToBinaryClassName(className);
    // exclude classes that have already been found or are marked to be excluded
    if (mInKeep.containsKey(className) || mOutKeep.containsKey(className) || mInDeps.containsKey(className) || mOutDeps.containsKey(className) || mExcludedClasses.contains(getOuterClassName(className))) {
        return;
    }
    // exclude classes that are not part of the JAR file being examined
    ClassReader cr = mZipClasses.get(className);
    if (cr == null) {
        return;
    }
    try {
        // exclude classes that are part of the default JRE (the one executing this program)
        if (getClass().getClassLoader().loadClass(className) != null) {
            return;
        }
    } catch (ClassNotFoundException e) {
    // ignore
    }
    // to be stubbed).
    if (className.contains("android")) {
        // TODO make configurable
        mOutDeps.put(className, cr);
    } else {
        mOutKeep.put(className, cr);
    }
}
------------------------
Find a functionally equivalent code:android.util.ArrayMap.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

Body of Frist Method:
{
    if (mSize > 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    }
}
Body of Second Method:
{
    if (mSize > 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.availableMimeTypeForExternalSource:COMMENT
Method Modifier: private     static      
Comment:/*
     * A helper function to check if the mime type is supported by media framework.
     */

Body of Frist Method:
{
    if (mimeType == MEDIA_MIMETYPE_TEXT_SUBRIP) {
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (MEDIA_MIMETYPE_TEXT_SUBRIP.equals(mimeType)) {
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequenceArray(key, value);
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.utils.UncheckedThrow.throwAnyException:COMMENT
Method Modifier: public      static      
Comment:/**
 * Throw any kind of exception without needing it to be checked
 * @param e any instance of a Exception
 */

Body of Frist Method:
{
    /**
     * Abuse type erasure by making the compiler think we are throwing RuntimeException,
     * which is unchecked, but then inserting any exception in there.
     */
    UncheckedThrow.<RuntimeException>throwAnyImpl(e);
}
Body of Second Method:
{
    /**
     * Abuse type erasure by making the compiler think we are throwing RuntimeException,
     * which is unchecked, but then inserting any exception in there.
     */
    UncheckedThrow.<RuntimeException>throwAnyImpl(e);
}
------------------------
Find a functionally equivalent code:android.widget.Spinner.setPopupBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param resId Resource ID of a background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */

Body of Frist Method:
{
    setPopupBackgroundDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setPopupBackgroundDrawable(getContext().getDrawable(resId));
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.inflate:COMMENT
Method Modifier: public      
Comment:/**
 * Inflates the layout.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #init(long)} was not called.
 */

Body of Frist Method:
{
    checkLock();
    try {
        SessionParams params = getParams();
        HardwareConfig hardwareConfig = params.getHardwareConfig();
        BridgeContext context = getContext();
        boolean isRtl = Bridge.isLocaleRtl(params.getLocale());
        int direction = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
        // the view group that receives the window background.
        ViewGroup backgroundView = null;
        if (mWindowIsFloating || params.isForceNoDecor()) {
            backgroundView = mViewRoot = mContentRoot = new FrameLayout(context);
            mViewRoot.setLayoutDirection(direction);
        } else {
            if (hasSoftwareButtons() && mNavigationBarOrientation == LinearLayout.VERTICAL) {
                /*
                     * This is a special case where the navigation bar is on the right.
                       +-------------------------------------------------+---+
                       | Status bar (always)                             |   |
                       +-------------------------------------------------+   |
                       | (Layout with background drawable)               |   |
                       | +---------------------------------------------+ |   |
                       | | Title/Action bar (optional)                 | |   |
                       | +---------------------------------------------+ |   |
                       | | Content, vertical extending                 | |   |
                       | |                                             | |   |
                       | +---------------------------------------------+ |   |
                       +-------------------------------------------------+---+

                       So we create a horizontal layout, with the nav bar on the right,
                       and the left part is the normal layout below without the nav bar at
                       the bottom
                     */
                LinearLayout topLayout = new LinearLayout(context);
                topLayout.setLayoutDirection(direction);
                mViewRoot = topLayout;
                topLayout.setOrientation(LinearLayout.HORIZONTAL);
                try {
                    NavigationBar navigationBar = new NavigationBar(context, hardwareConfig.getDensity(), LinearLayout.VERTICAL, isRtl, params.isRtlSupported());
                    navigationBar.setLayoutParams(new LinearLayout.LayoutParams(mNavigationBarSize, LayoutParams.MATCH_PARENT));
                    topLayout.addView(navigationBar);
                } catch (XmlPullParserException e) {
                }
            }
            /*
                 * we're creating the following layout
                 *
                   +-------------------------------------------------+
                   | Status bar (always)                             |
                   +-------------------------------------------------+
                   | (Layout with background drawable)               |
                   | +---------------------------------------------+ |
                   | | Title/Action bar (optional)                 | |
                   | +---------------------------------------------+ |
                   | | Content, vertical extending                 | |
                   | |                                             | |
                   | +---------------------------------------------+ |
                   +-------------------------------------------------+
                   | Navigation bar for soft buttons, maybe see above|
                   +-------------------------------------------------+

                 */
            LinearLayout topLayout = new LinearLayout(context);
            topLayout.setOrientation(LinearLayout.VERTICAL);
            topLayout.setLayoutDirection(direction);
            // if we don't already have a view root this is it
            if (mViewRoot == null) {
                mViewRoot = topLayout;
            } else {
                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
                layoutParams.weight = 1;
                topLayout.setLayoutParams(layoutParams);
                // this top layout is the first layout in the horizontal layout. see above)
                if (isRtl && params.isRtlSupported()) {
                    // If RTL is enabled, layoutlib will mirror the layouts. So, add the
                    // topLayout to the right of Navigation Bar and layoutlib will draw it
                    // to the left.
                    mViewRoot.addView(topLayout);
                } else {
                    // Add the top layout to the left of the Navigation Bar.
                    mViewRoot.addView(topLayout, 0);
                }
            }
            if (mStatusBarSize > 0) {
                // system bar
                try {
                    StatusBar systemBar = new StatusBar(context, hardwareConfig.getDensity(), direction, params.isRtlSupported());
                    systemBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mStatusBarSize));
                    topLayout.addView(systemBar);
                } catch (XmlPullParserException e) {
                }
            }
            LinearLayout backgroundLayout = new LinearLayout(context);
            backgroundView = backgroundLayout;
            backgroundLayout.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
            layoutParams.weight = 1;
            backgroundLayout.setLayoutParams(layoutParams);
            topLayout.addView(backgroundLayout);
            // if the theme says no title/action bar, then the size will be 0
            if (mActionBarSize > 0) {
                try {
                    FakeActionBar actionBar = new FakeActionBar(context, hardwareConfig.getDensity(), params.getAppLabel(), params.getAppIcon());
                    actionBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mActionBarSize));
                    backgroundLayout.addView(actionBar);
                } catch (XmlPullParserException e) {
                }
            } else if (mTitleBarSize > 0) {
                try {
                    TitleBar titleBar = new TitleBar(context, hardwareConfig.getDensity(), params.getAppLabel());
                    titleBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mTitleBarSize));
                    backgroundLayout.addView(titleBar);
                } catch (XmlPullParserException e) {
                }
            }
            // content frame
            mContentRoot = new FrameLayout(context);
            layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
            layoutParams.weight = 1;
            mContentRoot.setLayoutParams(layoutParams);
            backgroundLayout.addView(mContentRoot);
            if (mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
                // system bar
                try {
                    NavigationBar navigationBar = new NavigationBar(context, hardwareConfig.getDensity(), LinearLayout.HORIZONTAL, isRtl, params.isRtlSupported());
                    navigationBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mNavigationBarSize));
                    topLayout.addView(navigationBar);
                } catch (XmlPullParserException e) {
                }
            }
        }
        // Sets the project callback (custom view loader) to the fragment delegate so that
        // it can instantiate the custom Fragment.
        Fragment_Delegate.setProjectCallback(params.getProjectCallback());
        View view = mInflater.inflate(mBlockParser, mContentRoot);
        // done with the parser, pop it.
        context.popParser();
        Fragment_Delegate.setProjectCallback(null);
        // set the AttachInfo on the root view.
        AttachInfo_Accessor.setAttachInfo(mViewRoot);
        // post-inflate process. For now this supports TabHost/TabWidget
        postInflateProcess(view, params.getProjectCallback());
        // get the background drawable
        if (mWindowBackground != null && backgroundView != null) {
            Drawable d = ResourceHelper.getDrawable(mWindowBackground, context);
            backgroundView.setBackground(d);
        }
        return SUCCESS.createResult();
    } catch (PostInflateException e) {
        return ERROR_INFLATION.createResult(e.getMessage(), e);
    } catch (Throwable e) {
        // get the real cause of the exception.
        Throwable t = e;
        while (t.getCause() != null) {
            t = t.getCause();
        }
        return ERROR_INFLATION.createResult(t.getMessage(), t);
    }
}
Body of Second Method:
{
    checkLock();
    try {
        SessionParams params = getParams();
        HardwareConfig hardwareConfig = params.getHardwareConfig();
        BridgeContext context = getContext();
        boolean isRtl = Bridge.isLocaleRtl(params.getLocale());
        int layoutDirection = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
        // the view group that receives the window background.
        ViewGroup backgroundView;
        if (mWindowIsFloating || params.isForceNoDecor()) {
            backgroundView = mViewRoot = mContentRoot = new FrameLayout(context);
            mViewRoot.setLayoutDirection(layoutDirection);
        } else {
            int simulatedPlatformVersion = params.getSimulatedPlatformVersion();
            if (hasSoftwareButtons() && mNavigationBarOrientation == LinearLayout.VERTICAL) {
                /*
                     * This is a special case where the navigation bar is on the right.
                       +-------------------------------------------------+---+
                       | Status bar (always)                             |   |
                       +-------------------------------------------------+   |
                       | (Layout with background drawable)               |   |
                       | +---------------------------------------------+ |   |
                       | | Title/Action bar (optional)                 | |   |
                       | +---------------------------------------------+ |   |
                       | | Content, vertical extending                 | |   |
                       | |                                             | |   |
                       | +---------------------------------------------+ |   |
                       +-------------------------------------------------+---+

                       So we create a horizontal layout, with the nav bar on the right,
                       and the left part is the normal layout below without the nav bar at
                       the bottom
                     */
                LinearLayout topLayout = new LinearLayout(context);
                topLayout.setLayoutDirection(layoutDirection);
                mViewRoot = topLayout;
                topLayout.setOrientation(LinearLayout.HORIZONTAL);
                if (Config.showOnScreenNavBar(simulatedPlatformVersion)) {
                    try {
                        NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                        topLayout.addView(navigationBar);
                    } catch (XmlPullParserException ignored) {
                    }
                }
            }
            /*
                 * we're creating the following layout
                 *
                   +-------------------------------------------------+
                   | Status bar (always)                             |
                   +-------------------------------------------------+
                   | (Layout with background drawable)               |
                   | +---------------------------------------------+ |
                   | | Title/Action bar (optional)                 | |
                   | +---------------------------------------------+ |
                   | | Content, vertical extending                 | |
                   | |                                             | |
                   | +---------------------------------------------+ |
                   +-------------------------------------------------+
                   | Navigation bar for soft buttons, maybe see above|
                   +-------------------------------------------------+

                 */
            LinearLayout topLayout = new LinearLayout(context);
            topLayout.setOrientation(LinearLayout.VERTICAL);
            topLayout.setLayoutDirection(layoutDirection);
            // if we don't already have a view root this is it
            if (mViewRoot == null) {
                mViewRoot = topLayout;
            } else {
                int topLayoutWidth = params.getHardwareConfig().getScreenWidth() - mNavigationBarSize;
                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(topLayoutWidth, LayoutParams.MATCH_PARENT);
                topLayout.setLayoutParams(layoutParams);
                // this top layout is the first layout in the horizontal layout. see above)
                if (isRtl && params.isRtlSupported()) {
                    // If RTL is enabled, layoutlib will mirror the layouts. So, add the
                    // topLayout to the right of Navigation Bar and layoutlib will draw it
                    // to the left.
                    mViewRoot.addView(topLayout);
                } else {
                    // Add the top layout to the left of the Navigation Bar.
                    mViewRoot.addView(topLayout, 0);
                }
            }
            if (mStatusBarSize > 0) {
                // system bar
                try {
                    StatusBar statusBar = createStatusBar(context, hardwareConfig.getDensity(), layoutDirection, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(statusBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            LinearLayout backgroundLayout = new LinearLayout(context);
            backgroundView = backgroundLayout;
            backgroundLayout.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
            layoutParams.weight = 1;
            backgroundLayout.setLayoutParams(layoutParams);
            topLayout.addView(backgroundLayout);
            // if the theme says no title/action bar, then the size will be 0
            if (mActionBarSize > 0) {
                ActionBarLayout actionBar = createActionBar(context, params);
                backgroundLayout.addView(actionBar);
                actionBar.createMenuPopup();
                mContentRoot = actionBar.getContentRoot();
            } else if (mTitleBarSize > 0) {
                try {
                    TitleBar titleBar = createTitleBar(context, params.getAppLabel(), simulatedPlatformVersion);
                    backgroundLayout.addView(titleBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            // content frame
            if (mContentRoot == null) {
                mContentRoot = new FrameLayout(context);
                layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
                layoutParams.weight = 1;
                mContentRoot.setLayoutParams(layoutParams);
                backgroundLayout.addView(mContentRoot);
            }
            if (Config.showOnScreenNavBar(simulatedPlatformVersion) && mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
                // system bar
                try {
                    NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(navigationBar);
                } catch (XmlPullParserException ignored) {
                }
            }
        }
        // Sets the project callback (custom view loader) to the fragment delegate so that
        // it can instantiate the custom Fragment.
        Fragment_Delegate.setProjectCallback(params.getProjectCallback());
        View view = mInflater.inflate(mBlockParser, mContentRoot);
        // done with the parser, pop it.
        context.popParser();
        Fragment_Delegate.setProjectCallback(null);
        // set the AttachInfo on the root view.
        AttachInfo_Accessor.setAttachInfo(mViewRoot);
        // post-inflate process. For now this supports TabHost/TabWidget
        postInflateProcess(view, params.getProjectCallback());
        // get the background drawable
        if (mWindowBackground != null) {
            Drawable d = ResourceHelper.getDrawable(mWindowBackground, context);
            backgroundView.setBackground(d);
        }
        return SUCCESS.createResult();
    } catch (PostInflateException e) {
        return ERROR_INFLATION.createResult(e.getMessage(), e);
    } catch (Throwable e) {
        // get the real cause of the exception.
        Throwable t = e;
        while (t.getCause() != null) {
            t = t.getCause();
        }
        return ERROR_INFLATION.createResult(t.getMessage(), t);
    }
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the type for this restriction.
 * @return the type for this restriction
 */

Body of Frist Method:
{
    return type;
}
Body of Second Method:
{
    return mType;
}
------------------------
Find a functionally equivalent code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case RAW_SENSOR:
            return 16;
        case BAYER_RGGB:
            return 16;
    }
    return -1;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
    }
    return -1;
}
------------------------
Find a functionally equivalent code:android.app.Activity.onWindowStartingActionMode:COMMENT
Method Modifier: public      
Comment:/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */

Body of Frist Method:
{
    initActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}
Body of Second Method:
{
    initWindowDecorActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.requestAudioFocus:COMMENT
Method Modifier: protected   
Comment:/**
 * @see AudioManager#requestAudioFocus(AudioManager.OnAudioFocusChangeListener, int, int)
 */

Body of Frist Method:
{
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_AUDIO_FOCUS, Binder.getCallingUid(), callingPackageName) != AppOpsManager.MODE_ALLOWED) {
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().getGainRequest() == focusChangeHint) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // the reason for the audio focus request has changed: remove the current top of
            // stack and respond as if we had a new focus owner
            FocusRequester fr = mFocusStack.pop();
            fr.release();
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        // propagate the focus change through the stack
        if (!mFocusStack.empty()) {
            propagateFocusLossFromGain_syncAf(focusChangeHint);
        }
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusRequester(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid()));
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
Body of Second Method:
{
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_AUDIO_FOCUS, Binder.getCallingUid(), callingPackageName) != AppOpsManager.MODE_ALLOWED) {
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().getGainRequest() == focusChangeHint) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // the reason for the audio focus request has changed: remove the current top of
            // stack and respond as if we had a new focus owner
            FocusRequester fr = mFocusStack.pop();
            fr.release();
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        // propagate the focus change through the stack
        if (!mFocusStack.empty()) {
            propagateFocusLossFromGain_syncAf(focusChangeHint);
        }
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusRequester(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid()));
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the number of weeks to be shown.
 *
 * @param count The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

Body of Frist Method:
{
    if (mShownWeekCount != count) {
        mShownWeekCount = count;
        invalidate();
    }
}
Body of Second Method:
{
    mDelegate.setShownWeekCount(count);
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.insertChild:COMMENT
Method Modifier: public      
Comment:/**
 * Insert a new child into an existing parent.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#insertChild(Object, ILayoutPullParser, int, IAnimationListener)
 */

Body of Frist Method:
{
    checkLock();
    BridgeContext context = getContext();
    // create a block parser for the XML
    BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(childXml, context, false);
    // inflate the child without adding it to the root since we want to control where it'll
    // get added. We do pass the parentView however to ensure that the layoutParams will
    // be created correctly.
    final View child = mInflater.inflate(blockParser, parentView, false);
    blockParser.ensurePopped();
    invalidateRenderingSize();
    if (listener != null) {
        new AnimationThread(this, "insertChild", listener) {

            @Override
            public Result preAnimation() {
                parentView.setLayoutTransition(new LayoutTransition());
                return addView(parentView, child, index);
            }

            @Override
            public void postAnimation() {
                parentView.setLayoutTransition(null);
            }
        }.start();
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult(child);
    }
    // add it to the parentView in the correct location
    Result result = addView(parentView, child, index);
    if (result.isSuccess() == false) {
        return result;
    }
    result = render(false);
    if (result.isSuccess()) {
        result = result.getCopyWithData(child);
    }
    return result;
}
Body of Second Method:
{
    checkLock();
    BridgeContext context = getContext();
    // create a block parser for the XML
    BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(childXml, context, false);
    // inflate the child without adding it to the root since we want to control where it'll
    // get added. We do pass the parentView however to ensure that the layoutParams will
    // be created correctly.
    final View child = mInflater.inflate(blockParser, parentView, false);
    blockParser.ensurePopped();
    invalidateRenderingSize();
    if (listener != null) {
        new AnimationThread(this, "insertChild", listener) {

            @Override
            public Result preAnimation() {
                parentView.setLayoutTransition(new LayoutTransition());
                return addView(parentView, child, index);
            }

            @Override
            public void postAnimation() {
                parentView.setLayoutTransition(null);
            }
        }.start();
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult(child);
    }
    // add it to the parentView in the correct location
    Result result = addView(parentView, child, index);
    if (!result.isSuccess()) {
        return result;
    }
    result = render(false);
    if (result.isSuccess()) {
        result = result.getCopyWithData(child);
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.app.Activity.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically opens the options menu. If the options menu is already
 * open, this method does nothing.
 */

Body of Frist Method:
{
    mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
}
Body of Second Method:
{
    if (mActionBar == null || !mActionBar.openOptionsMenu()) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a functionally equivalent code:android.print.PrinterCapabilitiesInfo.getMediaSizes:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported media sizes.
 *
 * @return The media sizes.
 */

Body of Frist Method:
{
    return mMediaSizes;
}
Body of Second Method:
{
    return Collections.unmodifiableList(mMediaSizes);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of weeks to be shown.
 *
 * @return The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

Body of Frist Method:
{
    return mShownWeekCount;
}
Body of Second Method:
{
    return mDelegate.getShownWeekCount();
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothDevice.createBond:COMMENT
Method Modifier: public      
Comment:/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        return sService.createBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified path using the specified paint. The path will be
 * filled or framed based on the Style in the paint.
 *
 * @param path  The path to be drawn
 * @param paint The paint used to draw the path
 */

Body of Frist Method:
{
    native_drawPath(mNativeCanvas, path.ni(), paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.getAllocationByteCount:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the allocated memory used to store this bitmap's pixels.
 *
 * <p>This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to
 * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link
 * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link
 * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap
 * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be
 * the same as that returned by {@link #getByteCount()}.</p>
 *
 * <p>This value will not change over the lifetime of a Bitmap.</p>
 *
 * @see #reconfigure(int, int, Config)
 */

Body of Frist Method:
{
    return mBuffer.length;
}
Body of Second Method:
{
    if (mBuffer == null) {
        // so alloc size is always content size
        return getByteCount();
    }
    return mBuffer.length;
}
------------------------
Find a functionally equivalent code:android.app.Activity.startActivityForResult:COMMENT
Method Modifier: public      
Comment:/**
 * Same as calling {@link #startActivityForResult(Intent, int, Bundle)}
 * with no options.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see #startActivity
 */

Body of Frist Method:
{
    startActivityForResult(intent, requestCode, null);
}
Body of Second Method:
{
    startActivityForResult(intent, requestCode, null);
}
------------------------
Find a functionally equivalent code:android.nfc.tech.Ndef.getNdefMessage:COMMENT
Method Modifier: public      
Comment:/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */

Body of Frist Method:
{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException("Mock tags don't support this operation.");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "NFC service dead", e);
        return null;
    }
}
Body of Second Method:
{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException("Mock tags don't support this operation.");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else if (!tagService.isPresent(serviceHandle)) {
            throw new TagLostException();
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "NFC service dead", e);
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.isFastScrollEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */

Body of Frist Method:
{
    if (mFastScroller == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroller.isEnabled();
    }
}
Body of Second Method:
{
    if (mFastScroll == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroll.isEnabled();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.handleSystemServerProcess:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Finish remaining work for the newly forked system server process.
 */

Body of Frist Method:
{
    closeServerSocket();
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Libcore.os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    if (parsedArgs.invokeWith != null) {
        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, parsedArgs.remainingArgs);
    } else {
        /*
             * Pass the remaining arguments to SystemServer.
             */
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
    }
/* should never reach here */
}
Body of Second Method:
{
    closeServerSocket();
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
    if (systemServerClasspath != null) {
        performSystemServerDexOpt(systemServerClasspath);
    }
    if (parsedArgs.invokeWith != null) {
        String[] args = parsedArgs.remainingArgs;
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = "-cp";
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);
        }
        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, args);
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());
            Thread.currentThread().setContextClassLoader(cl);
        }
        /*
             * Pass the remaining arguments to SystemServer.
             */
        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
    }
/* should never reach here */
}
------------------------
Find a functionally equivalent code:android.app.ActivityManager.dumpPackageStateStatic:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "package", packageName });
    pw.println();
    dumpService(pw, fd, ProcessStats.SERVICE_NAME, new String[] { packageName });
    pw.println();
    dumpService(pw, fd, "usagestats", new String[] { "--packages", packageName });
    pw.println();
    dumpService(pw, fd, "package", new String[] { packageName });
    pw.println();
    dumpService(pw, fd, BatteryStats.SERVICE_NAME, new String[] { packageName });
    pw.flush();
}
Body of Second Method:
{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    dumpService(pw, fd, "package", new String[] { packageName });
    pw.println();
    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "-a", "package", packageName });
    pw.println();
    dumpService(pw, fd, "meminfo", new String[] { "--local", "--package", packageName });
    pw.println();
    dumpService(pw, fd, ProcessStats.SERVICE_NAME, new String[] { packageName });
    pw.println();
    dumpService(pw, fd, "usagestats", new String[] { "--packages", packageName });
    pw.println();
    dumpService(pw, fd, BatteryStats.SERVICE_NAME, new String[] { packageName });
    pw.flush();
}
------------------------
Find a functionally equivalent code:android.app.Notification.Style.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mSummaryTextSet) {
        extras.putCharSequence(EXTRA_SUMMARY_TEXT, mSummaryText);
    }
    if (mBigContentTitle != null) {
        extras.putCharSequence(EXTRA_TITLE_BIG, mBigContentTitle);
    }
}
Body of Second Method:
{
    if (mSummaryTextSet) {
        extras.putCharSequence(EXTRA_SUMMARY_TEXT, mSummaryText);
    }
    if (mBigContentTitle != null) {
        extras.putCharSequence(EXTRA_TITLE_BIG, mBigContentTitle);
    }
    extras.putString(EXTRA_TEMPLATE, this.getClass().getName());
}
------------------------
Find a functionally equivalent code:android.view.HardwareLayer.isValid:COMMENT
<android.view.HardwareLayer: boolean isValid()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Indicates whether this layer can be rendered.
 *
 * @return True if the layer can be rendered into, false otherwise
 */

Body of Frist Method:

Body of Second Method:
{
    return mFinalizer != null && mFinalizer.get() != 0;
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.translate:COMMENT
<android.graphics.Canvas: void translate(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified translation
 *
 * @param dx The distance to translate in X
 * @param dy The distance to translate in Y
 */

Body of Frist Method:

Body of Second Method:
{
    native_translate(mNativeCanvasWrapper, dx, dy);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getResources:COMMENT
Method Modifier: public      
Comment:/**
 * Return the Resources object this array was loaded from.
 */

Body of Frist Method:
{
    return mResources;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mResources;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.MyMethodVisitor.visitFieldInsn:COMMENT
Method Modifier: public      
Comment:// field instruction

Body of Frist Method:
{
    // name is the field's name.
    considerName(name);
    // desc is the field's descriptor (see Type).
    considerDesc(desc);
}
Body of Second Method:
{
    // owner is the class that declares the field.
    considerName(owner);
    // desc is the field's descriptor (see Type).
    considerDesc(desc);
}
------------------------
Find a functionally equivalent code:android.view.SurfaceControl.PhysicalDisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + "}";
}
Body of Second Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + ", appVsyncOffset " + appVsyncOffsetNanos + ", bufferDeadline " + presentationDeadlineNanos + "}";
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.doSecondaryLookupIfNecessary:COMMENT
Method Modifier: default     static      internal    
Comment:/**
 * Performs another lookup if previous lookup fails and it's a SIP call
 * and the peer's username is all numeric. Look up the username as it
 * could be a PSTN number in the contact database.
 *
 * @param context the query context
 * @param number the original phone number, could be a SIP URI
 * @param previousResult the result of previous lookup
 * @return previousResult if it's not the case
 */

Body of Frist Method:
{
    if (!previousResult.contactExists && PhoneNumberUtils.isUriNumber(number)) {
        String username = PhoneNumberUtils.getUsernameFromUriNumber(number);
        if (PhoneNumberUtils.isGlobalPhoneNumber(username)) {
            previousResult = getCallerInfo(context, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(username)));
        }
    }
    return previousResult;
}
Body of Second Method:
{
    if (!previousResult.contactExists && PhoneNumberUtils.isUriNumber(number)) {
        String username = PhoneNumberUtils.getUsernameFromUriNumber(number);
        if (PhoneNumberUtils.isGlobalPhoneNumber(username)) {
            previousResult = getCallerInfo(context, Uri.withAppendedPath(PhoneLookup.ENTERPRISE_CONTENT_FILTER_URI, Uri.encode(username)));
        }
    }
    return previousResult;
}
------------------------
Find a functionally equivalent code:com.android.internal.view.InputBindResult.writeToParcel:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeStrongInterface(method);
    if (channel != null) {
        dest.writeInt(1);
        channel.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(id);
    dest.writeInt(sequence);
}
Body of Second Method:
{
    dest.writeStrongInterface(method);
    if (channel != null) {
        dest.writeInt(1);
        channel.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(id);
    dest.writeInt(sequence);
    dest.writeInt(userActionNotificationSequenceNumber);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException("Failed to resolve attribute at index " + index);
        }
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.setAuxEffectSendLevel:COMMENT
<android.media.MediaPlayer: void setAuxEffectSendLevel(float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the send level of the player to the attached auxiliary effect
 * {@see #attachAuxEffect(int)}. The level value range is 0 to 1.0.
 * <p>By default the send level is 0, so even if an effect is attached to the player
 * this method must be called for the effect to be applied.
 * <p>Note that the passed level value is a raw scalar. UI controls should be scaled
 * logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 * so an appropriate conversion from linear UI input x to level is:
 * x == 0 -> level = 0
 * 0 < x <= R -> level = 10^(72*(x-R)/20/R)
 * @param level send level scalar
 */

Body of Frist Method:

Body of Second Method:
{
    if (isRestricted()) {
        return;
    }
    _setAuxEffectSendLevel(level);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the separator line between weeks.
 *
 * @param color The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

Body of Frist Method:
{
    if (mWeekSeparatorLineColor != color) {
        mWeekSeparatorLineColor = color;
        invalidateAllWeekViews();
    }
}
Body of Second Method:
{
    mDelegate.setWeekSeparatorLineColor(color);
}
------------------------
Find a functionally equivalent code:android.content.SyncInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    parcel.writeInt(authorityId);
    account.writeToParcel(parcel, 0);
    parcel.writeString(authority);
    parcel.writeLong(startTime);
}
Body of Second Method:
{
    parcel.writeInt(authorityId);
    parcel.writeParcelable(account, flags);
    parcel.writeString(authority);
    parcel.writeLong(startTime);
}
------------------------
Find a functionally equivalent code:android.view.HardwareLayer.destroy:COMMENT
<android.view.HardwareLayer: void destroy()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Destroys resources without waiting for a GC.
 */

Body of Frist Method:

Body of Second Method:
{
    if (!isValid()) {
        // Already destroyed
        return;
    }
    mRenderer.onLayerDestroyed(this);
    mRenderer = null;
    mFinalizer.release();
    mFinalizer = null;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRefreshCarrierInfo:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshCarrierInfo(CharSequence,CharSequence)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the carrier PLMN or SPN changes.
 *
 * @param plmn The operator name of the registered network.  May be null if it shouldn't
 * be displayed.
 * @param spn The service provider name.  May be null if it shouldn't be displayed.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.app.SharedPreferencesImpl.EditorImpl.commitToMemory:COMMENT
Method Modifier: private     
Comment:// Returns true if any changes were made

Body of Frist Method:
{
    MemoryCommitResult mcr = new MemoryCommitResult();
    synchronized (SharedPreferencesImpl.this) {
        // writing to disk.
        if (mDiskWritesInFlight > 0) {
            // We can't modify our mMap as a currently
            // in-flight write owns it.  Clone it before
            // modifying it.
            // noinspection unchecked
            mMap = new HashMap<String, Object>(mMap);
        }
        mcr.mapToWriteToDisk = mMap;
        mDiskWritesInFlight++;
        boolean hasListeners = mListeners.size() > 0;
        if (hasListeners) {
            mcr.keysModified = new ArrayList<String>();
            mcr.listeners = new HashSet<OnSharedPreferenceChangeListener>(mListeners.keySet());
        }
        synchronized (this) {
            if (mClear) {
                if (!mMap.isEmpty()) {
                    mcr.changesMade = true;
                    mMap.clear();
                }
                mClear = false;
            }
            for (Map.Entry<String, Object> e : mModified.entrySet()) {
                String k = e.getKey();
                Object v = e.getValue();
                if (v == this) {
                    // magic value for a removal mutation
                    if (!mMap.containsKey(k)) {
                        continue;
                    }
                    mMap.remove(k);
                } else {
                    boolean isSame = false;
                    if (mMap.containsKey(k)) {
                        Object existingValue = mMap.get(k);
                        if (existingValue != null && existingValue.equals(v)) {
                            continue;
                        }
                    }
                    mMap.put(k, v);
                }
                mcr.changesMade = true;
                if (hasListeners) {
                    mcr.keysModified.add(k);
                }
            }
            mModified.clear();
        }
    }
    return mcr;
}
Body of Second Method:
{
    MemoryCommitResult mcr = new MemoryCommitResult();
    synchronized (SharedPreferencesImpl.this) {
        // writing to disk.
        if (mDiskWritesInFlight > 0) {
            // We can't modify our mMap as a currently
            // in-flight write owns it.  Clone it before
            // modifying it.
            // noinspection unchecked
            mMap = new HashMap<String, Object>(mMap);
        }
        mcr.mapToWriteToDisk = mMap;
        mDiskWritesInFlight++;
        boolean hasListeners = mListeners.size() > 0;
        if (hasListeners) {
            mcr.keysModified = new ArrayList<String>();
            mcr.listeners = new HashSet<OnSharedPreferenceChangeListener>(mListeners.keySet());
        }
        synchronized (this) {
            if (mClear) {
                if (!mMap.isEmpty()) {
                    mcr.changesMade = true;
                    mMap.clear();
                }
                mClear = false;
            }
            for (Map.Entry<String, Object> e : mModified.entrySet()) {
                String k = e.getKey();
                Object v = e.getValue();
                // equivalent to calling remove on that key.
                if (v == this || v == null) {
                    if (!mMap.containsKey(k)) {
                        continue;
                    }
                    mMap.remove(k);
                } else {
                    if (mMap.containsKey(k)) {
                        Object existingValue = mMap.get(k);
                        if (existingValue != null && existingValue.equals(v)) {
                            continue;
                        }
                    }
                    mMap.put(k, v);
                }
                mcr.changesMade = true;
                if (hasListeners) {
                    mcr.keysModified.add(k);
                }
            }
            mModified.clear();
        }
    }
    return mcr;
}
------------------------
Find a functionally equivalent code:android.widget.ShareActionProvider.onCreateActionView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // Create the view and set its data model.
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    activityChooserView.setActivityChooserModel(dataModel);
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getResources().getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}
Body of Second Method:
{
    // Create the view and set its data model.
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    if (!activityChooserView.isInEditMode()) {
        ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
        activityChooserView.setActivityChooserModel(dataModel);
    }
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}
------------------------
Find a functionally equivalent code:android.net.Proxy.setHttpProxySystemProperty:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String host = null;
    String port = null;
    String exclList = null;
    String pacFileUrl = null;
    if (p != null) {
        host = p.getHost();
        port = Integer.toString(p.getPort());
        exclList = p.getExclusionList();
        pacFileUrl = p.getPacFileUrl();
    }
    setHttpProxySystemProperty(host, port, exclList, pacFileUrl);
}
Body of Second Method:
{
    String host = null;
    String port = null;
    String exclList = null;
    Uri pacFileUrl = Uri.EMPTY;
    if (p != null) {
        host = p.getHost();
        port = Integer.toString(p.getPort());
        exclList = p.getExclusionListAsString();
        pacFileUrl = p.getPacFileUrl();
    }
    setHttpProxySystemProperty(host, port, exclList, pacFileUrl);
}
------------------------
Find a functionally equivalent code:android.util.EventLog.Event.getTag:COMMENT
Method Modifier: public      
Comment:/**
 * @return the type tag code of the entry
 */

Body of Frist Method:
{
    return mBuffer.getInt(TAG_OFFSET);
}
Body of Second Method:
{
    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
    if (offset == 0) {
        offset = V1_PAYLOAD_START;
    }
    return mBuffer.getInt(offset);
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.delayedAnimationFrame:COMMENT
Method Modifier: private     
Comment:/**
 * Internal function called to process an animation frame on an animation that is currently
 * sleeping through its <code>startDelay</code> phase. The return value indicates whether it
 * should be woken up and put on the active animations queue.
 *
 * @param currentTime The current animation time, used to calculate whether the animation
 * has exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animation
 * should be added to the set of active animations.
 */

Body of Frist Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    } else {
        if (mPaused) {
            if (mPauseTime < 0) {
                mPauseTime = currentTime;
            }
            return false;
        } else if (mResumed) {
            mResumed = false;
            if (mPauseTime > 0) {
                // Offset by the duration that the animation was paused
                mDelayStartTime += (currentTime - mPauseTime);
            }
        }
        long deltaTime = currentTime - mDelayStartTime;
        if (deltaTime > mStartDelay) {
            // startDelay ended - start the anim and record the
            // mStartTime appropriately
            mStartTime = currentTime - (deltaTime - mStartDelay);
            mPlayingState = RUNNING;
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = currentTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mDelayStartTime += (currentTime - mPauseTime);
        }
    }
    long deltaTime = currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
        // startDelay ended - start the anim and record the
        // mStartTime appropriately
        mStartTime = currentTime - (deltaTime - mStartDelay);
        mPlayingState = RUNNING;
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupEndValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the end values for an animation.
 * The end values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
}
Body of Second Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
------------------------
Find a functionally equivalent code:com.android.documentsui.RootsCache.updateAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Gather roots from all known storage providers.
 */

Body of Frist Method:
{
    // Special root for recents
    mRecentsRoot.authority = null;
    mRecentsRoot.rootId = null;
    mRecentsRoot.icon = R.drawable.ic_root_recent;
    mRecentsRoot.flags = Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_CREATE;
    mRecentsRoot.title = mContext.getString(R.string.root_recent);
    mRecentsRoot.availableBytes = -1;
    new UpdateTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
Body of Second Method:
{
    // Special root for recents
    mRecentsRoot.authority = null;
    mRecentsRoot.rootId = null;
    mRecentsRoot.derivedIcon = R.drawable.ic_root_recent;
    mRecentsRoot.flags = Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_IS_CHILD;
    mRecentsRoot.title = mContext.getString(R.string.root_recent);
    mRecentsRoot.availableBytes = -1;
    new UpdateTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
------------------------
Find a functionally equivalent code:android.app.ActivityThread.handleCreateBackupAgent:COMMENT
Method Modifier: private     
Comment:// Instantiate a BackupAgent and tell it that it's alive

Body of Frist Method:
{
    if (DEBUG_BACKUP)
        Slog.v(TAG, "handleCreateBackupAgent: " + data);
    // Sanity check the requested target package's uid against ours
    try {
        PackageInfo requestedPackage = getPackageManager().getPackageInfo(data.appInfo.packageName, 0, UserHandle.myUserId());
        if (requestedPackage.applicationInfo.uid != Process.myUid()) {
            Slog.w(TAG, "Asked to instantiate non-matching package " + data.appInfo.packageName);
            return;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Can't reach package manager", e);
        return;
    }
    // no longer idle; we have backup work to do
    unscheduleGcIdler();
    // instantiate the BackupAgent class named in the manifest
    LoadedApk packageInfo = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    String packageName = packageInfo.mPackageName;
    if (packageName == null) {
        Slog.d(TAG, "Asked to create backup agent for nonexistent package");
        return;
    }
    if (mBackupAgents.get(packageName) != null) {
        Slog.d(TAG, "BackupAgent " + "  for " + packageName + " already exists");
        return;
    }
    BackupAgent agent = null;
    String classname = data.appInfo.backupAgentName;
    // full backup operation but no app-supplied agent?  use the default implementation
    if (classname == null && (data.backupMode == IApplicationThread.BACKUP_MODE_FULL || data.backupMode == IApplicationThread.BACKUP_MODE_RESTORE_FULL)) {
        classname = "android.app.backup.FullBackupAgent";
    }
    try {
        IBinder binder = null;
        try {
            if (DEBUG_BACKUP)
                Slog.v(TAG, "Initializing agent class " + classname);
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            agent = (BackupAgent) cl.loadClass(classname).newInstance();
            // set up the agent's context
            ContextImpl context = new ContextImpl();
            context.init(packageInfo, null, this);
            context.setOuterContext(agent);
            agent.attach(context);
            agent.onCreate();
            binder = agent.onBind();
            mBackupAgents.put(packageName, agent);
        } catch (Exception e) {
            // If this is during restore, fail silently; otherwise go
            // ahead and let the user see the crash.
            Slog.e(TAG, "Agent threw during creation: " + e);
            if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
                throw e;
            }
        // falling through with 'binder' still null
        }
        // tell the OS that we're live now
        try {
            ActivityManagerNative.getDefault().backupAgentCreated(packageName, binder);
        } catch (RemoteException e) {
        // nothing to do.
        }
    } catch (Exception e) {
        throw new RuntimeException("Unable to create BackupAgent " + classname + ": " + e.toString(), e);
    }
}
Body of Second Method:
{
    if (DEBUG_BACKUP)
        Slog.v(TAG, "handleCreateBackupAgent: " + data);
    // Sanity check the requested target package's uid against ours
    try {
        PackageInfo requestedPackage = getPackageManager().getPackageInfo(data.appInfo.packageName, 0, UserHandle.myUserId());
        if (requestedPackage.applicationInfo.uid != Process.myUid()) {
            Slog.w(TAG, "Asked to instantiate non-matching package " + data.appInfo.packageName);
            return;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Can't reach package manager", e);
        return;
    }
    // no longer idle; we have backup work to do
    unscheduleGcIdler();
    // instantiate the BackupAgent class named in the manifest
    LoadedApk packageInfo = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    String packageName = packageInfo.mPackageName;
    if (packageName == null) {
        Slog.d(TAG, "Asked to create backup agent for nonexistent package");
        return;
    }
    String classname = data.appInfo.backupAgentName;
    // full backup operation but no app-supplied agent?  use the default implementation
    if (classname == null && (data.backupMode == IApplicationThread.BACKUP_MODE_FULL || data.backupMode == IApplicationThread.BACKUP_MODE_RESTORE_FULL)) {
        classname = "android.app.backup.FullBackupAgent";
    }
    try {
        IBinder binder = null;
        BackupAgent agent = mBackupAgents.get(packageName);
        if (agent != null) {
            // reusing the existing instance
            if (DEBUG_BACKUP) {
                Slog.v(TAG, "Reusing existing agent instance");
            }
            binder = agent.onBind();
        } else {
            try {
                if (DEBUG_BACKUP)
                    Slog.v(TAG, "Initializing agent class " + classname);
                java.lang.ClassLoader cl = packageInfo.getClassLoader();
                agent = (BackupAgent) cl.loadClass(classname).newInstance();
                // set up the agent's context
                ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
                context.setOuterContext(agent);
                agent.attach(context);
                agent.onCreate();
                binder = agent.onBind();
                mBackupAgents.put(packageName, agent);
            } catch (Exception e) {
                // If this is during restore, fail silently; otherwise go
                // ahead and let the user see the crash.
                Slog.e(TAG, "Agent threw during creation: " + e);
                if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
                    throw e;
                }
            // falling through with 'binder' still null
            }
        }
        // tell the OS that we're live now
        try {
            ActivityManagerNative.getDefault().backupAgentCreated(packageName, binder);
        } catch (RemoteException e) {
        // nothing to do.
        }
    } catch (Exception e) {
        throw new RuntimeException("Unable to create BackupAgent " + classname + ": " + e.toString(), e);
    }
}
------------------------
Find a functionally equivalent code:android.net.LocalSocketImpl.create:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */

Body of Frist Method:
{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException("unknown sockType");
        }
        try {
            fd = Libcore.os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}
Body of Second Method:
{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException("unknown sockType");
        }
        try {
            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.fromFd:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */

Body of Frist Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Libcore.os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.policy.DeadZone.onTouchEvent:COMMENT
Method Modifier: public      
Comment:// I made you a touch event...

Body of Frist Method:
{
    if (DEBUG) {
        Log.v(TAG, this + " onTouch: " + MotionEvent.actionToString(event.getAction()));
    }
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_OUTSIDE) {
        poke(event);
    } else if (action == MotionEvent.ACTION_DOWN) {
        if (DEBUG) {
            Log.v(TAG, this + " ACTION_DOWN: " + event.getX() + "," + event.getY());
        }
        int size = (int) getSize(event.getEventTime());
        if ((mVertical && event.getX() < size) || event.getY() < size) {
            if (CHATTY) {
                Log.v(TAG, "consuming errant click: (" + event.getX() + "," + event.getY() + ")");
            }
            if (mShouldFlash) {
                post(mDebugFlash);
                postInvalidate();
            }
            // ...but I eated it
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (DEBUG) {
        Slog.v(TAG, this + " onTouch: " + MotionEvent.actionToString(event.getAction()));
    }
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_OUTSIDE) {
        poke(event);
    } else if (action == MotionEvent.ACTION_DOWN) {
        if (DEBUG) {
            Slog.v(TAG, this + " ACTION_DOWN: " + event.getX() + "," + event.getY());
        }
        int size = (int) getSize(event.getEventTime());
        if ((mVertical && event.getX() < size) || event.getY() < size) {
            if (CHATTY) {
                Slog.v(TAG, "consuming errant click: (" + event.getX() + "," + event.getY() + ")");
            }
            if (mShouldFlash) {
                post(mDebugFlash);
                postInvalidate();
            }
            // ...but I eated it
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.animation.ObjectAnimator.setTarget:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the target object whose property will be animated by this animation
 *
 * @param target The object being animated
 */

Body of Frist Method:
{
    if (mTarget != target) {
        final Object oldTarget = mTarget;
        mTarget = target;
        if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
            return;
        }
        // New target type should cause re-initialization prior to starting
        mInitialized = false;
    }
}
Body of Second Method:
{
    final Object oldTarget = getTarget();
    if (oldTarget != target) {
        mTarget = target == null ? null : new WeakReference<Object>(target);
        // New target should cause re-initialization prior to starting
        mInitialized = false;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.NinePatchDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (needsMirroring()) {
        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.right, mOpticalInsets.bottom);
    } else {
        return mOpticalInsets;
    }
}
Body of Second Method:
{
    if (needsMirroring()) {
        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.left, mOpticalInsets.bottom);
    } else {
        return mOpticalInsets;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the orientation of the gradient defined in this drawable.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param orientation The desired orientation (angle) of the gradient
 *
 * @see #mutate()
 */

Body of Frist Method:
{
    mGradientState.mOrientation = orientation;
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.mOrientation = orientation;
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.preference.Preference.compareTo:COMMENT
Method Modifier: public      
Comment:/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */

Body of Frist Method:
{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}
Body of Second Method:
{
    if (mOrder != another.mOrder) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setIntValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of ints.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = int.class;
    mKeyframeSet = KeyframeSet.ofInt(values);
}
Body of Second Method:
{
    mValueType = int.class;
    mKeyframes = KeyframeSet.ofInt(values);
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.isFastScrollAlwaysVisible:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */

Body of Frist Method:
{
    if (mFastScroller == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroller.isEnabled() && mFastScroller.isAlwaysShowEnabled();
    }
}
Body of Second Method:
{
    if (mFastScroll == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroll.isEnabled() && mFastScroll.isAlwaysShowEnabled();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.GlobalActions.createDialog:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Create the global actions dialog.
 * @return A new dialog.
 */

Body of Frist Method:
{
    // Simple toggle style if there's no vibrator, otherwise use a tri-state
    if (!mHasVibrator) {
        mSilentModeAction = new SilentModeToggleAction();
    } else {
        mSilentModeAction = new SilentModeTriStateAction(mContext, mAudioManager, mHandler);
    }
    mAirplaneModeOn = new ToggleAction(R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) {

        void onToggle(boolean on) {
            if (mHasTelephony && Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
                mIsWaitingForEcmExit = true;
                // Launch ECM exit dialog
                Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);
                ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                mContext.startActivity(ecmDialogIntent);
            } else {
                changeAirplaneModeSystemSetting(on);
            }
        }

        @Override
        protected void changeStateFromPress(boolean buttonOn) {
            if (!mHasTelephony)
                return;
            // In ECM mode airplane state cannot be changed
            if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
                mState = buttonOn ? State.TurningOn : State.TurningOff;
                mAirplaneState = mState;
            }
        }

        public boolean showDuringKeyguard() {
            return true;
        }

        public boolean showBeforeProvisioning() {
            return false;
        }
    };
    onAirplaneModeChanged();
    mItems = new ArrayList<Action>();
    // first: power off
    mItems.add(new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off) {

        public void onPress() {
            // shutdown by making sure radio and power are handled accordingly.
            mWindowManagerFuncs.shutdown(true);
        }

        public boolean onLongPress() {
            mWindowManagerFuncs.rebootSafeMode(true);
            return true;
        }

        public boolean showDuringKeyguard() {
            return true;
        }

        public boolean showBeforeProvisioning() {
            return true;
        }
    });
    // next: airplane mode
    mItems.add(mAirplaneModeOn);
    // next: bug report, if enabled
    if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
        mItems.add(new SinglePressAction(com.android.internal.R.drawable.stat_sys_adb, R.string.global_action_bug_report) {

            public void onPress() {
                AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
                builder.setTitle(com.android.internal.R.string.bugreport_title);
                builder.setMessage(com.android.internal.R.string.bugreport_message);
                builder.setNegativeButton(com.android.internal.R.string.cancel, null);
                builder.setPositiveButton(com.android.internal.R.string.report, new DialogInterface.OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        // Add a little delay before executing, to give the
                        // dialog a chance to go away before it takes a
                        // screenshot.
                        mHandler.postDelayed(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    ActivityManagerNative.getDefault().requestBugReport();
                                } catch (RemoteException e) {
                                }
                            }
                        }, 500);
                    }
                });
                AlertDialog dialog = builder.create();
                dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
                dialog.show();
            }

            public boolean onLongPress() {
                return false;
            }

            public boolean showDuringKeyguard() {
                return true;
            }

            public boolean showBeforeProvisioning() {
                return false;
            }
        });
    }
    // last: silent mode
    if (mShowSilentToggle) {
        mItems.add(mSilentModeAction);
    }
    // one more thing: optionally add a list of users to switch to
    if (SystemProperties.getBoolean("fw.power_user_switcher", false)) {
        addUsersToMenu(mItems);
    }
    mAdapter = new MyAdapter();
    AlertParams params = new AlertParams(mContext);
    params.mAdapter = mAdapter;
    params.mOnClickListener = this;
    params.mForceInverseBackground = true;
    GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params);
    // Handled by the custom class.
    dialog.setCanceledOnTouchOutside(false);
    dialog.getListView().setItemsCanFocus(true);
    dialog.getListView().setLongClickable(true);
    dialog.getListView().setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {

        @Override
        public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
            return mAdapter.getItem(position).onLongPress();
        }
    });
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.setOnDismissListener(this);
    return dialog;
}
Body of Second Method:
{
    // Simple toggle style if there's no vibrator, otherwise use a tri-state
    if (!mHasVibrator) {
        mSilentModeAction = new SilentModeToggleAction();
    } else {
        mSilentModeAction = new SilentModeTriStateAction(mContext, mAudioManager, mHandler);
    }
    mAirplaneModeOn = new ToggleAction(R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) {

        void onToggle(boolean on) {
            if (mHasTelephony && Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
                mIsWaitingForEcmExit = true;
                // Launch ECM exit dialog
                Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);
                ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                mContext.startActivity(ecmDialogIntent);
            } else {
                changeAirplaneModeSystemSetting(on);
            }
        }

        @Override
        protected void changeStateFromPress(boolean buttonOn) {
            if (!mHasTelephony)
                return;
            // In ECM mode airplane state cannot be changed
            if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
                mState = buttonOn ? State.TurningOn : State.TurningOff;
                mAirplaneState = mState;
            }
        }

        public boolean showDuringKeyguard() {
            return true;
        }

        public boolean showBeforeProvisioning() {
            return false;
        }
    };
    onAirplaneModeChanged();
    mItems = new ArrayList<Action>();
    String[] defaultActions = mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList);
    ArraySet<String> addedKeys = new ArraySet<String>();
    for (int i = 0; i < defaultActions.length; i++) {
        String actionKey = defaultActions[i];
        if (addedKeys.contains(actionKey)) {
            // If we already have added this, don't add it again.
            continue;
        }
        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
            mItems.add(new PowerAction());
        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
            mItems.add(mAirplaneModeOn);
        } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
                mItems.add(getBugReportAction());
            }
        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
            if (mShowSilentToggle) {
                mItems.add(mSilentModeAction);
            }
        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
            if (SystemProperties.getBoolean("fw.power_user_switcher", false)) {
                addUsersToMenu(mItems);
            }
        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
            mItems.add(getSettingsAction());
        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
            mItems.add(getLockdownAction());
        } else {
            Log.e(TAG, "Invalid global action key " + actionKey);
        }
        // Add here so we don't add more than one.
        addedKeys.add(actionKey);
    }
    mAdapter = new MyAdapter();
    AlertParams params = new AlertParams(mContext);
    params.mAdapter = mAdapter;
    params.mOnClickListener = this;
    params.mForceInverseBackground = true;
    GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params);
    // Handled by the custom class.
    dialog.setCanceledOnTouchOutside(false);
    dialog.getListView().setItemsCanFocus(true);
    dialog.getListView().setLongClickable(true);
    dialog.getListView().setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {

        @Override
        public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
            final Action action = mAdapter.getItem(position);
            if (action instanceof LongPressAction) {
                return ((LongPressAction) action).onLongPress();
            }
            return false;
        }
    });
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.setOnDismissListener(this);
    return dialog;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] != null) {
        // FIXME: handle styled strings!
        return mResourceData[index].getValue();
    }
    return null;
}
Body of Second Method:
{
    // FIXME: handle styled strings!
    return getString(index);
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.CallerInfoAsyncQueryHandler.onQueryComplete:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Overrides onQueryComplete from AsyncQueryHandler.
 *
 * This method takes into account the state of this class; we construct the CallerInfo
 * object only once for each set of listeners. When the query thread has done its work
 * and calls this method, we inform the remaining listeners in the queue, until we're
 * out of listeners.  Once we get the message indicating that we should expect no new
 * listeners for this CallerInfo object, we release the AsyncCursorInfo back into the
 * pool.
 */

Body of Frist Method:
{
    if (DBG)
        Rlog.d(LOG_TAG, "##### onQueryComplete() #####   query complete for token: " + token);
    // get the cookie and notify the listener.
    CookieWrapper cw = (CookieWrapper) cookie;
    if (cw == null) {
        // check the parameters to make sure they're viable.
        if (DBG)
            Rlog.d(LOG_TAG, "Cookie is null, ignoring onQueryComplete() request.");
        return;
    }
    if (cw.event == EVENT_END_OF_QUEUE) {
        release();
        return;
    }
    // check the token and if needed, create the callerinfo object.
    if (mCallerInfo == null) {
        if ((mQueryContext == null) || (mQueryUri == null)) {
            throw new QueryPoolException("Bad context or query uri, or CallerInfoAsyncQuery already released.");
        }
        // accordingly.
        if (cw.event == EVENT_EMERGENCY_NUMBER) {
            // Note we're setting the phone number here (refer to javadoc
            // comments at the top of CallerInfo class).
            mCallerInfo = new CallerInfo().markAsEmergency(mQueryContext);
        } else if (cw.event == EVENT_VOICEMAIL_NUMBER) {
            mCallerInfo = new CallerInfo().markAsVoiceMail();
        } else {
            mCallerInfo = CallerInfo.getCallerInfo(mQueryContext, mQueryUri, cursor);
            if (DBG)
                Rlog.d(LOG_TAG, "==> Got mCallerInfo: " + mCallerInfo);
            CallerInfo newCallerInfo = CallerInfo.doSecondaryLookupIfNecessary(mQueryContext, cw.number, mCallerInfo);
            if (newCallerInfo != mCallerInfo) {
                mCallerInfo = newCallerInfo;
                if (DBG)
                    Rlog.d(LOG_TAG, "#####async contact look up with numeric username" + mCallerInfo);
            }
            // Final step: look up the geocoded description.
            if (ENABLE_UNKNOWN_NUMBER_GEO_DESCRIPTION) {
                if (TextUtils.isEmpty(mCallerInfo.name)) {
                    // Actually when no contacts match the incoming phone number,
                    // the CallerInfo object is totally blank here (i.e. no name
                    // *or* phoneNumber).  So we need to pass in cw.number as
                    // a fallback number.
                    mCallerInfo.updateGeoDescription(mQueryContext, cw.number);
                }
            }
            // Use the number entered by the user for display.
            if (!TextUtils.isEmpty(cw.number)) {
                mCallerInfo.phoneNumber = PhoneNumberUtils.formatNumber(cw.number, mCallerInfo.normalizedNumber, CallerInfo.getCurrentCountryIso(mQueryContext));
            }
        }
        if (DBG)
            Rlog.d(LOG_TAG, "constructing CallerInfo object for token: " + token);
        // notify that we can clean up the queue after this.
        CookieWrapper endMarker = new CookieWrapper();
        endMarker.event = EVENT_END_OF_QUEUE;
        startQuery(token, endMarker, null, null, null, null, null);
    }
    // notify the listener that the query is complete.
    if (cw.listener != null) {
        if (DBG)
            Rlog.d(LOG_TAG, "notifying listener: " + cw.listener.getClass().toString() + " for token: " + token + mCallerInfo);
        cw.listener.onQueryComplete(token, cw.cookie, mCallerInfo);
    }
}
Body of Second Method:
{
    if (DBG)
        Rlog.d(LOG_TAG, "##### onQueryComplete() #####   query complete for token: " + token);
    // get the cookie and notify the listener.
    CookieWrapper cw = (CookieWrapper) cookie;
    if (cw == null) {
        // check the parameters to make sure they're viable.
        if (DBG)
            Rlog.d(LOG_TAG, "Cookie is null, ignoring onQueryComplete() request.");
        if (cursor != null) {
            cursor.close();
        }
        return;
    }
    if (cw.event == EVENT_END_OF_QUEUE) {
        release();
        if (cursor != null) {
            cursor.close();
        }
        return;
    }
    // check the token and if needed, create the callerinfo object.
    if (mCallerInfo == null) {
        if ((mContext == null) || (mQueryUri == null)) {
            throw new QueryPoolException("Bad context or query uri, or CallerInfoAsyncQuery already released.");
        }
        // accordingly.
        if (cw.event == EVENT_EMERGENCY_NUMBER) {
            // Note we're setting the phone number here (refer to javadoc
            // comments at the top of CallerInfo class).
            mCallerInfo = new CallerInfo().markAsEmergency(mContext);
        } else if (cw.event == EVENT_VOICEMAIL_NUMBER) {
            mCallerInfo = new CallerInfo().markAsVoiceMail(cw.subId);
        } else {
            mCallerInfo = CallerInfo.getCallerInfo(mContext, mQueryUri, cursor);
            if (DBG)
                Rlog.d(LOG_TAG, "==> Got mCallerInfo: " + mCallerInfo);
            CallerInfo newCallerInfo = CallerInfo.doSecondaryLookupIfNecessary(mContext, cw.number, mCallerInfo);
            if (newCallerInfo != mCallerInfo) {
                mCallerInfo = newCallerInfo;
                if (DBG)
                    Rlog.d(LOG_TAG, "#####async contact look up with numeric username" + mCallerInfo);
            }
            // Final step: look up the geocoded description.
            if (ENABLE_UNKNOWN_NUMBER_GEO_DESCRIPTION) {
                if (TextUtils.isEmpty(mCallerInfo.name)) {
                    // Actually when no contacts match the incoming phone number,
                    // the CallerInfo object is totally blank here (i.e. no name
                    // *or* phoneNumber).  So we need to pass in cw.number as
                    // a fallback number.
                    mCallerInfo.updateGeoDescription(mContext, cw.number);
                }
            }
            // Use the number entered by the user for display.
            if (!TextUtils.isEmpty(cw.number)) {
                mCallerInfo.phoneNumber = PhoneNumberUtils.formatNumber(cw.number, mCallerInfo.normalizedNumber, CallerInfo.getCurrentCountryIso(mContext));
            }
        }
        if (DBG)
            Rlog.d(LOG_TAG, "constructing CallerInfo object for token: " + token);
        // notify that we can clean up the queue after this.
        CookieWrapper endMarker = new CookieWrapper();
        endMarker.event = EVENT_END_OF_QUEUE;
        startQuery(token, endMarker, null, null, null, null, null);
    }
    // notify the listener that the query is complete.
    if (cw.listener != null) {
        if (DBG)
            Rlog.d(LOG_TAG, "notifying listener: " + cw.listener.getClass().toString() + " for token: " + token + mCallerInfo);
        cw.listener.onQueryComplete(token, cw.cookie, mCallerInfo);
    }
    if (cursor != null) {
        cursor.close();
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.concat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified matrix. If the specified
 * matrix is null, this method does nothing.
 *
 * @param matrix The matrix to preconcatenate with the current matrix
 */

Body of Frist Method:
{
    if (matrix != null)
        native_concat(mNativeCanvas, matrix.native_instance);
}
Body of Second Method:
{
    if (matrix != null)
        native_concat(mNativeCanvasWrapper, matrix.native_instance);
}
------------------------
Find a functionally equivalent code:android.os.Process.myPid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process, which can be used with
 * {@link #killProcess} and {@link #sendSignal}.
 */

Body of Frist Method:
{
    return Libcore.os.getpid();
}
Body of Second Method:
{
    return Os.getpid();
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<String> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putStringArrayList(key, value);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSyncManager.stopSync:COMMENT
Method Modifier: public      
Comment:/**
 * stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
 * the queue to break the sync loop
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager stopSync ***, Ref count:" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (--mStartSyncRefCount == 0) {
        mHandler.removeMessages(SYNC_MESSAGE);
    }
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.app.Activity.onCreateView:COMMENT
Method Modifier: public      
Comment:/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */

Body of Frist Method:
{
    if (!"fragment".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    String fname = attrs.getAttributeValue(null, "class");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = mFragments.findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = mFragments.findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(this, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = mFragments;
        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        mFragments.addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        }
        mFragments.moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException("Fragment " + fname + " did not create a view.");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}
Body of Second Method:
{
    if (!"fragment".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    return mFragments.onCreateView(parent, name, context, attrs);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.stopListening:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */

Body of Frist Method:
{
    try {
        sService.stopListening(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
Body of Second Method:
{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findDeps:COMMENT
Method Modifier: 
Comment:/**
 * Finds all dependencies for all classes in keepClasses which are also
 * listed in zipClasses. Returns a map of all the dependencies found.
 */

Body of Frist Method:
{
    TreeMap<String, ClassReader> deps = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> new_deps = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> new_keep = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> temp = new TreeMap<String, ClassReader>();
    DependencyVisitor visitor = getVisitor(zipClasses, inOutKeepClasses, new_keep, deps, new_deps);
    for (ClassReader cr : inOutKeepClasses.values()) {
        cr.accept(visitor, 0);
    }
    while (new_deps.size() > 0 || new_keep.size() > 0) {
        deps.putAll(new_deps);
        inOutKeepClasses.putAll(new_keep);
        temp.clear();
        temp.putAll(new_deps);
        temp.putAll(new_keep);
        new_deps.clear();
        new_keep.clear();
        mLog.debug("Found %1$d to keep, %2$d dependencies.", inOutKeepClasses.size(), deps.size());
        for (ClassReader cr : temp.values()) {
            cr.accept(visitor, 0);
        }
    }
    mLog.info("Found %1$d classes to keep, %2$d class dependencies.", inOutKeepClasses.size(), deps.size());
    return deps;
}
Body of Second Method:
{
    TreeMap<String, ClassReader> deps = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> new_deps = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> new_keep = new TreeMap<String, ClassReader>();
    TreeMap<String, ClassReader> temp = new TreeMap<String, ClassReader>();
    DependencyVisitor visitor = getVisitor(zipClasses, inOutKeepClasses, new_keep, deps, new_deps);
    for (ClassReader cr : inOutKeepClasses.values()) {
        visitor.setClassName(cr.getClassName());
        cr.accept(visitor, 0);
    }
    while (new_deps.size() > 0 || new_keep.size() > 0) {
        deps.putAll(new_deps);
        inOutKeepClasses.putAll(new_keep);
        temp.clear();
        temp.putAll(new_deps);
        temp.putAll(new_keep);
        new_deps.clear();
        new_keep.clear();
        mLog.debug("Found %1$d to keep, %2$d dependencies.", inOutKeepClasses.size(), deps.size());
        for (ClassReader cr : temp.values()) {
            visitor.setClassName(cr.getClassName());
            cr.accept(visitor, 0);
        }
    }
    mLog.info("Found %1$d classes to keep, %2$d class dependencies.", inOutKeepClasses.size(), deps.size());
    return deps;
}
------------------------
Find a functionally equivalent code:android.os.RecoverySystem.getTrustedCerts:COMMENT
Method Modifier: private     static      
Comment:/**
 * @return the set of certs that can be used to sign an OTA package.
 */

Body of Frist Method:
{
    HashSet<Certificate> trusted = new HashSet<Certificate>();
    if (keystore == null) {
        keystore = DEFAULT_KEYSTORE;
    }
    ZipFile zip = new ZipFile(keystore);
    try {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        Enumeration<? extends ZipEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            InputStream is = zip.getInputStream(entry);
            try {
                trusted.add(cf.generateCertificate(is));
            } finally {
                is.close();
            }
        }
    } finally {
        zip.close();
    }
    return trusted;
}
Body of Second Method:
{
    HashSet<X509Certificate> trusted = new HashSet<X509Certificate>();
    if (keystore == null) {
        keystore = DEFAULT_KEYSTORE;
    }
    ZipFile zip = new ZipFile(keystore);
    try {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        Enumeration<? extends ZipEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            InputStream is = zip.getInputStream(entry);
            try {
                trusted.add((X509Certificate) cf.generateCertificate(is));
            } finally {
                is.close();
            }
        }
    } finally {
        zip.close();
    }
    return trusted;
}
------------------------
Find a functionally equivalent code:android.accounts.AccountManager.getAuthenticatorTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */

Body of Frist Method:
{
    try {
        return mService.getAuthenticatorTypes();
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
------------------------
Find a functionally equivalent code:android.view.HardwareLayer.setLayerPaint:COMMENT
<android.view.HardwareLayer: void setLayerPaint(Paint)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Update the paint used when drawing this layer.
 *
 * @param paint The paint used when the layer is drawn into the destination canvas.
 * @see View#setLayerPaint(android.graphics.Paint)
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    nSetLayerPaint(mFinalizer.get(), paint.mNativePaint);
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a functionally equivalent code:com.android.systemui.ExpandHelper.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Use this to abort any pending expansions in progress.
 */

Body of Frist Method:
{
    finishExpanding(true);
    clearView();
    // reset the gesture detector
    mSGD = new ScaleGestureDetector(mContext, mScaleGestureListener);
}
Body of Second Method:
{
    finishExpanding(true, 0f);
    clearView();
    // reset the gesture detector
    mSGD = new ScaleGestureDetector(mContext, mScaleGestureListener);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.PagedView.determineScrollingStart:COMMENT
Method Modifier: protected   
Comment:/*
     * Determines if we should change the touch state to start scrolling after the
     * user moves their touch point too far.
     */

Body of Frist Method:
{
    // Disallow scrolling if we don't have a valid pointer index
    final int pointerIndex = ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1)
        return false;
    // Disallow scrolling if we started the gesture from outside the viewport
    final float x = ev.getX(pointerIndex);
    final float y = ev.getY(pointerIndex);
    if (!isTouchPointInViewportWithBuffer((int) x, (int) y))
        return false;
    // at the edge.
    if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)
        return false;
    final int xDiff = (int) Math.abs(x - mLastMotionX);
    final int yDiff = (int) Math.abs(y - mLastMotionY);
    final int touchSlop = Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
    boolean xPaged = xDiff > mPagingTouchSlop;
    boolean xMoved = xDiff > touchSlop;
    boolean yMoved = yDiff > touchSlop;
    return (xMoved || xPaged || yMoved) && (mUsePagingTouchSlop ? xPaged : xMoved);
}
Body of Second Method:
{
    // Disallow scrolling if we don't have a valid pointer index
    final int pointerIndex = ev.findPointerIndex(mActivePointerId);
    if (pointerIndex == -1)
        return false;
    // Disallow scrolling if we started the gesture from outside the viewport
    final float x = ev.getX(pointerIndex);
    final float y = ev.getY(pointerIndex);
    if (!isTouchPointInViewportWithBuffer((int) x, (int) y))
        return false;
    // at the edge.
    if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)
        return false;
    final int xDiff = (int) Math.abs(x - mLastMotionX);
    final int touchSlop = Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
    boolean xPaged = xDiff > mPagingTouchSlop;
    boolean xMoved = xDiff > touchSlop;
    return mUsePagingTouchSlop ? xPaged : xMoved;
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.getCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current hour in the range (0-23).
 */

Body of Frist Method:
{
    int currentHour = mHourSpinner.getValue();
    if (is24HourView()) {
        return currentHour;
    } else if (mIsAm) {
        return currentHour % HOURS_IN_HALF_DAY;
    } else {
        return (currentHour % HOURS_IN_HALF_DAY) + HOURS_IN_HALF_DAY;
    }
}
Body of Second Method:
{
    return mDelegate.getCurrentHour();
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.addScrapView:COMMENT
Method Modifier: 
Comment:/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */

Body of Frist Method:
{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}
Body of Second Method:
{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothInputDevice.setReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param report Report receiving buffer size
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a functionally equivalent code:android.content.Intent.filterEquals:COMMENT
Method Modifier: public      
Comment:/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */

Body of Frist Method:
{
    if (other == null) {
        return false;
    }
    if (mAction != other.mAction) {
        if (mAction != null) {
            if (!mAction.equals(other.mAction)) {
                return false;
            }
        } else {
            if (!other.mAction.equals(mAction)) {
                return false;
            }
        }
    }
    if (mData != other.mData) {
        if (mData != null) {
            if (!mData.equals(other.mData)) {
                return false;
            }
        } else {
            if (!other.mData.equals(mData)) {
                return false;
            }
        }
    }
    if (mType != other.mType) {
        if (mType != null) {
            if (!mType.equals(other.mType)) {
                return false;
            }
        } else {
            if (!other.mType.equals(mType)) {
                return false;
            }
        }
    }
    if (mPackage != other.mPackage) {
        if (mPackage != null) {
            if (!mPackage.equals(other.mPackage)) {
                return false;
            }
        } else {
            if (!other.mPackage.equals(mPackage)) {
                return false;
            }
        }
    }
    if (mComponent != other.mComponent) {
        if (mComponent != null) {
            if (!mComponent.equals(other.mComponent)) {
                return false;
            }
        } else {
            if (!other.mComponent.equals(mComponent)) {
                return false;
            }
        }
    }
    if (mCategories != other.mCategories) {
        if (mCategories != null) {
            if (!mCategories.equals(other.mCategories)) {
                return false;
            }
        } else {
            if (!other.mCategories.equals(mCategories)) {
                return false;
            }
        }
    }
    return true;
}
Body of Second Method:
{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
<android.hardware.camera2.CaptureRequest: void readFromParcel(Parcel)>
Method Modifier: public      private     hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  No          Yes         Yes         
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */

Body of Frist Method:
{
    mSettings.readFromParcel(in);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
}
Body of Second Method:
{
    mSettings.readFromParcel(in);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
}
------------------------
Find a functionally equivalent code:android.text.format.Time.toString:COMMENT
<android.text.format.Time: String toString()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return the current time in YYYYMMDDTHHMMSS<tz> format
 */

Body of Frist Method:

Body of Second Method:
{
    // toString() uses its own TimeCalculator rather than the shared one. Otherwise crazy stuff
    // happens during debugging when the debugger calls toString().
    TimeCalculator calculator = new TimeCalculator(this.timezone);
    calculator.copyFieldsFromTime(this);
    return calculator.toStringInternal();
}
------------------------
Find a functionally equivalent code:android.graphics.Path_Delegate.lineTo:COMMENT
Method Modifier: private     
Comment:/**
 * Add a line from the last point to the specified point (x,y).
 * If no moveTo() call has been made for this contour, the first point is
 * automatically set to (0,0).
 *
 * @param x The x-coordinate of the end of a line
 * @param y The y-coordinate of the end of a line
 */

Body of Frist Method:
{
    mPath.lineTo(mLastX = x, mLastY = y);
}
Body of Second Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    mPath.lineTo(mLastX = x, mLastY = y);
}
------------------------
Find a functionally equivalent code:com.android.smspush.WapPushManager.verifyData:COMMENT
Method Modifier: public      
Comment:/**
 * This method is used for testing
 */

Body of Frist Method:
{
    WapPushManDBHelper dbh = getDatabase(this);
    SQLiteDatabase db = dbh.getReadableDatabase();
    WapPushManDBHelper.queryData lastapp = dbh.queryLastApp(db, x_app_id, content_type);
    db.close();
    if (lastapp == null)
        return false;
    if (lastapp.packageName.equals(package_name) && lastapp.className.equals(class_name) && lastapp.appType == app_type && lastapp.needSignature == (need_signature ? 1 : 0) && lastapp.furtherProcessing == (further_processing ? 1 : 0)) {
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    WapPushManDBHelper dbh = getDatabase(this);
    SQLiteDatabase db = dbh.getReadableDatabase();
    WapPushManDBHelper.queryData lastapp = dbh.queryLastApp(db, x_app_id, content_type);
    if (LOCAL_LOGV)
        Log.v(LOG_TAG, "verifyData app id: " + x_app_id + " content type: " + content_type + " lastapp: " + lastapp);
    db.close();
    if (lastapp == null)
        return false;
    if (LOCAL_LOGV)
        Log.v(LOG_TAG, "verifyData lastapp.packageName: " + lastapp.packageName + " lastapp.className: " + lastapp.className + " lastapp.appType: " + lastapp.appType + " lastapp.needSignature: " + lastapp.needSignature + " lastapp.furtherProcessing: " + lastapp.furtherProcessing);
    if (lastapp.packageName.equals(package_name) && lastapp.className.equals(class_name) && lastapp.appType == app_type && lastapp.needSignature == (need_signature ? 1 : 0) && lastapp.furtherProcessing == (further_processing ? 1 : 0)) {
        return true;
    } else {
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.open:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */

Body of Frist Method:
{
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    return new ParcelFileDescriptor(fd);
}
Body of Second Method:
{
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    return new ParcelFileDescriptor(fd);
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.isGsm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM;
}
Body of Second Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.handleConfigurationChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Handles device configuration changes that may map to a change in the orientation
 * or orientation.
 * Monitoring orientation and rotation is optional, and is defined by the definition and value
 * of the "ro.audio.monitorOrientation" and "ro.audio.monitorRotation" system properties.
 */

Body of Frist Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        if (mMonitorRotation) {
            int newRotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();
            if (newRotation != mDeviceRotation) {
                mDeviceRotation = newRotation;
                setRotationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                    if (cameraSoundForced) {
                        s.setAllIndexesToMax();
                        mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    } else {
                        s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                        mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    }
                    // take new state into account for streams muted by ringer mode
                    setRingerModeInt(getRingerMode(), false);
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumePanel.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
Body of Second Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    if (!isPlatformTelevision()) {
                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                        if (cameraSoundForced) {
                            s.setAllIndexesToMax();
                            mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        } else {
                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        }
                        // take new state into account for streams muted by ringer mode
                        setRingerModeInt(getRingerMode(), false);
                    }
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.remoteControlDisplayWantsPlaybackPositionSync:COMMENT
Method Modifier: protected   
Comment:/**
 * Controls whether a remote control display needs periodic checks of the RemoteControlClient
 * playback position to verify that the estimated position has not drifted from the actual
 * position. By default the check is not performed.
 * The IRemoteControlDisplay must have been previously registered for this to have any effect.
 * @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
 * or disabled. Not null.
 * @param wantsSync if true, RemoteControlClient instances which expose their playback position
 * to the framework will regularly compare the estimated playback position with the actual
 * position, and will update the IRemoteControlDisplay implementation whenever a drift is
 * detected.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        boolean rcdRegistered = false;
        // store the information about this display
        // (display stack traversal order doesn't matter).
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                di.mWantsPositionSync = wantsSync;
                rcdRegistered = true;
                break;
            }
        }
        if (!rcdRegistered) {
            return;
        }
        // notify all current RemoteControlClients
        // (stack traversal order doesn't matter as we notify all RCCs)
        final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            final RemoteControlStackEntry rcse = stackIterator.next();
            if (rcse.mRcClient != null) {
                try {
                    rcse.mRcClient.setWantsSyncForDisplay(rcd, wantsSync);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error setting position sync flag for RCD on RCC: ", e);
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        boolean rcdRegistered = false;
        // store the information about this display
        // (display stack traversal order doesn't matter).
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                di.mWantsPositionSync = wantsSync;
                rcdRegistered = true;
                break;
            }
        }
        if (!rcdRegistered) {
            return;
        }
        // notify all current RemoteControlClients
        // (stack traversal order doesn't matter as we notify all RCCs)
        final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            final PlayerRecord prse = stackIterator.next();
            if (prse.getRcc() != null) {
                try {
                    prse.getRcc().setWantsSyncForDisplay(rcd, wantsSync);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error setting position sync flag for RCD on RCC: ", e);
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.EmergencyButton.takeEmergencyCallAction:COMMENT
Method Modifier: public      
Comment:/**
 * Shows the emergency dialer or returns the user to the existing call.
 */

Body of Frist Method:
{
    // TODO: implement a shorter timeout once new PowerManager API is ready.
    // should be the equivalent to the old userActivity(EMERGENCY_CALL_TIMEOUT)
    mPowerManager.userActivity(SystemClock.uptimeMillis(), true);
    if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
    } else {
        final boolean bypassHandler = true;
        KeyguardUpdateMonitor.getInstance(mContext).reportEmergencyCallAction(bypassHandler);
        Intent intent = new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivityAsUser(intent, new UserHandle(mLockPatternUtils.getCurrentUser()));
    }
}
Body of Second Method:
{
    // TODO: implement a shorter timeout once new PowerManager API is ready.
    // should be the equivalent to the old userActivity(EMERGENCY_CALL_TIMEOUT)
    mPowerManager.userActivity(SystemClock.uptimeMillis(), true);
    if (mLockPatternUtils.isInCall()) {
        mLockPatternUtils.resumeCall();
    } else {
        final boolean bypassHandler = true;
        KeyguardUpdateMonitor.getInstance(mContext).reportEmergencyCallAction(bypassHandler);
        Intent intent = new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivityAsUser(intent, new UserHandle(mLockPatternUtils.getCurrentUser()));
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserInfoChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserInfoChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user's info changed.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.removePrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes a listener for observing the state of print jobs.
 *
 * @param listener The listener to remove.
 * @hide
 */

Body of Frist Method:
{
    if (mPrintJobStateChangeListeners == null) {
        return;
    }
    PrintJobStateChangeListenerWrapper wrappedListener = mPrintJobStateChangeListeners.remove(listener);
    if (wrappedListener == null) {
        return;
    }
    if (mPrintJobStateChangeListeners.isEmpty()) {
        mPrintJobStateChangeListeners = null;
    }
    wrappedListener.destroy();
    try {
        mService.removePrintJobStateChangeListener(wrappedListener, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error removing print job state change listener", re);
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return;
    }
    if (mPrintJobStateChangeListeners == null) {
        return;
    }
    PrintJobStateChangeListenerWrapper wrappedListener = mPrintJobStateChangeListeners.remove(listener);
    if (wrappedListener == null) {
        return;
    }
    if (mPrintJobStateChangeListeners.isEmpty()) {
        mPrintJobStateChangeListeners = null;
    }
    wrappedListener.destroy();
    try {
        mService.removePrintJobStateChangeListener(wrappedListener, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error removing print job state change listener", re);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.open:COMMENT
Method Modifier: public      final       
Comment:/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * "assets" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */

Body of Frist Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        int asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException("Asset file: " + fileName);
}
Body of Second Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        long asset = openAsset(fileName, accessMode);
        if (asset != 0) {
            AssetInputStream res = new AssetInputStream(asset);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException("Asset file: " + fileName);
}
------------------------
Find a functionally equivalent code:android.media.AudioRecord.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops recording.
 * @throws IllegalStateException
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on an uninitialized AudioRecord.");
    }
    // stop recording
    synchronized (mRecordingStateLock) {
        native_stop();
        mRecordingState = RECORDSTATE_STOPPED;
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on an uninitialized AudioRecord.");
    }
    // stop recording
    synchronized (mRecordingStateLock) {
        handleFullVolumeRec(false);
        native_stop();
        mRecordingState = RECORDSTATE_STOPPED;
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param maxDate The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(maxDate);
    if (isSameDate(mTempDate, mMaxDate)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    // reinitialize the adapter since its range depends on max date
    mAdapter.init();
    Calendar date = mAdapter.mSelectedDate;
    if (date.after(mMaxDate)) {
        setDate(mMaxDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}
Body of Second Method:
{
    mDelegate.setMaxDate(maxDate);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<String>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<String>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getStringArrayList(key);
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.handleParentProc:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Handles post-fork cleanup of parent proc
 *
 * @param pid != 0; pid of child if &gt; 0 or indication of failed fork
 * if &lt; 0;
 * @param descriptors null-ok; file descriptors for child's new stdio if
 * specified.
 * @param pipeFd null-ok; pipe for communication with child.
 * @param parsedArgs non-null; zygote args
 * @return true for "exit command loop" and false for "continue command
 * loop"
 */

Body of Frist Method:
{
    if (pid > 0) {
        setChildPgid(pid);
    }
    if (descriptors != null) {
        for (FileDescriptor fd : descriptors) {
            IoUtils.closeQuietly(fd);
        }
    }
    boolean usingWrapper = false;
    if (pipeFd != null && pid > 0) {
        DataInputStream is = new DataInputStream(new FileInputStream(pipeFd));
        int innerPid = -1;
        try {
            innerPid = is.readInt();
        } catch (IOException ex) {
            Log.w(TAG, "Error reading pid from wrapped process, child may have died", ex);
        } finally {
            try {
                is.close();
            } catch (IOException ex) {
            }
        }
        // child process that we forked, or a descendant of it.
        if (innerPid > 0) {
            int parentPid = innerPid;
            while (parentPid > 0 && parentPid != pid) {
                parentPid = Process.getParentPid(parentPid);
            }
            if (parentPid > 0) {
                Log.i(TAG, "Wrapped process has pid " + innerPid);
                pid = innerPid;
                usingWrapper = true;
            } else {
                Log.w(TAG, "Wrapped process reported a pid that is not a child of " + "the process that we forked: childPid=" + pid + " innerPid=" + innerPid);
            }
        }
    }
    try {
        mSocketOutStream.writeInt(pid);
        mSocketOutStream.writeBoolean(usingWrapper);
    } catch (IOException ex) {
        Log.e(TAG, "Error reading from command socket", ex);
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (pid > 0) {
        setChildPgid(pid);
    }
    if (descriptors != null) {
        for (FileDescriptor fd : descriptors) {
            IoUtils.closeQuietly(fd);
        }
    }
    boolean usingWrapper = false;
    if (pipeFd != null && pid > 0) {
        DataInputStream is = new DataInputStream(new FileInputStream(pipeFd));
        int innerPid = -1;
        try {
            innerPid = is.readInt();
        } catch (IOException ex) {
            Log.w(TAG, "Error reading pid from wrapped process, child may have died", ex);
        } finally {
            try {
                is.close();
            } catch (IOException ex) {
            }
        }
        // child process that we forked, or a descendant of it.
        if (innerPid > 0) {
            int parentPid = innerPid;
            while (parentPid > 0 && parentPid != pid) {
                parentPid = Process.getParentPid(parentPid);
            }
            if (parentPid > 0) {
                Log.i(TAG, "Wrapped process has pid " + innerPid);
                pid = innerPid;
                usingWrapper = true;
            } else {
                Log.w(TAG, "Wrapped process reported a pid that is not a child of " + "the process that we forked: childPid=" + pid + " innerPid=" + innerPid);
            }
        }
    }
    try {
        mSocketOutStream.writeInt(pid);
        mSocketOutStream.writeBoolean(usingWrapper);
    } catch (IOException ex) {
        Log.e(TAG, "Error writing to command socket", ex);
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisSetXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashSet object from an XmlPullParser. The XML data could previously
 * have been generated by writeSetXml(). The XmlPullParser must be positioned
 * <em>after</em> the tag that begins the set.
 *
 * @param parser The XmlPullParser from which to read the set data.
 * @param endTag Name of the tag that will end the set, usually "set".
 * @param name An array of one string, used to return the name attribute
 * of the set's tag.
 *
 * @return HashSet The newly generated set.
 *
 * @throws XmlPullParserException
 * @throws java.io.IOException
 *
 * @see #readSetXml
 */

Body of Frist Method:
{
    HashSet set = new HashSet();
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            Object val = readThisValueXml(parser, name);
            set.add(val);
        // System.out.println("Adding to set: " + val);
        } else if (eventType == parser.END_TAG) {
            if (parser.getName().equals(endTag)) {
                return set;
            }
            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
}
Body of Second Method:
{
    return readThisSetXml(parser, endTag, name, null);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGattServer.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), // autoConnect is inverse of "isDirect"
        autoConnect ? false : true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of "isDirect"
        mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putChar:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a char, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putChar(key, value);
}
------------------------
Find a functionally equivalent code:com.android.internal.view.RotationPolicy.isRotationSupported:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Gets whether the device supports rotation. In general such a
 * device has an accelerometer and has the portrait and landscape
 * features.
 *
 * @param context Context for accessing system resources.
 * @return Whether the device supports rotation.
 */

Body of Frist Method:
{
    PackageManager pm = context.getPackageManager();
    return pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_LANDSCAPE);
}
Body of Second Method:
{
    PackageManager pm = context.getPackageManager();
    return pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_LANDSCAPE) && context.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a functionally equivalent code:android.app.Fragment.getLayoutInflater:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Hack so that DialogFragment can make its Dialog before creating
 * its views, and the view construction can use the dialog's context for
 * inflation.  Maybe this should become a public API. Note sure.
 */

Body of Frist Method:
{
    return mActivity.getLayoutInflater();
}
Body of Second Method:
{
    // Newer platform versions use the child fragment manager's LayoutInflaterFactory.
    if (mActivity.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
        LayoutInflater result = mActivity.getLayoutInflater().cloneInContext(mActivity);
        // Init if needed; use raw implementation below.
        getChildFragmentManager();
        result.setPrivateFactory(mChildFragmentManager.getLayoutInflaterFactory());
        return result;
    } else {
        return mActivity.getLayoutInflater();
    }
}
------------------------
Find a functionally equivalent code:android.widget.TextView.setTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 */

Body of Frist Method:
{
    TypedArray appearance = context.obtainStyledAttributes(resid, com.android.internal.R.styleable.TextAppearance);
    int color;
    ColorStateList colors;
    int ts;
    color = appearance.getColor(com.android.internal.R.styleable.TextAppearance_textColorHighlight, 0);
    if (color != 0) {
        setHighlightColor(color);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColor);
    if (colors != null) {
        setTextColor(colors);
    }
    ts = appearance.getDimensionPixelSize(com.android.internal.R.styleable.TextAppearance_textSize, 0);
    if (ts != 0) {
        setRawTextSize(ts);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorHint);
    if (colors != null) {
        setHintTextColor(colors);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorLink);
    if (colors != null) {
        setLinkTextColor(colors);
    }
    String familyName;
    int typefaceIndex, styleIndex;
    familyName = appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFamily);
    typefaceIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_typeface, -1);
    styleIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex);
    final int shadowcolor = appearance.getInt(com.android.internal.R.styleable.TextAppearance_shadowColor, 0);
    if (shadowcolor != 0) {
        final float dx = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDx, 0);
        final float dy = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDy, 0);
        final float r = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowcolor);
    }
    if (appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    appearance.recycle();
}
Body of Second Method:
{
    TypedArray appearance = context.obtainStyledAttributes(resid, com.android.internal.R.styleable.TextAppearance);
    int color;
    ColorStateList colors;
    int ts;
    color = appearance.getColor(com.android.internal.R.styleable.TextAppearance_textColorHighlight, 0);
    if (color != 0) {
        setHighlightColor(color);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColor);
    if (colors != null) {
        setTextColor(colors);
    }
    ts = appearance.getDimensionPixelSize(com.android.internal.R.styleable.TextAppearance_textSize, 0);
    if (ts != 0) {
        setRawTextSize(ts);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorHint);
    if (colors != null) {
        setHintTextColor(colors);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorLink);
    if (colors != null) {
        setLinkTextColor(colors);
    }
    String familyName;
    int typefaceIndex, styleIndex;
    familyName = appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFamily);
    typefaceIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_typeface, -1);
    styleIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex);
    final int shadowcolor = appearance.getInt(com.android.internal.R.styleable.TextAppearance_shadowColor, 0);
    if (shadowcolor != 0) {
        final float dx = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDx, 0);
        final float dy = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDy, 0);
        final float r = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowcolor);
    }
    if (appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_elegantTextHeight)) {
        setElegantTextHeight(appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_elegantTextHeight, false));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_letterSpacing)) {
        setLetterSpacing(appearance.getFloat(com.android.internal.R.styleable.TextAppearance_letterSpacing, 0));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings)) {
        setFontFeatureSettings(appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings));
    }
    appearance.recycle();
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to int: " + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getInt of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to int: " + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getInt of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a functionally equivalent code:android.app.Activity.onBackPressed:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */

Body of Frist Method:
{
    if (!mFragments.popBackStackImmediate()) {
        finish();
    }
}
Body of Second Method:
{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardAbsKeyInputView.handleAttemptLockout:COMMENT
Method Modifier: protected   
Comment:// Prevent user from using the PIN/Password entry until scheduled deadline.

Body of Frist Method:
{
    mPasswordEntry.setEnabled(false);
    long elapsedRealtime = SystemClock.elapsedRealtime();
    new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime, 1000) {

        @Override
        public void onTick(long millisUntilFinished) {
            int secondsRemaining = (int) (millisUntilFinished / 1000);
            mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown, true, secondsRemaining);
        }

        @Override
        public void onFinish() {
            mSecurityMessageDisplay.setMessage("", false);
            resetState();
        }
    }.start();
}
Body of Second Method:
{
    setPasswordEntryEnabled(false);
    long elapsedRealtime = SystemClock.elapsedRealtime();
    new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime, 1000) {

        @Override
        public void onTick(long millisUntilFinished) {
            int secondsRemaining = (int) (millisUntilFinished / 1000);
            mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown, true, secondsRemaining);
        }

        @Override
        public void onFinish() {
            mSecurityMessageDisplay.setMessage("", false);
            resetState();
        }
    }.start();
}
------------------------
Find a functionally equivalent code:android.text.TextLine.getOffsetBeforeAfter:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the next valid offset within this directional run, skipping
 * conjuncts and zero-width characters.  This should not be called to walk
 * off the end of the line, since the returned values might not be valid
 * on neighboring lines.  If the returned offset is less than zero or
 * greater than the line length, the offset should be recomputed on the
 * preceding or following line, respectively.
 *
 * @param runIndex the run index
 * @param runStart the start of the run
 * @param runLimit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param offset the offset
 * @param after true if the new offset should logically follow the provided
 * offset
 * @return the new offset
 */

Body of Frist Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, flags, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, flags, mStart + offset, cursorOpt) - mStart;
    }
}
Body of Second Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int dir = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, dir, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, dir, mStart + offset, cursorOpt) - mStart;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.ActionBarView.buildHomeContentDescription:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Compose a content description for the Home/Up affordance.
 *
 * <p>As this encompasses the icon/logo, title and subtitle all in one, we need
 * a description for the whole wad of stuff that can be localized properly.</p>
 */

Body of Frist Method:
{
    final CharSequence homeDesc;
    if (mHomeDescription != null) {
        homeDesc = mHomeDescription;
    } else {
        if ((mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
            homeDesc = mContext.getResources().getText(R.string.action_bar_up_description);
        } else {
            homeDesc = mContext.getResources().getText(R.string.action_bar_home_description);
        }
    }
    final CharSequence title = getTitle();
    final CharSequence subtitle = getSubtitle();
    if (!TextUtils.isEmpty(title)) {
        final String result;
        if (!TextUtils.isEmpty(subtitle)) {
            result = getResources().getString(R.string.action_bar_home_subtitle_description_format, title, subtitle, homeDesc);
        } else {
            result = getResources().getString(R.string.action_bar_home_description_format, title, homeDesc);
        }
        return result;
    }
    return homeDesc;
}
Body of Second Method:
{
    final CharSequence homeDesc;
    if (mHomeDescription != null) {
        homeDesc = mHomeDescription;
    } else {
        if ((mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
            homeDesc = mContext.getResources().getText(mDefaultUpDescription);
        } else {
            homeDesc = mContext.getResources().getText(R.string.action_bar_home_description);
        }
    }
    final CharSequence title = getTitle();
    final CharSequence subtitle = getSubtitle();
    if (!TextUtils.isEmpty(title)) {
        final String result;
        if (!TextUtils.isEmpty(subtitle)) {
            result = getResources().getString(R.string.action_bar_home_subtitle_description_format, title, subtitle, homeDesc);
        } else {
            result = getResources().getString(R.string.action_bar_home_description_format, title, homeDesc);
        }
        return result;
    }
    return homeDesc;
}
------------------------
Find a functionally equivalent code:android.security.KeyChain.createInstallIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns an {@code Intent} that can be used for credential
 * installation. The intent may be used without any extras, in
 * which case the user will be able to install credentials from
 * their own source.
 *
 * <p>Alternatively, {@link #EXTRA_CERTIFICATE} or {@link
 * #EXTRA_PKCS12} maybe used to specify the bytes of an X.509
 * certificate or a PKCS#12 key store for installation. These
 * extras may be combined with {@link #EXTRA_NAME} to provide a
 * default alias name for credentials being installed.
 *
 * <p>When used with {@link Activity#startActivityForResult},
 * {@link Activity#RESULT_OK} will be returned if a credential was
 * successfully installed, otherwise {@link
 * Activity#RESULT_CANCELED} will be returned.
 */

Body of Frist Method:
{
    Intent intent = new Intent(ACTION_INSTALL);
    intent.setClassName("com.android.certinstaller", "com.android.certinstaller.CertInstallerMain");
    return intent;
}
Body of Second Method:
{
    Intent intent = new Intent(ACTION_INSTALL);
    intent.setClassName(CERT_INSTALLER_PACKAGE, "com.android.certinstaller.CertInstallerMain");
    return intent;
}
------------------------
Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pManager.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Registers the application with the Wi-Fi framework. This function
 * must be the first to be called before any p2p operations are performed.
 *
 * @param srcContext is the context of the source
 * @param srcLooper is the Looper on which the callbacks are receivied
 * @param listener for callback at loss of framework communication. Can be null.
 * @return Channel instance that is necessary for performing any further p2p operations
 */

Body of Frist Method:
{
    Messenger messenger = getMessenger();
    if (messenger == null)
        return null;
    Channel c = new Channel(srcContext, srcLooper, listener);
    if (c.mAsyncChannel.connectSync(srcContext, c.mHandler, messenger) == AsyncChannel.STATUS_SUCCESSFUL) {
        return c;
    } else {
        return null;
    }
}
Body of Second Method:
{
    return initalizeChannel(srcContext, srcLooper, listener, getMessenger());
}
------------------------
Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.onCancelled:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " onCancelled");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " onCancelled");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}
------------------------
Find a functionally equivalent code:android.print.PrinterCapabilitiesInfo.getResolutions:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported resolutions.
 *
 * @return The resolutions.
 */

Body of Frist Method:
{
    return mResolutions;
}
Body of Second Method:
{
    return Collections.unmodifiableList(mResolutions);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.areTranslucentBarsAllowed:COMMENT
Method Modifier: private     internal    
Comment:/**
 * @return whether the navigation or status bar can be made translucent
 *
 * This should return true unless touch exploration is not enabled or
 * R.boolean.config_enableTranslucentDecor is false.
 */

Body of Frist Method:
{
    return mTranslucentDecorEnabled && !mTouchExplorationEnabled;
}
Body of Second Method:
{
    return mTranslucentDecorEnabled && !mAccessibilityManager.isTouchExplorationEnabled();
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or 0.0f if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a float value
 */

Body of Frist Method:
{
    unparcel();
    return getFloat(key, 0.0f);
}
Body of Second Method:
{
    return super.getFloat(key);
}
------------------------
Find a functionally equivalent code:android.os.Message.copyFrom:COMMENT
Method Modifier: public      
Comment:/**
 * Make this message like o.  Performs a shallow copy of the data field.
 * Does not copy the linked list fields, nor the timestamp or
 * target/callback of the original message.
 */

Body of Frist Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
Body of Second Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    this.sendingUid = o.sendingUid;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findGlobs:COMMENT
Method Modifier: 
Comment:/**
 * Insert in the inOutFound map all classes found in zipClasses that match the
 * given glob pattern.
 * <p/>
 * The glob pattern is not a regexp. It only accepts the "*" keyword to mean
 * "anything but a period". The "." and "$" characters match themselves.
 * The "**" keyword means everything including ".".
 * <p/>
 * Examples:
 * <ul>
 * <li>com.foo.* matches all classes in the package com.foo but NOT sub-packages.
 * <li>com.foo*.*$Event matches all internal Event classes in a com.foo*.* class.
 * </ul>
 */

Body of Frist Method:
{
    // transforms the glob pattern in a regexp:
    // - escape "." with "\."
    // - replace "*" by "[^.]*"
    // - escape "$" with "\$"
    // - add end-of-line match $
    globPattern = globPattern.replaceAll("\\$", "\\\\\\$");
    globPattern = globPattern.replaceAll("\\.", "\\\\.");
    // prevent ** from being altered by the next rule, then process the * rule and finally
    // the real ** rule (which is now @)
    globPattern = globPattern.replaceAll("\\*\\*", "@");
    globPattern = globPattern.replaceAll("\\*", "[^.]*");
    globPattern = globPattern.replaceAll("@", ".*");
    globPattern += "$";
    Pattern regexp = Pattern.compile(globPattern);
    for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
        String class_name = entry.getKey();
        if (regexp.matcher(class_name).matches()) {
            findClass(class_name, zipClasses, inOutFound);
        }
    }
}
Body of Second Method:
{
    Pattern regexp = getPatternFromGlob(globPattern);
    for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
        String class_name = entry.getKey();
        if (regexp.matcher(class_name).matches() && !mExcludedClasses.contains(getOuterClassName(class_name))) {
            findClass(class_name, zipClasses, inOutFound);
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getNonResourceString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined or is not
 * an immediate string value.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.needSensorRunningLp:COMMENT
Method Modifier: internal    
Comment:/*
     * We always let the sensor be switched on by default except when
     * the user has explicitly disabled sensor based rotation or when the
     * screen is switched off.
     */

Body of Frist Method:
{
    if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
        // orientation, then we need to turn the sensor or.
        return true;
    }
    if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) || (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
        // orientation management,
        return true;
    }
    if (mUserRotationMode == USER_ROTATION_LOCKED) {
        // still be turned off when the screen is off.)
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (mSupportAutoRotation) {
        if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
            // orientation, then we need to turn the sensor on.
            return true;
        }
    }
    if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) || (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
        // orientation management,
        return true;
    }
    if (mUserRotationMode == USER_ROTATION_LOCKED) {
        // still be turned off when the screen is off.)
        return false;
    }
    return mSupportAutoRotation;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.registerRemoteControlDisplay_int:COMMENT
Method Modifier: private     
Comment:/**
 * Register an IRemoteControlDisplay.
 * Notify all IRemoteControlClient of the new display and cause the RemoteControlClient
 * at the top of the stack to update the new display with its information.
 * @see android.media.IAudioService#registerRemoteControlDisplay(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay to register. No effect if null.
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param listenerComp the component for the listener interface, may be null if it's not needed
 * to verify it belongs to one of the enabled notification listeners
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.d(TAG, ">>> registerRemoteControlDisplay(" + rcd + ")");
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            if ((rcd == null) || rcDisplayIsPluggedIn_syncRcStack(rcd)) {
                return;
            }
            DisplayInfoForServer di = new DisplayInfoForServer(rcd, w, h);
            di.mEnabled = true;
            di.mClientNotifListComp = listenerComp;
            if (!di.init()) {
                if (DEBUG_RC)
                    Log.e(TAG, " error registering RCD");
                return;
            }
            // add RCD to list of displays
            mRcDisplays.add(di);
            // let all the remote control clients know there is a new display (so the remote
            // control stack traversal order doesn't matter).
            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.plugRemoteControlDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error connecting RCD to client: ", e);
                    }
                }
            }
            // we have a new display, of which all the clients are now aware: have it be
            // initialized wih the current gen ID and the current client info, do not
            // reset the information for the other (existing) displays
            sendMsg(mEventHandler, MSG_RCDISPLAY_INIT_INFO, SENDMSG_QUEUE, w, /*arg1*/
            h, /*arg2*/
            rcd, /*obj*/
            0);
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.d(TAG, ">>> registerRemoteControlDisplay(" + rcd + ")");
    synchronized (mAudioFocusLock) {
        synchronized (mPRStack) {
            if ((rcd == null) || rcDisplayIsPluggedIn_syncRcStack(rcd)) {
                return;
            }
            DisplayInfoForServer di = new DisplayInfoForServer(rcd, w, h);
            di.mEnabled = true;
            di.mClientNotifListComp = listenerComp;
            if (!di.init()) {
                if (DEBUG_RC)
                    Log.e(TAG, " error registering RCD");
                return;
            }
            // add RCD to list of displays
            mRcDisplays.add(di);
            // let all the remote control clients know there is a new display (so the remote
            // control stack traversal order doesn't matter).
            Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().plugRemoteControlDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error connecting RCD to client: ", e);
                    }
                }
            }
            // we have a new display, of which all the clients are now aware: have it be
            // initialized wih the current gen ID and the current client info, do not
            // reset the information for the other (existing) displays
            sendMsg(mEventHandler, MSG_RCDISPLAY_INIT_INFO, SENDMSG_QUEUE, w, /*arg1*/
            h, /*arg2*/
            rcd, /*obj*/
            0);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleReportFailedAttempt:COMMENT
Method Modifier: 
Comment:/**
 * Increments the number of failed Face Unlock attempts.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "handleReportFailedAttempt()");
    // We are going to the backup method, so we don't want to see Face Unlock again until the
    // next time the user visits keyguard.
    KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
    mKeyguardScreenCallback.reportFailedUnlockAttempt();
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "handleReportFailedAttempt()");
    // We are going to the backup method, so we don't want to see Face Unlock again until the
    // next time the user visits keyguard.
    KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
    mKeyguardScreenCallback.reportUnlockAttempt(false);
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleSPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Sample Profiling w/Streaming Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int interval = in.getInt();
    if (false) {
        Log.v("ddm-heap", "Sample prof stream start: size=" + bufferSize + ", flags=" + flags + ", interval=" + interval);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, true, interval);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int interval = in.getInt();
    if (DEBUG) {
        Log.v("ddm-heap", "Sample prof stream start: size=" + bufferSize + ", flags=" + flags + ", interval=" + interval);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, true, interval);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a functionally equivalent code:android.widget.CheckedTextView.internalSetPadding:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.internalSetPadding(left, top, right, bottom);
    setBasePadding(isLayoutRtl());
}
Body of Second Method:
{
    super.internalSetPadding(left, top, right, bottom);
    setBasePadding(isCheckMarkAtStart());
}
------------------------
Find a functionally equivalent code:android.widget.RemoteViews.apply:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    View result;
    Context c = prepareContext(context);
    LayoutInflater inflater = (LayoutInflater) c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    inflater = inflater.cloneInContext(c);
    inflater.setFilter(this);
    result = inflater.inflate(rvToApply.getLayoutId(), parent, false);
    rvToApply.performApply(result, parent, handler);
    return result;
}
Body of Second Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    View result;
    // RemoteViews may be built by an application installed in another
    // user. So build a context that loads resources from that user but
    // still returns the current users userId so settings like data / time formats
    // are loaded without requiring cross user persmissions.
    final Context contextForResources = getContextForResources(context);
    Context inflationContext = new ContextWrapper(context) {

        @Override
        public Resources getResources() {
            return contextForResources.getResources();
        }

        @Override
        public Resources.Theme getTheme() {
            return contextForResources.getTheme();
        }
    };
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    // Clone inflater so we load resources from correct context and
    // we don't add a filter to the static version returned by getSystemService.
    inflater = inflater.cloneInContext(inflationContext);
    inflater.setFilter(this);
    result = inflater.inflate(rvToApply.getLayoutId(), parent, false);
    rvToApply.performApply(result, parent, handler);
    return result;
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.startQuery:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Factory method to start the query based on a number.
 *
 * Note: if the number contains an "@" character we treat it
 * as a SIP address, and look it up directly in the Data table
 * rather than using the PhoneLookup table.
 * TODO: But eventually we should expose two separate methods, one for
 * numbers and one for SIP addresses, and then have
 * PhoneUtils.startGetCallerInfo() decide which one to call based on
 * the phone type of the incoming connection.
 */

Body of Frist Method:
{
    if (DBG) {
        Rlog.d(LOG_TAG, "##### CallerInfoAsyncQuery startQuery()... #####");
        Rlog.d(LOG_TAG, "- number: " + /*number*/
        "xxxxxxx");
        Rlog.d(LOG_TAG, "- cookie: " + cookie);
    }
    // Construct the URI object and query params, and start the query.
    Uri contactRef;
    String selection;
    String[] selectionArgs;
    if (PhoneNumberUtils.isUriNumber(number)) {
        // "number" is really a SIP address.
        if (DBG)
            Rlog.d(LOG_TAG, "  - Treating number as a SIP address: " + /*number*/
            "xxxxxxx");
        // We look up SIP addresses directly in the Data table:
        contactRef = Data.CONTENT_URI;
        // Note Data.DATA1 and SipAddress.SIP_ADDRESS are equivalent.
        // 
        // Also note we use "upper(data1)" in the WHERE clause, and
        // uppercase the incoming SIP address, in order to do a
        // case-insensitive match.
        // 
        // TODO: need to confirm that the use of upper() doesn't
        // prevent us from using the index!  (Linear scan of the whole
        // contacts DB can be very slow.)
        // 
        // TODO: May also need to normalize by adding "sip:" as a
        // prefix, if we start storing SIP addresses that way in the
        // database.
        selection = "upper(" + Data.DATA1 + ")=?" + " AND " + Data.MIMETYPE + "='" + SipAddress.CONTENT_ITEM_TYPE + "'";
        selectionArgs = new String[] { number.toUpperCase() };
    } else {
        // "number" is a regular phone number.  Use the PhoneLookup table:
        contactRef = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));
        selection = null;
        selectionArgs = null;
    }
    if (DBG) {
        Rlog.d(LOG_TAG, "==> contactRef: " + sanitizeUriToString(contactRef));
        Rlog.d(LOG_TAG, "==> selection: " + selection);
        if (selectionArgs != null) {
            for (int i = 0; i < selectionArgs.length; i++) {
                Rlog.d(LOG_TAG, "==> selectionArgs[" + i + "]: " + selectionArgs[i]);
            }
        }
    }
    CallerInfoAsyncQuery c = new CallerInfoAsyncQuery();
    c.allocate(context, contactRef);
    // create cookieWrapper, start query
    CookieWrapper cw = new CookieWrapper();
    cw.listener = listener;
    cw.cookie = cookie;
    cw.number = number;
    // check to see if these are recognized numbers, and use shortcuts if we can.
    if (PhoneNumberUtils.isLocalEmergencyNumber(number, context)) {
        cw.event = EVENT_EMERGENCY_NUMBER;
    } else if (PhoneNumberUtils.isVoiceMailNumber(number)) {
        cw.event = EVENT_VOICEMAIL_NUMBER;
    } else {
        cw.event = EVENT_NEW_QUERY;
    }
    c.mHandler.startQuery(token, // cookie
    cw, // uri
    contactRef, // projection
    null, // selection
    selection, // selectionArgs
    selectionArgs, // orderBy
    null);
    return c;
}
Body of Second Method:
{
    long subId = SubscriptionManager.getDefaultSubId();
    return startQuery(token, context, number, listener, cookie, subId);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.PanelBar.startOpeningPanel:COMMENT
Method Modifier: public      
Comment:// called from PanelView when self-expanding, too

Body of Frist Method:
{
    if (DEBUG)
        LOG("startOpeningPanel: " + panel);
    mTouchingPanel = panel;
    mPanelHolder.setSelectedPanel(mTouchingPanel);
    for (PanelView pv : mPanels) {
        if (pv != panel) {
            pv.collapse();
        }
    }
}
Body of Second Method:
{
    if (DEBUG)
        LOG("startOpeningPanel: " + panel);
    mTouchingPanel = panel;
    mPanelHolder.setSelectedPanel(mTouchingPanel);
    for (PanelView pv : mPanels) {
        if (pv != panel) {
            pv.collapse(false);
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.releaseTheme:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    synchronized (this) {
        deleteTheme(theme);
        decRefsLocked(theme);
    }
}
Body of Second Method:
{
    synchronized (this) {
        deleteTheme(theme);
        decRefsLocked(theme);
    }
}
------------------------
Find a functionally equivalent code:android.view.Window.setAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom window attributes.  <strong>PLEASE NOTE:</strong> the
 * layout params you give here should generally be from values previously
 * retrieved with {@link #getAttributes()}; you probably do not want to
 * blindly create and apply your own, since this will blow away any values
 * set by the framework that you are not interested in.
 *
 * @param a The new window attributes, which will completely override any
 * current values.
 */

Body of Frist Method:
{
    mWindowAttributes.copyFrom(a);
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(mWindowAttributes);
    }
}
Body of Second Method:
{
    mWindowAttributes.copyFrom(a);
    dispatchWindowAttributesChanged(mWindowAttributes);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */

Body of Frist Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    final int userId = mContext.getUserId();
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        if (updatedViews.get(i) != null) {
            updatedViews.get(i).setUser(new UserHandle(userId));
        }
        updateAppWidgetView(updatedIds[i], updatedViews.get(i), userId);
    }
}
Body of Second Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.transitionToHidden:COMMENT
Method Modifier: private     
Comment:/**
 * Shows nothing.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mThumbImage, mTrackImage, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    // Push the thumb and track outside the list bounds.
    final float offset = mLayoutFromRight ? mThumbImage.getWidth() : -mThumbImage.getWidth();
    final Animator slideOut = groupAnimatorOfFloat(View.TRANSLATION_X, offset, mThumbImage, mTrackImage).setDuration(DURATION_FADE_OUT);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeOut, slideOut);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mThumbImage, mTrackImage, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    // Push the thumb and track outside the list bounds.
    final float offset = mLayoutFromRight ? mThumbImage.getWidth() : -mThumbImage.getWidth();
    final Animator slideOut = groupAnimatorOfFloat(View.TRANSLATION_X, offset, mThumbImage, mTrackImage).setDuration(DURATION_FADE_OUT);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeOut, slideOut);
    mDecorAnimation.start();
    mShowingPreview = false;
}
------------------------
Find a functionally equivalent code:android.app.Activity.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Declare that the options menu has changed, so should be recreated.
 * The {@link #onCreateOptionsMenu(Menu)} method will be called the next
 * time it needs to be displayed.
 */

Body of Frist Method:
{
    mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mActionBar == null || !mActionBar.invalidateOptionsMenu()) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a functionally equivalent code:android.app.SearchDialog.createContentView:COMMENT
Method Modifier: private     
Comment:/**
 * We recreate the dialog view each time it becomes visible so as to limit
 * the scope of any problems with the contained resources.
 */

Body of Frist Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
    searchBar.setSearchDialog(this);
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getResources().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
Body of Second Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
    searchBar.setSearchDialog(this);
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
------------------------
Find a functionally equivalent code:android.printservice.PrintJob.getAdvancedIntOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return 0;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedIntOption(key);
}
------------------------
Find a functionally equivalent code:android.test.ProviderTestCase2.setUp:COMMENT
Method Modifier: protected   
Comment:/**
 * Sets up the environment for the test fixture.
 * <p>
 * Creates a new
 * {@link android.test.mock.MockContentResolver}, a new IsolatedContext
 * that isolates the provider's file operations, and a new instance of
 * the provider under test within the isolated environment.
 * </p>
 *
 * @throws Exception
 */

Body of Frist Method:
{
    super.setUp();
    mResolver = new MockContentResolver();
    final String filenamePrefix = "test.";
    RenamingDelegatingContext targetContextWrapper = new RenamingDelegatingContext(// The context that most methods are
    new MockContext2(), // The context that file methods are delegated to
    getContext(), filenamePrefix);
    mProviderContext = new IsolatedContext(mResolver, targetContextWrapper);
    mProvider = mProviderClass.newInstance();
    mProvider.attachInfoForTesting(mProviderContext, null);
    assertNotNull(mProvider);
    mResolver.addProvider(mProviderAuthority, getProvider());
}
Body of Second Method:
{
    super.setUp();
    mResolver = new MockContentResolver();
    final String filenamePrefix = "test.";
    RenamingDelegatingContext targetContextWrapper = new RenamingDelegatingContext(// The context that most methods are
    new MockContext2(), // The context that file methods are delegated to
    getContext(), filenamePrefix);
    mProviderContext = new IsolatedContext(mResolver, targetContextWrapper);
    mProvider = createProviderForTest(mProviderContext, mProviderClass, mProviderAuthority);
    mResolver.addProvider(mProviderAuthority, getProvider());
}
------------------------
Find a functionally equivalent code:android.os.StrictMode.writeGatheredViolationsToParcel:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        p.writeInt(violations.size());
        for (int i = 0; i < violations.size(); ++i) {
            violations.get(i).writeToParcel(p, 0);
        }
        if (LOG_V)
            Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());
        // somewhat redundant, as we're about to null the threadlocal
        violations.clear();
    }
    gatheredViolations.set(null);
}
Body of Second Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        p.writeInt(violations.size());
        for (int i = 0; i < violations.size(); ++i) {
            int start = p.dataPosition();
            violations.get(i).writeToParcel(p, 0);
            int size = p.dataPosition() - start;
            if (size > 10 * 1024) {
                Slog.d(TAG, "Wrote violation #" + i + " of " + violations.size() + ": " + (p.dataPosition() - start) + " bytes");
            }
        }
        if (LOG_V)
            Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());
        // somewhat redundant, as we're about to null the threadlocal
        violations.clear();
    }
    gatheredViolations.set(null);
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getKey:COMMENT
Method Modifier: public      
Comment:/**
 * This is the unique key for the restriction entry.
 * @return the key for the restriction.
 */

Body of Frist Method:
{
    return key;
}
Body of Second Method:
{
    return mKey;
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.removeRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use only
 */

Body of Frist Method:
{
    removeRoute(info);
}
Body of Second Method:
{
    removeRouteStatic(info);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.disableWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Disable Wifi
 * @return true if Wifi is disabled successfully
 */

Body of Frist Method:
{
    return mWifiManager.setWifiEnabled(false);
}
Body of Second Method:
{
    return mWifiManager.setWifiEnabled(false);
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.obtainTypedArray:COMMENT
Method Modifier: public      
Comment:/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */

Body of Frist Method:
{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException("Array resource ID #0x" + Integer.toHexString(id));
    }
    TypedArray array = getCachedStyledAttributes(len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}
Body of Second Method:
{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException("Array resource ID #0x" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.ResourceHelper.parseFloatAttribute:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parse a float attribute and return the parsed value into a given TypedValue.
 * @param attribute the name of the attribute. Can be null if <var>requireUnit</var> is false.
 * @param value the string value of the attribute
 * @param outValue the TypedValue to receive the parsed value
 * @param requireUnit whether the value is expected to contain a unit.
 * @return true if success.
 */

Body of Frist Method:
{
    assert requireUnit == false || attribute != null;
    // remove the space before and after
    value = value.trim();
    int len = value.length();
    if (len <= 0) {
        return false;
    }
    // check that there's no non ascii characters.
    char[] buf = value.toCharArray();
    for (int i = 0; i < len; i++) {
        if (buf[i] > 255) {
            return false;
        }
    }
    // check the first character
    if (buf[0] < '0' && buf[0] > '9' && buf[0] != '.' && buf[0] != '-') {
        return false;
    }
    // now look for the string that is after the float...
    Matcher m = sFloatPattern.matcher(value);
    if (m.matches()) {
        String f_str = m.group(1);
        String end = m.group(2);
        float f;
        try {
            f = Float.parseFloat(f_str);
        } catch (NumberFormatException e) {
            // this shouldn't happen with the regexp above.
            return false;
        }
        if (end.length() > 0 && end.charAt(0) != ' ') {
            // Might be a unit...
            if (parseUnit(end, outValue, sFloatOut)) {
                computeTypedValue(outValue, f, sFloatOut[0]);
                return true;
            }
            return false;
        }
        // make sure it's only spaces at the end.
        end = end.trim();
        if (end.length() == 0) {
            if (outValue != null) {
                if (requireUnit == false) {
                    outValue.type = TypedValue.TYPE_FLOAT;
                    outValue.data = Float.floatToIntBits(f);
                } else {
                    // no unit when required? Use dp and out an error.
                    applyUnit(sUnitNames[1], outValue, sFloatOut);
                    computeTypedValue(outValue, f, sFloatOut[0]);
                    Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!", value, attribute), null);
                }
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    assert !requireUnit || attribute != null;
    // remove the space before and after
    value = value.trim();
    int len = value.length();
    if (len <= 0) {
        return false;
    }
    // check that there's no non ascii characters.
    char[] buf = value.toCharArray();
    for (int i = 0; i < len; i++) {
        if (buf[i] > 255) {
            return false;
        }
    }
    // check the first character
    if ((buf[0] < '0' || buf[0] > '9') && buf[0] != '.' && buf[0] != '-' && buf[0] != '+') {
        return false;
    }
    // now look for the string that is after the float...
    Matcher m = sFloatPattern.matcher(value);
    if (m.matches()) {
        String f_str = m.group(1);
        String end = m.group(2);
        float f;
        try {
            f = Float.parseFloat(f_str);
        } catch (NumberFormatException e) {
            // this shouldn't happen with the regexp above.
            return false;
        }
        if (end.length() > 0 && end.charAt(0) != ' ') {
            // Might be a unit...
            if (parseUnit(end, outValue, sFloatOut)) {
                computeTypedValue(outValue, f, sFloatOut[0]);
                return true;
            }
            return false;
        }
        // make sure it's only spaces at the end.
        end = end.trim();
        if (end.length() == 0) {
            if (outValue != null) {
                if (!requireUnit) {
                    outValue.type = TypedValue.TYPE_FLOAT;
                    outValue.data = Float.floatToIntBits(f);
                } else {
                    // no unit when required? Use dp and out an error.
                    applyUnit(sUnitNames[1], outValue, sFloatOut);
                    computeTypedValue(outValue, f, sFloatOut[0]);
                    Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Dimension \"%1$s\" in attribute \"%2$s\" is missing unit!", value, attribute), null);
                }
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.framework.permission.tests.VibratorServicePermissionTest.testVibratePattern:COMMENT
Method Modifier: public      
Comment:/**
 * Test that calling {@link android.os.IVibratorService#vibratePattern(long[],
 * int, android.os.IBinder)} requires permissions.
 * <p>Tests permission:
 * {@link android.Manifest.permission#VIBRATE}
 * @throws RemoteException
 */

Body of Frist Method:
{
    try {
        mVibratorService.vibratePattern(Process.myUid(), null, new long[] { 0 }, 0, new Binder());
        fail("vibratePattern did not throw SecurityException as expected");
    } catch (SecurityException e) {
    // expected
    }
}
Body of Second Method:
{
    try {
        mVibratorService.vibratePattern(Process.myUid(), null, new long[] { 0 }, 0, AudioManager.STREAM_ALARM, new Binder());
        fail("vibratePattern did not throw SecurityException as expected");
    } catch (SecurityException e) {
    // expected
    }
}
------------------------
Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPeriodicsV2:COMMENT
Method Modifier: public      
Comment:/**
 * Test that we can create, remove and retrieve periodic syncs with a provided flex time.
 */

Body of Frist Method:
{
    final Account account1 = new Account("a@example.com", "example.type");
    final Account account2 = new Account("b@example.com", "example.type.2");
    final String authority = "testprovider";
    final Bundle extras1 = new Bundle();
    extras1.putString("a", "1");
    final Bundle extras2 = new Bundle();
    extras2.putString("a", "2");
    final int period1 = 200;
    final int period2 = 1000;
    final int flex1 = 10;
    final int flex2 = 100;
    PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1, flex1);
    PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1, flex1);
    PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2, flex2);
    PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2, flex2);
    MockContentResolver mockResolver = new MockContentResolver();
    SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
    removePeriodicSyncs(engine, account1, 0, authority);
    removePeriodicSyncs(engine, account2, 0, authority);
    removePeriodicSyncs(engine, account1, 1, authority);
    // This should add two distinct periodic syncs for account1 and one for account2
    engine.addPeriodicSync(sync1, 0);
    engine.addPeriodicSync(sync2, 0);
    // Should edit sync2 and update the period.
    engine.addPeriodicSync(sync3, 0);
    engine.addPeriodicSync(sync4, 0);
    // add a second user
    engine.addPeriodicSync(sync2, 1);
    List<PeriodicSync> syncs = engine.getPeriodicSyncs(account1, 0, authority);
    assertEquals(2, syncs.size());
    assertEquals(sync1, syncs.get(0));
    assertEquals(sync3, syncs.get(1));
    engine.removePeriodicSync(sync1, 0);
    syncs = engine.getPeriodicSyncs(account1, 0, authority);
    assertEquals(1, syncs.size());
    assertEquals(sync3, syncs.get(0));
    syncs = engine.getPeriodicSyncs(account2, 0, authority);
    assertEquals(1, syncs.size());
    assertEquals(sync4, syncs.get(0));
    syncs = engine.getPeriodicSyncs(sync2.account, 1, sync2.authority);
    assertEquals(1, syncs.size());
    assertEquals(sync2, syncs.get(0));
}
Body of Second Method:
{
    final Account account1 = new Account("a@example.com", "example.type");
    final Account account2 = new Account("b@example.com", "example.type.2");
    final String authority = "testprovider";
    final Bundle extras1 = new Bundle();
    extras1.putString("a", "1");
    final Bundle extras2 = new Bundle();
    extras2.putString("a", "2");
    final int period1 = 200;
    final int period2 = 1000;
    final int flex1 = 10;
    final int flex2 = 100;
    EndPoint point1 = new EndPoint(account1, authority, 0);
    EndPoint point2 = new EndPoint(account2, authority, 0);
    EndPoint point1User2 = new EndPoint(account1, authority, 1);
    PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1, flex1);
    PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1, flex1);
    PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2, flex2);
    PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2, flex2);
    EndPoint target1 = new EndPoint(account1, authority, 0);
    EndPoint target2 = new EndPoint(account2, authority, 0);
    EndPoint target1UserB = new EndPoint(account1, authority, 1);
    MockContentResolver mockResolver = new MockContentResolver();
    SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
    removePeriodicSyncs(engine, account1, 0, authority);
    removePeriodicSyncs(engine, account2, 0, authority);
    removePeriodicSyncs(engine, account1, 1, authority);
    // This should add two distinct periodic syncs for account1 and one for account2
    engine.updateOrAddPeriodicSync(target1, period1, flex1, extras1);
    engine.updateOrAddPeriodicSync(target1, period1, flex1, extras2);
    // Edit existing sync and update the period and flex.
    engine.updateOrAddPeriodicSync(target1, period2, flex2, extras2);
    engine.updateOrAddPeriodicSync(target2, period2, flex2, extras2);
    // add a target for a second user.
    engine.updateOrAddPeriodicSync(target1UserB, period1, flex1, extras2);
    List<PeriodicSync> syncs = engine.getPeriodicSyncs(target1);
    assertEquals(2, syncs.size());
    assertEquals(sync1, syncs.get(0));
    assertEquals(sync3, syncs.get(1));
    engine.removePeriodicSync(target1, extras1);
    syncs = engine.getPeriodicSyncs(target1);
    assertEquals(1, syncs.size());
    assertEquals(sync3, syncs.get(0));
    syncs = engine.getPeriodicSyncs(target2);
    assertEquals(1, syncs.size());
    assertEquals(sync4, syncs.get(0));
    syncs = engine.getPeriodicSyncs(target1UserB);
    assertEquals(1, syncs.size());
    assertEquals(sync2, syncs.get(0));
}
------------------------
Find a functionally equivalent code:android.net.LinkProperties.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface.
 */

Body of Frist Method:
{
    dest.writeString(getInterfaceName());
    dest.writeInt(mLinkAddresses.size());
    for (LinkAddress linkAddress : mLinkAddresses) {
        dest.writeParcelable(linkAddress, flags);
    }
    dest.writeInt(mDnses.size());
    for (InetAddress d : mDnses) {
        dest.writeByteArray(d.getAddress());
    }
    dest.writeString(mDomains);
    dest.writeInt(mMtu);
    dest.writeInt(mRoutes.size());
    for (RouteInfo route : mRoutes) {
        dest.writeParcelable(route, flags);
    }
    if (mHttpProxy != null) {
        dest.writeByte((byte) 1);
        dest.writeParcelable(mHttpProxy, flags);
    } else {
        dest.writeByte((byte) 0);
    }
    ArrayList<LinkProperties> stackedLinks = new ArrayList(mStackedLinks.values());
    dest.writeList(stackedLinks);
}
Body of Second Method:
{
    dest.writeString(getInterfaceName());
    dest.writeInt(mLinkAddresses.size());
    for (LinkAddress linkAddress : mLinkAddresses) {
        dest.writeParcelable(linkAddress, flags);
    }
    dest.writeInt(mDnses.size());
    for (InetAddress d : mDnses) {
        dest.writeByteArray(d.getAddress());
    }
    dest.writeString(mDomains);
    dest.writeInt(mMtu);
    dest.writeString(mTcpBufferSizes);
    dest.writeInt(mRoutes.size());
    for (RouteInfo route : mRoutes) {
        dest.writeParcelable(route, flags);
    }
    if (mHttpProxy != null) {
        dest.writeByte((byte) 1);
        dest.writeParcelable(mHttpProxy, flags);
    } else {
        dest.writeByte((byte) 0);
    }
    ArrayList<LinkProperties> stackedLinks = new ArrayList(mStackedLinks.values());
    dest.writeList(stackedLinks);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.rcDisplayIsPluggedIn_syncRcStack:COMMENT
Method Modifier: private     
Comment:/**
 * Is the remote control display interface already registered
 * @param rcd
 * @return true if the IRemoteControlDisplay is already in the list of displays
 */

Body of Frist Method:
{
    final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
    while (displayIterator.hasNext()) {
        final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
        if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
    while (displayIterator.hasNext()) {
        final DisplayInfoForServer di = displayIterator.next();
        if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

Body of Frist Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    ByteBuffer out = ByteBuffer.allocate(20 + vmIdent.length() * 2 + appName.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
Body of Second Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.addCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Add a callback to listen to events about specific kinds of media routes.
 * If the specified callback is already registered, its registration will be updated for any
 * additional route types specified.
 * <p>
 * This is a convenience method that has the same effect as calling
 * {@link #addCallback(int, Callback, int)} without flags.
 * </p>
 *
 * @param types Types of routes this callback is interested in
 * @param cb Callback to add
 */

Body of Frist Method:
{
    addCallback(types, cb, 0);
}
Body of Second Method:
{
    addCallback(types, cb, 0);
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageItemInfo.loadDefaultIcon:COMMENT
<android.content.pm.PackageItemInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Retrieve the default graphical icon associated with this item.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's default icon
 * such as the default activity icon.
 *
 * @hide
 */

Body of Frist Method:
{
    return pm.getDefaultActivityIcon();
}
Body of Second Method:
{
    return pm.getDefaultActivityIcon();
}
------------------------
Find a functionally equivalent code:android.widget.ActivityChooserView.updateAppearance:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the buttons state.
 */

Body of Frist Method:
{
    // Expand overflow button.
    if (mAdapter.getCount() > 0) {
        mExpandActivityOverflowButton.setEnabled(true);
    } else {
        mExpandActivityOverflowButton.setEnabled(false);
    }
    // Default activity button.
    final int activityCount = mAdapter.getActivityCount();
    final int historySize = mAdapter.getHistorySize();
    if (activityCount == 1 || activityCount > 1 && historySize > 0) {
        mDefaultActivityButton.setVisibility(VISIBLE);
        ResolveInfo activity = mAdapter.getDefaultActivity();
        PackageManager packageManager = mContext.getPackageManager();
        mDefaultActivityButtonImage.setImageDrawable(activity.loadIcon(packageManager));
        if (mDefaultActionButtonContentDescription != 0) {
            CharSequence label = activity.loadLabel(packageManager);
            String contentDescription = mContext.getString(mDefaultActionButtonContentDescription, label);
            mDefaultActivityButton.setContentDescription(contentDescription);
        }
    } else {
        mDefaultActivityButton.setVisibility(View.GONE);
    }
    // Activity chooser content.
    if (mDefaultActivityButton.getVisibility() == VISIBLE) {
        mActivityChooserContent.setBackgroundDrawable(mActivityChooserContentBackground);
    } else {
        mActivityChooserContent.setBackgroundDrawable(null);
    }
}
Body of Second Method:
{
    // Expand overflow button.
    if (mAdapter.getCount() > 0) {
        mExpandActivityOverflowButton.setEnabled(true);
    } else {
        mExpandActivityOverflowButton.setEnabled(false);
    }
    // Default activity button.
    final int activityCount = mAdapter.getActivityCount();
    final int historySize = mAdapter.getHistorySize();
    if (activityCount == 1 || activityCount > 1 && historySize > 0) {
        mDefaultActivityButton.setVisibility(VISIBLE);
        ResolveInfo activity = mAdapter.getDefaultActivity();
        PackageManager packageManager = mContext.getPackageManager();
        mDefaultActivityButtonImage.setImageDrawable(activity.loadIcon(packageManager));
        if (mDefaultActionButtonContentDescription != 0) {
            CharSequence label = activity.loadLabel(packageManager);
            String contentDescription = mContext.getString(mDefaultActionButtonContentDescription, label);
            mDefaultActivityButton.setContentDescription(contentDescription);
        }
    } else {
        mDefaultActivityButton.setVisibility(View.GONE);
    }
    // Activity chooser content.
    if (mDefaultActivityButton.getVisibility() == VISIBLE) {
        mActivityChooserContent.setBackground(mActivityChooserContentBackground);
    } else {
        mActivityChooserContent.setBackground(null);
    }
}
------------------------
Find a functionally equivalent code:android.view.KeyEvent.keyCodeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified keycode
 * such as "KEYCODE_A", "KEYCODE_DPAD_UP", or an equivalent numeric constant
 * such as "1001" if unknown.
 *
 * @param keyCode The key code.
 * @return The symbolic name of the specified keycode.
 *
 * @see KeyCharacterMap#getDisplayLabel
 */

Body of Frist Method:
{
    String symbolicName = KEYCODE_SYMBOLIC_NAMES.get(keyCode);
    return symbolicName != null ? symbolicName : Integer.toString(keyCode);
}
Body of Second Method:
{
    String symbolicName = nativeKeyCodeToString(keyCode);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(keyCode);
}
------------------------
Find a functionally equivalent code:android.widget.RelativeLayout.getChildMeasureSpec:COMMENT
Method Modifier: private     
Comment:/**
 * Get a measure spec that accounts for all of the constraints on this view.
 * This includes size constraints imposed by the RelativeLayout as well as
 * the View's desired dimension.
 *
 * @param childStart The left or top field of the child's layout params
 * @param childEnd The right or bottom field of the child's layout params
 * @param childSize The child's desired size (the width or height field of
 * the child's layout params)
 * @param startMargin The left or top margin
 * @param endMargin The right or bottom margin
 * @param startPadding mPaddingLeft or mPaddingTop
 * @param endPadding mPaddingRight or mPaddingBottom
 * @param mySize The width or height of this view (the RelativeLayout)
 * @return MeasureSpec for the child
 */

Body of Frist Method:
{
    if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
        if (childSize >= 0) {
            return MeasureSpec.makeMeasureSpec(childSize, MeasureSpec.EXACTLY);
        }
        // Carry it forward.
        return MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    }
    int childSpecMode = 0;
    int childSpecSize = 0;
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart < 0) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd < 0) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    int maxAvailable = tempEnd - tempStart;
    if (childStart >= 0 && childEnd >= 0) {
        // Constraints fixed both edges, so child must be an exact size
        childSpecMode = MeasureSpec.EXACTLY;
        childSpecSize = maxAvailable;
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maxmum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space
            childSpecMode = MeasureSpec.EXACTLY;
            childSpecSize = maxAvailable;
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // our max size
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
Body of Second Method:
{
    int childSpecMode = 0;
    int childSpecSize = 0;
    // RelativeLayout's measure spec."
    if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
        if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
            // Constraints fixed both edges, so child has an exact size.
            childSpecSize = Math.max(0, childEnd - childStart);
            childSpecMode = MeasureSpec.EXACTLY;
        } else if (childSize >= 0) {
            // The child specified an exact size.
            childSpecSize = childSize;
            childSpecMode = MeasureSpec.EXACTLY;
        } else {
            // Allow the child to be whatever size it wants.
            childSpecSize = 0;
            childSpecMode = MeasureSpec.UNSPECIFIED;
        }
        return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
    }
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart == VALUE_NOT_SET) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd == VALUE_NOT_SET) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    int maxAvailable = tempEnd - tempStart;
    if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
        // Constraints fixed both edges, so child must be an exact size
        childSpecMode = MeasureSpec.EXACTLY;
        childSpecSize = maxAvailable;
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maxmum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space
            childSpecMode = MeasureSpec.EXACTLY;
            childSpecSize = maxAvailable;
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // our max size
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.abortReliableWrite:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #abortReliableWrite()}
 */

Body of Frist Method:
{
    abortReliableWrite();
}
Body of Second Method:
{
    abortReliableWrite();
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeDispatching:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // Go home!
            launchHomeFromHotKey();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction();
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
Body of Second Method:
{
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            // Go home!
            launchHomeFromHotKey();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction();
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
------------------------
Find a functionally equivalent code:android.view.textservice.TextInfo.getSequence:COMMENT
Method Modifier: public      
Comment:/**
 * @return the sequence of TextInfo
 */

Body of Frist Method:
{
    return mSequence;
}
Body of Second Method:
{
    return mSequenceNumber;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchHoverEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}
Body of Second Method:
{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}
------------------------
Find a functionally equivalent code:android.view.Surface.lockCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalStateException("Surface was already locked");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalArgumentException("Surface was already locked");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
Body of Second Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetManager.getAppWidgetInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */

Body of Frist Method:
{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId, mContext.getUserId());
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.view.Window.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Set the type of the window, as per the WindowManager.LayoutParams
 * types.
 *
 * @param type The new window type (see WindowManager.LayoutParams).
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.type = type;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.type = type;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.postReevaluateRemote:COMMENT
<android.media.MediaFocusControl: void postReevaluateRemote()>
Method Modifier: protected   private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Call to make AudioService reevaluate whether it's in a mode where remote players should
 * have their volume controlled. In this implementation this is only to reset whether
 * VolumePanel should display remote volumes
 */

Body of Frist Method:
{
    sendMsg(mEventHandler, MSG_REEVALUATE_REMOTE, SENDMSG_QUEUE, 0, 0, null, 0);
}
Body of Second Method:
{
    sendMsg(mEventHandler, MSG_REEVALUATE_REMOTE, SENDMSG_QUEUE, 0, 0, null, 0);
}
------------------------
Find a functionally equivalent code:android.print.PrintDocumentInfo.Builder.setPageCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the total number of pages.
 * <p>
 * <strong>Default: </strong> {@link #PAGE_COUNT_UNKNOWN}
 * </p>
 *
 * @param pageCount The number of pages. Must be greater than
 * or equal to zero or {@link PrintDocumentInfo#PAGE_COUNT_UNKNOWN}.
 */

Body of Frist Method:
{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException("pageCount" + " must be greater than or euqal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}
Body of Second Method:
{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException("pageCount" + " must be greater than or equal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.setClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Changes the ClassLoader this Bundle uses when instantiating objects.
 *
 * @param loader An explicit ClassLoader to use when instantiating objects
 * inside of the Bundle.
 */

Body of Frist Method:
{
    mClassLoader = loader;
}
Body of Second Method:
{
    super.setClassLoader(loader);
}
------------------------
Find a functionally equivalent code:android.text.format.Time.parse3339:COMMENT
Method Modifier: public      
Comment:/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>"2008-10-13T16:00:00.000Z"</li>
 * <li>"2008-10-13T16:00:00.000+07:00"</li>
 * <li>"2008-10-13T16:00:00.000-07:00"</li>
 * <li>"2008-10-13"</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

Body of Frist Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (nativeParse3339(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (parse3339Internal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothSocket.read:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
Body of Second Method:
{
    if (mSocketIS == null)
        throw new IOException("read is called on null InputStream");
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
------------------------
Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.downloadFile:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a file using http connection from a test server and reports the
 * data usage stats to instrumentation out.
 */

Body of Frist Method:
{
    NetworkStats pre_test_stats = fetchDataFromProc(mUid);
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    TrafficStats.startDataProfiling(mContext);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(BandwidthTestUtil.DownloadFromUrl(targetUrl, tmpSaveFile));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    Log.d(LOG_TAG, prof_stats.toString());
    NetworkStats post_test_stats = fetchDataFromProc(mUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    AddStatsToResults(PROF_LABEL, prof_stats, results);
    AddStatsToResults(PROC_LABEL, proc_stats, results);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
Body of Second Method:
{
    NetworkStats pre_test_stats = fetchDataFromProc(mUid);
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    TrafficStats.startDataProfiling(mContext);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(BandwidthTestUtil.DownloadFromUrl(targetUrl, tmpSaveFile));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    Log.d(LOG_TAG, prof_stats.toString());
    NetworkStats post_test_stats = fetchDataFromProc(mUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
    addStatsToResults(PROC_LABEL, proc_stats, results, mUid);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
------------------------
Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.downloadFileUsingDownloadManager:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a file from a test server using the download manager and reports
 * the stats to instrumentation out.
 */

Body of Frist Method:
{
    // If we are using the download manager, then the data that is written to /proc/uid_stat/
    // is accounted against download manager's uid, since it uses pre-ICS API.
    int downloadManagerUid = mConnectionUtil.downloadManagerUid();
    assertTrue(downloadManagerUid >= 0);
    NetworkStats pre_test_stats = fetchDataFromProc(downloadManagerUid);
    // start profiling
    TrafficStats.startDataProfiling(mContext);
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    Log.v(LOG_TAG, "Download url: " + targetUrl);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(mConnectionUtil.startDownloadAndWait(targetUrl, 500000));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    NetworkStats post_test_stats = fetchDataFromProc(downloadManagerUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    Log.d(LOG_TAG, prof_stats.toString());
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    AddStatsToResults(PROF_LABEL, prof_stats, results);
    AddStatsToResults(PROC_LABEL, proc_stats, results);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
Body of Second Method:
{
    // If we are using the download manager, then the data that is written to /proc/uid_stat/
    // is accounted against download manager's uid, since it uses pre-ICS API.
    int downloadManagerUid = mConnectionUtil.downloadManagerUid();
    assertTrue(downloadManagerUid >= 0);
    NetworkStats pre_test_stats = fetchDataFromProc(downloadManagerUid);
    // start profiling
    TrafficStats.startDataProfiling(mContext);
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    Log.v(LOG_TAG, "Download url: " + targetUrl);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(mConnectionUtil.startDownloadAndWait(targetUrl, 500000));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    NetworkStats post_test_stats = fetchDataFromProc(downloadManagerUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    Log.d(LOG_TAG, prof_stats.toString());
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
    // remember to use download manager uid for proc stats
    addStatsToResults(PROC_LABEL, proc_stats, results, downloadManagerUid);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Boolean value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Boolean, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putBoolean(key, value);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getNonConfigurationString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Retrieve the string value for the attribute at <var>index</var> that is
 * not allowed to change with the given configurations.
 *
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from
 * {@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a functionally equivalent code:android.widget.EdgeEffect.onAbsorb:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the effect absorbs an impact at the given velocity.
 * Used when a fling reaches the scroll boundary.
 *
 * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
 * the method <code>getCurrVelocity</code> will provide a reasonable approximation
 * to use here.</p>
 *
 * @param velocity Velocity at impact in pixels per second.
 */

Body of Frist Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The edge should always be at least partially visible, regardless
    // of velocity.
    mEdgeAlphaStart = 0.f;
    mEdgeScaleY = mEdgeScaleYStart = 0.f;
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = 0.3f;
    mGlowScaleYStart = 0.f;
    // Factor the velocity by 8. Testing on device shows this works best to
    // reflect the strength of the user's scrolling.
    mEdgeAlphaFinish = Math.max(0, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1));
    // Edge should never get larger than the size of its asset.
    mEdgeScaleYFinish = Math.max(HELD_EDGE_SCALE_Y, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1.f));
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f), 1.75f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
}
Body of Second Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = 0.3f;
    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
    mTargetDisplacement = 0.5f;
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.isMultichannelConfigSupported:COMMENT
Method Modifier: private     static      
Comment:/**
 * Convenience method to check that the channel configuration (a.k.a channel mask) is supported
 * @param channelConfig the mask to validate
 * @return false if the AudioTrack can't be used with such a mask
 */

Body of Frist Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    final int channelCount = Integer.bitCount(channelConfig);
    if (channelCount > CHANNEL_COUNT_MAX) {
        loge("Channel configuration contains too many channels " + channelCount + ">" + CHANNEL_COUNT_MAX);
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    final int sidePair = AudioFormat.CHANNEL_OUT_SIDE_LEFT | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
    if ((channelConfig & sidePair) != 0 && (channelConfig & sidePair) != sidePair) {
        loge("Side channels can't be used independently");
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawRGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified RGB color, using srcover porterduff mode.
 *
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawRGB(mNativeCanvas, r, g, b);
}
Body of Second Method:
{
    drawColor(Color.rgb(r, g, b));
}
------------------------
Find a functionally equivalent code:android.app.Activity.onStop:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when you are no longer visible to the user.  You will next
 * receive either {@link #onRestart}, {@link #onDestroy}, or nothing,
 * depending on later user activity.
 *
 * <p>Note that this method may never be called, in low memory situations
 * where the system does not have enough memory to keep your activity's
 * process running after its {@link #onPause} method is called.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestart
 * @see #onResume
 * @see #onSaveInstanceState
 * @see #onDestroy
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStop " + this);
    if (mActionBar != null)
        mActionBar.setShowHideAnimationEnabled(false);
    getApplication().dispatchActivityStopped(this);
    mTranslucentCallback = null;
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStop " + this);
    if (mActionBar != null)
        mActionBar.setShowHideAnimationEnabled(false);
    mActivityTransitionState.onStop();
    getApplication().dispatchActivityStopped(this);
    mTranslucentCallback = null;
    mCalled = true;
}
------------------------
Find a functionally equivalent code:android.view.WindowManagerPolicy.createForceHideEnterAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Create and return an animation to re-display a force hidden window.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.speech.SpeechRecognizer.destroy:COMMENT
Method Modifier: public      
Comment:/**
 * Destroys the {@code SpeechRecognizer} object.
 */

Body of Frist Method:
{
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.getMatrix:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return, in ctm, the current transformation matrix. This does not alter
 * the matrix in the canvas, but just returns a copy of it.
 */

Body of Frist Method:
{
    native_getCTM(mNativeCanvas, ctm.native_instance);
}
Body of Second Method:
{
    native_getCTM(mNativeCanvasWrapper, ctm.native_instance);
}
------------------------
Find a functionally equivalent code:android.view.GraphicBuffer.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates new <code>GraphicBuffer</code> instance. This method will return null
 * if the buffer cannot be created.
 *
 * @param width The width in pixels of the buffer
 * @param height The height in pixels of the buffer
 * @param format The format of each pixel as specified in {@link PixelFormat}
 * @param usage Hint indicating how the buffer will be used
 *
 * @return A <code>GraphicBuffer</code> instance or null
 */

Body of Frist Method:
{
    int nativeObject = nCreateGraphicBuffer(width, height, format, usage);
    if (nativeObject != 0) {
        return new GraphicBuffer(width, height, format, usage, nativeObject);
    }
    return null;
}
Body of Second Method:
{
    long nativeObject = nCreateGraphicBuffer(width, height, format, usage);
    if (nativeObject != 0) {
        return new GraphicBuffer(width, height, format, usage, nativeObject);
    }
    return null;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isBiometricWeakInstalled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether biometric weak lock is installed and that the front facing camera exists
 */

Body of Frist Method:
{
    // Check that it's installed
    PackageManager pm = mContext.getPackageManager();
    try {
        pm.getPackageInfo("com.android.facelock", PackageManager.GET_ACTIVITIES);
    } catch (PackageManager.NameNotFoundException e) {
        return false;
    }
    // Check that the camera is enabled
    if (!pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT)) {
        return false;
    }
    if (getDevicePolicyManager().getCameraDisabled(null, getCurrentOrCallingUserId())) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    // Check that it's installed
    PackageManager pm = mContext.getPackageManager();
    try {
        pm.getPackageInfo("com.android.facelock", PackageManager.GET_ACTIVITIES);
    } catch (PackageManager.NameNotFoundException e) {
        return false;
    }
    // Check that the camera is enabled
    if (!pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT)) {
        return false;
    }
    if (getDevicePolicyManager().getCameraDisabled(null, getCurrentOrCallingUserId())) {
        return false;
    }
    // entire function and a lot of other code can be removed.
    if (DEBUG)
        Log.d(TAG, "Forcing isBiometricWeakInstalled() to return false to disable it");
    return false;
}
------------------------
Find a functionally equivalent code:android.text.DynamicLayout.addBlockAtOffset:COMMENT
Method Modifier: private     
Comment:/**
 * Create a new block, ending at the specified character offset.
 * A block will actually be created only if has at least one line, i.e. this offset is
 * not on the end line of the previous block.
 */

Body of Frist Method:
{
    final int line = getLineForOffset(offset);
    if (mBlockEndLines == null) {
        // Initial creation of the array, no test on previous block ending line
        mBlockEndLines = new int[ArrayUtils.idealIntArraySize(1)];
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
        return;
    }
    final int previousBlockEndLine = mBlockEndLines[mNumberOfBlocks - 1];
    if (line > previousBlockEndLine) {
        if (mNumberOfBlocks == mBlockEndLines.length) {
            // Grow the array if needed
            int[] blockEndLines = new int[ArrayUtils.idealIntArraySize(mNumberOfBlocks + 1)];
            System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, mNumberOfBlocks);
            mBlockEndLines = blockEndLines;
        }
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
    }
}
Body of Second Method:
{
    final int line = getLineForOffset(offset);
    if (mBlockEndLines == null) {
        // Initial creation of the array, no test on previous block ending line
        mBlockEndLines = ArrayUtils.newUnpaddedIntArray(1);
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
        return;
    }
    final int previousBlockEndLine = mBlockEndLines[mNumberOfBlocks - 1];
    if (line > previousBlockEndLine) {
        mBlockEndLines = GrowingArrayUtils.append(mBlockEndLines, mNumberOfBlocks, line);
        mNumberOfBlocks++;
    }
}
------------------------
Find a functionally equivalent code:android.net.DnsPinger.getDnsList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of DNS addresses, coming from either the link properties of the
 * specified connection or the default system DNS if the link properties has no dnses.
 * @return a non-empty non-null list
 */

Body of Frist Method:
{
    LinkProperties curLinkProps = getCurrentLinkProperties();
    if (curLinkProps == null) {
        loge("getCurLinkProperties:: LP for type" + mConnectionType + " is null!");
        return mDefaultDns;
    }
    Collection<InetAddress> dnses = curLinkProps.getDnses();
    if (dnses == null || dnses.size() == 0) {
        loge("getDns::LinkProps has null dns - returning default");
        return mDefaultDns;
    }
    return new ArrayList<InetAddress>(dnses);
}
Body of Second Method:
{
    LinkProperties curLinkProps = getCurrentLinkProperties();
    if (curLinkProps == null) {
        loge("getCurLinkProperties:: LP for type" + mConnectionType + " is null!");
        return mDefaultDns;
    }
    Collection<InetAddress> dnses = curLinkProps.getDnsServers();
    if (dnses == null || dnses.size() == 0) {
        loge("getDns::LinkProps has null dns - returning default");
        return mDefaultDns;
    }
    return new ArrayList<InetAddress>(dnses);
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.getPrintJob:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a print job given its id.
 *
 * @return The print job list.
 * @see PrintJob
 * @hide
 */

Body of Frist Method:
{
    try {
        PrintJobInfo printJob = mService.getPrintJobInfo(printJobId, mAppId, mUserId);
        if (printJob != null) {
            return new PrintJob(printJob, this);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print job", re);
    }
    return null;
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    try {
        PrintJobInfo printJob = mService.getPrintJobInfo(printJobId, mAppId, mUserId);
        if (printJob != null) {
            return new PrintJob(printJob, this);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print job", re);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.setPlaybackPositionUpdateListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be called whenever the media playback position is requested
 * to be updated.
 * Notifications will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the position update listener to be called
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        int oldCapa = mPlaybackPositionCapabilities;
        if (l != null) {
            mPlaybackPositionCapabilities |= MEDIA_POSITION_WRITABLE;
        } else {
            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_WRITABLE;
        }
        mPositionUpdateListener = l;
        if (oldCapa != mPlaybackPositionCapabilities) {
            // tell RCDs that this RCC's playback position capabilities have changed
            sendTransportControlInfo_syncCacheLock(null);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        mPositionUpdateListener = l;
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setMasterMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setMasterMute(boolean, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, 0, null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, UserHandle.getCallingUserId(), null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.transitionPreviewLayout:COMMENT
Method Modifier: private     
Comment:/**
 * Transitions the preview text to a new section. Handles animation,
 * measurement, and layout. If the new preview text is empty, returns false.
 *
 * @param sectionIndex The section index to which the preview should
 * transition.
 * @return False if the new preview text is empty.
 */

Body of Frist Method:
{
    final Object[] sections = mSections;
    String text = null;
    if (sections != null && sectionIndex >= 0 && sectionIndex < sections.length) {
        final Object section = sections[sectionIndex];
        if (section != null) {
            text = section.toString();
        }
    }
    final Rect bounds = mTempBounds;
    final ImageView preview = mPreviewImage;
    final TextView showing;
    final TextView target;
    if (mShowingPrimary) {
        showing = mPrimaryText;
        target = mSecondaryText;
    } else {
        showing = mSecondaryText;
        target = mPrimaryText;
    }
    // Set and layout target immediately.
    target.setText(text);
    measurePreview(target, bounds);
    applyLayout(target, bounds);
    if (mPreviewAnimation != null) {
        mPreviewAnimation.cancel();
    }
    // Cross-fade preview text.
    final Animator showTarget = animateAlpha(target, 1f).setDuration(DURATION_CROSS_FADE);
    final Animator hideShowing = animateAlpha(showing, 0f).setDuration(DURATION_CROSS_FADE);
    hideShowing.addListener(mSwitchPrimaryListener);
    // Apply preview image padding and animate bounds, if necessary.
    bounds.left -= mPreviewImage.getPaddingLeft();
    bounds.top -= mPreviewImage.getPaddingTop();
    bounds.right += mPreviewImage.getPaddingRight();
    bounds.bottom += mPreviewImage.getPaddingBottom();
    final Animator resizePreview = animateBounds(preview, bounds);
    resizePreview.setDuration(DURATION_RESIZE);
    mPreviewAnimation = new AnimatorSet();
    final AnimatorSet.Builder builder = mPreviewAnimation.play(hideShowing).with(showTarget);
    builder.with(resizePreview);
    // The current preview size is unaffected by hidden or showing. It's
    // used to set starting scales for things that need to be scaled down.
    final int previewWidth = preview.getWidth() - preview.getPaddingLeft() - preview.getPaddingRight();
    // If target is too large, shrink it immediately to fit and expand to
    // target size. Otherwise, start at target size.
    final int targetWidth = target.getWidth();
    if (targetWidth > previewWidth) {
        target.setScaleX((float) previewWidth / targetWidth);
        final Animator scaleAnim = animateScaleX(target, 1f).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    } else {
        target.setScaleX(1f);
    }
    // If showing is larger than target, shrink to target size.
    final int showingWidth = showing.getWidth();
    if (showingWidth > targetWidth) {
        final float scale = (float) targetWidth / showingWidth;
        final Animator scaleAnim = animateScaleX(showing, scale).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    }
    mPreviewAnimation.start();
    return (text != null && text.length() > 0);
}
Body of Second Method:
{
    final Object[] sections = mSections;
    String text = null;
    if (sections != null && sectionIndex >= 0 && sectionIndex < sections.length) {
        final Object section = sections[sectionIndex];
        if (section != null) {
            text = section.toString();
        }
    }
    final Rect bounds = mTempBounds;
    final View preview = mPreviewImage;
    final TextView showing;
    final TextView target;
    if (mShowingPrimary) {
        showing = mPrimaryText;
        target = mSecondaryText;
    } else {
        showing = mSecondaryText;
        target = mPrimaryText;
    }
    // Set and layout target immediately.
    target.setText(text);
    measurePreview(target, bounds);
    applyLayout(target, bounds);
    if (mPreviewAnimation != null) {
        mPreviewAnimation.cancel();
    }
    // Cross-fade preview text.
    final Animator showTarget = animateAlpha(target, 1f).setDuration(DURATION_CROSS_FADE);
    final Animator hideShowing = animateAlpha(showing, 0f).setDuration(DURATION_CROSS_FADE);
    hideShowing.addListener(mSwitchPrimaryListener);
    // Apply preview image padding and animate bounds, if necessary.
    bounds.left -= preview.getPaddingLeft();
    bounds.top -= preview.getPaddingTop();
    bounds.right += preview.getPaddingRight();
    bounds.bottom += preview.getPaddingBottom();
    final Animator resizePreview = animateBounds(preview, bounds);
    resizePreview.setDuration(DURATION_RESIZE);
    mPreviewAnimation = new AnimatorSet();
    final AnimatorSet.Builder builder = mPreviewAnimation.play(hideShowing).with(showTarget);
    builder.with(resizePreview);
    // The current preview size is unaffected by hidden or showing. It's
    // used to set starting scales for things that need to be scaled down.
    final int previewWidth = preview.getWidth() - preview.getPaddingLeft() - preview.getPaddingRight();
    // If target is too large, shrink it immediately to fit and expand to
    // target size. Otherwise, start at target size.
    final int targetWidth = target.getWidth();
    if (targetWidth > previewWidth) {
        target.setScaleX((float) previewWidth / targetWidth);
        final Animator scaleAnim = animateScaleX(target, 1f).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    } else {
        target.setScaleX(1f);
    }
    // If showing is larger than target, shrink to target size.
    final int showingWidth = showing.getWidth();
    if (showingWidth > targetWidth) {
        final float scale = (float) targetWidth / showingWidth;
        final Animator scaleAnim = animateScaleX(showing, scale).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    }
    mPreviewAnimation.start();
    return !TextUtils.isEmpty(text);
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.InputStage.deliver:COMMENT
Method Modifier: public      final       
Comment:/**
 * Delivers an event to be processed.
 */

Body of Frist Method:
{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (mView == null || !mAdded) {
        Slog.w(TAG, "Dropping event due to root view being removed: " + q.mEvent);
        finish(q, false);
    } else if (!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isTerminalInputEvent(q.mEvent)) {
        // If this is a focused event and the window doesn't currently have input focus,
        // then drop this event.  This could be an event that came back from the previous
        // stage but the window has lost focus in the meantime.
        Slog.w(TAG, "Dropping event due to no window focus: " + q.mEvent);
        finish(q, false);
    } else {
        apply(q, onProcess(q));
    }
}
Body of Second Method:
{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (shouldDropInputEvent(q)) {
        finish(q, false);
    } else {
        apply(q, onProcess(q));
    }
}
------------------------
Find a functionally equivalent code:android.transition.Transition.playTransition:COMMENT
Method Modifier: 
Comment:/**
 * Called by TransitionManager to play the transition. This calls
 * createAnimators() to set things up and create all of the animations and then
 * runAnimations() to actually start the animations.
 */

Body of Frist Method:
{
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null) {
                boolean cancel = false;
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues newValues = mEndValues.viewValues != null ? mEndValues.viewValues.get(oldView) : null;
                if (newValues == null) {
                    newValues = mEndValues.idValues.get(oldView.getId());
                }
                if (oldValues != null) {
                    // and won't get canceled
                    if (newValues != null) {
                        for (String key : oldValues.values.keySet()) {
                            Object oldValue = oldValues.values.get(key);
                            Object newValue = newValues.values.get(key);
                            if (oldValue != null && newValue != null && !oldValue.equals(newValue)) {
                                cancel = true;
                                if (DBG) {
                                    Log.d(LOG_TAG, "Transition.playTransition: " + "oldValue != newValue for " + key + ": old, new = " + oldValue + ", " + newValue);
                                }
                                break;
                            }
                        }
                    }
                }
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues);
    runAnimators();
}
Body of Second Method:
{
    mStartValuesList = new ArrayList<TransitionValues>();
    mEndValuesList = new ArrayList<TransitionValues>();
    matchStartAndEnd(mStartValues, mEndValues);
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    WindowId windowId = sceneRoot.getWindowId();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues startValues = getTransitionValues(oldView, true);
                TransitionValues endValues = getMatchedTransitionValues(oldView, true);
                boolean cancel = (startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues, endValues);
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);
    runAnimators();
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.postTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified translation.
 * M' = T(dx, dy) * M
 */

Body of Frist Method:
{
    return native_postTranslate(native_instance, dx, dy);
}
Body of Second Method:
{
    native_postTranslate(native_instance, dx, dy);
    return true;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.initializePanelMenu:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Initializes the menu associated with the given panel feature state. You
 * must at the very least set PanelFeatureState.menu to the Menu to be
 * associated with the given panel state. The default implementation creates
 * a new menu for the panel state.
 *
 * @param st The panel whose menu is being initialized.
 * @return Whether the initialization was successful.
 */

Body of Frist Method:
{
    Context context = getContext();
    // If we have an action bar, initialize the menu with a context themed for it.
    if ((st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR) && mActionBar != null) {
        TypedValue outValue = new TypedValue();
        Resources.Theme currentTheme = context.getTheme();
        currentTheme.resolveAttribute(com.android.internal.R.attr.actionBarWidgetTheme, outValue, true);
        final int targetThemeRes = outValue.resourceId;
        if (targetThemeRes != 0 && context.getThemeResId() != targetThemeRes) {
            context = new ContextThemeWrapper(context, targetThemeRes);
        }
    }
    final MenuBuilder menu = new MenuBuilder(context);
    menu.setCallback(this);
    st.setMenu(menu);
    return true;
}
Body of Second Method:
{
    Context context = getContext();
    // If we have an action bar, initialize the menu with the right theme.
    if ((st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR) && mDecorContentParent != null) {
        final TypedValue outValue = new TypedValue();
        final Theme baseTheme = context.getTheme();
        baseTheme.resolveAttribute(R.attr.actionBarTheme, outValue, true);
        Theme widgetTheme = null;
        if (outValue.resourceId != 0) {
            widgetTheme = context.getResources().newTheme();
            widgetTheme.setTo(baseTheme);
            widgetTheme.applyStyle(outValue.resourceId, true);
            widgetTheme.resolveAttribute(R.attr.actionBarWidgetTheme, outValue, true);
        } else {
            baseTheme.resolveAttribute(R.attr.actionBarWidgetTheme, outValue, true);
        }
        if (outValue.resourceId != 0) {
            if (widgetTheme == null) {
                widgetTheme = context.getResources().newTheme();
                widgetTheme.setTo(baseTheme);
            }
            widgetTheme.applyStyle(outValue.resourceId, true);
        }
        if (widgetTheme != null) {
            context = new ContextThemeWrapper(context, 0);
            context.getTheme().setTo(widgetTheme);
        }
    }
    final MenuBuilder menu = new MenuBuilder(context);
    menu.setCallback(this);
    st.setMenu(menu);
    return true;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.setClipToPadding:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to the padding of the ViewGroup. This
 * allows view groups to override this behavior
 *
 * @param clipToPadding true to clip children to the padding of the
 * group, false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipToPadding
 */

Body of Frist Method:
{
    setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
}
Body of Second Method:
{
    if (hasBooleanFlag(FLAG_CLIP_TO_PADDING) != clipToPadding) {
        setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
        invalidate(true);
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupValue:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function to set the value stored in a particular Keyframe. The value used is
 * whatever the value is for the property name specified in the keyframe on the target object.
 *
 * @param target The target object from which the current value should be extracted.
 * @param kf The keyframe which holds the property name and value.
 */

Body of Frist Method:
{
    if (mProperty != null) {
        kf.setValue(mProperty.get(target));
    }
    try {
        if (mGetter == null) {
            Class targetClass = target.getClass();
            setupGetter(targetClass);
            if (mGetter == null) {
                // Already logged the error - just return to avoid NPE
                return;
            }
        }
        kf.setValue(mGetter.invoke(target));
    } catch (InvocationTargetException e) {
        Log.e("PropertyValuesHolder", e.toString());
    } catch (IllegalAccessException e) {
        Log.e("PropertyValuesHolder", e.toString());
    }
}
Body of Second Method:
{
    if (mProperty != null) {
        Object value = convertBack(mProperty.get(target));
        kf.setValue(value);
    }
    try {
        if (mGetter == null) {
            Class targetClass = target.getClass();
            setupGetter(targetClass);
            if (mGetter == null) {
                // Already logged the error - just return to avoid NPE
                return;
            }
        }
        Object value = convertBack(mGetter.invoke(target));
        kf.setValue(value);
    } catch (InvocationTargetException e) {
        Log.e("PropertyValuesHolder", e.toString());
    } catch (IllegalAccessException e) {
        Log.e("PropertyValuesHolder", e.toString());
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.preTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified translation.
 * M' = M * T(dx, dy)
 */

Body of Frist Method:
{
    return native_preTranslate(native_instance, dx, dy);
}
Body of Second Method:
{
    native_preTranslate(native_instance, dx, dy);
    return true;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiManager.startScan:COMMENT
Method Modifier: public      
Comment:/**
 * Request a scan for access points. Returns immediately. The availability
 * of the results is made known later by means of an asynchronous event sent
 * on completion of the scan.
 * @return {@code true} if the operation succeeded, i.e., the scan was initiated
 */

Body of Frist Method:
{
    try {
        final WorkSource workSource = null;
        mService.startScan(workSource);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.startScan(null, null);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
------------------------
Find a functionally equivalent code:javax.obex.ClientOperation.continueOperation:COMMENT
Method Modifier: public      
Comment:/**
 * Continues the operation since there is no data to read.
 * @param sendEmpty <code>true</code> if the operation should send an empty
 * packet or not send anything if there is no data to send
 * @param inStream <code>true</code> if the stream is input stream or is
 * output stream
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            sendRequest(0x03);
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(0x02);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
Body of Second Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if (!mGetFinalFlag) {
                sendRequest(0x03);
            } else {
                sendRequest(0x83);
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            }
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(0x02);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchGetDisplayList:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is used to cause children of this ViewGroup to restore or recreate their
 * display lists. It is called by getDisplayList() when the parent ViewGroup does not need
 * to recreate its own display list, which would happen if it went through the normal
 * draw/dispatchDraw mechanisms.
 *
 * @hide
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) && child.hasStaticLayer()) {
            child.mRecreateDisplayList = (child.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
            child.mPrivateFlags &= ~PFLAG_INVALIDATED;
            child.getDisplayList();
            child.mRecreateDisplayList = false;
        }
    }
    if (mOverlay != null) {
        View overlayView = mOverlay.getOverlayView();
        overlayView.mRecreateDisplayList = (overlayView.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        overlayView.mPrivateFlags &= ~PFLAG_INVALIDATED;
        overlayView.getDisplayList();
        overlayView.mRecreateDisplayList = false;
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) && child.hasStaticLayer()) {
            recreateChildDisplayList(child);
        }
    }
    if (mOverlay != null) {
        View overlayView = mOverlay.getOverlayView();
        recreateChildDisplayList(overlayView);
    }
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size();
        for (int i = 0; i < disappearingCount; ++i) {
            final View child = disappearingChildren.get(i);
            recreateChildDisplayList(child);
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.InputStage.onDeliverToNext:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when an event is being delivered to the next stage.
 */

Body of Frist Method:
{
    if (mNext != null) {
        mNext.deliver(q);
    } else {
        finishInputEvent(q);
    }
}
Body of Second Method:
{
    if (DEBUG_INPUT_STAGES) {
        Log.v(TAG, "Done with " + getClass().getSimpleName() + ". " + q);
    }
    if (mNext != null) {
        mNext.deliver(q);
    } else {
        finishInputEvent(q);
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.makeNodeId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Makes a node id by shifting the <code>virtualDescendantId</code>
 * by {@link #VIRTUAL_DESCENDANT_ID_SHIFT} and taking
 * the bitwise or with the <code>accessibilityViewId</code>.
 *
 * @param accessibilityViewId A View accessibility id.
 * @param virtualDescendantId A virtual descendant id.
 * @return The node id.
 *
 * @hide
 */

Body of Frist Method:
{
    return (((long) virtualDescendantId) << VIRTUAL_DESCENDANT_ID_SHIFT) | accessibilityViewId;
}
Body of Second Method:
{
    // remap it here.
    if (virtualDescendantId == AccessibilityNodeProvider.HOST_VIEW_ID) {
        virtualDescendantId = UNDEFINED_ITEM_ID;
    }
    return (((long) virtualDescendantId) << VIRTUAL_DESCENDANT_ID_SHIFT) | accessibilityViewId;
}
------------------------
Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.uploadFile:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a test file to upload. The stats reported to instrumentation out
 * only include upload stats.
 */

Body of Frist Method:
{
    // Download a file from the server.
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(BandwidthTestUtil.DownloadFromUrl(targetUrl, tmpSaveFile));
    ts = Long.toString(System.currentTimeMillis());
    NetworkStats pre_test_stats = fetchDataFromProc(mUid);
    TrafficStats.startDataProfiling(mContext);
    assertTrue(BandwidthTestUtil.postFileToServer(mTestServer, mDeviceId, ts, tmpSaveFile));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    Log.d(LOG_TAG, prof_stats.toString());
    NetworkStats post_test_stats = fetchDataFromProc(mUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    AddStatsToResults(PROF_LABEL, prof_stats, results);
    AddStatsToResults(PROC_LABEL, proc_stats, results);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
Body of Second Method:
{
    // Download a file from the server.
    String ts = Long.toString(System.currentTimeMillis());
    String targetUrl = BandwidthTestUtil.buildDownloadUrl(mTestServer, FILE_SIZE, mDeviceId, ts);
    File tmpSaveFile = new File(BASE_DIR + File.separator + TMP_FILENAME);
    assertTrue(BandwidthTestUtil.DownloadFromUrl(targetUrl, tmpSaveFile));
    ts = Long.toString(System.currentTimeMillis());
    NetworkStats pre_test_stats = fetchDataFromProc(mUid);
    TrafficStats.startDataProfiling(mContext);
    assertTrue(BandwidthTestUtil.postFileToServer(mTestServer, mDeviceId, ts, tmpSaveFile));
    NetworkStats prof_stats = TrafficStats.stopDataProfiling(mContext);
    Log.d(LOG_TAG, prof_stats.toString());
    NetworkStats post_test_stats = fetchDataFromProc(mUid);
    NetworkStats proc_stats = post_test_stats.subtract(pre_test_stats);
    // Output measurements to instrumentation out, so that it can be compared to that of
    // the server.
    Bundle results = new Bundle();
    results.putString("device_id", mDeviceId);
    results.putString("timestamp", ts);
    results.putInt("size", FILE_SIZE);
    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
    addStatsToResults(PROC_LABEL, proc_stats, results, mUid);
    getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
    // Clean up.
    assertTrue(cleanUpFile(tmpSaveFile));
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setUseLevel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets whether or not this drawable will honor its <code>level</code>
 * property.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param useLevel True if this drawable should honor its level, false otherwise
 *
 * @see #mutate()
 * @see #setLevel(int)
 * @see #getLevel()
 */

Body of Frist Method:
{
    mGradientState.mUseLevel = useLevel;
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.mUseLevel = useLevel;
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.getHeight:COMMENT
<android.graphics.Canvas: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the height of the current drawing layer
 *
 * @return the height of the current drawing layer
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getHeight(mNativeCanvasWrapper);
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.postSkew:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified skew.
 * M' = K(kx, ky) * M
 */

Body of Frist Method:
{
    return native_postSkew(native_instance, kx, ky);
}
Body of Second Method:
{
    native_postSkew(native_instance, kx, ky);
    return true;
}
------------------------
Find a functionally equivalent code:android.text.TextUtils.obtain:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = new char[ArrayUtils.idealCharArraySize(len)];
    return buf;
}
Body of Second Method:
{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = ArrayUtils.newUnpaddedCharArray(len);
    return buf;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleUnlock:COMMENT
Method Modifier: 
Comment:/**
 * Stops the Face Unlock service and tells the device to grant access to the user.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "handleUnlock()");
    stop();
    int currentUserId = mLockPatternUtils.getCurrentUser();
    if (authenticatedUserId == currentUserId) {
        if (DEBUG)
            Log.d(TAG, "Unlocking for user " + authenticatedUserId);
        mKeyguardScreenCallback.reportSuccessfulUnlockAttempt();
        mKeyguardScreenCallback.dismiss(true);
    } else {
        Log.d(TAG, "Ignoring unlock for authenticated user (" + authenticatedUserId + ") because the current user is " + currentUserId);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "handleUnlock()");
    stop();
    int currentUserId = mLockPatternUtils.getCurrentUser();
    if (authenticatedUserId == currentUserId) {
        if (DEBUG)
            Log.d(TAG, "Unlocking for user " + authenticatedUserId);
        mKeyguardScreenCallback.reportUnlockAttempt(true);
        mKeyguardScreenCallback.dismiss(true);
    } else {
        Log.d(TAG, "Ignoring unlock for authenticated user (" + authenticatedUserId + ") because the current user is " + currentUserId);
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (DBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getGlobalWifiRunningTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that wifi has been on and the driver has
 * been in the running state while the device was running on battery.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.Main.processArgs:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns true if args where properly parsed.
 * Returns false if program should exit with command-line usage.
 * <p/>
 * Note: the String[0] is an output parameter wrapped in an array, since there is no
 * "out" parameter support.
 */

Body of Frist Method:
{
    boolean needs_dest = true;
    for (int i = 0; i < args.length; i++) {
        String s = args[i];
        if (s.equals("-v")) {
            log.setVerbose(true);
        } else if (s.equals("-p")) {
            sOptions.generatePublicAccess = false;
        } else if (s.equals("--list-deps")) {
            sOptions.listAllDeps = true;
            needs_dest = false;
        } else if (s.equals("--missing-deps")) {
            sOptions.listOnlyMissingDeps = true;
            needs_dest = false;
        } else if (!s.startsWith("-")) {
            if (needs_dest && osDestJar[0] == null) {
                osDestJar[0] = s;
            } else {
                osJarPath.add(s);
            }
        } else {
            log.error("Unknow argument: %s", s);
            return false;
        }
    }
    if (osJarPath.isEmpty()) {
        log.error("Missing parameter: path to input jar");
        return false;
    }
    if (needs_dest && osDestJar[0] == null) {
        log.error("Missing parameter: path to output jar");
        return false;
    }
    sOptions.generatePublicAccess = false;
    return true;
}
Body of Second Method:
{
    boolean needs_dest = true;
    for (String s : args) {
        if (s.equals("-v")) {
            log.setVerbose(true);
        } else if (s.equals("--list-deps")) {
            sOptions.listAllDeps = true;
            needs_dest = false;
        } else if (s.equals("--missing-deps")) {
            sOptions.listOnlyMissingDeps = true;
            needs_dest = false;
        } else if (!s.startsWith("-")) {
            if (needs_dest && osDestJar[0] == null) {
                osDestJar[0] = s;
            } else {
                osJarPath.add(s);
            }
        } else {
            log.error("Unknown argument: %s", s);
            return false;
        }
    }
    if (osJarPath.isEmpty()) {
        log.error("Missing parameter: path to input jar");
        return false;
    }
    if (needs_dest && osDestJar[0] == null) {
        log.error("Missing parameter: path to output jar");
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the startDelay for the underlying animator that animates the requested properties.
 * By default, the animator uses the default value for ValueAnimator. Calling this method
 * will cause the declared value to be used instead.
 * @param startDelay The delay of ensuing property animations, in milliseconds. The value
 * cannot be negative.
 * @return This object, allowing calls to methods in this class to be chained.
 */

Body of Frist Method:
{
    if (startDelay < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}
Body of Second Method:
{
    if (startDelay < 0) {
        throw new IllegalArgumentException("Animators cannot have negative start " + "delay: " + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}
------------------------
Find a functionally equivalent code:android.printservice.PrintJob.getAdvancedStringOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return null;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedStringOption(key);
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisIntArrayXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read an int[] object from an XmlPullParser.  The XML data could
 * previously have been generated by writeIntArrayXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the list.
 *
 * @param parser The XmlPullParser from which to read the list data.
 * @param endTag Name of the tag that will end the list, usually "list".
 * @param name An array of one string, used to return the name attribute
 * of the list's tag.
 *
 * @return Returns a newly generated int[].
 *
 * @see #readListXml
 */

Body of Frist Method:
{
    int num;
    try {
        num = Integer.parseInt(parser.getAttributeValue(null, "num"));
    } catch (NullPointerException e) {
        throw new XmlPullParserException("Need num attribute in byte-array");
    } catch (NumberFormatException e) {
        throw new XmlPullParserException("Not a number in num attribute in byte-array");
    }
    int[] array = new int[num];
    int i = 0;
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            if (parser.getName().equals("item")) {
                try {
                    array[i] = Integer.parseInt(parser.getAttributeValue(null, "value"));
                } catch (NullPointerException e) {
                    throw new XmlPullParserException("Need value attribute in item");
                } catch (NumberFormatException e) {
                    throw new XmlPullParserException("Not a number in value attribute in item");
                }
            } else {
                throw new XmlPullParserException("Expected item tag at: " + parser.getName());
            }
        } else if (eventType == parser.END_TAG) {
            if (parser.getName().equals(endTag)) {
                return array;
            } else if (parser.getName().equals("item")) {
                i++;
            } else {
                throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
            }
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
}
Body of Second Method:
{
    int num;
    try {
        num = Integer.parseInt(parser.getAttributeValue(null, "num"));
    } catch (NullPointerException e) {
        throw new XmlPullParserException("Need num attribute in byte-array");
    } catch (NumberFormatException e) {
        throw new XmlPullParserException("Not a number in num attribute in byte-array");
    }
    parser.next();
    int[] array = new int[num];
    int i = 0;
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            if (parser.getName().equals("item")) {
                try {
                    array[i] = Integer.parseInt(parser.getAttributeValue(null, "value"));
                } catch (NullPointerException e) {
                    throw new XmlPullParserException("Need value attribute in item");
                } catch (NumberFormatException e) {
                    throw new XmlPullParserException("Not a number in value attribute in item");
                }
            } else {
                throw new XmlPullParserException("Expected item tag at: " + parser.getName());
            }
        } else if (eventType == parser.END_TAG) {
            if (parser.getName().equals(endTag)) {
                return array;
            } else if (parser.getName().equals("item")) {
                i++;
            } else {
                throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
            }
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
}
------------------------
Find a functionally equivalent code:android.media.AudioService.adjustSuggestedStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#adjustVolume(int, int)
 */

Body of Frist Method:
{
    if (DEBUG_VOL)
        Log.d(TAG, "adjustSuggestedStreamVolume() stream=" + suggestedStreamType);
    int streamType;
    if (mVolumeControlStream != -1) {
        streamType = mVolumeControlStream;
    } else {
        streamType = getActiveStreamType(suggestedStreamType);
    }
    // Play sounds on STREAM_RING only and if lock screen is not on.
    if ((streamType != STREAM_REMOTE_MUSIC) && (flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ((mStreamVolumeAlias[streamType] != AudioSystem.STREAM_RING) || (mKeyguardManager != null && mKeyguardManager.isKeyguardLocked()))) {
        flags &= ~AudioManager.FLAG_PLAY_SOUND;
    }
    if (streamType == STREAM_REMOTE_MUSIC) {
        // don't play sounds for remote
        flags &= ~(AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_FIXED_VOLUME);
        // if (DEBUG_VOL) Log.i(TAG, "Need to adjust remote volume: calling adjustRemoteVolume()");
        mMediaFocusControl.adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, flags);
    } else {
        adjustStreamVolume(streamType, direction, flags, callingPackage);
    }
}
Body of Second Method:
{
    adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiConfiguration.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * indicates whether the configuration is valid
 * @return true if valid, false otherwise
 * @hide
 */

Body of Frist Method:
{
    if (allowedKeyManagement.cardinality() > 1) {
        if (allowedKeyManagement.cardinality() != 2) {
            return false;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) == false) {
            return false;
        }
        if ((allowedKeyManagement.get(KeyMgmt.IEEE8021X) == false) && (allowedKeyManagement.get(KeyMgmt.WPA_PSK) == false)) {
            return false;
        }
    }
    // TODO: Add more checks
    return true;
}
Body of Second Method:
{
    if (allowedKeyManagement == null)
        return false;
    if (allowedKeyManagement.cardinality() > 1) {
        if (allowedKeyManagement.cardinality() != 2) {
            return false;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) == false) {
            return false;
        }
        if ((allowedKeyManagement.get(KeyMgmt.IEEE8021X) == false) && (allowedKeyManagement.get(KeyMgmt.WPA_PSK) == false)) {
            return false;
        }
    }
    // TODO: Add more checks
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a char array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharArray(key, value);
}
------------------------
Find a functionally equivalent code:android.text.format.Time.setToNow:COMMENT
<android.text.format.Time: void setToNow()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the time of the given Time object to the current time.
 */

Body of Frist Method:

Body of Second Method:
{
    set(System.currentTimeMillis());
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.TrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    dest.writeInt(mTrackType);
    dest.writeString(getLanguage());
    if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));
    }
}
Body of Second Method:
{
    dest.writeInt(mTrackType);
    dest.writeString(getLanguage());
    if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
        dest.writeString(mFormat.getString(MediaFormat.KEY_MIME));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.connect:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    if (!registerApp(callback)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // the connection will continue after successful callback registration
    mAutoConnect = autoConnect;
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    if (!registerApp(callback)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // the connection will continue after successful callback registration
    mAutoConnect = autoConnect;
    return true;
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.seekTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * This is needed for implementing AssetFileDescriptor.AutoCloseOutputStream,
 * and I really don't think we want it to be public.
 * @hide
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.seekTo(pos);
    } else {
        try {
            return Libcore.os.lseek(mFd, pos, SEEK_SET);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.seekTo(pos);
    } else {
        try {
            return Os.lseek(mFd, pos, SEEK_SET);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
    }
}
------------------------
Find a functionally equivalent code:android.text.format.DateFormat.getBestDateTimePattern:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href="http://www.unicode.org/reports/tr35/#Date_Format_Patterns">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, "MMMMd" will return
 * "MMMM d" in the {@code en_US} locale, but "d. MMMM" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * "d 'de' MMMM".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same "MMMMd" input, this method will return "d LLLL" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so "Md" would give a different result to "MMMd", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */

Body of Frist Method:
{
    return ICU.getBestDateTimePattern(skeleton, locale.toString());
}
Body of Second Method:
{
    return ICU.getBestDateTimePattern(skeleton, locale);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.readCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (DBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.reinit:COMMENT
Method Modifier: 
Comment:/**
 * Native bitmap has been reconfigured, so set premult and cached
 * width/height values
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
    mIsPremultiplied = isPremultiplied;
}
Body of Second Method:
{
    mWidth = width;
    mHeight = height;
    mRequestPremultiplied = requestPremultiplied;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.indexOfKey:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */

Body of Frist Method:
{
    if (mGarbage) {
        gc();
    }
    return binarySearch(mKeys, 0, mSize, key);
}
Body of Second Method:
{
    if (mGarbage) {
        gc();
    }
    return binarySearch(mKeys, 0, mSize, key);
}
------------------------
Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Fast path that avoids the use of chatty remoted Cursors.
 */

Body of Frist Method:
{
    int callingUser = UserHandle.getCallingUserId();
    if (args != null) {
        int reqUser = args.getInt(Settings.CALL_METHOD_USER_KEY, callingUser);
        if (reqUser != callingUser) {
            callingUser = ActivityManager.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), reqUser, false, true, "get/set setting for user", null);
            if (LOCAL_LOGV)
                Slog.v(TAG, "   access setting for user " + callingUser);
        }
    }
    // Note: we assume that get/put operations for moved-to-global names have already
    // been directed to the new location on the caller side (otherwise we'd fix them
    // up here).
    DatabaseHelper dbHelper;
    SettingsCache cache;
    // Get methods
    if (Settings.CALL_METHOD_GET_SYSTEM.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(system:" + request + ") for " + callingUser);
        dbHelper = getOrEstablishDatabase(callingUser);
        cache = sSystemCaches.get(callingUser);
        return lookupValue(dbHelper, TABLE_SYSTEM, cache, request);
    }
    if (Settings.CALL_METHOD_GET_SECURE.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(secure:" + request + ") for " + callingUser);
        dbHelper = getOrEstablishDatabase(callingUser);
        cache = sSecureCaches.get(callingUser);
        return lookupValue(dbHelper, TABLE_SECURE, cache, request);
    }
    if (Settings.CALL_METHOD_GET_GLOBAL.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(global:" + request + ") for " + callingUser);
        // guard on the attempt to look them up
        return lookupValue(getOrEstablishDatabase(UserHandle.USER_OWNER), TABLE_GLOBAL, sGlobalCache, request);
    }
    // Put methods - new value is in the args bundle under the key named by
    // the Settings.NameValueTable.VALUE static.
    final String newValue = (args == null) ? null : args.getString(Settings.NameValueTable.VALUE);
    // to do it here.
    if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.WRITE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(String.format("Permission denial: writing to settings requires %1$s", android.Manifest.permission.WRITE_SETTINGS));
    }
    // Also need to take care of app op.
    if (getAppOpsManager().noteOp(AppOpsManager.OP_WRITE_SETTINGS, Binder.getCallingUid(), getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    final ContentValues values = new ContentValues();
    values.put(Settings.NameValueTable.NAME, request);
    values.put(Settings.NameValueTable.VALUE, newValue);
    if (Settings.CALL_METHOD_PUT_SYSTEM.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call_put(system:" + request + "=" + newValue + ") for " + callingUser);
        insertForUser(Settings.System.CONTENT_URI, values, callingUser);
    } else if (Settings.CALL_METHOD_PUT_SECURE.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call_put(secure:" + request + "=" + newValue + ") for " + callingUser);
        insertForUser(Settings.Secure.CONTENT_URI, values, callingUser);
    } else if (Settings.CALL_METHOD_PUT_GLOBAL.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call_put(global:" + request + "=" + newValue + ") for " + callingUser);
        insertForUser(Settings.Global.CONTENT_URI, values, callingUser);
    } else {
        Slog.w(TAG, "call() with invalid method: " + method);
    }
    return null;
}
Body of Second Method:
{
    int callingUser = UserHandle.getCallingUserId();
    if (args != null) {
        int reqUser = args.getInt(Settings.CALL_METHOD_USER_KEY, callingUser);
        if (reqUser != callingUser) {
            callingUser = ActivityManager.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), reqUser, false, true, "get/set setting for user", null);
            if (LOCAL_LOGV)
                Slog.v(TAG, "   access setting for user " + callingUser);
        }
    }
    // Note: we assume that get/put operations for moved-to-global names have already
    // been directed to the new location on the caller side (otherwise we'd fix them
    // up here).
    DatabaseHelper dbHelper;
    SettingsCache cache;
    // Get methods
    if (Settings.CALL_METHOD_GET_SYSTEM.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(system:" + request + ") for " + callingUser);
        // Check if this request should be (re)directed to the primary user's db
        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSystemCloneToManagedKeys, request)) {
            callingUser = UserHandle.USER_OWNER;
        }
        dbHelper = getOrEstablishDatabase(callingUser);
        cache = sSystemCaches.get(callingUser);
        return lookupValue(dbHelper, TABLE_SYSTEM, cache, request);
    }
    if (Settings.CALL_METHOD_GET_SECURE.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(secure:" + request + ") for " + callingUser);
        // Check if this is a setting to be copied from the primary user
        if (shouldShadowParentProfile(callingUser, sSecureCloneToManagedKeys, request)) {
            // If the request if for location providers and there's a restriction, return none
            if (Secure.LOCATION_PROVIDERS_ALLOWED.equals(request) && mUserManager.hasUserRestriction(UserManager.DISALLOW_SHARE_LOCATION, new UserHandle(callingUser))) {
                return sSecureCaches.get(callingUser).putIfAbsent(request, "");
            }
            callingUser = UserHandle.USER_OWNER;
        }
        dbHelper = getOrEstablishDatabase(callingUser);
        cache = sSecureCaches.get(callingUser);
        return lookupValue(dbHelper, TABLE_SECURE, cache, request);
    }
    if (Settings.CALL_METHOD_GET_GLOBAL.equals(method)) {
        if (LOCAL_LOGV)
            Slog.v(TAG, "call(global:" + request + ") for " + callingUser);
        // guard on the attempt to look them up
        return lookupValue(getOrEstablishDatabase(UserHandle.USER_OWNER), TABLE_GLOBAL, sGlobalCache, request);
    }
    // Put methods - new value is in the args bundle under the key named by
    // the Settings.NameValueTable.VALUE static.
    final String newValue = (args == null) ? null : args.getString(Settings.NameValueTable.VALUE);
    // to do it here.
    if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.WRITE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(String.format("Permission denial: writing to settings requires %1$s", android.Manifest.permission.WRITE_SETTINGS));
    }
    // Also need to take care of app op.
    if (getAppOpsManager().noteOp(AppOpsManager.OP_WRITE_SETTINGS, Binder.getCallingUid(), getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {
        return null;
    }
    final ContentValues values = new ContentValues();
    values.put(Settings.NameValueTable.NAME, request);
    values.put(Settings.NameValueTable.VALUE, newValue);
    if (Settings.CALL_METHOD_PUT_SYSTEM.equals(method)) {
        if (LOCAL_LOGV) {
            Slog.v(TAG, "call_put(system:" + request + "=" + newValue + ") for " + callingUser);
        }
        // Extra check for USER_OWNER to optimize for the 99%
        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSystemCloneToManagedKeys, request)) {
            // Don't write these settings, as they are cloned from the parent profile
            return null;
        }
        insertForUser(Settings.System.CONTENT_URI, values, callingUser);
        // Clone the settings to the managed profiles so that notifications can be sent out
        if (callingUser == UserHandle.USER_OWNER && mManagedProfiles != null && sSystemCloneToManagedKeys.contains(request)) {
            final long token = Binder.clearCallingIdentity();
            try {
                for (int i = mManagedProfiles.size() - 1; i >= 0; i--) {
                    if (LOCAL_LOGV) {
                        Slog.v(TAG, "putting to additional user " + mManagedProfiles.get(i).id);
                    }
                    insertForUser(Settings.System.CONTENT_URI, values, mManagedProfiles.get(i).id);
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    } else if (Settings.CALL_METHOD_PUT_SECURE.equals(method)) {
        if (LOCAL_LOGV) {
            Slog.v(TAG, "call_put(secure:" + request + "=" + newValue + ") for " + callingUser);
        }
        // Extra check for USER_OWNER to optimize for the 99%
        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSecureCloneToManagedKeys, request)) {
            // Don't write these settings, as they are cloned from the parent profile
            return null;
        }
        insertForUser(Settings.Secure.CONTENT_URI, values, callingUser);
        // Clone the settings to the managed profiles so that notifications can be sent out
        if (callingUser == UserHandle.USER_OWNER && mManagedProfiles != null && sSecureCloneToManagedKeys.contains(request)) {
            final long token = Binder.clearCallingIdentity();
            try {
                for (int i = mManagedProfiles.size() - 1; i >= 0; i--) {
                    if (LOCAL_LOGV) {
                        Slog.v(TAG, "putting to additional user " + mManagedProfiles.get(i).id);
                    }
                    try {
                        insertForUser(Settings.Secure.CONTENT_URI, values, mManagedProfiles.get(i).id);
                    } catch (SecurityException e) {
                        // Temporary fix, see b/17450158
                        Slog.w(TAG, "Cannot clone request '" + request + "' with value '" + newValue + "' to managed profile (id " + mManagedProfiles.get(i).id + ")", e);
                    }
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    } else if (Settings.CALL_METHOD_PUT_GLOBAL.equals(method)) {
        if (LOCAL_LOGV) {
            Slog.v(TAG, "call_put(global:" + request + "=" + newValue + ") for " + callingUser);
        }
        insertForUser(Settings.Global.CONTENT_URI, values, callingUser);
    } else {
        Slog.w(TAG, "call() with invalid method: " + method);
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.text.DynamicLayout.updateBlocks:COMMENT
Method Modifier: hidden      
Comment:/**
 * This method is called every time the layout is reflowed after an edition.
 * It updates the internal block data structure. The text is split in blocks
 * of contiguous lines, with at least one block for the entire text.
 * When a range of lines is edited, new blocks (from 0 to 3 depending on the
 * overlap structure) will replace the set of overlapping blocks.
 * Blocks are listed in order and are represented by their ending line number.
 * An index is associated to each block (which will be used by display lists),
 * this class simply invalidates the index of blocks overlapping a modification.
 *
 * This method is package private and not private so that it can be tested.
 *
 * @param startLine the first line of the range of modified lines
 * @param endLine the last line of the range, possibly equal to startLine, lower
 * than getLineCount()
 * @param newLineCount the number of lines that will replace the range, possibly 0
 *
 * @hide
 */

Body of Frist Method:
{
    if (mBlockEndLines == null) {
        createBlocks();
        return;
    }
    int firstBlock = -1;
    int lastBlock = -1;
    for (int i = 0; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= startLine) {
            firstBlock = i;
            break;
        }
    }
    for (int i = firstBlock; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= endLine) {
            lastBlock = i;
            break;
        }
    }
    final int lastBlockEndLine = mBlockEndLines[lastBlock];
    boolean createBlockBefore = startLine > (firstBlock == 0 ? 0 : mBlockEndLines[firstBlock - 1] + 1);
    boolean createBlock = newLineCount > 0;
    boolean createBlockAfter = endLine < mBlockEndLines[lastBlock];
    int numAddedBlocks = 0;
    if (createBlockBefore)
        numAddedBlocks++;
    if (createBlock)
        numAddedBlocks++;
    if (createBlockAfter)
        numAddedBlocks++;
    final int numRemovedBlocks = lastBlock - firstBlock + 1;
    final int newNumberOfBlocks = mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
    if (newNumberOfBlocks == 0) {
        // Even when text is empty, there is actually one line and hence one block
        mBlockEndLines[0] = 0;
        mBlockIndices[0] = INVALID_BLOCK_INDEX;
        mNumberOfBlocks = 1;
        return;
    }
    if (newNumberOfBlocks > mBlockEndLines.length) {
        final int newSize = ArrayUtils.idealIntArraySize(newNumberOfBlocks);
        int[] blockEndLines = new int[newSize];
        int[] blockIndices = new int[newSize];
        System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, firstBlock);
        System.arraycopy(mBlockIndices, 0, blockIndices, 0, firstBlock);
        System.arraycopy(mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        mBlockEndLines = blockEndLines;
        mBlockIndices = blockIndices;
    } else {
        System.arraycopy(mBlockEndLines, lastBlock + 1, mBlockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, mBlockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
    }
    mNumberOfBlocks = newNumberOfBlocks;
    int newFirstChangedBlock;
    final int deltaLines = newLineCount - (endLine - startLine + 1);
    if (deltaLines != 0) {
        // Display list whose index is >= mIndexFirstChangedBlock is valid
        // but it needs to update its drawing location.
        newFirstChangedBlock = firstBlock + numAddedBlocks;
        for (int i = newFirstChangedBlock; i < mNumberOfBlocks; i++) {
            mBlockEndLines[i] += deltaLines;
        }
    } else {
        newFirstChangedBlock = mNumberOfBlocks;
    }
    mIndexFirstChangedBlock = Math.min(mIndexFirstChangedBlock, newFirstChangedBlock);
    int blockIndex = firstBlock;
    if (createBlockBefore) {
        mBlockEndLines[blockIndex] = startLine - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlock) {
        mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlockAfter) {
        mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
    }
}
Body of Second Method:
{
    if (mBlockEndLines == null) {
        createBlocks();
        return;
    }
    int firstBlock = -1;
    int lastBlock = -1;
    for (int i = 0; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= startLine) {
            firstBlock = i;
            break;
        }
    }
    for (int i = firstBlock; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= endLine) {
            lastBlock = i;
            break;
        }
    }
    final int lastBlockEndLine = mBlockEndLines[lastBlock];
    boolean createBlockBefore = startLine > (firstBlock == 0 ? 0 : mBlockEndLines[firstBlock - 1] + 1);
    boolean createBlock = newLineCount > 0;
    boolean createBlockAfter = endLine < mBlockEndLines[lastBlock];
    int numAddedBlocks = 0;
    if (createBlockBefore)
        numAddedBlocks++;
    if (createBlock)
        numAddedBlocks++;
    if (createBlockAfter)
        numAddedBlocks++;
    final int numRemovedBlocks = lastBlock - firstBlock + 1;
    final int newNumberOfBlocks = mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
    if (newNumberOfBlocks == 0) {
        // Even when text is empty, there is actually one line and hence one block
        mBlockEndLines[0] = 0;
        mBlockIndices[0] = INVALID_BLOCK_INDEX;
        mNumberOfBlocks = 1;
        return;
    }
    if (newNumberOfBlocks > mBlockEndLines.length) {
        int[] blockEndLines = ArrayUtils.newUnpaddedIntArray(Math.max(mBlockEndLines.length * 2, newNumberOfBlocks));
        int[] blockIndices = new int[blockEndLines.length];
        System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, firstBlock);
        System.arraycopy(mBlockIndices, 0, blockIndices, 0, firstBlock);
        System.arraycopy(mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        mBlockEndLines = blockEndLines;
        mBlockIndices = blockIndices;
    } else {
        System.arraycopy(mBlockEndLines, lastBlock + 1, mBlockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, mBlockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
    }
    mNumberOfBlocks = newNumberOfBlocks;
    int newFirstChangedBlock;
    final int deltaLines = newLineCount - (endLine - startLine + 1);
    if (deltaLines != 0) {
        // Display list whose index is >= mIndexFirstChangedBlock is valid
        // but it needs to update its drawing location.
        newFirstChangedBlock = firstBlock + numAddedBlocks;
        for (int i = newFirstChangedBlock; i < mNumberOfBlocks; i++) {
            mBlockEndLines[i] += deltaLines;
        }
    } else {
        newFirstChangedBlock = mNumberOfBlocks;
    }
    mIndexFirstChangedBlock = Math.min(mIndexFirstChangedBlock, newFirstChangedBlock);
    int blockIndex = firstBlock;
    if (createBlockBefore) {
        mBlockEndLines[blockIndex] = startLine - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlock) {
        mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlockAfter) {
        mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.addMenuPresenter:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Add a presenter to this menu. This will only hold a WeakReference;
 * you do not need to explicitly remove a presenter, but you can using
 * {@link #removeMenuPresenter(MenuPresenter)}.
 *
 * @param presenter The presenter to add
 */

Body of Frist Method:
{
    mPresenters.add(new WeakReference<MenuPresenter>(presenter));
    presenter.initForMenu(mContext, this);
    mIsActionItemsStale = true;
}
Body of Second Method:
{
    addMenuPresenter(presenter, mContext);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the week numbers.
 *
 * @param color The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

Body of Frist Method:
{
    if (mWeekNumberColor != color) {
        mWeekNumberColor = color;
        if (mShowWeekNumber) {
            invalidateAllWeekViews();
        }
    }
}
Body of Second Method:
{
    mDelegate.setWeekNumberColor(color);
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.selectSystemTheme:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (curTheme != 0) {
        return curTheme;
    }
    if (targetSdkVersion < Build.VERSION_CODES.HONEYCOMB) {
        return orig;
    }
    if (targetSdkVersion < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        return holo;
    }
    return deviceDefault;
}
Body of Second Method:
{
    if (curTheme != 0) {
        return curTheme;
    }
    if (targetSdkVersion < Build.VERSION_CODES.HONEYCOMB) {
        return orig;
    }
    if (targetSdkVersion < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        return holo;
    }
    if (targetSdkVersion < Build.VERSION_CODES.CUR_DEVELOPMENT) {
        return dark;
    }
    return deviceDefault;
}
------------------------
Find a functionally equivalent code:android.app.Notification.setLatestEventInfo:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the {@link #contentView} field to be a view with the standard "Latest Event"
 * layout.
 *
 * <p>Uses the {@link #icon} and {@link #when} fields to set the icon and time fields
 * in the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.
 * If this is an activity, it must include the
 * {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requires
 * that you take care of task management as described in the
 * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
 * Stack</a> document.
 *
 * @deprecated Use {@link Builder} instead.
 */

Body of Frist Method:
{
    Notification.Builder builder = new Notification.Builder(context);
    // First, ensure that key pieces of information that may have been set directly
    // are preserved
    builder.setWhen(this.when);
    builder.setSmallIcon(this.icon);
    builder.setPriority(this.priority);
    builder.setTicker(this.tickerText);
    builder.setNumber(this.number);
    builder.mFlags = this.flags;
    builder.setSound(this.sound, this.audioStreamType);
    builder.setDefaults(this.defaults);
    builder.setVibrate(this.vibrate);
    // now apply the latestEventInfo fields
    if (contentTitle != null) {
        builder.setContentTitle(contentTitle);
    }
    if (contentText != null) {
        builder.setContentText(contentText);
    }
    builder.setContentIntent(contentIntent);
    builder.buildInto(this);
}
Body of Second Method:
{
    Notification.Builder builder = new Notification.Builder(context);
    // First, ensure that key pieces of information that may have been set directly
    // are preserved
    builder.setWhen(this.when);
    builder.setSmallIcon(this.icon);
    builder.setPriority(this.priority);
    builder.setTicker(this.tickerText);
    builder.setNumber(this.number);
    builder.setColor(this.color);
    builder.mFlags = this.flags;
    builder.setSound(this.sound, this.audioStreamType);
    builder.setDefaults(this.defaults);
    builder.setVibrate(this.vibrate);
    // now apply the latestEventInfo fields
    if (contentTitle != null) {
        builder.setContentTitle(contentTitle);
    }
    if (contentText != null) {
        builder.setContentText(contentText);
    }
    builder.setContentIntent(contentIntent);
    builder.buildInto(this);
}
------------------------
Find a functionally equivalent code:android.app.Activity.onPanelClosed:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPanelClosed(int, Menu)} for
 * activities. This calls through to {@link #onOptionsMenuClosed(Menu)}
 * method for the {@link android.view.Window#FEATURE_OPTIONS_PANEL} panel,
 * so that subclasses of Activity don't need to deal with feature codes.
 * For context menus ({@link Window#FEATURE_CONTEXT_MENU}), the
 * {@link #onContextMenuClosed(Menu)} will be called.
 */

Body of Frist Method:
{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            mFragments.dispatchOptionsMenuClosed(menu);
            onOptionsMenuClosed(menu);
            break;
        case Window.FEATURE_CONTEXT_MENU:
            onContextMenuClosed(menu);
            break;
        case Window.FEATURE_ACTION_BAR:
            initActionBar();
            mActionBar.dispatchMenuVisibilityChanged(false);
            break;
    }
}
Body of Second Method:
{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            mFragments.dispatchOptionsMenuClosed(menu);
            onOptionsMenuClosed(menu);
            break;
        case Window.FEATURE_CONTEXT_MENU:
            onContextMenuClosed(menu);
            break;
        case Window.FEATURE_ACTION_BAR:
            initWindowDecorActionBar();
            mActionBar.dispatchMenuVisibilityChanged(false);
            break;
    }
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarCompile:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.Camera.applyToCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Computes the matrix corresponding to the current transformation
 * and applies it to the specified Canvas.
 *
 * @param canvas The Canvas to set the transform matrix onto
 */

Body of Frist Method:
{
    if (canvas.isHardwareAccelerated()) {
        if (mMatrix == null)
            mMatrix = new Matrix();
        getMatrix(mMatrix);
        canvas.concat(mMatrix);
    } else {
        nativeApplyToCanvas(canvas.mNativeCanvas);
    }
}
Body of Second Method:
{
    if (canvas.isHardwareAccelerated()) {
        if (mMatrix == null)
            mMatrix = new Matrix();
        getMatrix(mMatrix);
        canvas.concat(mMatrix);
    } else {
        nativeApplyToCanvas(canvas.getNativeCanvasWrapper());
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientType:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the type of gradient used by this drawable..</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradient The type of the gradient: {@link #LINEAR_GRADIENT},
 * {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}
 *
 * @see #mutate()
 */

Body of Frist Method:
{
    mGradientState.setGradientType(gradient);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientType(gradient);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.widget.ImageView.setImageResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class="note">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */

Body of Frist Method:
{
    if (mUri != null || mResource != resId) {
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
Body of Second Method:
{
    if (mUri != null || mResource != resId) {
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmGenerator.transform:COMMENT
Method Modifier: 
Comment:/**
 * Transforms a class.
 * <p/>
 * There are 3 kind of transformations:
 *
 * 1- For "mock" dependencies classes, we want to remove all code from methods and replace
 * by a stub. Native methods must be implemented with this stub too. Abstract methods are
 * left intact. Modified classes must be overridable (non-private, non-final).
 * Native methods must be made non-final, non-private.
 *
 * 2- For "keep" classes, we want to rewrite all native methods as indicated above.
 * If a class has native methods, it must also be made non-private, non-final.
 *
 * Note that unfortunately static methods cannot be changed to non-static (since static and
 * non-static are invoked differently.)
 */

Body of Frist Method:
{
    boolean hasNativeMethods = hasNativeMethods(cr);
    // Get the class name, as an internal name (e.g. com/android/SomeClass$InnerClass)
    String className = cr.getClassName();
    String newName = transformName(className);
    // transformName returns its input argument if there's no need to rename the class
    if (newName != className) {
        mRenameCount++;
        // This class is being renamed, so remove it from the list of classes not renamed.
        mClassesNotRenamed.remove(className);
    }
    mLog.debug("Transform %s%s%s%s", className, newName == className ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
    // Rewrite the new class from scratch, without reusing the constant pool from the
    // original class reader.
    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
    ClassVisitor cv = new RefactorClassAdapter(cw, mRefactorClasses);
    if (newName != className) {
        cv = new RenameClassAdapter(cv, className, newName);
    }
    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly, stubNativesOnly || hasNativeMethods);
    Set<String> delegateMethods = mDelegateMethods.get(className);
    if (delegateMethods != null && !delegateMethods.isEmpty()) {
        // known to have no native methods, just skip this step.
        if (hasNativeMethods || !(delegateMethods.size() == 1 && delegateMethods.contains(DelegateClassAdapter.ALL_NATIVES))) {
            cv = new DelegateClassAdapter(mLog, cv, className, delegateMethods);
        }
    }
    cr.accept(cv, 0);
    return cw.toByteArray();
}
Body of Second Method:
{
    boolean hasNativeMethods = hasNativeMethods(cr);
    // Get the class name, as an internal name (e.g. com/android/SomeClass$InnerClass)
    String className = cr.getClassName();
    String newName = transformName(className);
    // transformName returns its input argument if there's no need to rename the class
    if (!newName.equals(className)) {
        mRenameCount++;
        // This class is being renamed, so remove it from the list of classes not renamed.
        mClassesNotRenamed.remove(className);
    }
    mLog.debug("Transform %s%s%s%s", className, newName.equals(className) ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
    // Rewrite the new class from scratch, without reusing the constant pool from the
    // original class reader.
    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
    ClassVisitor cv = cw;
    if (mReplaceMethodCallsClasses.contains(className)) {
        cv = new ReplaceMethodCallsAdapter(cv);
    }
    cv = new RefactorClassAdapter(cv, mRefactorClasses);
    if (!newName.equals(className)) {
        cv = new RenameClassAdapter(cv, className, newName);
    }
    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly);
    Set<String> delegateMethods = mDelegateMethods.get(className);
    if (delegateMethods != null && !delegateMethods.isEmpty()) {
        // known to have no native methods, just skip this step.
        if (hasNativeMethods || !(delegateMethods.size() == 1 && delegateMethods.contains(DelegateClassAdapter.ALL_NATIVES))) {
            cv = new DelegateClassAdapter(mLog, cv, className, delegateMethods);
        }
    }
    cr.accept(cv, 0);
    return cw.toByteArray();
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.makeStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    final int sysNum = copyFromSystem ? sSystem.mStringBlocks.length : 0;
    final int num = getStringBlockCount();
    mStringBlocks = new StringBlock[num];
    if (localLOGV)
        Log.v(TAG, "Making string blocks for " + this + ": " + num);
    for (int i = 0; i < num; i++) {
        if (i < sysNum) {
            mStringBlocks[i] = sSystem.mStringBlocks[i];
        } else {
            mStringBlocks[i] = new StringBlock(getNativeStringBlock(i), true);
        }
    }
}
Body of Second Method:
{
    final int seedNum = (seed != null) ? seed.length : 0;
    final int num = getStringBlockCount();
    mStringBlocks = new StringBlock[num];
    if (localLOGV)
        Log.v(TAG, "Making string blocks for " + this + ": " + num);
    for (int i = 0; i < num; i++) {
        if (i < seedNum) {
            mStringBlocks[i] = seed[i];
        } else {
            mStringBlocks[i] = new StringBlock(getNativeStringBlock(i), true);
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onNewPlayer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mRefresh) {
        synchronized (this) {
            scheduleNotification(NOTIFY_SEEK, 0);
        }
    }
}
Body of Second Method:
{
    if (mRefresh) {
        synchronized (this) {
            mStopped = false;
            mSeeking = true;
            scheduleNotification(NOTIFY_SEEK, 0);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visitInnerClass:COMMENT
Method Modifier: public      
Comment:/* Visits the header of an inner class. */

Body of Frist Method:
{
    // remove protected or private and set as public
    if (Main.sOptions.generatePublicAccess) {
        access = access & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED);
        access |= Opcodes.ACC_PUBLIC;
    }
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // note: leave abstract classes as such
    // don't try to implement stub for interfaces
    super.visitInnerClass(name, outerName, innerName, access);
}
Body of Second Method:
{
    // remove final
    access = access & ~Opcodes.ACC_FINAL;
    // note: leave abstract classes as such
    // don't try to implement stub for interfaces
    super.visitInnerClass(name, outerName, innerName, access);
}
------------------------
Find a functionally equivalent code:android.util.ArrayMap.get:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a value from the array.
 * @param key The key of the value to retrieve.
 * @return Returns the value associated with the given key,
 * or null if there is no such key.
 */

Body of Frist Method:
{
    final int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}
Body of Second Method:
{
    final int index = indexOfKey(key);
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}
------------------------
Find a functionally equivalent code:android.net.Proxy.validate:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Validate syntax of hostname, port and exclusion list entries
 * {@hide}
 */

Body of Frist Method:
{
    Matcher match = HOSTNAME_PATTERN.matcher(hostname);
    Matcher listMatch = EXCLLIST_PATTERN.matcher(exclList);
    if (!match.matches()) {
        throw new IllegalArgumentException();
    }
    if (!listMatch.matches()) {
        throw new IllegalArgumentException();
    }
    if (hostname.length() > 0 && port.length() == 0) {
        throw new IllegalArgumentException();
    }
    if (port.length() > 0) {
        if (hostname.length() == 0) {
            throw new IllegalArgumentException();
        }
        int portVal = -1;
        try {
            portVal = Integer.parseInt(port);
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException();
        }
        if (portVal <= 0 || portVal > 0xFFFF) {
            throw new IllegalArgumentException();
        }
    }
}
Body of Second Method:
{
    Matcher match = HOSTNAME_PATTERN.matcher(hostname);
    Matcher listMatch = EXCLLIST_PATTERN.matcher(exclList);
    if (!match.matches())
        return PROXY_HOSTNAME_INVALID;
    if (!listMatch.matches())
        return PROXY_EXCLLIST_INVALID;
    if (hostname.length() > 0 && port.length() == 0)
        return PROXY_PORT_EMPTY;
    if (port.length() > 0) {
        if (hostname.length() == 0)
            return PROXY_HOSTNAME_EMPTY;
        int portVal = -1;
        try {
            portVal = Integer.parseInt(port);
        } catch (NumberFormatException ex) {
            return PROXY_PORT_INVALID;
        }
        if (portVal <= 0 || portVal > 0xFFFF)
            return PROXY_PORT_INVALID;
    }
    return PROXY_VALID;
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.WaveView.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

Body of Frist Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration);
    }
}
Body of Second Method:
{
    final boolean hapticEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
    if (hapticEnabled) {
        if (mVibrator == null) {
            mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
        }
        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyUp:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * A key was released and not handled by anything else in the window.
 *
 * @see #onKeyDown
 * @see android.view.KeyEvent
 */

Body of Frist Method:
{
    final KeyEvent.DispatcherState dispatcher = mDecor != null ? mDecor.getKeyDispatcherState() : null;
    if (dispatcher != null) {
        dispatcher.handleUpEvent(event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // Similar code is in PhoneFallbackEventHandler in case the window
                // doesn't have one of these.  In this case, we execute it here and
                // eat the event instead, because we have mVolumeControlStreamType
                // and they don't.
                getAudioManager().handleKeyUp(event, mVolumeControlStreamType);
                return true;
            }
        case KeyEvent.KEYCODE_MENU:
            {
                onKeyUpPanel(featureId < 0 ? FEATURE_OPTIONS_PANEL : featureId, event);
                return true;
            }
        case KeyEvent.KEYCODE_BACK:
            {
                if (featureId < 0)
                    break;
                if (event.isTracking() && !event.isCanceled()) {
                    if (featureId == FEATURE_OPTIONS_PANEL) {
                        PanelFeatureState st = getPanelState(featureId, false);
                        if (st != null && st.isInExpandedMode) {
                            // If the user is in an expanded menu and hits back, it
                            // should go back to the icon menu
                            reopenMenu(true);
                            return true;
                        }
                    }
                    closePanel(featureId);
                    return true;
                }
                break;
            }
        case KeyEvent.KEYCODE_SEARCH:
            {
                /*
                 * Do this in onKeyUp since the Search key is also used for
                 * chording quick launch shortcuts.
                 */
                if (getKeyguardManager().inKeyguardRestrictedInputMode()) {
                    break;
                }
                if (event.isTracking() && !event.isCanceled()) {
                    launchDefaultSearch();
                }
                return true;
            }
    }
    return false;
}
Body of Second Method:
{
    final KeyEvent.DispatcherState dispatcher = mDecor != null ? mDecor.getKeyDispatcherState() : null;
    if (dispatcher != null) {
        dispatcher.handleUpEvent(event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                // use the suggested stream.
                if (mMediaController != null) {
                    mMediaController.adjustVolume(0, AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_VIBRATE);
                } else {
                    MediaSessionLegacyHelper.getHelper(getContext()).sendAdjustVolumeBy(mVolumeControlStreamType, 0, AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_VIBRATE);
                }
                return true;
            }
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // Similar code is in PhoneFallbackEventHandler in case the window
                // doesn't have one of these.  In this case, we execute it here and
                // eat the event instead, because we have mVolumeControlStreamType
                // and they don't.
                getAudioManager().handleKeyUp(event, mVolumeControlStreamType);
                return true;
            }
        // KeyEvent.isMediaKey()
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            {
                if (mMediaController != null) {
                    if (mMediaController.dispatchMediaButtonEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
        case KeyEvent.KEYCODE_MENU:
            {
                onKeyUpPanel(featureId < 0 ? FEATURE_OPTIONS_PANEL : featureId, event);
                return true;
            }
        case KeyEvent.KEYCODE_BACK:
            {
                if (featureId < 0)
                    break;
                if (event.isTracking() && !event.isCanceled()) {
                    if (featureId == FEATURE_OPTIONS_PANEL) {
                        PanelFeatureState st = getPanelState(featureId, false);
                        if (st != null && st.isInExpandedMode) {
                            // If the user is in an expanded menu and hits back, it
                            // should go back to the icon menu
                            reopenMenu(true);
                            return true;
                        }
                    }
                    closePanel(featureId);
                    return true;
                }
                break;
            }
        case KeyEvent.KEYCODE_SEARCH:
            {
                /*
                 * Do this in onKeyUp since the Search key is also used for
                 * chording quick launch shortcuts.
                 */
                if (getKeyguardManager().inKeyguardRestrictedInputMode()) {
                    break;
                }
                if (event.isTracking() && !event.isCanceled()) {
                    launchDefaultSearch();
                }
                return true;
            }
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.systemui.usb.StorageNotification.setMediaStorageNotification:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the media storage notification.
 */

Body of Frist Method:
{
    if (!visible && mMediaStorageNotification == null) {
        return;
    }
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mMediaStorageNotification != null && visible) {
        /*
             * Dismiss the previous notification - we're about to
             * re-use it.
             */
        final int notificationId = mMediaStorageNotification.icon;
        notificationManager.cancel(notificationId);
    }
    if (visible) {
        Resources r = Resources.getSystem();
        CharSequence title = r.getText(titleId);
        CharSequence message = r.getText(messageId);
        if (mMediaStorageNotification == null) {
            mMediaStorageNotification = new Notification();
            mMediaStorageNotification.when = 0;
        }
        mMediaStorageNotification.defaults &= ~Notification.DEFAULT_SOUND;
        if (dismissable) {
            mMediaStorageNotification.flags = Notification.FLAG_AUTO_CANCEL;
        } else {
            mMediaStorageNotification.flags = Notification.FLAG_ONGOING_EVENT;
        }
        mMediaStorageNotification.tickerText = title;
        if (pi == null) {
            Intent intent = new Intent();
            pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
        }
        mMediaStorageNotification.icon = icon;
        mMediaStorageNotification.setLatestEventInfo(mContext, title, message, pi);
    }
    final int notificationId = mMediaStorageNotification.icon;
    if (visible) {
        notificationManager.notifyAsUser(null, notificationId, mMediaStorageNotification, UserHandle.ALL);
    } else {
        notificationManager.cancelAsUser(null, notificationId, UserHandle.ALL);
    }
}
Body of Second Method:
{
    if (!visible && mMediaStorageNotification == null) {
        return;
    }
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mMediaStorageNotification != null && visible) {
        /*
             * Dismiss the previous notification - we're about to
             * re-use it.
             */
        final int notificationId = mMediaStorageNotification.icon;
        notificationManager.cancel(notificationId);
    }
    if (visible) {
        Resources r = Resources.getSystem();
        CharSequence title = r.getText(titleId);
        CharSequence message = r.getText(messageId);
        if (mMediaStorageNotification == null) {
            mMediaStorageNotification = new Notification();
            mMediaStorageNotification.when = 0;
        }
        mMediaStorageNotification.defaults &= ~Notification.DEFAULT_SOUND;
        if (dismissable) {
            mMediaStorageNotification.flags = Notification.FLAG_AUTO_CANCEL;
        } else {
            mMediaStorageNotification.flags = Notification.FLAG_ONGOING_EVENT;
        }
        mMediaStorageNotification.tickerText = title;
        if (pi == null) {
            Intent intent = new Intent();
            pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
        }
        mMediaStorageNotification.icon = icon;
        mMediaStorageNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
        mMediaStorageNotification.setLatestEventInfo(mContext, title, message, pi);
        mMediaStorageNotification.visibility = Notification.VISIBILITY_PUBLIC;
        mMediaStorageNotification.category = Notification.CATEGORY_SYSTEM;
    }
    final int notificationId = mMediaStorageNotification.icon;
    if (visible) {
        notificationManager.notifyAsUser(null, notificationId, mMediaStorageNotification, UserHandle.ALL);
    } else {
        notificationManager.cancelAsUser(null, notificationId, UserHandle.ALL);
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.moveChild:COMMENT
Method Modifier: public      
Comment:/**
 * Moves a view to a new parent at a given location
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#moveChild(Object, Object, int, Map, IAnimationListener)
 */

Body of Frist Method:
{
    checkLock();
    invalidateRenderingSize();
    LayoutParams layoutParams = null;
    if (layoutParamsMap != null) {
        // need to create a new LayoutParams object for the new parent.
        layoutParams = newParentView.generateLayoutParams(new BridgeLayoutParamsMapAttributes(layoutParamsMap));
    }
    // get the current parent of the view that needs to be moved.
    final ViewGroup previousParent = (ViewGroup) childView.getParent();
    if (listener != null) {
        final LayoutParams params = layoutParams;
        // parent views are different we fake the animation through a no animation thread.
        if (previousParent != newParentView) {
            new Thread("not animated moveChild") {

                @Override
                public void run() {
                    Result result = moveView(previousParent, newParentView, childView, index, params);
                    if (result.isSuccess() == false) {
                        listener.done(result);
                    }
                    // ready to do the work, acquire the scene.
                    result = acquire(250);
                    if (result.isSuccess() == false) {
                        listener.done(result);
                        return;
                    }
                    try {
                        result = render(false);
                        if (result.isSuccess()) {
                            listener.onNewFrame(RenderSessionImpl.this.getSession());
                        }
                    } finally {
                        release();
                    }
                    listener.done(result);
                }
            }.start();
        } else {
            new AnimationThread(this, "moveChild", listener) {

                @Override
                public Result preAnimation() {
                    // set up the transition for the parent.
                    LayoutTransition transition = new LayoutTransition();
                    previousParent.setLayoutTransition(transition);
                    // tweak the animation durations and start delays (to match the duration of
                    // animation playing just before).
                    // Note: Cannot user Animation.setDuration() directly. Have to set it
                    // on the LayoutTransition.
                    transition.setDuration(LayoutTransition.DISAPPEARING, 100);
                    // CHANGE_DISAPPEARING plays after DISAPPEARING
                    transition.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 100);
                    transition.setDuration(LayoutTransition.CHANGE_DISAPPEARING, 100);
                    transition.setDuration(LayoutTransition.CHANGE_APPEARING, 100);
                    // CHANGE_APPEARING plays after CHANGE_APPEARING
                    transition.setStartDelay(LayoutTransition.APPEARING, 100);
                    transition.setDuration(LayoutTransition.APPEARING, 100);
                    return moveView(previousParent, newParentView, childView, index, params);
                }

                @Override
                public void postAnimation() {
                    previousParent.setLayoutTransition(null);
                    newParentView.setLayoutTransition(null);
                }
            }.start();
        }
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult(layoutParams);
    }
    Result result = moveView(previousParent, newParentView, childView, index, layoutParams);
    if (result.isSuccess() == false) {
        return result;
    }
    result = render(false);
    if (layoutParams != null && result.isSuccess()) {
        result = result.getCopyWithData(layoutParams);
    }
    return result;
}
Body of Second Method:
{
    checkLock();
    invalidateRenderingSize();
    LayoutParams layoutParams = null;
    if (layoutParamsMap != null) {
        // need to create a new LayoutParams object for the new parent.
        layoutParams = newParentView.generateLayoutParams(new BridgeLayoutParamsMapAttributes(layoutParamsMap));
    }
    // get the current parent of the view that needs to be moved.
    final ViewGroup previousParent = (ViewGroup) childView.getParent();
    if (listener != null) {
        final LayoutParams params = layoutParams;
        // parent views are different we fake the animation through a no animation thread.
        if (previousParent != newParentView) {
            new Thread("not animated moveChild") {

                @Override
                public void run() {
                    Result result = moveView(previousParent, newParentView, childView, index, params);
                    if (!result.isSuccess()) {
                        listener.done(result);
                    }
                    // ready to do the work, acquire the scene.
                    result = acquire(250);
                    if (!result.isSuccess()) {
                        listener.done(result);
                        return;
                    }
                    try {
                        result = render(false);
                        if (result.isSuccess()) {
                            listener.onNewFrame(RenderSessionImpl.this.getSession());
                        }
                    } finally {
                        release();
                    }
                    listener.done(result);
                }
            }.start();
        } else {
            new AnimationThread(this, "moveChild", listener) {

                @Override
                public Result preAnimation() {
                    // set up the transition for the parent.
                    LayoutTransition transition = new LayoutTransition();
                    previousParent.setLayoutTransition(transition);
                    // tweak the animation durations and start delays (to match the duration of
                    // animation playing just before).
                    // Note: Cannot user Animation.setDuration() directly. Have to set it
                    // on the LayoutTransition.
                    transition.setDuration(LayoutTransition.DISAPPEARING, 100);
                    // CHANGE_DISAPPEARING plays after DISAPPEARING
                    transition.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 100);
                    transition.setDuration(LayoutTransition.CHANGE_DISAPPEARING, 100);
                    transition.setDuration(LayoutTransition.CHANGE_APPEARING, 100);
                    // CHANGE_APPEARING plays after CHANGE_APPEARING
                    transition.setStartDelay(LayoutTransition.APPEARING, 100);
                    transition.setDuration(LayoutTransition.APPEARING, 100);
                    return moveView(previousParent, newParentView, childView, index, params);
                }

                @Override
                public void postAnimation() {
                    previousParent.setLayoutTransition(null);
                    newParentView.setLayoutTransition(null);
                }
            }.start();
        }
        // always return success since the real status will come through the listener.
        return SUCCESS.createResult(layoutParams);
    }
    Result result = moveView(previousParent, newParentView, childView, index, layoutParams);
    if (!result.isSuccess()) {
        return result;
    }
    result = render(false);
    if (layoutParams != null && result.isSuccess()) {
        result = result.getCopyWithData(layoutParams);
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.sendKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */

Body of Frist Method:
{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    return false;
}
Body of Second Method:
{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    mIMM.notifyUserAction();
    return false;
}
------------------------
Find a functionally equivalent code:android.os.Process.openZygoteSocketIfNeeded:COMMENT
Method Modifier: private     static      
Comment:/**
 * Tries to open socket to Zygote process if not already open. If
 * already open, does nothing.  May block and retry.
 */

Body of Frist Method:
{
    int retryCount;
    if (sPreviousZygoteOpenFailed) {
        /*
             * If we've failed before, expect that we'll fail again and
             * don't pause for retries.
             */
        retryCount = 0;
    } else {
        retryCount = 10;
    }
    /*
         * See bug #811181: Sometimes runtime can make it up before zygote.
         * Really, we'd like to do something better to avoid this condition,
         * but for now just wait a bit...
         */
    for (int retry = 0; (sZygoteSocket == null) && (retry < (retryCount + 1)); retry++) {
        if (retry > 0) {
            try {
                Log.i("Zygote", "Zygote not up yet, sleeping...");
                Thread.sleep(ZYGOTE_RETRY_MILLIS);
            } catch (InterruptedException ex) {
            // should never happen
            }
        }
        try {
            sZygoteSocket = new LocalSocket();
            sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET, LocalSocketAddress.Namespace.RESERVED));
            sZygoteInputStream = new DataInputStream(sZygoteSocket.getInputStream());
            sZygoteWriter = new BufferedWriter(new OutputStreamWriter(sZygoteSocket.getOutputStream()), 256);
            Log.i("Zygote", "Process: zygote socket opened");
            sPreviousZygoteOpenFailed = false;
            break;
        } catch (IOException ex) {
            if (sZygoteSocket != null) {
                try {
                    sZygoteSocket.close();
                } catch (IOException ex2) {
                    Log.e(LOG_TAG, "I/O exception on close after exception", ex2);
                }
            }
            sZygoteSocket = null;
        }
    }
    if (sZygoteSocket == null) {
        sPreviousZygoteOpenFailed = true;
        throw new ZygoteStartFailedEx("connect failed");
    }
}
Body of Second Method:
{
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
------------------------
Find a functionally equivalent code:android.app.ActivityManager.getLauncherLargeIconSize:COMMENT
Method Modifier: public      
Comment:/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */

Body of Frist Method:
{
    final Resources res = mContext.getResources();
    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
    final int sw = res.getConfiguration().smallestScreenWidthDp;
    if (sw < 600) {
        // Smaller than approx 7" tablets, use the regular icon size.
        return size;
    }
    final int density = res.getDisplayMetrics().densityDpi;
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
        case DisplayMetrics.DENSITY_MEDIUM:
            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_TV:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return (size * DisplayMetrics.DENSITY_XXHIGH) / DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XXHIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH * 2) / DisplayMetrics.DENSITY_XXHIGH;
        default:
            // abnormal value that is a reasonable scaling of it.
            return (int) ((size * 1.5f) + .5f);
    }
}
Body of Second Method:
{
    return getLauncherLargeIconSizeInner(mContext);
}
------------------------
Find a functionally equivalent code:android.text.Layout.isRtlCharAt:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the character at offset is right to left (RTL).
 * @param offset the offset
 * @return true if the character is RTL, false if it is LTR
 */

Body of Frist Method:
{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + (runs[i] & RUN_LENGTH_MASK);
        // corresponding of the last run
        if (offset >= start) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is "out of bounds"
    return false;
}
Body of Second Method:
{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + runs[i];
        int limit = start + (runs[i + 1] & RUN_LENGTH_MASK);
        if (offset >= start && offset < limit) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is "out of bounds"
    return false;
}
------------------------
Find a functionally equivalent code:android.app.admin.DevicePolicyManager.setGlobalProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by an application that is administering the device to set the
 * global proxy and exclusion list.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call
 * this method; if it has not, a security exception will be thrown.
 * Only the first device admin can set the proxy. If a second admin attempts
 * to set the proxy, the {@link ComponentName} of the admin originally setting the
 * proxy will be returned. If successful in setting the proxy, null will
 * be returned.
 * The method can be called repeatedly by the device admin alrady setting the
 * proxy to update the proxy and exclusion list.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param proxySpec the global proxy desired. Must be an HTTP Proxy.
 * Pass Proxy.NO_PROXY to reset the proxy.
 * @param exclusionList a list of domains to be excluded from the global proxy.
 * @return returns null if the proxy was successfully set, or a {@link ComponentName}
 * of the device admin that sets thew proxy otherwise.
 * @hide
 */

Body of Frist Method:
{
    if (proxySpec == null) {
        throw new NullPointerException();
    }
    if (mService != null) {
        try {
            String hostSpec;
            String exclSpec;
            if (proxySpec.equals(Proxy.NO_PROXY)) {
                hostSpec = null;
                exclSpec = null;
            } else {
                if (!proxySpec.type().equals(Proxy.Type.HTTP)) {
                    throw new IllegalArgumentException();
                }
                InetSocketAddress sa = (InetSocketAddress) proxySpec.address();
                String hostName = sa.getHostName();
                int port = sa.getPort();
                StringBuilder hostBuilder = new StringBuilder();
                hostSpec = hostBuilder.append(hostName).append(":").append(Integer.toString(port)).toString();
                if (exclusionList == null) {
                    exclSpec = "";
                } else {
                    StringBuilder listBuilder = new StringBuilder();
                    boolean firstDomain = true;
                    for (String exclDomain : exclusionList) {
                        if (!firstDomain) {
                            listBuilder = listBuilder.append(",");
                        } else {
                            firstDomain = false;
                        }
                        listBuilder = listBuilder.append(exclDomain.trim());
                    }
                    exclSpec = listBuilder.toString();
                }
                android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec);
            }
            return mService.setGlobalProxy(admin, hostSpec, exclSpec, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
Body of Second Method:
{
    if (proxySpec == null) {
        throw new NullPointerException();
    }
    if (mService != null) {
        try {
            String hostSpec;
            String exclSpec;
            if (proxySpec.equals(Proxy.NO_PROXY)) {
                hostSpec = null;
                exclSpec = null;
            } else {
                if (!proxySpec.type().equals(Proxy.Type.HTTP)) {
                    throw new IllegalArgumentException();
                }
                InetSocketAddress sa = (InetSocketAddress) proxySpec.address();
                String hostName = sa.getHostName();
                int port = sa.getPort();
                StringBuilder hostBuilder = new StringBuilder();
                hostSpec = hostBuilder.append(hostName).append(":").append(Integer.toString(port)).toString();
                if (exclusionList == null) {
                    exclSpec = "";
                } else {
                    StringBuilder listBuilder = new StringBuilder();
                    boolean firstDomain = true;
                    for (String exclDomain : exclusionList) {
                        if (!firstDomain) {
                            listBuilder = listBuilder.append(",");
                        } else {
                            firstDomain = false;
                        }
                        listBuilder = listBuilder.append(exclDomain.trim());
                    }
                    exclSpec = listBuilder.toString();
                }
                if (android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec) != android.net.Proxy.PROXY_VALID)
                    throw new IllegalArgumentException();
            }
            return mService.setGlobalProxy(admin, hostSpec, exclSpec, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.preRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified rotation.
 * M' = M * R(degrees)
 */

Body of Frist Method:
{
    return native_preRotate(native_instance, degrees);
}
Body of Second Method:
{
    native_preRotate(native_instance, degrees);
    return true;
}
------------------------
Find a functionally equivalent code:com.android.systemui.ExpandHelper.vibrate:COMMENT
Method Modifier: private     
Comment:/**
 * Triggers haptic feedback.
 */

Body of Frist Method:
{
    if (mVibrator == null) {
        mVibrator = (android.os.Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
    }
    mVibrator.vibrate(duration);
}
Body of Second Method:
{
    if (mVibrator == null) {
        mVibrator = (android.os.Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
    }
    mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.setPixel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Write the specified {@link Color} into the bitmap (assuming it is
 * mutable) at the x,y coordinate. The color must be a
 * non-premultiplied ARGB value.</p>
 *
 * @param x     The x coordinate of the pixel to replace (0...width-1)
 * @param y     The y coordinate of the pixel to replace (0...height-1)
 * @param color The ARGB color to write into the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y are outside of the bitmap's
 * bounds.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativeBitmap, x, y, color, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativeBitmap, x, y, color);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a char[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (char[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "char[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharArray(key);
}
------------------------
Find a functionally equivalent code:android.widget.TextView.getExtendedPaddingTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended top padding of the view, including both the
 * top Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

Body of Frist Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}
Body of Second Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.clearDisappearingChildren:COMMENT
Method Modifier: public      
Comment:/**
 * Removes any pending animations for views that have been removed. Call
 * this if you don't want animations for exiting views to stack up.
 */

Body of Frist Method:
{
    if (mDisappearingChildren != null) {
        mDisappearingChildren.clear();
        invalidate();
    }
}
Body of Second Method:
{
    final ArrayList<View> disappearingChildren = mDisappearingChildren;
    if (disappearingChildren != null) {
        final int count = disappearingChildren.size();
        for (int i = 0; i < count; i++) {
            final View view = disappearingChildren.get(i);
            if (view.mAttachInfo != null) {
                view.dispatchDetachedFromWindow();
            }
            view.clearAnimation();
        }
        disappearingChildren.clear();
        invalidate();
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.isConnecting:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the route is in the process of connecting and is not
 * yet ready for use.
 *
 * @return True if this route is in the process of connecting.
 */

Body of Frist Method:
{
    return mStatusCode == STATUS_CONNECTING;
}
Body of Second Method:
{
    return mResolvedStatusCode == STATUS_CONNECTING;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.cancelPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels a pending drag.
 *
 * @see #startPendingDrag()
 */

Body of Frist Method:
{
    mList.removeCallbacks(mDeferStartDrag);
    mHasPendingDrag = false;
}
Body of Second Method:
{
    mPendingDrag = -1;
}
------------------------
Find a functionally equivalent code:android.net.MobileDataStateTracker.setEnableApn:COMMENT
Method Modifier: private     
Comment:/**
 * Internal method supporting the ENABLE_MMS feature.
 * @param apnType the type of APN to be enabled or disabled (e.g., mms)
 * @param enable {@code true} to enable the specified APN type,
 * {@code false} to disable it.
 * @return an integer value representing the outcome of the request.
 */

Body of Frist Method:
{
    getPhoneService(false);
    /*
         * If the phone process has crashed in the past, we'll get a
         * RemoteException and need to re-reference the service.
         */
    for (int retry = 0; retry < 2; retry++) {
        if (mPhoneService == null) {
            loge("Ignoring feature request because could not acquire PhoneService");
            break;
        }
        try {
            if (enable) {
                return mPhoneService.enableApnType(apnType);
            } else {
                return mPhoneService.disableApnType(apnType);
            }
        } catch (RemoteException e) {
            if (retry == 0)
                getPhoneService(true);
        }
    }
    loge("Could not " + (enable ? "enable" : "disable") + " APN type \"" + apnType + "\"");
    return PhoneConstants.APN_REQUEST_FAILED;
}
Body of Second Method:
{
    getPhoneService(false);
    /*
         * If the phone process has crashed in the past, we'll get a
         * RemoteException and need to re-reference the service.
         */
    for (int retry = 0; retry < 2; retry++) {
        if (mPhoneService == null) {
            loge("Ignoring feature request because could not acquire PhoneService");
            break;
        }
    // try {
    // if (enable) {
    // return mPhoneService.enableApnType(apnType);
    // } else {
    // return mPhoneService.disableApnType(apnType);
    // }
    // } catch (RemoteException e) {
    // if (retry == 0) getPhoneService(true);
    // }
    }
    loge("Could not " + (enable ? "enable" : "disable") + " APN type \"" + apnType + "\"");
    return PhoneConstants.APN_REQUEST_FAILED;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.addAccessibilityStateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */

Body of Frist Method:
{
    return mAccessibilityStateChangeListeners.add(listener);
}
Body of Second Method:
{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.invokeOnItemScrollListener:COMMENT
Method Modifier: 
Comment:/**
 * Notify our scroll listener (if there is one) of a change in scroll state
 */

Body of Frist Method:
{
    if (mFastScroller != null) {
        mFastScroller.onScroll(mFirstPosition, getChildCount(), mItemCount);
    }
    if (mOnScrollListener != null) {
        mOnScrollListener.onScroll(this, mFirstPosition, getChildCount(), mItemCount);
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
}
Body of Second Method:
{
    if (mFastScroll != null) {
        mFastScroll.onScroll(mFirstPosition, getChildCount(), mItemCount);
    }
    if (mOnScrollListener != null) {
        mOnScrollListener.onScroll(this, mFirstPosition, getChildCount(), mItemCount);
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
}
------------------------
Find a functionally equivalent code:android.widget.Toast.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the view for the specified duration.
 */

Body of Frist Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}
Body of Second Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}
------------------------
Find a functionally equivalent code:android.util.SparseIntArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        int[] nvalues = new int[n];
        // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerBaseTest.setUp:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mContext = getInstrumentation().getContext();
    mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);
    mReceiver = registerNewMultipleDownloadsReceiver();
}
Body of Second Method:
{
    super.setUp();
    mContext = getInstrumentation().getContext();
    mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);
    mListener = registerDownloadsListener();
}
------------------------
Find a functionally equivalent code:android.media.AudioRecord.startRecording:COMMENT
Method Modifier: public      
Comment:/**
 * Starts recording from the AudioRecord instance when the specified synchronization event
 * occurs on the specified audio session.
 * @throws IllegalStateException
 * @param syncEvent event that triggers the capture.
 * @see MediaSyncEvent
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("startRecording() called on an " + "uninitialized AudioRecord.");
    }
    // start recording
    synchronized (mRecordingStateLock) {
        if (native_start(syncEvent.getType(), syncEvent.getAudioSessionId()) == SUCCESS) {
            mRecordingState = RECORDSTATE_RECORDING;
        }
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("startRecording() called on an " + "uninitialized AudioRecord.");
    }
    // start recording
    synchronized (mRecordingStateLock) {
        if (native_start(syncEvent.getType(), syncEvent.getAudioSessionId()) == SUCCESS) {
            handleFullVolumeRec(true);
            mRecordingState = RECORDSTATE_RECORDING;
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.transitionToDragging:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb, preview, and track.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage, mPreviewImage).setDuration(DURATION_FADE_IN);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, slideIn);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage, mPreviewImage).setDuration(DURATION_FADE_IN);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, slideIn);
    mDecorAnimation.start();
    mShowingPreview = true;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.skew:COMMENT
<android.graphics.Canvas: void skew(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified skew.
 *
 * @param sx The amount to skew in X
 * @param sy The amount to skew in Y
 */

Body of Frist Method:

Body of Second Method:
{
    native_skew(mNativeCanvasWrapper, sx, sy);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetManager.getAppWidgetIds:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */

Body of Frist Method:
{
    try {
        return sService.getAppWidgetIds(provider, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.applyThemeStyle:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.eventTypeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */

Body of Frist Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
Body of Second Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOWS_CHANGED");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
------------------------
Find a functionally equivalent code:android.text.MeasuredText.setPara:COMMENT
Method Modifier: 
Comment:/**
 * Analyzes text for bidirectional runs.  Allocates working buffers.
 */

Body of Frist Method:
{
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = new float[ArrayUtils.idealFloatArraySize(len)];
    }
    if (mChars == null || mChars.length < len) {
        mChars = new char[ArrayUtils.idealCharArraySize(len)];
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = new byte[ArrayUtils.idealByteArraySize(len)];
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
Body of Second Method:
{
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = ArrayUtils.newUnpaddedFloatArray(len);
    }
    if (mChars == null || mChars.length < len) {
        mChars = ArrayUtils.newUnpaddedCharArray(len);
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = ArrayUtils.newUnpaddedByteArray(len);
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.isPotentialLocalEmergencyNumber:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given number might *potentially* result in a call to an
 * emergency service, for the country that the user is in. The current
 * country is determined using the CountryDetector.
 *
 * Specifically, this method will return true if the specified number
 * is an emergency number in the current country, *or* if the number
 * simply starts with the same digits as any emergency number for the
 * current country.
 *
 * This method is intended for internal use by the phone app when
 * deciding whether to allow ACTION_CALL intents from 3rd party apps
 * (where we're required to *not* allow emergency calls to be placed.)
 *
 * @param number the number to look up.
 * @param context the specific context which the number should be checked against
 * @return true if the specified number is an emergency number for a local country, based on the
 * CountryDetector.
 *
 * @see android.location.CountryDetector
 * @hide
 */

Body of Frist Method:
{
    return isLocalEmergencyNumberInternal(number, context, false);
}
Body of Second Method:
{
    return isPotentialLocalEmergencyNumber(context, getDefaultVoiceSubId(), number);
}
------------------------
Find a functionally equivalent code:android.graphics.BitmapFactory.decodeStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Decode an input stream into a bitmap. If the input stream is null, or
 * cannot be used to decode a bitmap, the function returns null.
 * The stream's position will be where ever it was after the encoded data
 * was read.
 *
 * @param is The input stream that holds the raw data to be decoded into a
 * bitmap.
 * @return The decoded bitmap, or null if the image data could not be decoded.
 */

Body of Frist Method:
{
    return decodeStream(is, null, null);
}
Body of Second Method:
{
    return decodeStream(is, null, null);
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.getScrapView:COMMENT
Method Modifier: 
Comment:/**
 * @return A view from the ScrapViews collection. These are unordered.
 */

Body of Frist Method:
{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}
Body of Second Method:
{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.getThemeValue:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    int block = loadThemeAttributeValue(theme, ident, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        StringBlock[] blocks = mStringBlocks;
        if (blocks == null) {
            ensureStringBlocks();
            blocks = mStringBlocks;
        }
        outValue.string = blocks[block].get(outValue.data);
        return true;
    }
    return false;
}
Body of Second Method:
{
    int block = loadThemeAttributeValue(theme, ident, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        StringBlock[] blocks = mStringBlocks;
        if (blocks == null) {
            ensureStringBlocks();
            blocks = mStringBlocks;
        }
        outValue.string = blocks[block].get(outValue.data);
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.text.StaticLayout.generate:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    // XXX
    int DEFAULT_DIR = DIR_LEFT_TO_RIGHT;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // paragraph.
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    // From the Unicode Line Breaking Algorithm (at least approximately)
                    boolean isLineBreak = isSpaceOrTab || // / is class SY and - is class HY, except when followed by a digit
                    ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || // (non-starters), which can be broken after but not before
                    (c >= CHAR_FIRST_CJK && isIdeographic(c, true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart], false));
                    if (isLineBreak) {
                        okWidth = w;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars = (j + 1 < spanEnd);
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        endPos = here + 1;
                        above = fm.ascent;
                        below = fm.descent;
                        top = fm.top;
                        bottom = fm.bottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        break;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected month.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.MONTH);
}
Body of Second Method:
{
    return mDelegate.getMonth();
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AbstractClassAdapter.renameTypeAsType:COMMENT
Method Modifier: 
Comment:/**
 * Renames an object type, e.g. "Lcom.package.MyClass;" or an array type that has an
 * object element, e.g. "[Lcom.package.MyClass;".
 * This is like renameType() except that it returns a Type object.
 * If the type doesn't need to be renamed, returns the input type object.
 */

Body of Frist Method:
{
    if (type == null) {
        return null;
    }
    if (type.getSort() == Type.OBJECT) {
        String in = type.getInternalName();
        String newIn = renameInternalType(in);
        if (newIn != in) {
            return Type.getType("L" + newIn + ";");
        }
    } else if (type.getSort() == Type.ARRAY) {
        StringBuilder sb = new StringBuilder();
        for (int n = type.getDimensions(); n > 0; n--) {
            sb.append('[');
        }
        sb.append(renameType(type.getElementType()));
        return Type.getType(sb.toString());
    }
    return type;
}
Body of Second Method:
{
    if (type == null) {
        return null;
    }
    if (type.getSort() == Type.OBJECT) {
        String in = type.getInternalName();
        String newIn = renameInternalType(in);
        if (!newIn.equals(in)) {
            return Type.getType("L" + newIn + ";");
        }
    } else if (type.getSort() == Type.ARRAY) {
        StringBuilder sb = new StringBuilder();
        for (int n = type.getDimensions(); n > 0; n--) {
            sb.append('[');
        }
        sb.append(renameType(type.getElementType()));
        return Type.getType(sb.toString());
    }
    return type;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.initFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityEvent}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mEventType = parcel.readInt();
    mMovementGranularity = parcel.readInt();
    mAction = parcel.readInt();
    mContentChangeTypes = parcel.readInt();
    mPackageName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    mEventTime = parcel.readLong();
    mConnectionId = parcel.readInt();
    readAccessibilityRecordFromParcel(this, parcel);
    // Read the records.
    final int recordCount = parcel.readInt();
    for (int i = 0; i < recordCount; i++) {
        AccessibilityRecord record = AccessibilityRecord.obtain();
        readAccessibilityRecordFromParcel(record, parcel);
        record.mConnectionId = mConnectionId;
        mRecords.add(record);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mEventType = parcel.readInt();
    mMovementGranularity = parcel.readInt();
    mAction = parcel.readInt();
    mContentChangeTypes = parcel.readInt();
    mPackageName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    mEventTime = parcel.readLong();
    mConnectionId = parcel.readInt();
    readAccessibilityRecordFromParcel(this, parcel);
    // Read the records.
    final int recordCount = parcel.readInt();
    if (recordCount > 0) {
        mRecords = new ArrayList<AccessibilityRecord>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            AccessibilityRecord record = AccessibilityRecord.obtain();
            readAccessibilityRecordFromParcel(record, parcel);
            record.mConnectionId = mConnectionId;
            mRecords.add(record);
        }
    }
}
------------------------
Find a functionally equivalent code:android.text.format.Time.normalize:COMMENT
<android.text.format.Time: long normalize(boolean)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Ensures the values in each field are in range. For example if the
 * current value of this calendar is March 32, normalize() will convert it
 * to April 1. It also fills in weekDay, yearDay, isDst and gmtoff.
 *
 * <p>
 * If "ignoreDst" is true, then this method sets the "isDst" field to -1
 * (the "unknown" value) before normalizing.  It then computes the
 * correct value for "isDst".
 *
 * <p>
 * See {@link #toMillis(boolean)} for more information about when to
 * use <tt>true</tt> or <tt>false</tt> for "ignoreDst".
 *
 * @return the UTC milliseconds since the epoch
 */

Body of Frist Method:

Body of Second Method:
{
    calculator.copyFieldsFromTime(this);
    long timeInMillis = calculator.toMillis(ignoreDst);
    calculator.copyFieldsToTime(this);
    return timeInMillis;
}
------------------------
Find a functionally equivalent code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    }
}
------------------------
Find a functionally equivalent code:android.view.animation.AnimationUtils.loadInterpolator:COMMENT
Method Modifier: public      static      
Comment:/**
 * Loads an {@link Interpolator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animation object reference by the specified id
 * @throws NotFoundException
 */

Body of Frist Method:
{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context, parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
Body of Second Method:
{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context.getResources(), context.getTheme(), parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.obtainAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */

Body of Frist Method:
{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mRsrcs = attrs;
    array.mXml = parser;
    return array;
}
Body of Second Method:
{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param date The selected date.
 *
 * @throws IllegalArgumentException of the provided date is before the
 * minimal or after the maximal date.
 *
 * @see #setDate(long, boolean, boolean)
 * @see #setMinDate(long)
 * @see #setMaxDate(long)
 */

Body of Frist Method:
{
    setDate(date, false, false);
}
Body of Second Method:
{
    mDelegate.setDate(date);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (false) {
            System.out.println("******************************************************************");
            System.out.println("Got drawable resource: type=" + value.type + " str=" + value.string + " int=0x" + Integer.toHexString(value.data) + " cookie=" + value.assetCookie);
            System.out.println("******************************************************************");
        }
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.toString:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return a string debug representation of this instance.
 */

Body of Frist Method:
{
    // Warning: never check in this file with VERBOSE_DEBUG = true
    // because that will result in PII in the system log.
    final boolean VERBOSE_DEBUG = false;
    if (VERBOSE_DEBUG) {
        return new StringBuilder(384).append(super.toString() + " { ").append("\nname: " + name).append("\nphoneNumber: " + phoneNumber).append("\nnormalizedNumber: " + normalizedNumber).append("\ngeoDescription: " + geoDescription).append("\ncnapName: " + cnapName).append("\nnumberPresentation: " + numberPresentation).append("\nnamePresentation: " + namePresentation).append("\ncontactExits: " + contactExists).append("\nphoneLabel: " + phoneLabel).append("\nnumberType: " + numberType).append("\nnumberLabel: " + numberLabel).append("\nphotoResource: " + photoResource).append("\nperson_id: " + person_id).append("\nneedUpdate: " + needUpdate).append("\ncontactRefUri: " + contactRefUri).append("\ncontactRingtoneUri: " + contactRefUri).append("\nshouldSendToVoicemail: " + shouldSendToVoicemail).append("\ncachedPhoto: " + cachedPhoto).append("\nisCachedPhotoCurrent: " + isCachedPhotoCurrent).append("\nemergency: " + mIsEmergency).append("\nvoicemail " + mIsVoiceMail).append("\ncontactExists " + contactExists).append(" }").toString();
    } else {
        return new StringBuilder(128).append(super.toString() + " { ").append("name " + ((name == null) ? "null" : "non-null")).append(", phoneNumber " + ((phoneNumber == null) ? "null" : "non-null")).append(" }").toString();
    }
}
Body of Second Method:
{
    // Warning: never check in this file with VERBOSE_DEBUG = true
    // because that will result in PII in the system log.
    final boolean VERBOSE_DEBUG = false;
    if (VERBOSE_DEBUG) {
        return new StringBuilder(384).append(super.toString() + " { ").append("\nname: " + name).append("\nphoneNumber: " + phoneNumber).append("\nnormalizedNumber: " + normalizedNumber).append("\ngeoDescription: " + geoDescription).append("\ncnapName: " + cnapName).append("\nnumberPresentation: " + numberPresentation).append("\nnamePresentation: " + namePresentation).append("\ncontactExits: " + contactExists).append("\nphoneLabel: " + phoneLabel).append("\nnumberType: " + numberType).append("\nnumberLabel: " + numberLabel).append("\nphotoResource: " + photoResource).append("\ncontactIdOrZero: " + contactIdOrZero).append("\nneedUpdate: " + needUpdate).append("\ncontactRingtoneUri: " + contactRingtoneUri).append("\ncontactDisplayPhotoUri: " + contactDisplayPhotoUri).append("\nshouldSendToVoicemail: " + shouldSendToVoicemail).append("\ncachedPhoto: " + cachedPhoto).append("\nisCachedPhotoCurrent: " + isCachedPhotoCurrent).append("\nemergency: " + mIsEmergency).append("\nvoicemail " + mIsVoiceMail).append("\ncontactExists " + contactExists).append(" }").toString();
    } else {
        return new StringBuilder(128).append(super.toString() + " { ").append("name " + ((name == null) ? "null" : "non-null")).append(", phoneNumber " + ((phoneNumber == null) ? "null" : "non-null")).append(" }").toString();
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.ChallengeLayout.showChallenge:COMMENT
Method Modifier: 
Comment:/**
 * Show or hide the challenge layout.
 *
 * If you want to show the challenge layout in bouncer mode where applicable,
 * use {@link #showBouncer()} instead.
 *
 * @param b true to show, false to hide
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.MediaCodecInfo.getName:COMMENT
Method Modifier: public      final       
Comment:/**
 * Retrieve the codec name.
 */

Body of Frist Method:
{
    return MediaCodecList.getCodecName(mIndex);
}
Body of Second Method:
{
    return mName;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.executeReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a short array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putShortArray(key, value);
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.setSynchronizationMode:COMMENT
Method Modifier: public      
Comment:/**
 * Set the playback position synchronization mode.
 * Must be called on a registered RemoteController.
 * @param sync {@link #POSITION_SYNCHRONIZATION_NONE} or {@link #POSITION_SYNCHRONIZATION_CHECK}
 * @return true if the synchronization mode was successfully set.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) || (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    mAudioManager.remoteControlDisplayWantsPlaybackPositionSync(mRcd, POSITION_SYNCHRONIZATION_CHECK == sync);
    return true;
}
Body of Second Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    mAudioManager.remoteControlDisplayWantsPlaybackPositionSync(mRcd, POSITION_SYNCHRONIZATION_CHECK == sync);
    return true;
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the currently selected string value.
 * @return the currently selected value, which can be null for types that aren't for holding
 * single string values.
 */

Body of Frist Method:
{
    return currentValue;
}
Body of Second Method:
{
    return mCurrentValue;
}
------------------------
Find a functionally equivalent code:android.app.admin.DevicePolicyManager.getMaximumTimeToLock:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide per-user version
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.getMaximumTimeToLock(admin, userHandle);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return 0;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            return mService.getMaximumTimeToLock(admin, userHandle);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return 0;
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetManager.notifyAppWidgetViewDataChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */

Body of Frist Method:
{
    try {
        sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.getPeriodicSyncs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */

Body of Frist Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.beginReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without commiting any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "beginReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "beginReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the string value to use as the selected value for this restriction. This value will
 * be persisted by the system for later use by the application.
 * @param selectedString the string value to select.
 */

Body of Frist Method:
{
    currentValue = selectedString;
}
Body of Second Method:
{
    mCurrentValue = selectedString;
}
------------------------
Find a functionally equivalent code:android.text.format.Time.parse:COMMENT
Method Modifier: public      
Comment:/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the "time" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>"20081013T160000Z"</li>
 * <li>"20081013T160000"</li>
 * <li>"20081013"</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with "Z" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = "20081013T160000Z";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

Body of Frist Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (nativeParse(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (parseInternal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPeriodics:COMMENT
Method Modifier: public      
Comment:/**
 * Test that we can create, remove and retrieve periodic syncs. Backwards compatibility -
 * periodic syncs with no flex time are no longer used.
 */

Body of Frist Method:
{
    final Account account1 = new Account("a@example.com", "example.type");
    final Account account2 = new Account("b@example.com", "example.type.2");
    final String authority = "testprovider";
    final Bundle extras1 = new Bundle();
    extras1.putString("a", "1");
    final Bundle extras2 = new Bundle();
    extras2.putString("a", "2");
    final int period1 = 200;
    final int period2 = 1000;
    PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1);
    PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1);
    PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2);
    PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2);
    removePeriodicSyncs(engine, account1, 0, authority);
    removePeriodicSyncs(engine, account2, 0, authority);
    removePeriodicSyncs(engine, account1, 1, authority);
    // this should add two distinct periodic syncs for account1 and one for account2
    engine.addPeriodicSync(sync1, 0);
    engine.addPeriodicSync(sync2, 0);
    engine.addPeriodicSync(sync3, 0);
    engine.addPeriodicSync(sync4, 0);
    // add a second user
    engine.addPeriodicSync(sync2, 1);
    List<PeriodicSync> syncs = engine.getPeriodicSyncs(account1, 0, authority);
    assertEquals(2, syncs.size());
    assertEquals(sync1, syncs.get(0));
    assertEquals(sync3, syncs.get(1));
    engine.removePeriodicSync(sync1, 0);
    syncs = engine.getPeriodicSyncs(account1, 0, authority);
    assertEquals(1, syncs.size());
    assertEquals(sync3, syncs.get(0));
    syncs = engine.getPeriodicSyncs(account2, 0, authority);
    assertEquals(1, syncs.size());
    assertEquals(sync4, syncs.get(0));
    syncs = engine.getPeriodicSyncs(sync2.account, 1, sync2.authority);
    assertEquals(1, syncs.size());
    assertEquals(sync2, syncs.get(0));
}
Body of Second Method:
{
    final Account account1 = new Account("a@example.com", "example.type");
    final Account account2 = new Account("b@example.com", "example.type.2");
    final String authority = "testprovider";
    final Bundle extras1 = new Bundle();
    extras1.putString("a", "1");
    final Bundle extras2 = new Bundle();
    extras2.putString("a", "2");
    final int period1 = 200;
    final int period2 = 1000;
    PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1);
    EndPoint end1 = new EndPoint(account1, authority, 0);
    PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1);
    PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2);
    PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2);
    removePeriodicSyncs(engine, account1, 0, authority);
    removePeriodicSyncs(engine, account2, 0, authority);
    removePeriodicSyncs(engine, account1, 1, authority);
    // this should add two distinct periodic syncs for account1 and one for account2
    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period1, 0, extras1);
    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period1, 0, extras2);
    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period2, 0, extras2);
    engine.updateOrAddPeriodicSync(new EndPoint(account2, authority, 0), period2, 0, extras2);
    // add a second user
    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 1), period1, 0, extras2);
    List<PeriodicSync> syncs = engine.getPeriodicSyncs(new EndPoint(account1, authority, 0));
    assertEquals(2, syncs.size());
    assertEquals(sync1, syncs.get(0));
    assertEquals(sync3, syncs.get(1));
    engine.removePeriodicSync(new EndPoint(account1, authority, 0), extras1);
    syncs = engine.getPeriodicSyncs(new EndPoint(account1, authority, 0));
    assertEquals(1, syncs.size());
    assertEquals(sync3, syncs.get(0));
    syncs = engine.getPeriodicSyncs(new EndPoint(account2, authority, 0));
    assertEquals(1, syncs.size());
    assertEquals(sync4, syncs.get(0));
    syncs = engine.getPeriodicSyncs(new EndPoint(sync2.account, sync2.authority, 1));
    assertEquals(1, syncs.size());
    assertEquals(sync2, syncs.get(0));
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteHost:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

Body of Frist Method:
{
    try {
        sService.deleteHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.addContentView:COMMENT
Method Modifier: public      
Comment:/**
 * Add an additional content view to the activity.  Added after any existing
 * ones in the activity -- existing views are NOT removed.
 *
 * @param view The desired content to display.
 * @param params Layout parameters for the view.
 */

Body of Frist Method:
{
    getWindow().addContentView(view, params);
    initActionBar();
}
Body of Second Method:
{
    getWindow().addContentView(view, params);
    initWindowDecorActionBar();
}
------------------------
Find a functionally equivalent code:android.graphics.Matrix.ni:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    return native_instance;
}
Body of Second Method:
{
    return native_instance;
}
------------------------
Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.getOrEstablishDatabase:COMMENT
Method Modifier: private     
Comment:// Lazy initialize the database helper and caches for this user, if necessary

Body of Frist Method:
{
    if (callingUser >= Process.SYSTEM_UID) {
        if (USER_CHECK_THROWS) {
            throw new IllegalArgumentException("Uid rather than user handle: " + callingUser);
        } else {
            Slog.wtf(TAG, "establish db for uid rather than user: " + callingUser);
        }
    }
    long oldId = Binder.clearCallingIdentity();
    try {
        DatabaseHelper dbHelper = mOpenHelpers.get(callingUser);
        if (null == dbHelper) {
            establishDbTracking(callingUser);
            dbHelper = mOpenHelpers.get(callingUser);
        }
        return dbHelper;
    } finally {
        Binder.restoreCallingIdentity(oldId);
    }
}
Body of Second Method:
{
    if (callingUser >= Process.SYSTEM_UID) {
        if (USER_CHECK_THROWS) {
            throw new IllegalArgumentException("Uid rather than user handle: " + callingUser);
        } else {
            Slog.wtf(TAG, "establish db for uid rather than user: " + callingUser);
        }
    }
    long oldId = Binder.clearCallingIdentity();
    try {
        DatabaseHelper dbHelper;
        synchronized (this) {
            dbHelper = mOpenHelpers.get(callingUser);
        }
        if (null == dbHelper) {
            establishDbTracking(callingUser);
            synchronized (this) {
                dbHelper = mOpenHelpers.get(callingUser);
            }
        }
        return dbHelper;
    } finally {
        Binder.restoreCallingIdentity(oldId);
    }
}
------------------------
Find a functionally equivalent code:android.widget.AdapterView.performItemClick:COMMENT
Method Modifier: public      
Comment:/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */

Body of Frist Method:
{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        mOnItemClickListener.onItemClick(this, view, position, id);
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.Theme.setTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set this theme to hold the same contents as the theme
 * <var>other</var>.  If both of these themes are from the same
 * Resources object, they will be identical after this function
 * returns.  If they are from different Resources, only the resources
 * they have in common will be set in this theme.
 *
 * @param other The existing Theme to copy from.
 */

Body of Frist Method:
{
    AssetManager.copyTheme(mTheme, other.mTheme);
}
Body of Second Method:
{
    AssetManager.copyTheme(mTheme, other.mTheme);
    mThemeResId = other.mThemeResId;
    mKey = other.mKey;
}
------------------------
Find a functionally equivalent code:android.view.animation.Transformation.set:COMMENT
Method Modifier: public      
Comment:/**
 * Clones the specified transformation.
 *
 * @param t The transformation to clone.
 */

Body of Frist Method:
{
    mAlpha = t.getAlpha();
    mMatrix.set(t.getMatrix());
    mTransformationType = t.getTransformationType();
}
Body of Second Method:
{
    mAlpha = t.getAlpha();
    mMatrix.set(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    } else {
        mHasClipRect = false;
        mClipRect.setEmpty();
    }
    mTransformationType = t.getTransformationType();
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.closeServerSocket:COMMENT
Method Modifier: default     static      internal    
Comment:/**
 * Close and clean up zygote sockets. Called on shutdown and on the
 * child's exit path.
 */

Body of Frist Method:
{
    try {
        if (sServerSocket != null) {
            sServerSocket.close();
        }
    } catch (IOException ex) {
        Log.e(TAG, "Zygote:  error closing sockets", ex);
    }
    sServerSocket = null;
}
Body of Second Method:
{
    try {
        if (sServerSocket != null) {
            FileDescriptor fd = sServerSocket.getFileDescriptor();
            sServerSocket.close();
            if (fd != null) {
                Os.close(fd);
            }
        }
    } catch (IOException ex) {
        Log.e(TAG, "Zygote:  error closing sockets", ex);
    } catch (ErrnoException ex) {
        Log.e(TAG, "Zygote:  error closing descriptor", ex);
    }
    sServerSocket = null;
}
------------------------
Find a functionally equivalent code:android.util.LongSparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealLongArraySize(mSize + 1);
            long[] nkeys = new long[n];
            Object[] nvalues = new Object[n];
            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:android.transition.Transition.end:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is called automatically by the Transition and
 * TransitionSet classes when a transition finishes, either because
 * a transition did nothing (returned a null Animator from
 * {@link Transition#createAnimator(ViewGroup, TransitionValues,
 * TransitionValues)}) or because the transition returned a valid
 * Animator and end() was called in the onAnimationEnd()
 * callback of the AnimatorListener.
 *
 * @hide
 */

Body of Frist Method:
{
    --mNumInstances;
    if (mNumInstances == 0) {
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionEnd(this);
            }
        }
        for (int i = 0; i < mStartValues.itemIdValues.size(); ++i) {
            TransitionValues tv = mStartValues.itemIdValues.valueAt(i);
            View v = tv.view;
            if (v.hasTransientState()) {
                v.setHasTransientState(false);
            }
        }
        for (int i = 0; i < mEndValues.itemIdValues.size(); ++i) {
            TransitionValues tv = mEndValues.itemIdValues.valueAt(i);
            View v = tv.view;
            if (v.hasTransientState()) {
                v.setHasTransientState(false);
            }
        }
        mEnded = true;
    }
}
Body of Second Method:
{
    --mNumInstances;
    if (mNumInstances == 0) {
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionEnd(this);
            }
        }
        for (int i = 0; i < mStartValues.itemIdValues.size(); ++i) {
            View view = mStartValues.itemIdValues.valueAt(i);
            if (view != null) {
                view.setHasTransientState(false);
            }
        }
        for (int i = 0; i < mEndValues.itemIdValues.size(); ++i) {
            View view = mEndValues.itemIdValues.valueAt(i);
            if (view != null) {
                view.setHasTransientState(false);
            }
        }
        mEnded = true;
    }
}
------------------------
Find a functionally equivalent code:android.os.PowerManager.validateWakeLockParameters:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
Body of Second Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
        case DOZE_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
------------------------
Find a functionally equivalent code:android.speech.tts.TextToSpeechService.SynthHandler.enqueueSpeechItem:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */

Body of Frist Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
}
Body of Second Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}
------------------------
Find a functionally equivalent code:android.media.Ringtone.play:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ringtone.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        // (typically because ringer mode is silent).
        if (mAudioManager.getStreamVolume(mStreamType) != 0) {
            mLocalPlayer.start();
        }
    } else if (mAllowRemote) {
        final Uri canonicalUri = mUri.getCanonicalUri();
        try {
            mRemotePlayer.play(mRemoteToken, canonicalUri, mStreamType);
        } catch (RemoteException e) {
            if (!playFallbackRingtone()) {
                Log.w(TAG, "Problem playing ringtone: " + e);
            }
        }
    } else {
        if (!playFallbackRingtone()) {
            Log.w(TAG, "Neither local nor remote playback available");
        }
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        // (typically because ringer mode is silent).
        if (mAudioManager.getStreamVolume(AudioAttributes.toLegacyStreamType(mAudioAttributes)) != 0) {
            mLocalPlayer.start();
        }
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        final Uri canonicalUri = mUri.getCanonicalUri();
        try {
            mRemotePlayer.play(mRemoteToken, canonicalUri, mAudioAttributes);
        } catch (RemoteException e) {
            if (!playFallbackRingtone()) {
                Log.w(TAG, "Problem playing ringtone: " + e);
            }
        }
    } else {
        if (!playFallbackRingtone()) {
            Log.w(TAG, "Neither local nor remote playback available");
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (s != null) {
        try {
            return Float.parseFloat(s);
        } catch (NumberFormatException e) {
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
        // we'll return the default value below.
        }
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    try {
        if (s != null) {
            return Float.parseFloat(s);
        }
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
    }
    return defValue;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (RenderResources.REFERENCE_NULL.equals(s)) {
        return defValue;
    }
    if (s == null || s.length() == 0) {
        return defValue;
    }
    try {
        return XmlUtils.convertValueToInt(s, defValue);
    } catch (NumberFormatException e) {
    // pass
    }
    // Field is not null and is not an integer.
    // Check for possible constants and try to find them.
    // Get the map of attribute-constant -> IntegerValue
    Map<String, Integer> map = null;
    if (mIsFramework[index]) {
        map = Bridge.getEnumValues(mNames[index]);
    } else {
        // get the styleable matching the resolved name
        RenderResources res = mContext.getRenderResources();
        ResourceValue attr = res.getProjectResource(ResourceType.ATTR, mNames[index]);
        if (attr instanceof AttrResourceValue) {
            map = ((AttrResourceValue) attr).getAttributeValues();
        }
    }
    if (map != null) {
        // accumulator to store the value of the 1+ constants.
        int result = 0;
        // split the value in case this is a mix of several flags.
        String[] keywords = s.split("\\|");
        for (String keyword : keywords) {
            Integer i = map.get(keyword.trim());
            if (i != null) {
                result |= i.intValue();
            } else {
                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" is not a valid value", keyword, mNames[index]), null);
            }
        }
        return result;
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    try {
        if (s != null) {
            return XmlUtils.convertValueToInt(s, defValue);
        }
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid integer", s, mNames[index]), null);
        return defValue;
    }
    return defValue;
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.cancelSync:COMMENT
Method Modifier: public      static      
Comment:/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */

Body of Frist Method:
{
    try {
        getContentService().cancelSync(account, authority);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        getContentService().cancelSync(account, authority, null);
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.widget.TextView.getExtendedPaddingBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended bottom padding of the view, including both the
 * bottom Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

Body of Frist Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}
Body of Second Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setModeInt:COMMENT
<android.media.AudioService: int setModeInt(int,IBinder,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
Comment:// any mode other than NORMAL.

Body of Frist Method:
{
    int newModeOwnerPid = 0;
    if (cb == null) {
        Log.e(TAG, "setModeInt() called with null binder");
        return newModeOwnerPid;
    }
    SetModeDeathHandler hdlr = null;
    Iterator iter = mSetModeDeathHandlers.iterator();
    while (iter.hasNext()) {
        SetModeDeathHandler h = (SetModeDeathHandler) iter.next();
        if (h.getPid() == pid) {
            hdlr = h;
            // Remove from client list so that it is re-inserted at top of list
            iter.remove();
            hdlr.getBinder().unlinkToDeath(hdlr, 0);
            break;
        }
    }
    int status = AudioSystem.AUDIO_STATUS_OK;
    do {
        if (mode == AudioSystem.MODE_NORMAL) {
            // get new mode from client at top the list if any
            if (!mSetModeDeathHandlers.isEmpty()) {
                hdlr = mSetModeDeathHandlers.get(0);
                cb = hdlr.getBinder();
                mode = hdlr.getMode();
            }
        } else {
            if (hdlr == null) {
                hdlr = new SetModeDeathHandler(cb, pid);
            }
            // Register for client death notification
            try {
                cb.linkToDeath(hdlr, 0);
            } catch (RemoteException e) {
                // Client has died!
                Log.w(TAG, "setMode() could not link to " + cb + " binder death");
            }
            // Last client to call setMode() is always at top of client list
            // as required by SetModeDeathHandler.binderDied()
            mSetModeDeathHandlers.add(0, hdlr);
            hdlr.setMode(mode);
        }
        if (mode != mMode) {
            status = AudioSystem.setPhoneState(mode);
            if (status == AudioSystem.AUDIO_STATUS_OK) {
                mMode = mode;
            } else {
                if (hdlr != null) {
                    mSetModeDeathHandlers.remove(hdlr);
                    cb.unlinkToDeath(hdlr, 0);
                }
                // force reading new top of mSetModeDeathHandlers stack
                mode = AudioSystem.MODE_NORMAL;
            }
        } else {
            status = AudioSystem.AUDIO_STATUS_OK;
        }
    } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
    if (status == AudioSystem.AUDIO_STATUS_OK) {
        if (mode != AudioSystem.MODE_NORMAL) {
            if (mSetModeDeathHandlers.isEmpty()) {
                Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
            } else {
                newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
            }
        }
        int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
        if (streamType == STREAM_REMOTE_MUSIC) {
            // here handle remote media playback the same way as local playback
            streamType = AudioManager.STREAM_MUSIC;
        }
        int device = getDeviceForStream(streamType);
        int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
        setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true);
        updateStreamVolumeAlias(true);
    }
    return newModeOwnerPid;
}
Body of Second Method:
{
    if (DEBUG_MODE) {
        Log.v(TAG, "setModeInt(mode=" + mode + ", pid=" + pid + ")");
    }
    int newModeOwnerPid = 0;
    if (cb == null) {
        Log.e(TAG, "setModeInt() called with null binder");
        return newModeOwnerPid;
    }
    SetModeDeathHandler hdlr = null;
    Iterator iter = mSetModeDeathHandlers.iterator();
    while (iter.hasNext()) {
        SetModeDeathHandler h = (SetModeDeathHandler) iter.next();
        if (h.getPid() == pid) {
            hdlr = h;
            // Remove from client list so that it is re-inserted at top of list
            iter.remove();
            hdlr.getBinder().unlinkToDeath(hdlr, 0);
            break;
        }
    }
    int status = AudioSystem.AUDIO_STATUS_OK;
    do {
        if (mode == AudioSystem.MODE_NORMAL) {
            // get new mode from client at top the list if any
            if (!mSetModeDeathHandlers.isEmpty()) {
                hdlr = mSetModeDeathHandlers.get(0);
                cb = hdlr.getBinder();
                mode = hdlr.getMode();
                if (DEBUG_MODE) {
                    Log.w(TAG, " using mode=" + mode + " instead due to death hdlr at pid=" + hdlr.mPid);
                }
            }
        } else {
            if (hdlr == null) {
                hdlr = new SetModeDeathHandler(cb, pid);
            }
            // Register for client death notification
            try {
                cb.linkToDeath(hdlr, 0);
            } catch (RemoteException e) {
                // Client has died!
                Log.w(TAG, "setMode() could not link to " + cb + " binder death");
            }
            // Last client to call setMode() is always at top of client list
            // as required by SetModeDeathHandler.binderDied()
            mSetModeDeathHandlers.add(0, hdlr);
            hdlr.setMode(mode);
        }
        if (mode != mMode) {
            status = AudioSystem.setPhoneState(mode);
            if (status == AudioSystem.AUDIO_STATUS_OK) {
                if (DEBUG_MODE) {
                    Log.v(TAG, " mode successfully set to " + mode);
                }
                mMode = mode;
            } else {
                if (hdlr != null) {
                    mSetModeDeathHandlers.remove(hdlr);
                    cb.unlinkToDeath(hdlr, 0);
                }
                // force reading new top of mSetModeDeathHandlers stack
                if (DEBUG_MODE) {
                    Log.w(TAG, " mode set to MODE_NORMAL after phoneState pb");
                }
                mode = AudioSystem.MODE_NORMAL;
            }
        } else {
            status = AudioSystem.AUDIO_STATUS_OK;
        }
    } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
    if (status == AudioSystem.AUDIO_STATUS_OK) {
        if (mode != AudioSystem.MODE_NORMAL) {
            if (mSetModeDeathHandlers.isEmpty()) {
                Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
            } else {
                newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
            }
        }
        int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
        int device = getDeviceForStream(streamType);
        int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
        setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true);
        updateStreamVolumeAlias(true);
    }
    return newModeOwnerPid;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiConfiguration.getKeyIdForCredentials:COMMENT
<android.net.wifi.WifiConfiguration: String getKeyIdForCredentials(WifiConfiguration)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Get an identifier for associating credentials with this config
 * @param current configuration contains values for additional fields
 * that are not part of this configuration. Used
 * when a config with some fields is passed by an application.
 * @throws IllegalStateException if config is invalid for key id generation
 * @hide
 */

Body of Frist Method:
{
    String keyMgmt = null;
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
Body of Second Method:
{
    String keyMgmt = null;
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.getAppWidgetIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.safeCharSequence:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Make sure this CharSequence is safe to put into a bundle, which basically
 * means it had better not be some custom Parcelable implementation.
 * @hide
 */

Body of Frist Method:
{
    if (cs instanceof Parcelable) {
        Log.e(TAG, "warning: " + cs.getClass().getCanonicalName() + " instance is a custom Parcelable and not allowed in Notification");
        return cs.toString();
    }
    return cs;
}
Body of Second Method:
{
    if (cs == null)
        return cs;
    if (cs.length() > MAX_CHARSEQUENCE_LENGTH) {
        cs = cs.subSequence(0, MAX_CHARSEQUENCE_LENGTH);
    }
    if (cs instanceof Parcelable) {
        Log.e(TAG, "warning: " + cs.getClass().getCanonicalName() + " instance is a custom Parcelable and not allowed in Notification");
        return cs.toString();
    }
    return cs;
}
------------------------
Find a functionally equivalent code:android.util.SparseIntArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            int[] nvalues = new int[n];
            // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseIntArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.setThumbPos:COMMENT
Method Modifier: private     
Comment:/**
 * Positions the thumb and preview widgets.
 *
 * @param position The position, between 0 and 1, along the track at which
 * to place the thumb.
 */

Body of Frist Method:
{
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final ImageView trackImage = mTrackImage;
    final ImageView thumbImage = mThumbImage;
    final float min = trackImage.getTop();
    final float max = trackImage.getBottom();
    final float offset = min;
    final float range = max - min;
    final float thumbMiddle = position * range + offset;
    thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
    final float previewPos = mOverlayPosition == OVERLAY_AT_THUMB ? thumbMiddle : 0;
    // Center the preview on the thumb, constrained to the list bounds.
    final ImageView previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
Body of Second Method:
{
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final View trackImage = mTrackImage;
    final View thumbImage = mThumbImage;
    final float min = trackImage.getTop();
    final float max = trackImage.getBottom();
    final float offset = min;
    final float range = max - min;
    final float thumbMiddle = position * range + offset;
    thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
    final View previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float previewPos;
    switch(mOverlayPosition) {
        case OVERLAY_AT_THUMB:
            previewPos = thumbMiddle;
            break;
        case OVERLAY_ABOVE_THUMB:
            previewPos = thumbMiddle - previewHalfHeight;
            break;
        case OVERLAY_FLOATING:
        default:
            previewPos = 0;
            break;
    }
    // Center the preview on the thumb, constrained to the list bounds.
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.analyze:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the analysis using parameters from the constructor.
 * Fills the generator with classes & dependencies found.
 */

Body of Frist Method:
{
    Map<String, ClassReader> zipClasses = parseZip(mOsSourceJar);
    mLog.info("Found %d classes in input JAR%s.", zipClasses.size(), mOsSourceJar.size() > 1 ? "s" : "");
    Map<String, ClassReader> found = findIncludes(zipClasses);
    Map<String, ClassReader> deps = findDeps(zipClasses, found);
    if (mGen != null) {
        mGen.setKeep(found);
        mGen.setDeps(deps);
    }
}
Body of Second Method:
{
    TreeMap<String, ClassReader> zipClasses = new TreeMap<String, ClassReader>();
    Map<String, InputStream> filesFound = new TreeMap<String, InputStream>();
    parseZip(mOsSourceJar, zipClasses, filesFound);
    mLog.info("Found %d classes in input JAR%s.", zipClasses.size(), mOsSourceJar.size() > 1 ? "s" : "");
    Map<String, ClassReader> found = findIncludes(zipClasses);
    Map<String, ClassReader> deps = findDeps(zipClasses, found);
    if (mGen != null) {
        mGen.setKeep(found);
        mGen.setDeps(deps);
        mGen.setCopyFiles(filesFound);
        mGen.setRewriteMethodCallClasses(mReplaceMethodCallClasses);
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.setClipChildren:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to their bounds before drawing. This
 * allows view groups to override this behavior for animations, etc.
 *
 * @param clipChildren true to clip children to their bounds,
 * false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipChildren
 */

Body of Frist Method:
{
    boolean previousValue = (mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN;
    if (clipChildren != previousValue) {
        setBooleanFlag(FLAG_CLIP_CHILDREN, clipChildren);
        for (int i = 0; i < mChildrenCount; ++i) {
            View child = getChildAt(i);
            if (child.mDisplayList != null) {
                child.mDisplayList.setClipToBounds(clipChildren);
            }
        }
    }
}
Body of Second Method:
{
    boolean previousValue = (mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN;
    if (clipChildren != previousValue) {
        setBooleanFlag(FLAG_CLIP_CHILDREN, clipChildren);
        for (int i = 0; i < mChildrenCount; ++i) {
            View child = getChildAt(i);
            if (child.mRenderNode != null) {
                child.mRenderNode.setClipToBounds(clipChildren);
            }
        }
        invalidate(true);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handlePokeWakelock:COMMENT
Method Modifier: 
Comment:/**
 * If the screen is on, pokes the wakelock to keep the screen alive and active for a specific
 * amount of time.
 */

Body of Frist Method:
{
    PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    if (powerManager.isScreenOn()) {
        mKeyguardScreenCallback.userActivity(millis);
    }
}
Body of Second Method:
{
    PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    if (powerManager.isScreenOn()) {
        mKeyguardScreenCallback.userActivity();
    }
}
------------------------
Find a functionally equivalent code:android.widget.ListPopupWindow.ForwardingListener.onTouchObserved:COMMENT
Method Modifier: private     
Comment:/**
 * Observes motion events and determines when to start forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to start forwarding motion events, false otherwise
 */

Body of Frist Method:
{
    final View src = mSrc;
    if (!src.isEnabled()) {
        return false;
    }
    final int actionMasked = srcEvent.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            mActivePointerId = srcEvent.getPointerId(0);
            if (mDisallowIntercept == null) {
                mDisallowIntercept = new DisallowIntercept();
            }
            src.postDelayed(mDisallowIntercept, mTapTimeout);
            break;
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
            if (activePointerIndex >= 0) {
                final float x = srcEvent.getX(activePointerIndex);
                final float y = srcEvent.getY(activePointerIndex);
                if (!src.pointInView(x, y, mScaledTouchSlop)) {
                    // The pointer has moved outside of the view.
                    if (mDisallowIntercept != null) {
                        src.removeCallbacks(mDisallowIntercept);
                    }
                    src.getParent().requestDisallowInterceptTouchEvent(true);
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            if (mDisallowIntercept != null) {
                src.removeCallbacks(mDisallowIntercept);
            }
            break;
    }
    return false;
}
Body of Second Method:
{
    final View src = mSrc;
    if (!src.isEnabled()) {
        return false;
    }
    final int actionMasked = srcEvent.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            mActivePointerId = srcEvent.getPointerId(0);
            mWasLongPress = false;
            if (mDisallowIntercept == null) {
                mDisallowIntercept = new DisallowIntercept();
            }
            src.postDelayed(mDisallowIntercept, mTapTimeout);
            if (mTriggerLongPress == null) {
                mTriggerLongPress = new TriggerLongPress();
            }
            src.postDelayed(mTriggerLongPress, mLongPressTimeout);
            break;
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
            if (activePointerIndex >= 0) {
                final float x = srcEvent.getX(activePointerIndex);
                final float y = srcEvent.getY(activePointerIndex);
                // Has the pointer has moved outside of the view?
                if (!src.pointInView(x, y, mScaledTouchSlop)) {
                    clearCallbacks();
                    // Don't let the parent intercept our events.
                    src.getParent().requestDisallowInterceptTouchEvent(true);
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            clearCallbacks();
            break;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.os.ParcelFileDescriptor.createReliablePipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.invalidateChild:COMMENT
Method Modifier: public      final       
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 */

Body of Frist Method:
{
    ViewParent parent = this;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            child.mLocalDirtyRect.union(dirty);
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
                }
            }
        } while (parent != null);
    }
}
Body of Second Method:
{
    ViewParent parent = this;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
                }
            }
        } while (parent != null);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.ni:COMMENT
Method Modifier: default     final       
Comment:/* package */

Body of Frist Method:
{
    return mNativeBitmap;
}
Body of Second Method:
{
    return mNativeBitmap;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mSize >= mKeys.length && (mGarbage || hasReclaimedRefs())) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        WeakReference<?>[] nvalues = new WeakReference[n];
        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = new WeakReference(value);
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mSize >= mKeys.length && (mGarbage || hasReclaimedRefs())) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, new WeakReference(value));
    mSize++;
}
------------------------
Find a functionally equivalent code:android.net.http.CertificateChainValidator.handleTrustStorageUpdate:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles updates to credential storage.
 */

Body of Frist Method:
{
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.handleTrustStorageUpdate();
        }
    } catch (KeyManagementException ignored) {
    }
}
Body of Second Method:
{
    TrustManagerFactory tmf;
    try {
        tmf = TrustManagerFactory.getInstance("X.509");
        tmf.init((KeyStore) null);
    } catch (NoSuchAlgorithmException e) {
        Slog.w(TAG, "Couldn't find default X.509 TrustManagerFactory");
        return;
    } catch (KeyStoreException e) {
        Slog.w(TAG, "Couldn't initialize default X.509 TrustManagerFactory", e);
        return;
    }
    TrustManager[] tms = tmf.getTrustManagers();
    boolean sentUpdate = false;
    for (TrustManager tm : tms) {
        try {
            Method updateMethod = tm.getClass().getDeclaredMethod("handleTrustStorageUpdate");
            updateMethod.setAccessible(true);
            updateMethod.invoke(tm);
            sentUpdate = true;
        } catch (Exception e) {
        }
    }
    if (!sentUpdate) {
        Slog.w(TAG, "Didn't find a TrustManager to handle CA list update");
    }
}
------------------------
Find a functionally equivalent code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<View, TransitionValues> endCopy = new ArrayMap<View, TransitionValues>(endValues.viewValues);
    SparseArray<TransitionValues> endIdCopy = new SparseArray<TransitionValues>(endValues.idValues.size());
    for (int i = 0; i < endValues.idValues.size(); ++i) {
        int id = endValues.idValues.keyAt(i);
        endIdCopy.put(id, endValues.idValues.valueAt(i));
    }
    LongSparseArray<TransitionValues> endItemIdCopy = new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
    for (int i = 0; i < endValues.itemIdValues.size(); ++i) {
        long id = endValues.itemIdValues.keyAt(i);
        endItemIdCopy.put(id, endValues.itemIdValues.valueAt(i));
    }
    // Walk through the start values, playing everything we find
    // Remove from the end set as we go
    ArrayList<TransitionValues> startValuesList = new ArrayList<TransitionValues>();
    ArrayList<TransitionValues> endValuesList = new ArrayList<TransitionValues>();
    for (View view : startValues.viewValues.keySet()) {
        TransitionValues start = null;
        TransitionValues end = null;
        boolean isInListView = false;
        if (view.getParent() instanceof ListView) {
            isInListView = true;
        }
        if (!isInListView) {
            int id = view.getId();
            start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
            if (endValues.viewValues.get(view) != null) {
                end = endValues.viewValues.get(view);
                endCopy.remove(view);
            } else if (id != View.NO_ID) {
                end = endValues.idValues.get(id);
                View removeView = null;
                for (View viewToRemove : endCopy.keySet()) {
                    if (viewToRemove.getId() == id) {
                        removeView = viewToRemove;
                    }
                }
                if (removeView != null) {
                    endCopy.remove(removeView);
                }
            }
            endIdCopy.remove(id);
            if (isValidTarget(view, id)) {
                startValuesList.add(start);
                endValuesList.add(end);
            }
        } else {
            ListView parent = (ListView) view.getParent();
            if (parent.getAdapter().hasStableIds()) {
                int position = parent.getPositionForView(view);
                long itemId = parent.getItemIdAtPosition(position);
                start = startValues.itemIdValues.get(itemId);
                endItemIdCopy.remove(itemId);
                // TODO: deal with targetIDs for itemIDs for ListView items
                startValuesList.add(start);
                endValuesList.add(end);
            }
        }
    }
    int startItemIdCopySize = startValues.itemIdValues.size();
    for (int i = 0; i < startItemIdCopySize; ++i) {
        long id = startValues.itemIdValues.keyAt(i);
        if (isValidTarget(null, id)) {
            TransitionValues start = startValues.itemIdValues.get(id);
            TransitionValues end = endValues.itemIdValues.get(id);
            endItemIdCopy.remove(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    // Now walk through the remains of the end set
    for (View view : endCopy.keySet()) {
        int id = view.getId();
        if (isValidTarget(view, id)) {
            TransitionValues start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
            TransitionValues end = endCopy.get(view);
            endIdCopy.remove(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    int endIdCopySize = endIdCopy.size();
    for (int i = 0; i < endIdCopySize; ++i) {
        int id = endIdCopy.keyAt(i);
        if (isValidTarget(null, id)) {
            TransitionValues start = startValues.idValues.get(id);
            TransitionValues end = endIdCopy.get(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    int endItemIdCopySize = endItemIdCopy.size();
    for (int i = 0; i < endItemIdCopySize; ++i) {
        long id = endItemIdCopy.keyAt(i);
        // TODO: Deal with targetIDs and itemIDs
        TransitionValues start = startValues.itemIdValues.get(id);
        TransitionValues end = endItemIdCopy.get(id);
        startValuesList.add(start);
        endValuesList.add(end);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    for (int i = 0; i < startValuesList.size(); ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        // Only bother trying to animate with values that differ between start/end
        if (start != null || end != null) {
            if (start == null || !start.equals(end)) {
                if (DBG) {
                    View view = (end != null) ? end.view : start.view;
                    Log.d(LOG_TAG, "  differing start/end values for view " + view);
                    if (start == null || end == null) {
                        Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                    } else {
                        for (String key : start.values.keySet()) {
                            Object startValue = start.values.get(key);
                            Object endValue = end.values.get(key);
                            if (startValue != endValue && !startValue.equals(endValue)) {
                                Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                            }
                        }
                    }
                }
                // TODO: what to do about targetIds and itemIds?
                Animator animator = createAnimator(sceneRoot, start, end);
                if (animator != null) {
                    // Save animation info for future cancellation purposes
                    View view = null;
                    TransitionValues infoValues = null;
                    if (end != null) {
                        view = end.view;
                        String[] properties = getTransitionProperties();
                        if (view != null && properties != null && properties.length > 0) {
                            infoValues = new TransitionValues();
                            infoValues.view = view;
                            TransitionValues newValues = endValues.viewValues.get(view);
                            if (newValues != null) {
                                for (int j = 0; j < properties.length; ++j) {
                                    infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                                }
                            }
                            int numExistingAnims = runningAnimators.size();
                            for (int j = 0; j < numExistingAnims; ++j) {
                                Animator anim = runningAnimators.keyAt(j);
                                AnimationInfo info = runningAnimators.get(anim);
                                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                    if (info.values.equals(infoValues)) {
                                        // Favor the old animator
                                        animator = null;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        view = (start != null) ? start.view : null;
                    }
                    if (animator != null) {
                        AnimationInfo info = new AnimationInfo(view, getName(), infoValues);
                        runningAnimators.put(animator, info);
                        mAnimators.add(animator);
                    }
                }
            }
        }
    }
}
Body of Second Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || areValuesChanged(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (minStartDelay != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link NumberPicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param minDate The minimal supported date.
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    mCalendarView.setMinDate(minDate);
    if (mCurrentDate.before(mMinDate)) {
        mCurrentDate.setTimeInMillis(mMinDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}
Body of Second Method:
{
    mDelegate.setMinDate(minDate);
}
------------------------
Find a functionally equivalent code:android.preference.PreferenceActivity.loadHeadersFromResource:COMMENT
Method Modifier: public      
Comment:/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */

Body of Frist Method:
{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!"preference-headers".equals(nodeName)) {
            throw new RuntimeException("XML document must start with <preference-headers> tag; found" + nodeName + " at " + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if ("header".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals("extra")) {
                        getResources().parseBundleExtra("extra", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals("intent")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException("Error parsing headers", e);
    } catch (IOException e) {
        throw new RuntimeException("Error parsing headers", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}
Body of Second Method:
{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!"preference-headers".equals(nodeName)) {
            throw new RuntimeException("XML document must start with <preference-headers> tag; found" + nodeName + " at " + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if ("header".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = obtainStyledAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals("extra")) {
                        getResources().parseBundleExtra("extra", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals("intent")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException("Error parsing headers", e);
    } catch (IOException e) {
        throw new RuntimeException("Error parsing headers", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.showBootMessage:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mHeadless)
        return;
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                mBootMsgDialog = new ProgressDialog(mContext) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            mBootMsgDialog.setMessage(msg);
        }
    });
}
Body of Second Method:
{
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                int theme;
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                } else {
                    theme = 0;
                }
                mBootMsgDialog = new ProgressDialog(mContext, theme) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            mBootMsgDialog.setMessage(msg);
        }
    });
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #getDocumentType(String)
 */

Body of Frist Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during getType", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during getType", e);
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.view.animation.Transformation.compose:COMMENT
Method Modifier: public      
Comment:/**
 * Apply this Transformation to an existing Transformation, e.g. apply
 * a scale effect to something that has already been rotated.
 * @param t
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
------------------------
Find a functionally equivalent code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return available_native(fd);
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    return available_native(myFd);
}
------------------------
Find a functionally equivalent code:android.text.Layout.getParagraphLeadingMargin:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the effective leading margin (unsigned) for this line,
 * taking into account LeadingMarginSpan and LeadingMarginSpan2.
 * @param line the line index
 * @return the leading margin of this line
 */

Body of Frist Method:
{
    if (!mSpannedText) {
        return 0;
    }
    Spanned spanned = (Spanned) mText;
    int lineStart = getLineStart(line);
    int lineEnd = getLineEnd(line);
    int spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.class);
    LeadingMarginSpan[] spans = getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.class);
    if (spans.length == 0) {
        // no leading margin span;
        return 0;
    }
    int margin = 0;
    boolean isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
    for (int i = 0; i < spans.length; i++) {
        LeadingMarginSpan span = spans[i];
        boolean useFirstLineMargin = isFirstParaLine;
        if (span instanceof LeadingMarginSpan2) {
            int spStart = spanned.getSpanStart(span);
            int spanLine = getLineForOffset(spStart);
            int count = ((LeadingMarginSpan2) span).getLeadingMarginLineCount();
            useFirstLineMargin = line < spanLine + count;
        }
        margin += span.getLeadingMargin(useFirstLineMargin);
    }
    return margin;
}
Body of Second Method:
{
    if (!mSpannedText) {
        return 0;
    }
    Spanned spanned = (Spanned) mText;
    int lineStart = getLineStart(line);
    int lineEnd = getLineEnd(line);
    int spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.class);
    LeadingMarginSpan[] spans = getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.class);
    if (spans.length == 0) {
        // no leading margin span;
        return 0;
    }
    int margin = 0;
    boolean isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
    boolean useFirstLineMargin = isFirstParaLine;
    for (int i = 0; i < spans.length; i++) {
        if (spans[i] instanceof LeadingMarginSpan2) {
            int spStart = spanned.getSpanStart(spans[i]);
            int spanLine = getLineForOffset(spStart);
            int count = ((LeadingMarginSpan2) spans[i]).getLeadingMarginLineCount();
            // if there is more than one LeadingMarginSpan2, use the count that is greatest
            useFirstLineMargin |= line < spanLine + count;
        }
    }
    for (int i = 0; i < spans.length; i++) {
        LeadingMarginSpan span = spans[i];
        margin += span.getLeadingMargin(useFirstLineMargin);
    }
    return margin;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyDown:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * A key was pressed down and not handled by anything else in the window.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */

Body of Frist Method:
{
    /* ****************************************************************************
         * HOW TO DECIDE WHERE YOUR KEY HANDLING GOES.
         *
         * If your key handling must happen before the app gets a crack at the event,
         * it goes in PhoneWindowManager.
         *
         * If your key handling should happen in all windows, and does not depend on
         * the state of the current application, other than that the current
         * application can override the behavior by handling the event itself, it
         * should go in PhoneFallbackEventHandler.
         *
         * Only if your handling depends on the window, and the fact that it has
         * a DecorView, should it go here.
         * ****************************************************************************/
    final KeyEvent.DispatcherState dispatcher = mDecor != null ? mDecor.getKeyDispatcherState() : null;
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                // Similar code is in PhoneFallbackEventHandler in case the window
                // doesn't have one of these.  In this case, we execute it here and
                // eat the event instead, because we have mVolumeControlStreamType
                // and they don't.
                getAudioManager().handleKeyDown(event, mVolumeControlStreamType);
                return true;
            }
        case KeyEvent.KEYCODE_MENU:
            {
                onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId, event);
                return true;
            }
        case KeyEvent.KEYCODE_BACK:
            {
                if (event.getRepeatCount() > 0)
                    break;
                if (featureId < 0)
                    break;
                // Currently don't do anything with long press.
                if (dispatcher != null) {
                    dispatcher.startTracking(event, this);
                }
                return true;
            }
    }
    return false;
}
Body of Second Method:
{
    /* ****************************************************************************
         * HOW TO DECIDE WHERE YOUR KEY HANDLING GOES.
         *
         * If your key handling must happen before the app gets a crack at the event,
         * it goes in PhoneWindowManager.
         *
         * If your key handling should happen in all windows, and does not depend on
         * the state of the current application, other than that the current
         * application can override the behavior by handling the event itself, it
         * should go in PhoneFallbackEventHandler.
         *
         * Only if your handling depends on the window, and the fact that it has
         * a DecorView, should it go here.
         * ****************************************************************************/
    final KeyEvent.DispatcherState dispatcher = mDecor != null ? mDecor.getKeyDispatcherState() : null;
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            {
                int direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
                // use the suggested stream.
                if (mMediaController != null) {
                    mMediaController.adjustVolume(direction, AudioManager.FLAG_SHOW_UI);
                } else {
                    MediaSessionLegacyHelper.getHelper(getContext()).sendAdjustVolumeBy(mVolumeControlStreamType, direction, AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
                }
                return true;
            }
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                getAudioManager().handleKeyDown(event, mVolumeControlStreamType);
                return true;
            }
        // KeyEvent.isMediaKey()
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
            {
                if (mMediaController != null) {
                    if (mMediaController.dispatchMediaButtonEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
        case KeyEvent.KEYCODE_MENU:
            {
                onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId, event);
                return true;
            }
        case KeyEvent.KEYCODE_BACK:
            {
                if (event.getRepeatCount() > 0)
                    break;
                if (featureId < 0)
                    break;
                // Currently don't do anything with long press.
                if (dispatcher != null) {
                    dispatcher.startTracking(event, this);
                }
                return true;
            }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.createTheme:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        int res = newTheme();
        incRefsLocked(res);
        return res;
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        long res = newTheme();
        incRefsLocked(res);
        return res;
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */

Body of Frist Method:
{
    onUserInteraction();
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
Body of Second Method:
{
    onUserInteraction();
    // the window handling it
    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
------------------------
Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDevice.updateSupplicantDetails:COMMENT
<android.net.wifi.p2p.WifiP2pDevice: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Updates details obtained from supplicant @hide
 */

Body of Frist Method:
{
    if (device == null) {
        throw new IllegalArgumentException("device is null");
    }
    if (device.deviceAddress == null) {
        throw new IllegalArgumentException("deviceAddress is null");
    }
    if (!deviceAddress.equals(device.deviceAddress)) {
        throw new IllegalArgumentException("deviceAddress does not match");
    }
    deviceName = device.deviceName;
    primaryDeviceType = device.primaryDeviceType;
    secondaryDeviceType = device.secondaryDeviceType;
    wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;
    deviceCapability = device.deviceCapability;
    groupCapability = device.groupCapability;
    wfdInfo = device.wfdInfo;
}
Body of Second Method:
{
    if (device == null) {
        throw new IllegalArgumentException("device is null");
    }
    if (device.deviceAddress == null) {
        throw new IllegalArgumentException("deviceAddress is null");
    }
    if (!deviceAddress.equals(device.deviceAddress)) {
        throw new IllegalArgumentException("deviceAddress does not match");
    }
    deviceName = device.deviceName;
    primaryDeviceType = device.primaryDeviceType;
    secondaryDeviceType = device.secondaryDeviceType;
    wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;
    deviceCapability = device.deviceCapability;
    groupCapability = device.groupCapability;
    wfdInfo = device.wfdInfo;
}
------------------------
Find a functionally equivalent code:android.graphics.Typeface.createFromAsset:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new typeface from the specified font data.
 * @param mgr The application's asset manager
 * @param path  The file name of the font data in the assets directory
 * @return The new typeface.
 */

Body of Frist Method:
{
    return new Typeface(nativeCreateFromAsset(mgr, path));
}
Body of Second Method:
{
    if (sFallbackFonts != null) {
        FontFamily fontFamily = new FontFamily();
        if (fontFamily.addFontFromAsset(mgr, path)) {
            FontFamily[] families = { fontFamily };
            return createFromFamiliesWithDefault(families);
        }
    }
    throw new RuntimeException("Font asset not found " + path);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the week numbers.
 *
 * @return The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

Body of Frist Method:
{
    return mWeekNumberColor;
}
Body of Second Method:
{
    return mDelegate.getWeekNumberColor();
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getKeyguardStoredPasswordQuality:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Retrieves the quality mode we're in.
 * {@see DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}
 *
 * @return stored password quality
 */

Body of Frist Method:
{
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    // method and treat biometric as a special case.
    if (quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
        quality = (int) getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    }
    return quality;
}
Body of Second Method:
{
    return getKeyguardStoredPasswordQuality(getCurrentOrCallingUserId());
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.setAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color's alpha value.
 *
 * @param alpha The alpha value to set, between 0 and 255.
 */

Body of Frist Method:
{
    // make it 0..256
    alpha += alpha >> 7;
    int baseAlpha = mState.mBaseColor >>> 24;
    int useAlpha = baseAlpha * alpha >> 8;
    int oldUseColor = mState.mUseColor;
    mState.mUseColor = (mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
    if (oldUseColor != mState.mUseColor) {
        invalidateSelf();
    }
}
Body of Second Method:
{
    // make it 0..256
    alpha += alpha >> 7;
    final int baseAlpha = mColorState.mBaseColor >>> 24;
    final int useAlpha = baseAlpha * alpha >> 8;
    final int useColor = (mColorState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
    if (mColorState.mUseColor != useColor) {
        mColorState.mUseColor = useColor;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsContract.getRootId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.
 */

Body of Frist Method:
{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() < 2) {
        throw new IllegalArgumentException("Not a root: " + rootUri);
    }
    if (!PATH_ROOT.equals(paths.get(0))) {
        throw new IllegalArgumentException("Not a root: " + rootUri);
    }
    return paths.get(1);
}
Body of Second Method:
{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() >= 2 && PATH_ROOT.equals(paths.get(0))) {
        return paths.get(1);
    }
    throw new IllegalArgumentException("Invalid URI: " + rootUri);
}
------------------------
Find a functionally equivalent code:android.app.backup.BackupAgent.fullBackupFileTree:COMMENT
Method Modifier: protected   final       hidden      
Comment:/**
 * Scan the dir tree (if it actually exists) and process each entry we find.  If the
 * 'excludes' parameter is non-null, it is consulted each time a new file system entity
 * is visited to see whether that entity (and its subtree, if appropriate) should be
 * omitted from the backup process.
 *
 * @hide
 */

Body of Frist Method:
{
    File rootFile = new File(rootPath);
    if (rootFile.exists()) {
        LinkedList<File> scanQueue = new LinkedList<File>();
        scanQueue.add(rootFile);
        while (scanQueue.size() > 0) {
            File file = scanQueue.remove(0);
            String filePath;
            try {
                filePath = file.getCanonicalPath();
                // prune this subtree?
                if (excludes != null && excludes.contains(filePath)) {
                    continue;
                }
                // If it's a directory, enqueue its contents for scanning.
                StructStat stat = Libcore.os.lstat(filePath);
                if (OsConstants.S_ISLNK(stat.st_mode)) {
                    if (DEBUG)
                        Log.i(TAG, "Symlink (skipping)!: " + file);
                    continue;
                } else if (OsConstants.S_ISDIR(stat.st_mode)) {
                    File[] contents = file.listFiles();
                    if (contents != null) {
                        for (File entry : contents) {
                            scanQueue.add(0, entry);
                        }
                    }
                }
            } catch (IOException e) {
                if (DEBUG)
                    Log.w(TAG, "Error canonicalizing path of " + file);
                continue;
            } catch (ErrnoException e) {
                if (DEBUG)
                    Log.w(TAG, "Error scanning file " + file + " : " + e);
                continue;
            }
            // Finally, back this file up before proceeding
            FullBackup.backupToTar(packageName, domain, null, rootPath, filePath, output.getData());
        }
    }
}
Body of Second Method:
{
    File rootFile = new File(rootPath);
    if (rootFile.exists()) {
        LinkedList<File> scanQueue = new LinkedList<File>();
        scanQueue.add(rootFile);
        while (scanQueue.size() > 0) {
            File file = scanQueue.remove(0);
            String filePath;
            try {
                filePath = file.getCanonicalPath();
                // prune this subtree?
                if (excludes != null && excludes.contains(filePath)) {
                    continue;
                }
                // If it's a directory, enqueue its contents for scanning.
                StructStat stat = Os.lstat(filePath);
                if (OsConstants.S_ISLNK(stat.st_mode)) {
                    if (DEBUG)
                        Log.i(TAG, "Symlink (skipping)!: " + file);
                    continue;
                } else if (OsConstants.S_ISDIR(stat.st_mode)) {
                    File[] contents = file.listFiles();
                    if (contents != null) {
                        for (File entry : contents) {
                            scanQueue.add(0, entry);
                        }
                    }
                }
            } catch (IOException e) {
                if (DEBUG)
                    Log.w(TAG, "Error canonicalizing path of " + file);
                continue;
            } catch (ErrnoException e) {
                if (DEBUG)
                    Log.w(TAG, "Error scanning file " + file + " : " + e);
                continue;
            }
            // Finally, back this file up before proceeding
            FullBackup.backupToTar(packageName, domain, null, rootPath, filePath, output.getData());
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.RemoteController.getEstimatedMediaPosition:COMMENT
Method Modifier: public      
Comment:/**
 * Return the estimated playback position of the current media track or a negative value
 * if not available.
 *
 * <p>The value returned is estimated by the current process and may not be perfect.
 * The time returned by this method is calculated from the last state change time based
 * on the current play position at that time and the last known playback speed.
 * An application may call {@link #setSynchronizationMode(int)} to apply
 * a synchronization policy that will periodically re-sync the estimated position
 * with the RemoteControlClient.</p>
 *
 * @return the current estimated playback position in milliseconds or a negative value
 * if not available
 *
 * @see OnClientUpdateListener#onClientPlaybackStateUpdate(int, long, long, float)
 */

Body of Frist Method:
{
    if (mLastPlaybackInfo != null) {
        if (!RemoteControlClient.playbackPositionShouldMove(mLastPlaybackInfo.mState)) {
            return mLastPlaybackInfo.mCurrentPosMs;
        }
        // Take the current position at the time of state change and estimate.
        final long thenPos = mLastPlaybackInfo.mCurrentPosMs;
        if (thenPos < 0) {
            return -1;
        }
        final long now = SystemClock.elapsedRealtime();
        final long then = mLastPlaybackInfo.mStateChangeTimeMs;
        final long sinceThen = now - then;
        final long scaledSinceThen = (long) (sinceThen * mLastPlaybackInfo.mSpeed);
        return thenPos + scaledSinceThen;
    }
    return -1;
}
Body of Second Method:
{
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                PlaybackState state = mCurrentSession.getPlaybackState();
                if (state != null) {
                    return state.getPosition();
                }
            }
        }
    } else {
        final PlaybackInfo lastPlaybackInfo;
        synchronized (mInfoLock) {
            lastPlaybackInfo = mLastPlaybackInfo;
        }
        if (lastPlaybackInfo != null) {
            if (!RemoteControlClient.playbackPositionShouldMove(lastPlaybackInfo.mState)) {
                return lastPlaybackInfo.mCurrentPosMs;
            }
            // Take the current position at the time of state change and
            // estimate.
            final long thenPos = lastPlaybackInfo.mCurrentPosMs;
            if (thenPos < 0) {
                return -1;
            }
            final long now = SystemClock.elapsedRealtime();
            final long then = lastPlaybackInfo.mStateChangeTimeMs;
            final long sinceThen = now - then;
            final long scaledSinceThen = (long) (sinceThen * lastPlaybackInfo.mSpeed);
            return thenPos + scaledSinceThen;
        }
    }
    return -1;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setRingerMode(int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != getRingerMode()) {
        setRingerModeInt(ringerMode, true);
        // Send sticky broadcast
        broadcastRingerMode(ringerMode);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume || isPlatformTelevision()) {
        return;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (checkZen) {
        checkZen(ringerMode);
    }
    if (ringerMode != getRingerMode()) {
        setRingerModeInt(ringerMode, true);
        // Send sticky broadcast
        broadcastRingerMode(ringerMode);
    }
}
------------------------
Find a functionally equivalent code:com.android.smoketest.ProcessErrorsTest.runOneActivity:COMMENT
Method Modifier: public      
Comment:/**
 * A method to run the specified Activity and return a {@link Collection} of the Activities that
 * were in an error state, as listed by {@link ActivityManager.getProcessesInErrorState()}.
 * <p />
 * The method will launch the app, wait for 7 seconds, check for apps in the error state, send
 * the Home intent, wait for 2 seconds, and then return.
 */

Body of Frist Method:
{
    final long appLaunchWait = 7000;
    final long homeLaunchWait = 2000;
    Log.i(TAG, String.format("Running activity %s/%s", app.activityInfo.packageName, app.activityInfo.name));
    // We check for any Crash or ANR dialogs that are already up, and we ignore them.  This is
    // so that we don't report crashes that were caused by prior apps (which those particular
    // tests should have caught and reported already).
    final Collection<ProcessError> preErrProcs = ProcessError.fromCollection(mActivityManager.getProcessesInErrorState());
    // launch app, and wait 7 seconds for it to start/settle
    final Intent intent = intentForActivity(app);
    getContext().startActivity(intent);
    try {
        Thread.sleep(appLaunchWait);
    } catch (InterruptedException e) {
    // ignore
    }
    // Send the "home" intent and wait 2 seconds for us to get there
    getContext().startActivity(mHomeIntent);
    try {
        Thread.sleep(homeLaunchWait);
    } catch (InterruptedException e) {
    // ignore
    }
    // See if there are any errors.  We wait until down here to give ANRs as much time as
    // possible to occur.
    final Collection<ProcessError> errProcs = ProcessError.fromCollection(mActivityManager.getProcessesInErrorState());
    // crash package name against the package name for {@code app}
    if (errProcs != null) {
        Iterator<ProcessError> errIter = errProcs.iterator();
        while (errIter.hasNext()) {
            ProcessError err = errIter.next();
            if (!packageMatches(app, err)) {
                // async!  Drop into mAsyncErrors and don't report now
                mAsyncErrors.add(err);
                errIter.remove();
            }
        }
    }
    // 2) Errors that are pertinent to this particular app invocation
    if (errProcs != null && preErrProcs != null) {
        errProcs.removeAll(preErrProcs);
    }
    return errProcs;
}
Body of Second Method:
{
    final long appLaunchWait = 7000;
    final long homeLaunchWait = 2000;
    Log.i(TAG, String.format("Running activity %s/%s", app.activityInfo.packageName, app.activityInfo.name));
    // We check for any Crash or ANR dialogs that are already up, and we ignore them.  This is
    // so that we don't report crashes that were caused by prior apps (which those particular
    // tests should have caught and reported already).
    final Collection<ProcessError> preErrProcs = ProcessError.fromCollection(mActivityManager.getProcessesInErrorState());
    // launch app, and wait 7 seconds for it to start/settle
    final Intent intent = intentForActivity(app);
    if (intent == null) {
        Log.i(TAG, String.format("Activity %s/%s is disabled, skipping", app.activityInfo.packageName, app.activityInfo.name));
        return Collections.EMPTY_LIST;
    }
    getContext().startActivity(intent);
    try {
        Thread.sleep(appLaunchWait);
    } catch (InterruptedException e) {
    // ignore
    }
    // Send the "home" intent and wait 2 seconds for us to get there
    getContext().startActivity(mHomeIntent);
    try {
        Thread.sleep(homeLaunchWait);
    } catch (InterruptedException e) {
    // ignore
    }
    // See if there are any errors.  We wait until down here to give ANRs as much time as
    // possible to occur.
    final Collection<ProcessError> errProcs = ProcessError.fromCollection(mActivityManager.getProcessesInErrorState());
    // crash package name against the package name for {@code app}
    if (errProcs != null) {
        Iterator<ProcessError> errIter = errProcs.iterator();
        while (errIter.hasNext()) {
            ProcessError err = errIter.next();
            if (!packageMatches(app, err)) {
                // async!  Drop into mAsyncErrors and don't report now
                mAsyncErrors.add(err);
                errIter.remove();
            }
        }
    }
    // 2) Errors that are pertinent to this particular app invocation
    if (errProcs != null && preErrProcs != null) {
        errProcs.removeAll(preErrProcs);
    }
    return errProcs;
}
------------------------
Find a functionally equivalent code:android.widget.OverScroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location. If it returns true, the
 * animation is not yet finished.
 */

Body of Frist Method:
{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                float q = (float) (elapsedTime) / duration;
                if (mInterpolator == null) {
                    q = Scroller.viscousFluid(q);
                } else {
                    q = mInterpolator.getInterpolation(q);
                }
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}
Body of Second Method:
{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                final float q = mInterpolator.getInterpolation(elapsedTime / (float) duration);
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the source to be a virtual descendant of the given <code>root</code>.
 * If <code>virtualDescendantId</code> is {@link View#NO_ID} the root
 * is set as the source.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report themselves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 */

Body of Frist Method:
{
    enforceNotSealed();
    mWindowId = (root != null) ? root.getAccessibilityWindowId() : UNDEFINED;
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
    mSourceNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
Body of Second Method:
{
    enforceNotSealed();
    mWindowId = (root != null) ? root.getAccessibilityWindowId() : UNDEFINED_ITEM_ID;
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
    mSourceNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.getSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the spinners are shown.
 *
 * @return True if the spinners are shown.
 */

Body of Frist Method:
{
    return mSpinners.isShown();
}
Body of Second Method:
{
    return mDelegate.getSpinnersShown();
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.usingBiometricWeak:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return true if the lockscreen method is set to biometric weak
 */

Body of Frist Method:
{
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    return quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
}
Body of Second Method:
{
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    return quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.updateProgressBars:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Updates the progress bars that are shown in the title bar.
 *
 * @param value Can be one of {@link Window#PROGRESS_VISIBILITY_ON},
 * {@link Window#PROGRESS_VISIBILITY_OFF},
 * {@link Window#PROGRESS_INDETERMINATE_ON},
 * {@link Window#PROGRESS_INDETERMINATE_OFF}, or a value
 * starting at {@link Window#PROGRESS_START} through
 * {@link Window#PROGRESS_END} for setting the default
 * progress (if {@link Window#PROGRESS_END} is given,
 * the progress bar widgets in the title will be hidden after an
 * animation), a value between
 * {@link Window#PROGRESS_SECONDARY_START} -
 * {@link Window#PROGRESS_SECONDARY_END} for the
 * secondary progress (if
 * {@link Window#PROGRESS_SECONDARY_END} is given, the
 * progress bar widgets will still be shown with the secondary
 * progress bar will be completely filled in.)
 */

Body of Frist Method:
{
    ProgressBar circularProgressBar = getCircularProgressBar(true);
    ProgressBar horizontalProgressBar = getHorizontalProgressBar(true);
    final int features = getLocalFeatures();
    if (value == PROGRESS_VISIBILITY_ON) {
        if ((features & (1 << FEATURE_PROGRESS)) != 0) {
            int level = horizontalProgressBar.getProgress();
            int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ? View.VISIBLE : View.INVISIBLE;
            horizontalProgressBar.setVisibility(visibility);
        }
        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            circularProgressBar.setVisibility(View.VISIBLE);
        }
    } else if (value == PROGRESS_VISIBILITY_OFF) {
        if ((features & (1 << FEATURE_PROGRESS)) != 0) {
            horizontalProgressBar.setVisibility(View.GONE);
        }
        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            circularProgressBar.setVisibility(View.GONE);
        }
    } else if (value == PROGRESS_INDETERMINATE_ON) {
        horizontalProgressBar.setIndeterminate(true);
    } else if (value == PROGRESS_INDETERMINATE_OFF) {
        horizontalProgressBar.setIndeterminate(false);
    } else if (PROGRESS_START <= value && value <= PROGRESS_END) {
        // We want to set the progress value before testing for visibility
        // so that when the progress bar becomes visible again, it has the
        // correct level.
        horizontalProgressBar.setProgress(value - PROGRESS_START);
        if (value < PROGRESS_END) {
            showProgressBars(horizontalProgressBar, circularProgressBar);
        } else {
            hideProgressBars(horizontalProgressBar, circularProgressBar);
        }
    } else if (PROGRESS_SECONDARY_START <= value && value <= PROGRESS_SECONDARY_END) {
        horizontalProgressBar.setSecondaryProgress(value - PROGRESS_SECONDARY_START);
        showProgressBars(horizontalProgressBar, circularProgressBar);
    }
}
Body of Second Method:
{
    ProgressBar circularProgressBar = getCircularProgressBar(true);
    ProgressBar horizontalProgressBar = getHorizontalProgressBar(true);
    final int features = getLocalFeatures();
    if (value == PROGRESS_VISIBILITY_ON) {
        if ((features & (1 << FEATURE_PROGRESS)) != 0) {
            if (horizontalProgressBar != null) {
                int level = horizontalProgressBar.getProgress();
                int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ? View.VISIBLE : View.INVISIBLE;
                horizontalProgressBar.setVisibility(visibility);
            } else {
                Log.e(TAG, "Horizontal progress bar not located in current window decor");
            }
        }
        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            if (circularProgressBar != null) {
                circularProgressBar.setVisibility(View.VISIBLE);
            } else {
                Log.e(TAG, "Circular progress bar not located in current window decor");
            }
        }
    } else if (value == PROGRESS_VISIBILITY_OFF) {
        if ((features & (1 << FEATURE_PROGRESS)) != 0) {
            if (horizontalProgressBar != null) {
                horizontalProgressBar.setVisibility(View.GONE);
            } else {
                Log.e(TAG, "Horizontal progress bar not located in current window decor");
            }
        }
        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
            if (circularProgressBar != null) {
                circularProgressBar.setVisibility(View.GONE);
            } else {
                Log.e(TAG, "Circular progress bar not located in current window decor");
            }
        }
    } else if (value == PROGRESS_INDETERMINATE_ON) {
        if (horizontalProgressBar != null) {
            horizontalProgressBar.setIndeterminate(true);
        } else {
            Log.e(TAG, "Horizontal progress bar not located in current window decor");
        }
    } else if (value == PROGRESS_INDETERMINATE_OFF) {
        if (horizontalProgressBar != null) {
            horizontalProgressBar.setIndeterminate(false);
        } else {
            Log.e(TAG, "Horizontal progress bar not located in current window decor");
        }
    } else if (PROGRESS_START <= value && value <= PROGRESS_END) {
        // correct level.
        if (horizontalProgressBar != null) {
            horizontalProgressBar.setProgress(value - PROGRESS_START);
        } else {
            Log.e(TAG, "Horizontal progress bar not located in current window decor");
        }
        if (value < PROGRESS_END) {
            showProgressBars(horizontalProgressBar, circularProgressBar);
        } else {
            hideProgressBars(horizontalProgressBar, circularProgressBar);
        }
    } else if (PROGRESS_SECONDARY_START <= value && value <= PROGRESS_SECONDARY_END) {
        if (horizontalProgressBar != null) {
            horizontalProgressBar.setSecondaryProgress(value - PROGRESS_SECONDARY_START);
        } else {
            Log.e(TAG, "Horizontal progress bar not located in current window decor");
        }
        showProgressBars(horizontalProgressBar, circularProgressBar);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onClockVisibilityChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onClockVisibilityChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when visibility of lockscreen clock changes, such as when
 * obscured by a widget.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.clipPath:COMMENT
Method Modifier: public      
Comment:/**
 * Intersect the current clip with the specified path.
 *
 * @param path The path to intersect with the current clip
 * @return     true if the resulting is non-empty
 */

Body of Frist Method:
{
    return clipPath(path, Region.Op.INTERSECT);
}
Body of Second Method:
{
    return clipPath(path, Region.Op.INTERSECT);
}
------------------------
Find a functionally equivalent code:android.app.Activity.onMenuOpened:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * @return The default implementation returns true.
 */

Body of Frist Method:
{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, "Tried to open action bar menu with no action bar");
        }
    }
    return true;
}
Body of Second Method:
{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, "Tried to open action bar menu with no action bar");
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in the focused month.
 *
 * @return The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

Body of Frist Method:
{
    return mFocusedMonthDateColor;
}
Body of Second Method:
{
    return mDelegate.getFocusedMonthDateColor();
}
------------------------
Find a functionally equivalent code:android.service.notification.StatusBarNotification.cloneLight:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.basePkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
}
Body of Second Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.BitmapDrawable.getBitmap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the bitmap used by this drawable to render. May be null.
 */

Body of Frist Method:
{
    return mBitmap;
}
Body of Second Method:
{
    return mBitmapState.mBitmap;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.getWidth:COMMENT
<android.graphics.Canvas: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the width of the current drawing layer
 *
 * @return the width of the current drawing layer
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getWidth(mNativeCanvasWrapper);
}
------------------------
Find a functionally equivalent code:android.os.UserManager.getMaxSupportedUsers:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the maximum number of users that can be created on this device. A return value
 * of 1 means that it is a single user device.
 * @hide
 * @return a value greater than or equal to 1
 */

Body of Frist Method:
{
    // Don't allow multiple users on certain builds
    if (android.os.Build.ID.startsWith("JVP"))
        return 1;
    return SystemProperties.getInt("fw.max_users", Resources.getSystem().getInteger(R.integer.config_multiuserMaximumUsers));
}
Body of Second Method:
{
    // Don't allow multiple users on certain builds
    if (android.os.Build.ID.startsWith("JVP"))
        return 1;
    // Svelte devices don't get multi-user.
    if (ActivityManager.isLowRamDeviceStatic())
        return 1;
    return SystemProperties.getInt("fw.max_users", Resources.getSystem().getInteger(R.integer.config_multiuserMaximumUsers));
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.transitionToVisible:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb and track.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, fadeOut, slideIn);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, fadeOut, slideIn);
    mDecorAnimation.start();
    mShowingPreview = false;
}
------------------------
Find a functionally equivalent code:android.content.ContentProvider.attachInfo:COMMENT
Method Modifier: public      
Comment:/**
 * After being instantiated, this is called to tell the content provider
 * about itself.
 *
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */

Body of Frist Method:
{
    attachInfo(context, info, false);
}
Body of Second Method:
{
    attachInfo(context, info, false);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.updateEncryptionPassword:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Update the encryption password if it is enabled *
 */

Body of Frist Method:
{
    DevicePolicyManager dpm = getDevicePolicyManager();
    if (dpm.getStorageEncryptionStatus(getCurrentOrCallingUserId()) != DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE) {
        return;
    }
    IBinder service = ServiceManager.getService("mount");
    if (service == null) {
        Log.e(TAG, "Could not find the mount service to update the encryption password");
        return;
    }
    IMountService mountService = IMountService.Stub.asInterface(service);
    try {
        mountService.changeEncryptionPassword(password);
    } catch (RemoteException e) {
        Log.e(TAG, "Error changing encryption password", e);
    }
}
Body of Second Method:
{
    if (!isDeviceEncryptionEnabled()) {
        return;
    }
    final IBinder service = ServiceManager.getService("mount");
    if (service == null) {
        Log.e(TAG, "Could not find the mount service to update the encryption password");
        return;
    }
    new AsyncTask<Void, Void, Void>() {

        @Override
        protected Void doInBackground(Void... dummy) {
            IMountService mountService = IMountService.Stub.asInterface(service);
            try {
                mountService.changeEncryptionPassword(type, password);
            } catch (RemoteException e) {
                Log.e(TAG, "Error changing encryption password", e);
            }
            return null;
        }
    }.execute();
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.getDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @return The selected date.
 */

Body of Frist Method:
{
    return mAdapter.mSelectedDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getDate();
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setOnDateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be notified upon selected date change.
 *
 * @param listener The listener to be notified.
 */

Body of Frist Method:
{
    mOnDateChangeListener = listener;
}
Body of Second Method:
{
    mDelegate.setOnDateChangeListener(listener);
}
------------------------
Find a functionally equivalent code:android.text.Layout.measurePara:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
Body of Second Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.setSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set whether or not the provider is synced when it receives a network tickle.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being controlled
 * @param sync true if the provider should be synced when tickles are received for it
 */

Body of Frist Method:
{
    try {
        getContentService().setSyncAutomatically(account, authority, sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    setSyncAutomaticallyAsUser(account, authority, sync, UserHandle.myUserId());
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.Arguments.parseArgs:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Parses the commandline arguments intended for the Zygote spawner
 * (such as "--setuid=" and "--setgid=") and creates an array
 * containing the remaining args.
 *
 * Per security review bug #1112214, duplicate args are disallowed in
 * critical cases to make injection harder.
 */

Body of Frist Method:
{
    int curArg = 0;
    for (; /* curArg */
    curArg < args.length; curArg++) {
        String arg = args[curArg];
        if (arg.equals("--")) {
            curArg++;
            break;
        } else if (arg.startsWith("--setuid=")) {
            if (uidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            uidSpecified = true;
            uid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--setgid=")) {
            if (gidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            gidSpecified = true;
            gid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--target-sdk-version=")) {
            if (targetSdkVersionSpecified) {
                throw new IllegalArgumentException("Duplicate target-sdk-version specified");
            }
            targetSdkVersionSpecified = true;
            targetSdkVersion = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.equals("--enable-debugger")) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
        } else if (arg.equals("--enable-safemode")) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        } else if (arg.equals("--enable-checkjni")) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        } else if (arg.equals("--enable-jni-logging")) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        } else if (arg.equals("--enable-assert")) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        } else if (arg.equals("--runtime-init")) {
            runtimeInit = true;
        } else if (arg.startsWith("--seinfo=")) {
            if (seInfoSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            seInfoSpecified = true;
            seInfo = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--capabilities=")) {
            if (capabilitiesSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            capabilitiesSpecified = true;
            String capString = arg.substring(arg.indexOf('=') + 1);
            String[] capStrings = capString.split(",", 2);
            if (capStrings.length == 1) {
                effectiveCapabilities = Long.decode(capStrings[0]);
                permittedCapabilities = effectiveCapabilities;
            } else {
                permittedCapabilities = Long.decode(capStrings[0]);
                effectiveCapabilities = Long.decode(capStrings[1]);
            }
        } else if (arg.startsWith("--rlimit=")) {
            // Duplicate --rlimit arguments are specifically allowed.
            String[] limitStrings = arg.substring(arg.indexOf('=') + 1).split(",");
            if (limitStrings.length != 3) {
                throw new IllegalArgumentException("--rlimit= should have 3 comma-delimited ints");
            }
            int[] rlimitTuple = new int[limitStrings.length];
            for (int i = 0; i < limitStrings.length; i++) {
                rlimitTuple[i] = Integer.parseInt(limitStrings[i]);
            }
            if (rlimits == null) {
                rlimits = new ArrayList();
            }
            rlimits.add(rlimitTuple);
        } else if (arg.equals("-classpath")) {
            if (classpath != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                classpath = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("-classpath requires argument");
            }
        } else if (arg.startsWith("--setgroups=")) {
            if (gids != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            String[] params = arg.substring(arg.indexOf('=') + 1).split(",");
            gids = new int[params.length];
            for (int i = params.length - 1; i >= 0; i--) {
                gids[i] = Integer.parseInt(params[i]);
            }
        } else if (arg.equals("--invoke-with")) {
            if (invokeWith != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                invokeWith = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("--invoke-with requires argument");
            }
        } else if (arg.startsWith("--nice-name=")) {
            if (niceName != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            niceName = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--mount-external-multiuser")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER;
        } else if (arg.equals("--mount-external-multiuser-all")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER_ALL;
        } else {
            break;
        }
    }
    if (runtimeInit && classpath != null) {
        throw new IllegalArgumentException("--runtime-init and -classpath are incompatible");
    }
    remainingArgs = new String[args.length - curArg];
    System.arraycopy(args, curArg, remainingArgs, 0, remainingArgs.length);
}
Body of Second Method:
{
    int curArg = 0;
    for (; /* curArg */
    curArg < args.length; curArg++) {
        String arg = args[curArg];
        if (arg.equals("--")) {
            curArg++;
            break;
        } else if (arg.startsWith("--setuid=")) {
            if (uidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            uidSpecified = true;
            uid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--setgid=")) {
            if (gidSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            gidSpecified = true;
            gid = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.startsWith("--target-sdk-version=")) {
            if (targetSdkVersionSpecified) {
                throw new IllegalArgumentException("Duplicate target-sdk-version specified");
            }
            targetSdkVersionSpecified = true;
            targetSdkVersion = Integer.parseInt(arg.substring(arg.indexOf('=') + 1));
        } else if (arg.equals("--enable-debugger")) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
        } else if (arg.equals("--enable-safemode")) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        } else if (arg.equals("--enable-checkjni")) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        } else if (arg.equals("--enable-jni-logging")) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        } else if (arg.equals("--enable-assert")) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        } else if (arg.equals("--runtime-init")) {
            runtimeInit = true;
        } else if (arg.startsWith("--seinfo=")) {
            if (seInfoSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            seInfoSpecified = true;
            seInfo = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--capabilities=")) {
            if (capabilitiesSpecified) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            capabilitiesSpecified = true;
            String capString = arg.substring(arg.indexOf('=') + 1);
            String[] capStrings = capString.split(",", 2);
            if (capStrings.length == 1) {
                effectiveCapabilities = Long.decode(capStrings[0]);
                permittedCapabilities = effectiveCapabilities;
            } else {
                permittedCapabilities = Long.decode(capStrings[0]);
                effectiveCapabilities = Long.decode(capStrings[1]);
            }
        } else if (arg.startsWith("--rlimit=")) {
            // Duplicate --rlimit arguments are specifically allowed.
            String[] limitStrings = arg.substring(arg.indexOf('=') + 1).split(",");
            if (limitStrings.length != 3) {
                throw new IllegalArgumentException("--rlimit= should have 3 comma-delimited ints");
            }
            int[] rlimitTuple = new int[limitStrings.length];
            for (int i = 0; i < limitStrings.length; i++) {
                rlimitTuple[i] = Integer.parseInt(limitStrings[i]);
            }
            if (rlimits == null) {
                rlimits = new ArrayList();
            }
            rlimits.add(rlimitTuple);
        } else if (arg.equals("-classpath")) {
            if (classpath != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                classpath = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("-classpath requires argument");
            }
        } else if (arg.startsWith("--setgroups=")) {
            if (gids != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            String[] params = arg.substring(arg.indexOf('=') + 1).split(",");
            gids = new int[params.length];
            for (int i = params.length - 1; i >= 0; i--) {
                gids[i] = Integer.parseInt(params[i]);
            }
        } else if (arg.equals("--invoke-with")) {
            if (invokeWith != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            try {
                invokeWith = args[++curArg];
            } catch (IndexOutOfBoundsException ex) {
                throw new IllegalArgumentException("--invoke-with requires argument");
            }
        } else if (arg.startsWith("--nice-name=")) {
            if (niceName != null) {
                throw new IllegalArgumentException("Duplicate arg specified");
            }
            niceName = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.equals("--mount-external-multiuser")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER;
        } else if (arg.equals("--mount-external-multiuser-all")) {
            mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER_ALL;
        } else if (arg.equals("--query-abi-list")) {
            abiListQuery = true;
        } else if (arg.startsWith("--instruction-set=")) {
            instructionSet = arg.substring(arg.indexOf('=') + 1);
        } else if (arg.startsWith("--app-data-dir=")) {
            appDataDir = arg.substring(arg.indexOf('=') + 1);
        } else {
            break;
        }
    }
    if (runtimeInit && classpath != null) {
        throw new IllegalArgumentException("--runtime-init and -classpath are incompatible");
    }
    remainingArgs = new String[args.length - curArg];
    System.arraycopy(args, curArg, remainingArgs, 0, remainingArgs.length);
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.scrapActiveViews:COMMENT
Method Modifier: 
Comment:/**
 * Move all views remaining in mActiveViews to mScrapViews.
 */

Body of Frist Method:
{
    final View[] activeViews = mActiveViews;
    final boolean hasListener = mRecyclerListener != null;
    final boolean multipleScraps = mViewTypeCount > 1;
    ArrayList<View> scrapViews = mCurrentScrap;
    final int count = activeViews.length;
    for (int i = count - 1; i >= 0; i--) {
        final View victim = activeViews[i];
        if (victim != null) {
            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
            int whichScrap = lp.viewType;
            activeViews[i] = null;
            final boolean scrapHasTransientState = victim.hasTransientState();
            if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
                // Do not move views that should be ignored
                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
                    removeDetachedView(victim, false);
                }
                if (scrapHasTransientState) {
                    if (mAdapter != null && mAdapterHasStableIds) {
                        if (mTransientStateViewsById == null) {
                            mTransientStateViewsById = new LongSparseArray<View>();
                        }
                        long id = mAdapter.getItemId(mFirstActivePosition + i);
                        mTransientStateViewsById.put(id, victim);
                    } else {
                        if (mTransientStateViews == null) {
                            mTransientStateViews = new SparseArray<View>();
                        }
                        mTransientStateViews.put(mFirstActivePosition + i, victim);
                    }
                }
                continue;
            }
            if (multipleScraps) {
                scrapViews = mScrapViews[whichScrap];
            }
            victim.dispatchStartTemporaryDetach();
            lp.scrappedFromPosition = mFirstActivePosition + i;
            scrapViews.add(victim);
            victim.setAccessibilityDelegate(null);
            if (hasListener) {
                mRecyclerListener.onMovedToScrapHeap(victim);
            }
        }
    }
    pruneScrapViews();
}
Body of Second Method:
{
    final View[] activeViews = mActiveViews;
    final boolean hasListener = mRecyclerListener != null;
    final boolean multipleScraps = mViewTypeCount > 1;
    ArrayList<View> scrapViews = mCurrentScrap;
    final int count = activeViews.length;
    for (int i = count - 1; i >= 0; i--) {
        final View victim = activeViews[i];
        if (victim != null) {
            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
            final int whichScrap = lp.viewType;
            activeViews[i] = null;
            if (victim.hasTransientState()) {
                // Store views with transient state for later use.
                victim.dispatchStartTemporaryDetach();
                if (mAdapter != null && mAdapterHasStableIds) {
                    if (mTransientStateViewsById == null) {
                        mTransientStateViewsById = new LongSparseArray<View>();
                    }
                    long id = mAdapter.getItemId(mFirstActivePosition + i);
                    mTransientStateViewsById.put(id, victim);
                } else if (!mDataChanged) {
                    if (mTransientStateViews == null) {
                        mTransientStateViews = new SparseArray<View>();
                    }
                    mTransientStateViews.put(mFirstActivePosition + i, victim);
                } else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                    // The data has changed, we can't keep this view.
                    removeDetachedView(victim, false);
                }
            } else if (!shouldRecycleViewType(whichScrap)) {
                // Discard non-recyclable views except headers/footers.
                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                    removeDetachedView(victim, false);
                }
            } else {
                // Store everything else on the appropriate scrap heap.
                if (multipleScraps) {
                    scrapViews = mScrapViews[whichScrap];
                }
                victim.dispatchStartTemporaryDetach();
                lp.scrappedFromPosition = mFirstActivePosition + i;
                scrapViews.add(victim);
                if (hasListener) {
                    mRecyclerListener.onMovedToScrapHeap(victim);
                }
            }
        }
    }
    pruneScrapViews();
}
------------------------
Find a functionally equivalent code:android.view.MenuInflater.parseMenu:COMMENT
Method Modifier: private     
Comment:/**
 * Called internally to fill the given menu. If a sub menu is seen, it will
 * call this recursively.
 */

Body of Frist Method:
{
    MenuState menuState = new MenuState(menu);
    int eventType = parser.getEventType();
    String tagName;
    boolean lookingForEndOfUnknownTag = false;
    String unknownTagName = null;
    // This loop will skip to the menu start tag
    do {
        if (eventType == XmlPullParser.START_TAG) {
            tagName = parser.getName();
            if (tagName.equals(XML_MENU)) {
                // Go to next tag
                eventType = parser.next();
                break;
            }
            throw new RuntimeException("Expecting menu, got " + tagName);
        }
        eventType = parser.next();
    } while (eventType != XmlPullParser.END_DOCUMENT);
    boolean reachedEndOfMenu = false;
    while (!reachedEndOfMenu) {
        switch(eventType) {
            case XmlPullParser.START_TAG:
                if (lookingForEndOfUnknownTag) {
                    break;
                }
                tagName = parser.getName();
                if (tagName.equals(XML_GROUP)) {
                    menuState.readGroup(attrs);
                } else if (tagName.equals(XML_ITEM)) {
                    menuState.readItem(attrs);
                } else if (tagName.equals(XML_MENU)) {
                    // A menu start tag denotes a submenu for an item
                    SubMenu subMenu = menuState.addSubMenuItem();
                    // Parse the submenu into returned SubMenu
                    parseMenu(parser, attrs, subMenu);
                } else {
                    lookingForEndOfUnknownTag = true;
                    unknownTagName = tagName;
                }
                break;
            case XmlPullParser.END_TAG:
                tagName = parser.getName();
                if (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {
                    lookingForEndOfUnknownTag = false;
                    unknownTagName = null;
                } else if (tagName.equals(XML_GROUP)) {
                    menuState.resetGroup();
                } else if (tagName.equals(XML_ITEM)) {
                    // a submenu, it would have been added already)
                    if (!menuState.hasAddedItem()) {
                        if (menuState.itemActionProvider != null && menuState.itemActionProvider.hasSubMenu()) {
                            menuState.addSubMenuItem();
                        } else {
                            menuState.addItem();
                        }
                    }
                } else if (tagName.equals(XML_MENU)) {
                    reachedEndOfMenu = true;
                }
                break;
            case XmlPullParser.END_DOCUMENT:
                throw new RuntimeException("Unexpected end of document");
        }
        eventType = parser.next();
    }
}
Body of Second Method:
{
    MenuState menuState = new MenuState(menu);
    int eventType = parser.getEventType();
    String tagName;
    boolean lookingForEndOfUnknownTag = false;
    String unknownTagName = null;
    // This loop will skip to the menu start tag
    do {
        if (eventType == XmlPullParser.START_TAG) {
            tagName = parser.getName();
            if (tagName.equals(XML_MENU)) {
                // Go to next tag
                eventType = parser.next();
                break;
            }
            throw new RuntimeException("Expecting menu, got " + tagName);
        }
        eventType = parser.next();
    } while (eventType != XmlPullParser.END_DOCUMENT);
    boolean reachedEndOfMenu = false;
    while (!reachedEndOfMenu) {
        switch(eventType) {
            case XmlPullParser.START_TAG:
                if (lookingForEndOfUnknownTag) {
                    break;
                }
                tagName = parser.getName();
                if (tagName.equals(XML_GROUP)) {
                    menuState.readGroup(attrs);
                } else if (tagName.equals(XML_ITEM)) {
                    menuState.readItem(attrs);
                } else if (tagName.equals(XML_MENU)) {
                    // A menu start tag denotes a submenu for an item
                    SubMenu subMenu = menuState.addSubMenuItem();
                    registerMenu(subMenu, attrs);
                    // Parse the submenu into returned SubMenu
                    parseMenu(parser, attrs, subMenu);
                } else {
                    lookingForEndOfUnknownTag = true;
                    unknownTagName = tagName;
                }
                break;
            case XmlPullParser.END_TAG:
                tagName = parser.getName();
                if (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {
                    lookingForEndOfUnknownTag = false;
                    unknownTagName = null;
                } else if (tagName.equals(XML_GROUP)) {
                    menuState.resetGroup();
                } else if (tagName.equals(XML_ITEM)) {
                    // a submenu, it would have been added already)
                    if (!menuState.hasAddedItem()) {
                        if (menuState.itemActionProvider != null && menuState.itemActionProvider.hasSubMenu()) {
                            registerMenu(menuState.addSubMenuItem(), attrs);
                        } else {
                            registerMenu(menuState.addItem(), attrs);
                        }
                    }
                } else if (tagName.equals(XML_MENU)) {
                    reachedEndOfMenu = true;
                }
                break;
            case XmlPullParser.END_DOCUMENT:
                throw new RuntimeException("Unexpected end of document");
        }
        eventType = parser.next();
    }
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.getLinkProperties:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the IP information for a given network type.
 *
 * @param networkType the network type of interest.
 * @return a {@link LinkProperties} object describing the IP info
 * for the given networkType, or {@code null} if there is
 * no current default network.
 *
 * <p>This method requires the call to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getLinkProperties(networkType);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getLinkPropertiesForType(networkType);
    } catch (RemoteException e) {
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.app.backup.FullBackup.restoreFile:COMMENT
Method Modifier: public      static      
Comment:/**
 * Copy data from a socket to the given File location on permanent storage.  The
 * modification time and access mode of the resulting file will be set if desired,
 * although group/all rwx modes will be stripped: the restored file will not be
 * accessible from outside the target application even if the original file was.
 * If the {@code type} parameter indicates that the result should be a directory,
 * the socket parameter may be {@code null}; even if it is valid, no data will be
 * read from it in this case.
 * <p>
 * If the {@code mode} argument is negative, then the resulting output file will not
 * have its access mode or last modification time reset as part of this operation.
 *
 * @param data Socket supplying the data to be copied to the output file.  If the
 * output is a directory, this may be {@code null}.
 * @param size Number of bytes of data to copy from the socket to the file.  At least
 * this much data must be available through the {@code data} parameter.
 * @param type Must be either {@link BackupAgent#TYPE_FILE} for ordinary file data
 * or {@link BackupAgent#TYPE_DIRECTORY} for a directory.
 * @param mode Unix-style file mode (as used by the chmod(2) syscall) to be set on
 * the output file or directory.  group/all rwx modes are stripped even if set
 * in this parameter.  If this parameter is negative then neither
 * the mode nor the mtime values will be applied to the restored file.
 * @param mtime A timestamp in the standard Unix epoch that will be imposed as the
 * last modification time of the output file.  if the {@code mode} parameter is
 * negative then this parameter will be ignored.
 * @param outFile Location within the filesystem to place the data.  This must point
 * to a location that is writeable by the caller, preferably using an absolute path.
 * @throws IOException
 */

Body of Frist Method:
{
    if (type == BackupAgent.TYPE_DIRECTORY) {
        // drop down to the final metadata adjustment.
        if (outFile != null)
            outFile.mkdirs();
    } else {
        FileOutputStream out = null;
        // Pull the data from the pipe, copying it to the output file, until we're done
        try {
            if (outFile != null) {
                File parent = outFile.getParentFile();
                if (!parent.exists()) {
                    // in practice this will only be for the default semantic directories,
                    // and using the default mode for those is appropriate.
                    parent.mkdirs();
                }
                out = new FileOutputStream(outFile);
            }
        } catch (IOException e) {
            Log.e(TAG, "Unable to create/open file " + outFile.getPath(), e);
        }
        byte[] buffer = new byte[32 * 1024];
        final long origSize = size;
        FileInputStream in = new FileInputStream(data.getFileDescriptor());
        while (size > 0) {
            int toRead = (size > buffer.length) ? buffer.length : (int) size;
            int got = in.read(buffer, 0, toRead);
            if (got <= 0) {
                Log.w(TAG, "Incomplete read: expected " + size + " but got " + (origSize - size));
                break;
            }
            if (out != null) {
                try {
                    out.write(buffer, 0, got);
                } catch (IOException e) {
                    // Problem writing to the file.  Quit copying data and delete
                    // the file, but of course keep consuming the input stream.
                    Log.e(TAG, "Unable to write to file " + outFile.getPath(), e);
                    out.close();
                    out = null;
                    outFile.delete();
                }
            }
            size -= got;
        }
        if (out != null)
            out.close();
    }
    // Now twiddle the state to match the backup, assuming all went well
    if (mode >= 0 && outFile != null) {
        try {
            // explicitly prevent emplacement of files accessible by outside apps
            mode &= 0700;
            Libcore.os.chmod(outFile.getPath(), (int) mode);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        outFile.setLastModified(mtime);
    }
}
Body of Second Method:
{
    if (type == BackupAgent.TYPE_DIRECTORY) {
        // drop down to the final metadata adjustment.
        if (outFile != null)
            outFile.mkdirs();
    } else {
        FileOutputStream out = null;
        // Pull the data from the pipe, copying it to the output file, until we're done
        try {
            if (outFile != null) {
                File parent = outFile.getParentFile();
                if (!parent.exists()) {
                    // in practice this will only be for the default semantic directories,
                    // and using the default mode for those is appropriate.
                    parent.mkdirs();
                }
                out = new FileOutputStream(outFile);
            }
        } catch (IOException e) {
            Log.e(TAG, "Unable to create/open file " + outFile.getPath(), e);
        }
        byte[] buffer = new byte[32 * 1024];
        final long origSize = size;
        FileInputStream in = new FileInputStream(data.getFileDescriptor());
        while (size > 0) {
            int toRead = (size > buffer.length) ? buffer.length : (int) size;
            int got = in.read(buffer, 0, toRead);
            if (got <= 0) {
                Log.w(TAG, "Incomplete read: expected " + size + " but got " + (origSize - size));
                break;
            }
            if (out != null) {
                try {
                    out.write(buffer, 0, got);
                } catch (IOException e) {
                    // Problem writing to the file.  Quit copying data and delete
                    // the file, but of course keep consuming the input stream.
                    Log.e(TAG, "Unable to write to file " + outFile.getPath(), e);
                    out.close();
                    out = null;
                    outFile.delete();
                }
            }
            size -= got;
        }
        if (out != null)
            out.close();
    }
    // Now twiddle the state to match the backup, assuming all went well
    if (mode >= 0 && outFile != null) {
        try {
            // explicitly prevent emplacement of files accessible by outside apps
            mode &= 0700;
            Os.chmod(outFile.getPath(), (int) mode);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        outFile.setLastModified(mtime);
    }
}
------------------------
Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.testAppStability:COMMENT
Method Modifier: public      
Comment:/**
 * Actual test case that launches the package and throws an exception on the
 * first error.
 *
 * @throws Exception
 */

Body of Frist Method:
{
    String packageName = mArgs.getString(PACKAGE_TO_LAUNCH);
    if (packageName != null) {
        Log.d(TAG, "Launching app " + packageName);
        Collection<ProcessErrorStateInfo> err = launchActivity(packageName);
        // Make sure there are no errors when launching the application,
        // otherwise raise an
        // exception with the first error encountered.
        assertNull(getFirstError(err), err);
        assertTrue("App crashed after launch.", processStillUp(packageName));
    } else {
        Log.d(TAG, "Missing argument, use " + PACKAGE_TO_LAUNCH + " to specify the package to launch");
    }
}
Body of Second Method:
{
    String packageName = mArgs.getString(PACKAGE_TO_LAUNCH);
    if (packageName != null) {
        Log.d(TAG, "Launching app " + packageName);
        ProcessErrorStateInfo err = launchActivity(packageName);
        // Make sure there are no errors when launching the application,
        // otherwise raise an
        // exception with the first error encountered.
        assertNull(getStackTrace(err), err);
        assertTrue("App crashed after launch.", processStillUp(packageName));
    } else {
        Log.d(TAG, "Missing argument, use " + PACKAGE_TO_LAUNCH + " to specify the package to launch");
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Paint_Delegate.measureText:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    return new BidiRenderer(null, this, text).renderText(index, index + count, isRtl, null, 0, false, 0, 0);
}
Body of Second Method:
{
    return new BidiRenderer(null, this, text).renderText(index, index + count, bidiFlags, advances, advancesIndex, false);
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setFloatValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of floats.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = float.class;
    mKeyframeSet = KeyframeSet.ofFloat(values);
}
Body of Second Method:
{
    mValueType = float.class;
    mKeyframes = KeyframeSet.ofFloat(values);
}
------------------------
Find a functionally equivalent code:android.app.IActivityManager.profileControl:COMMENT
Method Modifier: public      
Comment:// Turn on/off profiling in a particular process.

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of currently selected values.
 * @return the list of current selections, if type is {@link #TYPE_MULTI_SELECT},
 * null otherwise.
 */

Body of Frist Method:
{
    return currentValues;
}
Body of Second Method:
{
    return mCurrentValues;
}
------------------------
Find a functionally equivalent code:android.transition.Transition.captureHierarchy:COMMENT
Method Modifier: private     
Comment:/**
 * Recursive method which captures values for an entire view hierarchy,
 * starting at some root view. Transitions without targetIDs will use this
 * method to capture values for all possible views.
 *
 * @param view The view for which to capture values. Children of this View
 * will also be captured, recursively down to the leaf nodes.
 * @param start true if values are being captured in the start scene, false
 * otherwise.
 */

Body of Frist Method:
{
    if (view == null) {
        return;
    }
    boolean isListViewItem = false;
    if (view.getParent() instanceof ListView) {
        isListViewItem = true;
    }
    if (isListViewItem && !((ListView) view.getParent()).getAdapter().hasStableIds()) {
        // ignore listview children unless we can track them with stable IDs
        return;
    }
    int id = View.NO_ID;
    long itemId = View.NO_ID;
    if (!isListViewItem) {
        id = view.getId();
    } else {
        ListView listview = (ListView) view.getParent();
        int position = listview.getPositionForView(view);
        itemId = listview.getItemIdAtPosition(position);
        view.setHasTransientState(true);
    }
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    TransitionValues values = new TransitionValues();
    values.view = view;
    if (start) {
        captureStartValues(values);
    } else {
        captureEndValues(values);
    }
    if (start) {
        if (!isListViewItem) {
            mStartValues.viewValues.put(view, values);
            if (id >= 0) {
                mStartValues.idValues.put((int) id, values);
            }
        } else {
            mStartValues.itemIdValues.put(itemId, values);
        }
    } else {
        if (!isListViewItem) {
            mEndValues.viewValues.put(view, values);
            if (id >= 0) {
                mEndValues.idValues.put((int) id, values);
            }
        } else {
            mEndValues.itemIdValues.put(itemId, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null && view != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
Body of Second Method:
{
    if (view == null) {
        return;
    }
    int id = view.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    if (view.getParent() instanceof ViewGroup) {
        TransitionValues values = new TransitionValues();
        values.view = view;
        if (start) {
            captureStartValues(values);
        } else {
            captureEndValues(values);
        }
        values.targetedTransitions.add(this);
        capturePropagationValues(values);
        if (start) {
            addViewValues(mStartValues, view, values);
        } else {
            addViewValues(mEndValues, view, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
------------------------
Find a functionally equivalent code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
Body of Second Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.setAudioStreamType:COMMENT
<android.media.MediaPlayer: void setAudioStreamType(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the audio stream type for this MediaPlayer. See {@link AudioManager}
 * for a list of stream types. Must call this method before prepare() or
 * prepareAsync() in order for the target stream type to become effective
 * thereafter.
 *
 * @param streamtype the audio stream type
 * @see android.media.AudioManager
 */

Body of Frist Method:

Body of Second Method:
{
    _setAudioStreamType(streamtype);
    mStreamType = streamtype;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a byte[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (byte[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getByteArray(key);
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.detach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.
 *
 * Must run on mHandler.
 */

Body of Frist Method:
{
    if (mWindow == null) {
        // already detached!
        return;
    }
    try {
        onDreamingStopped();
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed in onDreamingStopped()", t);
    // we were going to stop anyway
    }
    if (mDebug)
        Slog.v(TAG, "detach(): Removing window from window manager");
    try {
        // force our window to be removed synchronously
        mWindowManager.removeViewImmediate(mWindow.getDecorView());
        // the following will print a log message if it finds any other leaked windows
        WindowManagerGlobal.getInstance().closeAll(mWindowToken, this.getClass().getName(), "Dream");
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed removing window view", t);
    }
    mWindow = null;
    mWindowToken = null;
}
Body of Second Method:
{
    if (mStarted) {
        if (mDebug)
            Slog.v(TAG, "detach(): Calling onDreamingStopped()");
        mStarted = false;
        onDreamingStopped();
    }
    if (mWindow != null) {
        // force our window to be removed synchronously
        if (mDebug)
            Slog.v(TAG, "detach(): Removing window from window manager");
        mWindow.getWindowManager().removeViewImmediate(mWindow.getDecorView());
        mWindow = null;
    }
    if (mWindowToken != null) {
        // the following will print a log message if it finds any other leaked windows
        WindowManagerGlobal.getInstance().closeAll(mWindowToken, this.getClass().getName(), "Dream");
        mWindowToken = null;
        mCanDoze = false;
    }
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.getCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current minute.
 */

Body of Frist Method:
{
    return mMinuteSpinner.getValue();
}
Body of Second Method:
{
    return mDelegate.getCurrentMinute();
}
------------------------
Find a functionally equivalent code:android.widget.Switch.hitThumb:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if (x, y) is within the target area of the switch thumb
 */

Body of Frist Method:
{
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + (int) (mThumbPosition + 0.5f) - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
Body of Second Method:
{
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarAllowOnly:COMMENT
Method Modifier: private     static      native      
Comment:// transcription, SR_SemanticResult** result, size_t* resultCount);

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.text.method.Touch.onTouchEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */

Body of Frist Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
Body of Second Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                ds[0].mIsSelectionStarted = false;
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                            ds[0].mIsActivelySelecting = true;
                            ds[0].mIsSelectionStarted = true;
                        }
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        ds[0].mIsActivelySelecting = false;
                    }
                    float dx;
                    float dy;
                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        scrollTo(widget, layout, nx, ny);
                    }
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.view.Surface.transferFrom:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * This is intended to be used by {@link SurfaceView#updateWindow} only.
 * @param other access is not thread safe
 * @hide
 * @deprecated
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    if (other != this) {
        final int newPtr;
        synchronized (other.mLock) {
            newPtr = other.mNativeObject;
            other.setNativeObjectLocked(0);
        }
        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newPtr);
        }
    }
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    if (other != this) {
        final long newPtr;
        synchronized (other.mLock) {
            newPtr = other.mNativeObject;
            other.setNativeObjectLocked(0);
        }
        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newPtr);
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.getRecordCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of records contained in the event.
 *
 * @return The number of records.
 */

Body of Frist Method:
{
    return mRecords.size();
}
Body of Second Method:
{
    return mRecords == null ? 0 : mRecords.size();
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.isRunning:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Indicates whether the animation is currently running or not.</p>
 *
 * @return true if the animation is running, false otherwise
 */

Body of Frist Method:
{
    return mCurFrame > -1;
}
Body of Second Method:
{
    return mRunning;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<CharSequence>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<CharSequence>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharSequenceArrayList(key);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.peekValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (boolean[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getBooleanArray(key);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onSimStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onSimStateChanged(State)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the SIM state changes.
 * @param simState
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.scrollTo:COMMENT
Method Modifier: private     
Comment:/**
 * Scrolls to a specific position within the section
 * @param position
 */

Body of Frist Method:
{
    mScrollCompleted = false;
    final int count = mList.getCount();
    final Object[] sections = mSections;
    final int sectionCount = sections == null ? 0 : sections.length;
    int sectionIndex;
    if (sections != null && sectionCount > 1) {
        final int exactSection = MathUtils.constrain((int) (position * sectionCount), 0, sectionCount - 1);
        int targetSection = exactSection;
        int targetIndex = mSectionIndexer.getPositionForSection(targetSection);
        sectionIndex = targetSection;
        // Given the expected section and index, the following code will
        // try to account for missing sections (no names starting with..)
        // It will compute the scroll space of surrounding empty sections
        // and interpolate the currently visible letter's range across the
        // available space, so that there is always some list movement while
        // the user moves the thumb.
        int nextIndex = count;
        int prevIndex = targetIndex;
        int prevSection = targetSection;
        int nextSection = targetSection + 1;
        // Assume the next section is unique
        if (targetSection < sectionCount - 1) {
            nextIndex = mSectionIndexer.getPositionForSection(targetSection + 1);
        }
        // Find the previous index if we're slicing the previous section
        if (nextIndex == targetIndex) {
            // Non-existent letter
            while (targetSection > 0) {
                targetSection--;
                prevIndex = mSectionIndexer.getPositionForSection(targetSection);
                if (prevIndex != targetIndex) {
                    prevSection = targetSection;
                    sectionIndex = targetSection;
                    break;
                } else if (targetSection == 0) {
                    // When section reaches 0 here, sectionIndex must follow it.
                    // Assuming mSectionIndexer.getPositionForSection(0) == 0.
                    sectionIndex = 0;
                    break;
                }
            }
        }
        // Find the next index, in case the assumed next index is not
        // unique. For instance, if there is no P, then request for P's
        // position actually returns Q's. So we need to look ahead to make
        // sure that there is really a Q at Q's position. If not, move
        // further down...
        int nextNextSection = nextSection + 1;
        while (nextNextSection < sectionCount && mSectionIndexer.getPositionForSection(nextNextSection) == nextIndex) {
            nextNextSection++;
            nextSection++;
        }
        // Compute the beginning and ending scroll range percentage of the
        // currently visible section. This could be equal to or greater than
        // (1 / nSections). If the target position is near the previous
        // position, snap to the previous position.
        final float prevPosition = (float) prevSection / sectionCount;
        final float nextPosition = (float) nextSection / sectionCount;
        final float snapThreshold = (count == 0) ? Float.MAX_VALUE : .125f / count;
        if (prevSection == exactSection && position - prevPosition < snapThreshold) {
            targetIndex = prevIndex;
        } else {
            targetIndex = prevIndex + (int) ((nextIndex - prevIndex) * (position - prevPosition) / (nextPosition - prevPosition));
        }
        // Clamp to valid positions.
        targetIndex = MathUtils.constrain(targetIndex, 0, count - 1);
        if (mList instanceof ExpandableListView) {
            final ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(targetIndex + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(targetIndex + mHeaderCount, 0);
        } else {
            mList.setSelection(targetIndex + mHeaderCount);
        }
    } else {
        final int index = MathUtils.constrain((int) (position * count), 0, count - 1);
        if (mList instanceof ExpandableListView) {
            ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(index + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(index + mHeaderCount, 0);
        } else {
            mList.setSelection(index + mHeaderCount);
        }
        sectionIndex = -1;
    }
    if (mCurrentSection != sectionIndex) {
        mCurrentSection = sectionIndex;
        if (transitionPreviewLayout(sectionIndex)) {
            transitionToDragging();
        } else {
            transitionToVisible();
        }
    }
}
Body of Second Method:
{
    mScrollCompleted = false;
    final int count = mList.getCount();
    final Object[] sections = mSections;
    final int sectionCount = sections == null ? 0 : sections.length;
    int sectionIndex;
    if (sections != null && sectionCount > 1) {
        final int exactSection = MathUtils.constrain((int) (position * sectionCount), 0, sectionCount - 1);
        int targetSection = exactSection;
        int targetIndex = mSectionIndexer.getPositionForSection(targetSection);
        sectionIndex = targetSection;
        // Given the expected section and index, the following code will
        // try to account for missing sections (no names starting with..)
        // It will compute the scroll space of surrounding empty sections
        // and interpolate the currently visible letter's range across the
        // available space, so that there is always some list movement while
        // the user moves the thumb.
        int nextIndex = count;
        int prevIndex = targetIndex;
        int prevSection = targetSection;
        int nextSection = targetSection + 1;
        // Assume the next section is unique
        if (targetSection < sectionCount - 1) {
            nextIndex = mSectionIndexer.getPositionForSection(targetSection + 1);
        }
        // Find the previous index if we're slicing the previous section
        if (nextIndex == targetIndex) {
            // Non-existent letter
            while (targetSection > 0) {
                targetSection--;
                prevIndex = mSectionIndexer.getPositionForSection(targetSection);
                if (prevIndex != targetIndex) {
                    prevSection = targetSection;
                    sectionIndex = targetSection;
                    break;
                } else if (targetSection == 0) {
                    // When section reaches 0 here, sectionIndex must follow it.
                    // Assuming mSectionIndexer.getPositionForSection(0) == 0.
                    sectionIndex = 0;
                    break;
                }
            }
        }
        // Find the next index, in case the assumed next index is not
        // unique. For instance, if there is no P, then request for P's
        // position actually returns Q's. So we need to look ahead to make
        // sure that there is really a Q at Q's position. If not, move
        // further down...
        int nextNextSection = nextSection + 1;
        while (nextNextSection < sectionCount && mSectionIndexer.getPositionForSection(nextNextSection) == nextIndex) {
            nextNextSection++;
            nextSection++;
        }
        // Compute the beginning and ending scroll range percentage of the
        // currently visible section. This could be equal to or greater than
        // (1 / nSections). If the target position is near the previous
        // position, snap to the previous position.
        final float prevPosition = (float) prevSection / sectionCount;
        final float nextPosition = (float) nextSection / sectionCount;
        final float snapThreshold = (count == 0) ? Float.MAX_VALUE : .125f / count;
        if (prevSection == exactSection && position - prevPosition < snapThreshold) {
            targetIndex = prevIndex;
        } else {
            targetIndex = prevIndex + (int) ((nextIndex - prevIndex) * (position - prevPosition) / (nextPosition - prevPosition));
        }
        // Clamp to valid positions.
        targetIndex = MathUtils.constrain(targetIndex, 0, count - 1);
        if (mList instanceof ExpandableListView) {
            final ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(targetIndex + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(targetIndex + mHeaderCount, 0);
        } else {
            mList.setSelection(targetIndex + mHeaderCount);
        }
    } else {
        final int index = MathUtils.constrain((int) (position * count), 0, count - 1);
        if (mList instanceof ExpandableListView) {
            ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(index + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(index + mHeaderCount, 0);
        } else {
            mList.setSelection(index + mHeaderCount);
        }
        sectionIndex = -1;
    }
    if (mCurrentSection != sectionIndex) {
        mCurrentSection = sectionIndex;
        final boolean hasPreview = transitionPreviewLayout(sectionIndex);
        if (!mShowingPreview && hasPreview) {
            transitionToDragging();
        } else if (mShowingPreview && !hasPreview) {
            transitionToVisible();
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.ListView.arrowScrollImpl:COMMENT
Method Modifier: private     
Comment:/**
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable,
 * whether there are focusable items etc.
 *
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */

Body of Frist Method:
{
    if (getChildCount() <= 0) {
        return false;
    }
    View selectedView = getSelectedView();
    int selectedPos = mSelectedPosition;
    int nextSelectedPosition = nextSelectedPositionForDirection(selectedView, selectedPos, direction);
    int amountToScroll = amountToScroll(direction, nextSelectedPosition);
    // if we are moving focus, we may OVERRIDE the default behavior
    final ArrowScrollFocusResult focusResult = mItemsCanFocus ? arrowScrollFocused(direction) : null;
    if (focusResult != null) {
        nextSelectedPosition = focusResult.getSelectedPosition();
        amountToScroll = focusResult.getAmountToScroll();
    }
    boolean needToRedraw = focusResult != null;
    if (nextSelectedPosition != INVALID_POSITION) {
        handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
        setSelectedPositionInt(nextSelectedPosition);
        setNextSelectedPositionInt(nextSelectedPosition);
        selectedView = getSelectedView();
        selectedPos = nextSelectedPosition;
        if (mItemsCanFocus && focusResult == null) {
            // there was no new view found to take focus, make sure we
            // don't leave focus with the old selection
            final View focused = getFocusedChild();
            if (focused != null) {
                focused.clearFocus();
            }
        }
        needToRedraw = true;
        checkSelectionChanged();
    }
    if (amountToScroll > 0) {
        scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
        needToRedraw = true;
    }
    // item that was panned off screen gives up focus.
    if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
        final View focused = selectedView.findFocus();
        if (!isViewAncestorOf(focused, this) || distanceToView(focused) > 0) {
            focused.clearFocus();
        }
    }
    // if  the current selection is panned off, we need to remove the selection
    if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView, this)) {
        selectedView = null;
        hideSelector();
        // but we don't want to set the ressurect position (that would make subsequent
        // unhandled key events bring back the item we just scrolled off!)
        mResurrectToPosition = INVALID_POSITION;
    }
    if (needToRedraw) {
        if (selectedView != null) {
            positionSelector(selectedPos, selectedView);
            mSelectedTop = selectedView.getTop();
        }
        if (!awakenScrollBars()) {
            invalidate();
        }
        invokeOnItemScrollListener();
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (getChildCount() <= 0) {
        return false;
    }
    View selectedView = getSelectedView();
    int selectedPos = mSelectedPosition;
    int nextSelectedPosition = nextSelectedPositionForDirection(selectedView, selectedPos, direction);
    int amountToScroll = amountToScroll(direction, nextSelectedPosition);
    // if we are moving focus, we may OVERRIDE the default behavior
    final ArrowScrollFocusResult focusResult = mItemsCanFocus ? arrowScrollFocused(direction) : null;
    if (focusResult != null) {
        nextSelectedPosition = focusResult.getSelectedPosition();
        amountToScroll = focusResult.getAmountToScroll();
    }
    boolean needToRedraw = focusResult != null;
    if (nextSelectedPosition != INVALID_POSITION) {
        handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
        setSelectedPositionInt(nextSelectedPosition);
        setNextSelectedPositionInt(nextSelectedPosition);
        selectedView = getSelectedView();
        selectedPos = nextSelectedPosition;
        if (mItemsCanFocus && focusResult == null) {
            // there was no new view found to take focus, make sure we
            // don't leave focus with the old selection
            final View focused = getFocusedChild();
            if (focused != null) {
                focused.clearFocus();
            }
        }
        needToRedraw = true;
        checkSelectionChanged();
    }
    if (amountToScroll > 0) {
        scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
        needToRedraw = true;
    }
    // item that was panned off screen gives up focus.
    if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
        final View focused = selectedView.findFocus();
        if (!isViewAncestorOf(focused, this) || distanceToView(focused) > 0) {
            focused.clearFocus();
        }
    }
    // if  the current selection is panned off, we need to remove the selection
    if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView, this)) {
        selectedView = null;
        hideSelector();
        // but we don't want to set the ressurect position (that would make subsequent
        // unhandled key events bring back the item we just scrolled off!)
        mResurrectToPosition = INVALID_POSITION;
    }
    if (needToRedraw) {
        if (selectedView != null) {
            positionSelectorLikeFocus(selectedPos, selectedView);
            mSelectedTop = selectedView.getTop();
        }
        if (!awakenScrollBars()) {
            invalidate();
        }
        invokeOnItemScrollListener();
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible description of the entry, as a possible sub-text for the title.
 * You can use this to describe the entry in more detail or to display the current state of
 * the restriction.
 * @param description the user-visible description string.
 */

Body of Frist Method:
{
    this.description = description;
}
Body of Second Method:
{
    this.mDescription = description;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.registerMediaButtonIntent:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.registerMediaButtonIntent(PendingIntent pi, ComponentName c)
 * precondition: mediaIntent != null
 */

Body of Frist Method:
{
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            pushMediaButtonReceiver_syncAfRcs(mediaIntent, eventReceiver, token);
            // new RC client, assume every type of information shall be queried
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
Body of Second Method:
{
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mPRStack) {
        if (pushMediaButtonReceiver_syncPrs(mediaIntent, eventReceiver, token)) {
            // new RC client, assume every type of information shall be queried
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.framework.permission.tests.VibratorServicePermissionTest.testVibrate:COMMENT
Method Modifier: public      
Comment:/**
 * Test that calling {@link android.os.IVibratorService#vibrate(long)} requires permissions.
 * <p>Tests permission:
 * {@link android.Manifest.permission#VIBRATE}
 * @throws RemoteException
 */

Body of Frist Method:
{
    try {
        mVibratorService.vibrate(Process.myUid(), null, 2000, new Binder());
        fail("vibrate did not throw SecurityException as expected");
    } catch (SecurityException e) {
    // expected
    }
}
Body of Second Method:
{
    try {
        mVibratorService.vibrate(Process.myUid(), null, 2000, AudioManager.STREAM_ALARM, new Binder());
        fail("vibrate did not throw SecurityException as expected");
    } catch (SecurityException e) {
    // expected
    }
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleAirplaneModeEnableDisable:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching on/off Airplane mode numerous times at
 * various intervals.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_5MB_FILENAME;
    long filesize = DOWNLOAD_5MB_FILESIZE;
    // make sure WiFi is enabled, and airplane mode is not on
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // are we making any progress?
        waitForFileToGrow(downloadedFile);
        // download disable
        Log.i(LOG_TAG, "Turning on Airplane mode...");
        setAirplaneModeOn(true);
        // wait 1 minute
        Thread.sleep(60 * 1000);
        // download enable
        Log.i(LOG_TAG, "Turning off Airplane mode...");
        setAirplaneModeOn(false);
        // make sure we're starting to download some data...
        waitForFileToGrow(downloadedFile);
        // reenable the connection to start up the download again
        Log.i(LOG_TAG, "Turning on Airplane mode again...");
        setAirplaneModeOn(true);
        // wait 20 seconds
        Thread.sleep(20 * 1000);
        // Finish up the download...
        Log.i(LOG_TAG, "Turning off Airplane mode again...");
        setAirplaneModeOn(false);
        Log.i(LOG_TAG, "Waiting up to 3 minutes for donwload to complete...");
        // wait up to 3 mins before timeout
        waitForDownloadsOrTimeout(dlRequest, 180 * 1000);
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    long filesize = DOWNLOAD_FILESIZE;
    // make sure WiFi is enabled, and airplane mode is not on
    doCommonDownloadSetup();
    String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
    File downloadedFile = new File(localDownloadDirectory, filename);
    long dlRequest = -1;
    try {
        downloadedFile.delete();
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        // Local destination of downloaded file
        Uri localUri = Uri.fromFile(downloadedFile);
        Log.i(LOG_TAG, "setting localUri to: " + localUri.getPath());
        request.setDestinationUri(localUri);
        request.setAllowedNetworkTypes(Request.NETWORK_WIFI);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        // are we making any progress?
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // download disable
        Log.i(LOG_TAG, "Turning on Airplane mode...");
        setAirplaneModeOn(true);
        // wait 1 minute
        Thread.sleep(60 * 1000);
        // download enable
        Log.i(LOG_TAG, "Turning off Airplane mode...");
        setAirplaneModeOn(false);
        // make sure we're starting to download some data...
        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
        // reenable the connection to start up the download again
        Log.i(LOG_TAG, "Turning on Airplane mode again...");
        setAirplaneModeOn(true);
        // wait 20 seconds
        Thread.sleep(20 * 1000);
        // Finish up the download...
        Log.i(LOG_TAG, "Turning off Airplane mode again...");
        setAirplaneModeOn(false);
        Log.i(LOG_TAG, "Waiting up to 10 minutes for donwload to complete...");
        // wait up to 10 mins
        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
        ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
        verifyFileSize(pfd, filesize);
    } finally {
        Log.i(LOG_TAG, "Cleaning up files...");
        if (dlRequest != -1) {
            mDownloadManager.remove(dlRequest);
        }
        downloadedFile.delete();
    }
}
------------------------
Find a functionally equivalent code:android.view.LayoutInflater_Delegate.rInflate:COMMENT
Method Modifier: default     static      
Comment:/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 *
 * This implementation just records the merge status before calling the default implementation.
 */

Body of Frist Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
Body of Second Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate, inheritContext);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawPaint:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with
 * the specified paint. This is equivalent (but faster) to drawing an
 * infinitely large rectangle with the specified paint.
 *
 * @param paint The paint used to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawPaint(mNativeCanvas, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPaint(mNativeCanvasWrapper, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:com.android.internal.util.FileRotator.maybeRotate:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Examine all files managed by this rotator, renaming or deleting if their
 * age matches the configured thresholds.
 */

Body of Frist Method:
{
    final long rotateBefore = currentTimeMillis - mRotateAgeMillis;
    final long deleteBefore = currentTimeMillis - mDeleteAgeMillis;
    final FileInfo info = new FileInfo(mPrefix);
    for (String name : mBasePath.list()) {
        if (!info.parse(name))
            continue;
        if (info.isActive()) {
            if (info.startMillis <= rotateBefore) {
                // found active file; rotate if old enough
                if (LOGD)
                    Slog.d(TAG, "rotating " + name);
                info.endMillis = currentTimeMillis;
                final File file = new File(mBasePath, name);
                final File destFile = new File(mBasePath, info.build());
                file.renameTo(destFile);
            }
        } else if (info.endMillis <= deleteBefore) {
            // found rotated file; delete if old enough
            if (LOGD)
                Slog.d(TAG, "deleting " + name);
            final File file = new File(mBasePath, name);
            file.delete();
        }
    }
}
Body of Second Method:
{
    final long rotateBefore = currentTimeMillis - mRotateAgeMillis;
    final long deleteBefore = currentTimeMillis - mDeleteAgeMillis;
    final FileInfo info = new FileInfo(mPrefix);
    String[] baseFiles = mBasePath.list();
    if (baseFiles == null) {
        return;
    }
    for (String name : baseFiles) {
        if (!info.parse(name))
            continue;
        if (info.isActive()) {
            if (info.startMillis <= rotateBefore) {
                // found active file; rotate if old enough
                if (LOGD)
                    Slog.d(TAG, "rotating " + name);
                info.endMillis = currentTimeMillis;
                final File file = new File(mBasePath, name);
                final File destFile = new File(mBasePath, info.build());
                file.renameTo(destFile);
            }
        } else if (info.endMillis <= deleteBefore) {
            // found rotated file; delete if old enough
            if (LOGD)
                Slog.d(TAG, "deleting " + name);
            final File file = new File(mBasePath, name);
            file.delete();
        }
    }
}
------------------------
Find a functionally equivalent code:android.preference.DialogPreference.setDialogIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the icon (resource ID) of the dialog. This will be shown on
 * subsequent dialogs.
 *
 * @param dialogIconRes The icon, as a resource ID.
 */

Body of Frist Method:
{
    mDialogIcon = getContext().getResources().getDrawable(dialogIconRes);
}
Body of Second Method:
{
    mDialogIcon = getContext().getDrawable(dialogIconRes);
}
------------------------
Find a functionally equivalent code:android.util.ArraySet.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

Body of Frist Method:
{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}
Body of Second Method:
{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}
------------------------
Find a functionally equivalent code:android.view.animation.Transformation.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Reset the transformation to a state that leaves the object
 * being animated in an unmodified state. The transformation type is
 * {@link #TYPE_BOTH} by default.
 */

Body of Frist Method:
{
    if (mMatrix == null) {
        mMatrix = new Matrix();
    } else {
        mMatrix.reset();
    }
    mAlpha = 1.0f;
    mTransformationType = TYPE_BOTH;
}
Body of Second Method:
{
    if (mMatrix == null) {
        mMatrix = new Matrix();
    } else {
        mMatrix.reset();
    }
    mClipRect.setEmpty();
    mHasClipRect = false;
    mAlpha = 1.0f;
    mTransformationType = TYPE_BOTH;
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callGet_Original:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses the "_Original" methods for {@link OuterClass#get}
 * or {@link InnerClass#get}via reflection.
 */

Body of Frist Method:
{
    Method m = instance.getClass().getMethod("get_Original", new Class<?>[] { int.class, long.class });
    Object result = m.invoke(instance, new Object[] { a, b });
    return ((Integer) result).intValue();
}
Body of Second Method:
{
    Method m = instance.getClass().getMethod("get_Original", int.class, long.class);
    Object result = m.invoke(instance, a, b);
    return (Integer) result;
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.PositionScroller.scrollToVisible:COMMENT
<android.widget.AbsListView.PositionScroller: void scrollToVisible(int,int,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Scroll such that targetPos is in the visible padded region without scrolling
 * boundPos out of view. Assumes targetPos is onscreen.
 */

Body of Frist Method:
{
    final int firstPos = mFirstPosition;
    final int childCount = getChildCount();
    final int lastPos = firstPos + childCount - 1;
    final int paddedTop = mListPadding.top;
    final int paddedBottom = getHeight() - mListPadding.bottom;
    if (targetPos < firstPos || targetPos > lastPos) {
        Log.w(TAG, "scrollToVisible called with targetPos " + targetPos + " not visible [" + firstPos + ", " + lastPos + "]");
    }
    if (boundPos < firstPos || boundPos > lastPos) {
        // boundPos doesn't matter, it's already offscreen.
        boundPos = INVALID_POSITION;
    }
    final View targetChild = getChildAt(targetPos - firstPos);
    final int targetTop = targetChild.getTop();
    final int targetBottom = targetChild.getBottom();
    int scrollBy = 0;
    if (targetBottom > paddedBottom) {
        scrollBy = targetBottom - paddedBottom;
    }
    if (targetTop < paddedTop) {
        scrollBy = targetTop - paddedTop;
    }
    if (scrollBy == 0) {
        return;
    }
    if (boundPos >= 0) {
        final View boundChild = getChildAt(boundPos - firstPos);
        final int boundTop = boundChild.getTop();
        final int boundBottom = boundChild.getBottom();
        final int absScroll = Math.abs(scrollBy);
        if (scrollBy < 0 && boundBottom + absScroll > paddedBottom) {
            // Don't scroll the bound view off the bottom of the screen.
            scrollBy = Math.max(0, boundBottom - paddedBottom);
        } else if (scrollBy > 0 && boundTop - absScroll < paddedTop) {
            // Don't scroll the bound view off the top of the screen.
            scrollBy = Math.min(0, boundTop - paddedTop);
        }
    }
    smoothScrollBy(scrollBy, duration);
}
Body of Second Method:
{
    final int firstPos = mFirstPosition;
    final int childCount = getChildCount();
    final int lastPos = firstPos + childCount - 1;
    final int paddedTop = mListPadding.top;
    final int paddedBottom = getHeight() - mListPadding.bottom;
    if (targetPos < firstPos || targetPos > lastPos) {
        Log.w(TAG, "scrollToVisible called with targetPos " + targetPos + " not visible [" + firstPos + ", " + lastPos + "]");
    }
    if (boundPos < firstPos || boundPos > lastPos) {
        // boundPos doesn't matter, it's already offscreen.
        boundPos = INVALID_POSITION;
    }
    final View targetChild = getChildAt(targetPos - firstPos);
    final int targetTop = targetChild.getTop();
    final int targetBottom = targetChild.getBottom();
    int scrollBy = 0;
    if (targetBottom > paddedBottom) {
        scrollBy = targetBottom - paddedBottom;
    }
    if (targetTop < paddedTop) {
        scrollBy = targetTop - paddedTop;
    }
    if (scrollBy == 0) {
        return;
    }
    if (boundPos >= 0) {
        final View boundChild = getChildAt(boundPos - firstPos);
        final int boundTop = boundChild.getTop();
        final int boundBottom = boundChild.getBottom();
        final int absScroll = Math.abs(scrollBy);
        if (scrollBy < 0 && boundBottom + absScroll > paddedBottom) {
            // Don't scroll the bound view off the bottom of the screen.
            scrollBy = Math.max(0, boundBottom - paddedBottom);
        } else if (scrollBy > 0 && boundTop - absScroll < paddedTop) {
            // Don't scroll the bound view off the top of the screen.
            scrollBy = Math.min(0, boundTop - paddedTop);
        }
    }
    smoothScrollBy(scrollBy, duration);
}
------------------------
Find a functionally equivalent code:android.os.Process.myPpid:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Returns the identifier of this process' parent.
 * @hide
 */

Body of Frist Method:
{
    return Libcore.os.getppid();
}
Body of Second Method:
{
    return Os.getppid();
}
------------------------
Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateStatus:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateStatus(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    validateDeviceAddress(deviceAddress);
    WifiP2pDevice d = mDevices.get(deviceAddress);
    if (d != null) {
        d.status = status;
    }
}
Body of Second Method:
{
    validateDeviceAddress(deviceAddress);
    WifiP2pDevice d = mDevices.get(deviceAddress);
    if (d != null) {
        d.status = status;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Picture.createFromStream:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Create a new picture (already recorded) from the data in the stream. This
 * data was generated by a previous call to writeToStream(). Pictures that
 * have been persisted across device restarts are not guaranteed to decode
 * properly and are highly discouraged.
 *
 * <p>
 * <strong>Note:</strong> a picture created from an input stream cannot be
 * replayed on a hardware accelerated canvas.
 *
 * @see #writeToStream(java.io.OutputStream)
 * @deprecated The recommended alternative is to not use writeToStream and
 * instead draw the picture into a Bitmap from which you can persist it as
 * raw or compressed pixels.
 */

Body of Frist Method:
{
    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]), true);
}
Body of Second Method:
{
    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]));
}
------------------------
Find a functionally equivalent code:android.os.NullVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    vibrate(pattern, repeat);
}
Body of Second Method:
{
    if (repeat >= pattern.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
}
------------------------
Find a functionally equivalent code:android.ddm.DdmHandleHeap.handleHPGC:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "HeaP Garbage Collection" request.
     */

Body of Frist Method:
{
    if (false)
        Log.d("ddm-heap", "Heap GC request");
    System.gc();
    // empty response
    return null;
}
Body of Second Method:
{
    if (false)
        Log.d("ddm-heap", "Heap GC request");
    Runtime.getRuntime().gc();
    // empty response
    return null;
}
------------------------
Find a functionally equivalent code:android.text.format.Time.format:COMMENT
Method Modifier: public      
Comment:/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */

Body of Frist Method:
{
    synchronized (Time.class) {
        Locale locale = Locale.getDefault();
        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
            LocaleData localeData = LocaleData.get(locale);
            sAm = localeData.amPm[0];
            sPm = localeData.amPm[1];
            sZeroDigit = localeData.zeroDigit;
            sShortMonths = localeData.shortMonthNames;
            sLongMonths = localeData.longMonthNames;
            sLongStandaloneMonths = localeData.longStandAloneMonthNames;
            sShortWeekdays = localeData.shortWeekdayNames;
            sLongWeekdays = localeData.longWeekdayNames;
            Resources r = Resources.getSystem();
            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
            sLocale = locale;
        }
        String result = format1(format);
        if (sZeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    }
}
Body of Second Method:
{
    calculator.copyFieldsFromTime(this);
    return calculator.format(format);
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsContract.deleteDocument:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Bundle in = new Bundle();
    in.putString(Document.COLUMN_DOCUMENT_ID, getDocumentId(documentUri));
    client.call(METHOD_DELETE_DOCUMENT, null, in);
}
Body of Second Method:
{
    final Bundle in = new Bundle();
    in.putParcelable(DocumentsContract.EXTRA_URI, documentUri);
    client.call(METHOD_DELETE_DOCUMENT, null, in);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.verifyCellularConnection:COMMENT
<com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest: void verifyCellularConnection()>
Method Modifier: public      private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// help function to verify 3G connection

Body of Frist Method:
{
    NetworkInfo extraNetInfo = mCM.getActiveNetworkInfo();
    assertEquals("network type is not MOBILE", ConnectivityManager.TYPE_MOBILE, extraNetInfo.getType());
    assertTrue("not connected to cellular network", extraNetInfo.isConnected());
}
Body of Second Method:
{
    NetworkInfo extraNetInfo = mCm.getActiveNetworkInfo();
    assertEquals("network type is not MOBILE", ConnectivityManager.TYPE_MOBILE, extraNetInfo.getType());
    assertTrue("not connected to cellular network", extraNetInfo.isConnected());
}
------------------------
Find a functionally equivalent code:android.util.SparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            Object[] nvalues = new Object[n];
            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of the focused month.
 *
 * @param color The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

Body of Frist Method:
{
    if (mFocusedMonthDateColor != color) {
        mFocusedMonthDateColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasFocusedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setFocusedMonthDateColor(color);
}
------------------------
Find a functionally equivalent code:android.provider.Settings.Secure.putIntForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LOCATION_MODE.equals(name)) {
        // TODO: once b/10491283 fixed, remove this hack
        return setLocationModeForUser(cr, value, userHandle);
    }
    return putStringForUser(cr, name, Integer.toString(value), userHandle);
}
Body of Second Method:
{
    return putStringForUser(cr, name, Integer.toString(value), userHandle);
}
------------------------
Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleServiceConnected:COMMENT
Method Modifier: 
Comment:/**
 * Tells the service to start its UI via an AIDL interface.  Called when the
 * onServiceConnected() callback is received.
 */

Body of Frist Method:
{
    Log.d(TAG, "handleServiceConnected()");
    // onServiceConnected() rather than using a handler.
    if (!mBoundToService) {
        Log.d(TAG, "Dropping startUi() in handleServiceConnected() because no longer bound");
        return;
    }
    try {
        mService.registerCallback(mFaceUnlockCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "Caught exception connecting to Face Unlock: " + e.toString());
        mService = null;
        mBoundToService = false;
        mIsRunning = false;
        return;
    }
    if (mFaceUnlockView != null) {
        IBinder windowToken = mFaceUnlockView.getWindowToken();
        if (windowToken != null) {
            // When switching between portrait and landscape view while Face Unlock is running,
            // the screen will eventually go dark unless we poke the wakelock when Face Unlock
            // is restarted.
            mKeyguardScreenCallback.userActivity(0);
            int[] position;
            position = new int[2];
            mFaceUnlockView.getLocationInWindow(position);
            startUi(windowToken, position[0], position[1], mFaceUnlockView.getWidth(), mFaceUnlockView.getHeight());
        } else {
            Log.e(TAG, "windowToken is null in handleServiceConnected()");
        }
    }
}
Body of Second Method:
{
    Log.d(TAG, "handleServiceConnected()");
    // onServiceConnected() rather than using a handler.
    if (!mBoundToService) {
        Log.d(TAG, "Dropping startUi() in handleServiceConnected() because no longer bound");
        return;
    }
    try {
        mService.registerCallback(mFaceUnlockCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "Caught exception connecting to Face Unlock: " + e.toString());
        mService = null;
        mBoundToService = false;
        mIsRunning = false;
        return;
    }
    if (mFaceUnlockView != null) {
        IBinder windowToken = mFaceUnlockView.getWindowToken();
        if (windowToken != null) {
            // When switching between portrait and landscape view while Face Unlock is running,
            // the screen will eventually go dark unless we poke the wakelock when Face Unlock
            // is restarted.
            mKeyguardScreenCallback.userActivity();
            int[] position;
            position = new int[2];
            mFaceUnlockView.getLocationInWindow(position);
            startUi(windowToken, position[0], position[1], mFaceUnlockView.getWidth(), mFaceUnlockView.getHeight());
        } else {
            Log.e(TAG, "windowToken is null in handleServiceConnected()");
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:android.view.inputmethod.InputMethodManager.clearBindingLocked:COMMENT
Method Modifier: 
Comment:/**
 * Reset all of the state associated with being bound to an input method.
 */

Body of Frist Method:
{
    clearConnectionLocked();
    setInputChannelLocked(null);
    mBindSequence = -1;
    mCurId = null;
    mCurMethod = null;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "Clearing binding!");
    clearConnectionLocked();
    setInputChannelLocked(null);
    mBindSequence = -1;
    mCurId = null;
    mCurMethod = null;
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureRequestKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */

Body of Frist Method:
{
    if (mAvailableRequestKeys == null) {
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class);
    }
    return mAvailableRequestKeys;
}
Body of Second Method:
{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableRequestKeys must be non-null " + "in the characteristics");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailableRequestKeys;
}
------------------------
Find a functionally equivalent code:android.widget.TextView.setError:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the right-hand compound drawable of the TextView to the "error"
 * icon and sets an error message that will be displayed in a popup when
 * the TextView has focus.  The icon and error message will be reset to
 * null when any key events cause changes to the TextView's text.  If the
 * <code>error</code> is <code>null</code>, the error message and icon
 * will be cleared.
 */

Body of Frist Method:
{
    if (error == null) {
        setError(null, null);
    } else {
        Drawable dr = getContext().getResources().getDrawable(com.android.internal.R.drawable.indicator_input_error);
        dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight());
        setError(error, dr);
    }
}
Body of Second Method:
{
    if (error == null) {
        setError(null, null);
    } else {
        Drawable dr = getContext().getDrawable(com.android.internal.R.drawable.indicator_input_error);
        dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight());
        setError(error, dr);
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.init:COMMENT
Method Modifier: 
Comment:/**
 * Internal function, called by ValueAnimator, to set up the TypeEvaluator that will be used
 * to calculate animated values.
 */

Body of Frist Method:
{
    if (mEvaluator == null) {
        // We already handle int and float automatically, but not their Object
        // equivalents
        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
    }
    if (mEvaluator != null) {
        // KeyframeSet knows how to evaluate the common types - only give it a custom
        // evaluator if one has been set on this class
        mKeyframeSet.setEvaluator(mEvaluator);
    }
}
Body of Second Method:
{
    if (mEvaluator == null) {
        // We already handle int and float automatically, but not their Object
        // equivalents
        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
    }
    if (mEvaluator != null) {
        // KeyframeSet knows how to evaluate the common types - only give it a custom
        // evaluator if one has been set on this class
        mKeyframes.setEvaluator(mEvaluator);
    }
}
------------------------
Find a functionally equivalent code:android.app.KeyguardManager.exitKeyguardSecurely:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
 * and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
 * instead; this allows you to seamlessly hide the keyguard as your application
 * moves in and out of the foreground and does not require that any special
 * permissions be requested.
 *
 * Exit the keyguard securely.  The use case for this api is that, after
 * disabling the keyguard, your app, which was granted permission to
 * disable the keyguard and show a limited amount of information deemed
 * safe without the user getting past the keyguard, needs to navigate to
 * something that is not safe to view without getting past the keyguard.
 *
 * This will, if the keyguard is secure, bring up the unlock screen of
 * the keyguard.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#DISABLE_KEYGUARD}.
 *
 * @param callback Let's you know whether the operation was succesful and
 * it is safe to launch anything that would normally be considered safe
 * once the user has gotten past the keyguard.
 */

Body of Frist Method:
{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                callback.onKeyguardExitResult(success);
            }
        });
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                if (callback != null) {
                    callback.onKeyguardExitResult(success);
                }
            }
        });
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageItemInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */

Body of Frist Method:
{
    if (icon != 0) {
        Drawable dr = pm.getDrawable(packageName, icon, getApplicationInfo());
        if (dr != null) {
            return dr;
        }
    }
    return loadDefaultIcon(pm);
}
Body of Second Method:
{
    return pm.loadItemIcon(this, getApplicationInfo());
}
------------------------
Find a functionally equivalent code:android.animation.LayoutTransition.setupChangeAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function called by runChangingTransition for both the children and the parent
 * hierarchy.
 */

Body of Frist Method:
{
    // changes for the existing children in the container.
    if (layoutChangeListenerMap.get(child) != null) {
        return;
    }
    // on these views
    if (child.getWidth() == 0 && child.getHeight() == 0) {
        return;
    }
    // Make a copy of the appropriate animation
    final Animator anim = baseAnimator.clone();
    // Set the target object for the animation
    anim.setTarget(child);
    // A ObjectAnimator (or AnimatorSet of them) can extract start values from
    // its target object
    anim.setupStartValues();
    // If there's an animation running on this view already, cancel it
    Animator currentAnimation = pendingAnimations.get(child);
    if (currentAnimation != null) {
        currentAnimation.cancel();
        pendingAnimations.remove(child);
    }
    // Cache the animation in case we need to cancel it later
    pendingAnimations.put(child, anim);
    // For the animations which don't get started, we have to have a means of
    // removing them from the cache, lest we leak them and their target objects.
    // We run an animator for the default duration+100 (an arbitrary time, but one
    // which should far surpass the delay between setting them up here and
    // handling layout events which start them.
    ValueAnimator pendingAnimRemover = ValueAnimator.ofFloat(0f, 1f).setDuration(duration + 100);
    pendingAnimRemover.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            pendingAnimations.remove(child);
        }
    });
    pendingAnimRemover.start();
    // Add a listener to track layout changes on this view. If we don't get a callback,
    // then there's nothing to animate.
    final View.OnLayoutChangeListener listener = new View.OnLayoutChangeListener() {

        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Tell the animation to extract end values from the changed object
            anim.setupEndValues();
            if (anim instanceof ValueAnimator) {
                boolean valuesDiffer = false;
                ValueAnimator valueAnim = (ValueAnimator) anim;
                PropertyValuesHolder[] oldValues = valueAnim.getValues();
                for (int i = 0; i < oldValues.length; ++i) {
                    PropertyValuesHolder pvh = oldValues[i];
                    KeyframeSet keyframeSet = pvh.mKeyframeSet;
                    if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
                        valuesDiffer = true;
                    }
                }
                if (!valuesDiffer) {
                    return;
                }
            }
            long startDelay = 0;
            switch(changeReason) {
                case APPEARING:
                    startDelay = mChangingAppearingDelay + staggerDelay;
                    staggerDelay += mChangingAppearingStagger;
                    if (mChangingAppearingInterpolator != sChangingAppearingInterpolator) {
                        anim.setInterpolator(mChangingAppearingInterpolator);
                    }
                    break;
                case DISAPPEARING:
                    startDelay = mChangingDisappearingDelay + staggerDelay;
                    staggerDelay += mChangingDisappearingStagger;
                    if (mChangingDisappearingInterpolator != sChangingDisappearingInterpolator) {
                        anim.setInterpolator(mChangingDisappearingInterpolator);
                    }
                    break;
                case CHANGING:
                    startDelay = mChangingDelay + staggerDelay;
                    staggerDelay += mChangingStagger;
                    if (mChangingInterpolator != sChangingInterpolator) {
                        anim.setInterpolator(mChangingInterpolator);
                    }
                    break;
            }
            anim.setStartDelay(startDelay);
            anim.setDuration(duration);
            Animator prevAnimation = currentChangingAnimations.get(child);
            if (prevAnimation != null) {
                prevAnimation.cancel();
            }
            Animator pendingAnimation = pendingAnimations.get(child);
            if (pendingAnimation != null) {
                pendingAnimations.remove(child);
            }
            // Cache the animation in case we need to cancel it later
            currentChangingAnimations.put(child, anim);
            parent.requestTransitionStart(LayoutTransition.this);
            // this only removes listeners whose views changed - must clear the
            // other listeners later
            child.removeOnLayoutChangeListener(this);
            layoutChangeListenerMap.remove(child);
        }
    };
    // Remove the animation from the cache when it ends
    anim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animator) {
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.startTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }

        @Override
        public void onAnimationCancel(Animator animator) {
            child.removeOnLayoutChangeListener(listener);
            layoutChangeListenerMap.remove(child);
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            currentChangingAnimations.remove(child);
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.endTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }
    });
    child.addOnLayoutChangeListener(listener);
    // cache the listener for later removal
    layoutChangeListenerMap.put(child, listener);
}
Body of Second Method:
{
    // changes for the existing children in the container.
    if (layoutChangeListenerMap.get(child) != null) {
        return;
    }
    // on these views
    if (child.getWidth() == 0 && child.getHeight() == 0) {
        return;
    }
    // Make a copy of the appropriate animation
    final Animator anim = baseAnimator.clone();
    // Set the target object for the animation
    anim.setTarget(child);
    // A ObjectAnimator (or AnimatorSet of them) can extract start values from
    // its target object
    anim.setupStartValues();
    // If there's an animation running on this view already, cancel it
    Animator currentAnimation = pendingAnimations.get(child);
    if (currentAnimation != null) {
        currentAnimation.cancel();
        pendingAnimations.remove(child);
    }
    // Cache the animation in case we need to cancel it later
    pendingAnimations.put(child, anim);
    // For the animations which don't get started, we have to have a means of
    // removing them from the cache, lest we leak them and their target objects.
    // We run an animator for the default duration+100 (an arbitrary time, but one
    // which should far surpass the delay between setting them up here and
    // handling layout events which start them.
    ValueAnimator pendingAnimRemover = ValueAnimator.ofFloat(0f, 1f).setDuration(duration + 100);
    pendingAnimRemover.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            pendingAnimations.remove(child);
        }
    });
    pendingAnimRemover.start();
    // Add a listener to track layout changes on this view. If we don't get a callback,
    // then there's nothing to animate.
    final View.OnLayoutChangeListener listener = new View.OnLayoutChangeListener() {

        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Tell the animation to extract end values from the changed object
            anim.setupEndValues();
            if (anim instanceof ValueAnimator) {
                boolean valuesDiffer = false;
                ValueAnimator valueAnim = (ValueAnimator) anim;
                PropertyValuesHolder[] oldValues = valueAnim.getValues();
                for (int i = 0; i < oldValues.length; ++i) {
                    PropertyValuesHolder pvh = oldValues[i];
                    if (pvh.mKeyframes instanceof KeyframeSet) {
                        KeyframeSet keyframeSet = (KeyframeSet) pvh.mKeyframes;
                        if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
                            valuesDiffer = true;
                        }
                    } else if (!pvh.mKeyframes.getValue(0).equals(pvh.mKeyframes.getValue(1))) {
                        valuesDiffer = true;
                    }
                }
                if (!valuesDiffer) {
                    return;
                }
            }
            long startDelay = 0;
            switch(changeReason) {
                case APPEARING:
                    startDelay = mChangingAppearingDelay + staggerDelay;
                    staggerDelay += mChangingAppearingStagger;
                    if (mChangingAppearingInterpolator != sChangingAppearingInterpolator) {
                        anim.setInterpolator(mChangingAppearingInterpolator);
                    }
                    break;
                case DISAPPEARING:
                    startDelay = mChangingDisappearingDelay + staggerDelay;
                    staggerDelay += mChangingDisappearingStagger;
                    if (mChangingDisappearingInterpolator != sChangingDisappearingInterpolator) {
                        anim.setInterpolator(mChangingDisappearingInterpolator);
                    }
                    break;
                case CHANGING:
                    startDelay = mChangingDelay + staggerDelay;
                    staggerDelay += mChangingStagger;
                    if (mChangingInterpolator != sChangingInterpolator) {
                        anim.setInterpolator(mChangingInterpolator);
                    }
                    break;
            }
            anim.setStartDelay(startDelay);
            anim.setDuration(duration);
            Animator prevAnimation = currentChangingAnimations.get(child);
            if (prevAnimation != null) {
                prevAnimation.cancel();
            }
            Animator pendingAnimation = pendingAnimations.get(child);
            if (pendingAnimation != null) {
                pendingAnimations.remove(child);
            }
            // Cache the animation in case we need to cancel it later
            currentChangingAnimations.put(child, anim);
            parent.requestTransitionStart(LayoutTransition.this);
            // this only removes listeners whose views changed - must clear the
            // other listeners later
            child.removeOnLayoutChangeListener(this);
            layoutChangeListenerMap.remove(child);
        }
    };
    // Remove the animation from the cache when it ends
    anim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animator) {
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.startTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }

        @Override
        public void onAnimationCancel(Animator animator) {
            child.removeOnLayoutChangeListener(listener);
            layoutChangeListenerMap.remove(child);
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            currentChangingAnimations.remove(child);
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.endTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }
    });
    child.addOnLayoutChangeListener(listener);
    // cache the listener for later removal
    layoutChangeListenerMap.put(child, listener);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.clearLock:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Clear any lock pattern or password.
 */

Body of Frist Method:
{
    if (!isFallback)
        deleteGallery();
    saveLockPassword(null, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    setLockPatternEnabled(false);
    saveLockPattern(null);
    setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
}
Body of Second Method:
{
    if (!isFallback)
        deleteGallery();
    saveLockPassword(null, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    setLockPatternEnabled(false);
    saveLockPattern(null);
    setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    onAfterChangingPassword();
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.Uid.getSensorStats:COMMENT
Method Modifier: public      abstract    
Comment:/**
 * Returns a mapping containing sensor statistics.
 *
 * @return a Map from Integer sensor ids to Uid.Sensor objects.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.Bitmap.setPixels:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Replace pixels in the bitmap with the colors in the array. Each element
 * in the array is a packed int prepresenting a non-premultiplied ARGB
 * {@link Color}.</p>
 *
 * @param pixels   The colors to write to the bitmap
 * @param offset   The index of the first color to read from pixels[]
 * @param stride   The number of colors in pixels[] to skip between rows.
 * Normally this value will be the same as the width of
 * the bitmap, but it can be larger (or negative).
 * @param x        The x coordinate of the first pixel to write to in
 * the bitmap.
 * @param y        The y coordinate of the first pixel to write to in
 * the bitmap.
 * @param width    The number of colors to copy from pixels[] per row
 * @param height   The number of rows to write to the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y, width, height are outside of
 * the bitmap's bounds.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a functionally equivalent code:android.util.Spline.interpolate:COMMENT
<android.util.Spline: float interpolate(float)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Interpolates the value of Y = f(X) for given X.
 * Clamps X to the domain of the spline.
 *
 * @param x The X value.
 * @return The interpolated Y = f(X) value.
 */

Body of Frist Method:
{
    // Handle the boundary cases.
    final int n = mX.length;
    if (Float.isNaN(x)) {
        return x;
    }
    if (x <= mX[0]) {
        return mY[0];
    }
    if (x >= mX[n - 1]) {
        return mY[n - 1];
    }
    // Find the index 'i' of the last point with smaller X.
    // We know this will be within the spline due to the boundary tests.
    int i = 0;
    while (x >= mX[i + 1]) {
        i += 1;
        if (x == mX[i]) {
            return mY[i];
        }
    }
    // Perform cubic Hermite spline interpolation.
    float h = mX[i + 1] - mX[i];
    float t = (x - mX[i]) / h;
    return (mY[i] * (1 + 2 * t) + h * mM[i] * t) * (1 - t) * (1 - t) + (mY[i + 1] * (3 - 2 * t) + h * mM[i + 1] * (t - 1)) * t * t;
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.Ringtone.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops a playing ringtone.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        destroyLocalPlayer();
    } else if (mAllowRemote) {
        try {
            mRemotePlayer.stop(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem stopping ringtone: " + e);
        }
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        destroyLocalPlayer();
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        try {
            mRemotePlayer.stop(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem stopping ringtone: " + e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.ListPopupWindow.ForwardingListener.onTouchForwarded:COMMENT
Method Modifier: private     
Comment:/**
 * Handled forwarded motion events and determines when to stop
 * forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to continue forwarding motion events, false to cancel
 */

Body of Frist Method:
{
    final View src = mSrc;
    final ListPopupWindow popup = getPopup();
    if (popup == null || !popup.isShowing()) {
        return false;
    }
    final DropDownListView dst = popup.mDropDownList;
    if (dst == null || !dst.isShown()) {
        return false;
    }
    // Convert event to destination-local coordinates.
    final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
    src.toGlobalMotionEvent(dstEvent);
    dst.toLocalMotionEvent(dstEvent);
    // Forward converted event to destination view, then recycle it.
    final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
    dstEvent.recycle();
    return handled;
}
Body of Second Method:
{
    final View src = mSrc;
    final ListPopupWindow popup = getPopup();
    if (popup == null || !popup.isShowing()) {
        return false;
    }
    final DropDownListView dst = popup.mDropDownList;
    if (dst == null || !dst.isShown()) {
        return false;
    }
    // Convert event to destination-local coordinates.
    final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
    src.toGlobalMotionEvent(dstEvent);
    dst.toLocalMotionEvent(dstEvent);
    // Forward converted event to destination view, then recycle it.
    final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
    dstEvent.recycle();
    // Always cancel forwarding when the touch stream ends.
    final int action = srcEvent.getActionMasked();
    final boolean keepForwarding = action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL;
    return handled && keepForwarding;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.layoutWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // we've already done the status bar
    if (win == mStatusBar || win == mNavigationBar) {
        return;
    }
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = attrs.flags;
    final int sim = attrs.softInputMode;
    final int sysUiFl = win.getSystemUiVisibility();
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                        cf.left = mDockLeft;
                        cf.top = mDockTop;
                        cf.right = mDockRight;
                        cf.bottom = mDockBottom;
                    } else {
                        cf.left = mContentLeft;
                        cf.top = mContentTop;
                        cf.right = mContentRight;
                        cf.bottom = mContentBottom;
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_UNIVERSE_BACKGROUND) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_WALLPAPER) {
                // The wallpaper also has Real Ultimate Power.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_TOAST || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL) {
                // Status bar panels are the only windows who can go on top of
                // the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // Toasts are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // TYPE_SYSTEM_ERROR is above the NavigationBar so it can't be allowed to extend over it.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
        df.left = df.top = of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
        df.right = df.bottom = of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString());
    win.computeFrameLw(pf, df, of, cf, vf, dcf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
}
Body of Second Method:
{
    // we've already done the status bar
    final WindowManager.LayoutParams attrs = win.getAttrs();
    if ((win == mStatusBar && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) == 0) || win == mNavigationBar) {
        return;
    }
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (win == mStatusBar && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        cf.bottom = mContentBottom;
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_UNIVERSE_BACKGROUND) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_WALLPAPER) {
                // The wallpaper also has Real Ultimate Power, but we want to tell
                // it about the overscan area.
                pf.left = df.left = mOverscanScreenLeft;
                pf.top = df.top = mOverscanScreenTop;
                pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                of.left = cf.left = mUnrestrictedScreenLeft;
                of.top = cf.top = mUnrestrictedScreenTop;
                of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL) {
                // Status bar panels are the only windows who can go on top of
                // the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // TYPE_SYSTEM_ERROR is above the NavigationBar so it can't be allowed to extend over it.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString());
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
------------------------
Find a functionally equivalent code:android.app.Instrumentation.newActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Perform instantiation of the process's {@link Activity} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Activity
 * object.
 * @param intent The Intent object that specified the activity class being
 * instantiated.
 *
 * @return The newly instantiated Activity object.
 */

Body of Frist Method:
{
    return (Activity) cl.loadClass(className).newInstance();
}
Body of Second Method:
{
    return (Activity) cl.loadClass(className).newInstance();
}
------------------------
Find a functionally equivalent code:android.content.SyncRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */

Body of Frist Method:
{
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
    }
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD, mTxBytes);
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD, mRxBytes);
    mSyncConfigExtras.putInt(ContentResolver.SYNC_EXTRAS_PRIORITY, mPriority);
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        validatePeriodicExtras(mCustomExtras);
        validatePeriodicExtras(mSyncConfigExtras);
        // Verify that account and provider are not null.
        if (mAccount == null) {
            throw new IllegalArgumentException("Account must not be null for periodic" + " sync.");
        }
        if (mAuthority == null) {
            throw new IllegalArgumentException("Authority must not be null for periodic" + " sync.");
        }
    } else if (mSyncType == SYNC_TYPE_UNKNOWN) {
        throw new IllegalArgumentException("Must call either syncOnce() or syncPeriodic()");
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with " + "setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
Body of Second Method:
{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.dumpTheme:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.MediaCodecInfo.getSupportedTypes:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query the media types supported by the codec.
 */

Body of Frist Method:
{
    return MediaCodecList.getSupportedTypes(mIndex);
}
Body of Second Method:
{
    Set<String> typeSet = mCaps.keySet();
    String[] types = typeSet.toArray(new String[typeSet.size()]);
    Arrays.sort(types);
    return types;
}
------------------------
Find a functionally equivalent code:android.text.SpannableStringBuilder.setSpan:COMMENT
Method Modifier: public      
Comment:/**
 * Mark the specified range of text with the specified object.
 * The flags determine how the span will behave when text is
 * inserted at the start or end of the span's range.
 */

Body of Frist Method:
{
    setSpan(true, what, start, end, flags);
}
Body of Second Method:
{
    setSpan(true, what, start, end, flags);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCStack:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control focus stack
 */

Body of Frist Method:
{
    pw.println("\nRemote Control stack entries (last is top of stack):");
    synchronized (mRCStack) {
        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            RemoteControlStackEntry rcse = stackIterator.next();
            pw.println("  pi: " + rcse.mMediaIntent + " -- pack: " + rcse.mCallingPackageName + "  -- ercvr: " + rcse.mReceiverComponent + "  -- client: " + rcse.mRcClient + "  -- uid: " + rcse.mCallingUid + "  -- type: " + rcse.mPlaybackType + "  state: " + rcse.mPlaybackState);
        }
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control stack entries (last is top of stack):");
    synchronized (mPRStack) {
        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw, true);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.NetworkManagementServiceTest.testNetworkObservers:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that network observers work properly.
 */

Body of Frist Method:
{
    BaseNetworkObserver observer = mock(BaseNetworkObserver.class);
    // Used by registerObserver.
    doReturn(new Binder()).when(observer).asBinder();
    mNMService.registerObserver(observer);
    // Forget everything that happened to the mock so far, so we can explicitly verify
    // everything that happens and does not happen to it from now on.
    reset(observer);
    // Now send NetworkManagementService messages and ensure that the observer methods are
    // called. After every valid message we expect a callback soon after; to ensure that
    // invalid messages don't cause any callbacks, we call verifyNoMoreInteractions at the end.
    /**
     * Interface changes.
     */
    sendMessage("600 Iface added rmnet12");
    expectSoon(observer).interfaceAdded("rmnet12");
    sendMessage("600 Iface removed eth1");
    expectSoon(observer).interfaceRemoved("eth1");
    sendMessage("607 Iface removed eth1");
    // Invalid code.
    sendMessage("600 Iface borked lo down");
    // Invalid event.
    sendMessage("600 Iface changed clat4 up again");
    // Extra tokens.
    sendMessage("600 Iface changed clat4 up");
    expectSoon(observer).interfaceStatusChanged("clat4", true);
    sendMessage("600 Iface linkstate rmnet0 down");
    expectSoon(observer).interfaceLinkStateChanged("rmnet0", false);
    sendMessage("600 IFACE linkstate clat4 up");
    // Invalid group.
    /**
     * Bandwidth control events.
     */
    sendMessage("601 limit alert data rmnet_usb0");
    expectSoon(observer).limitReached("data", "rmnet_usb0");
    sendMessage("601 invalid alert data rmnet0");
    // Invalid group.
    sendMessage("601 limit increased data rmnet0");
    // Invalid event.
    /**
     * Interface class activity.
     */
    sendMessage("613 IfaceClass active rmnet0");
    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true);
    sendMessage("613 IfaceClass idle eth0");
    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false);
    sendMessage("613 IfaceClass reallyactive rmnet0");
    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", false);
    sendMessage("613 InterfaceClass reallyactive rmnet0");
    // Invalid group.
    /**
     * IP address changes.
     */
    sendMessage("614 Address updated fe80::1/64 wlan0 128 253");
    expectSoon(observer).addressUpdated("fe80::1/64", "wlan0", 128, 253);
    // There is no "added".
    sendMessage("614 Address added fe80::1/64 wlan0 128 253");
    expectSoon(observer).addressRemoved("fe80::1/64", "wlan0", 128, 253);
    sendMessage("614 Address removed 2001:db8::1/64 wlan0 1 0");
    expectSoon(observer).addressRemoved("2001:db8::1/64", "wlan0", 1, 0);
    sendMessage("666 Address added 2001:db8::1/64 wlan0 1 0");
    // Invalid code.
    // Make sure nothing else was called.
    verifyNoMoreInteractions(observer);
}
Body of Second Method:
{
    BaseNetworkObserver observer = mock(BaseNetworkObserver.class);
    // Used by registerObserver.
    doReturn(new Binder()).when(observer).asBinder();
    mNMService.registerObserver(observer);
    // Forget everything that happened to the mock so far, so we can explicitly verify
    // everything that happens and does not happen to it from now on.
    reset(observer);
    // Now send NetworkManagementService messages and ensure that the observer methods are
    // called. After every valid message we expect a callback soon after; to ensure that
    // invalid messages don't cause any callbacks, we call verifyNoMoreInteractions at the end.
    /**
     * Interface changes.
     */
    sendMessage("600 Iface added rmnet12");
    expectSoon(observer).interfaceAdded("rmnet12");
    sendMessage("600 Iface removed eth1");
    expectSoon(observer).interfaceRemoved("eth1");
    sendMessage("607 Iface removed eth1");
    // Invalid code.
    sendMessage("600 Iface borked lo down");
    // Invalid event.
    sendMessage("600 Iface changed clat4 up again");
    // Extra tokens.
    sendMessage("600 Iface changed clat4 up");
    expectSoon(observer).interfaceStatusChanged("clat4", true);
    sendMessage("600 Iface linkstate rmnet0 down");
    expectSoon(observer).interfaceLinkStateChanged("rmnet0", false);
    sendMessage("600 IFACE linkstate clat4 up");
    // Invalid group.
    /**
     * Bandwidth control events.
     */
    sendMessage("601 limit alert data rmnet_usb0");
    expectSoon(observer).limitReached("data", "rmnet_usb0");
    sendMessage("601 invalid alert data rmnet0");
    // Invalid group.
    sendMessage("601 limit increased data rmnet0");
    // Invalid event.
    /**
     * Interface class activity.
     */
    sendMessage("613 IfaceClass active rmnet0");
    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 0);
    sendMessage("613 IfaceClass active rmnet0 1234");
    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 1234);
    sendMessage("613 IfaceClass idle eth0");
    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 0);
    sendMessage("613 IfaceClass idle eth0 1234");
    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 1234);
    sendMessage("613 IfaceClass reallyactive rmnet0 1234");
    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", false, 1234);
    sendMessage("613 InterfaceClass reallyactive rmnet0");
    // Invalid group.
    /**
     * IP address changes.
     */
    sendMessage("614 Address updated fe80::1/64 wlan0 128 253");
    expectSoon(observer).addressUpdated("wlan0", new LinkAddress("fe80::1/64", 128, 253));
    // There is no "added", so we take this as "removed".
    sendMessage("614 Address added fe80::1/64 wlan0 128 253");
    expectSoon(observer).addressRemoved("wlan0", new LinkAddress("fe80::1/64", 128, 253));
    sendMessage("614 Address removed 2001:db8::1/64 wlan0 1 0");
    expectSoon(observer).addressRemoved("wlan0", new LinkAddress("2001:db8::1/64", 1, 0));
    sendMessage("614 Address removed 2001:db8::1/64 wlan0 1");
    // Not enough arguments.
    sendMessage("666 Address removed 2001:db8::1/64 wlan0 1 0");
    // Invalid code.
    /**
     * DNS information broadcasts.
     */
    sendMessage("615 DnsInfo servers rmnet_usb0 3600 2001:db8::1");
    expectSoon(observer).interfaceDnsServerInfo("rmnet_usb0", 3600, new String[] { "2001:db8::1" });
    sendMessage("615 DnsInfo servers wlan0 14400 2001:db8::1,2001:db8::2");
    expectSoon(observer).interfaceDnsServerInfo("wlan0", 14400, new String[] { "2001:db8::1", "2001:db8::2" });
    // We don't check for negative lifetimes, only for parse errors.
    sendMessage("615 DnsInfo servers wlan0 -3600 ::1");
    expectSoon(observer).interfaceDnsServerInfo("wlan0", -3600, new String[] { "::1" });
    sendMessage("615 DnsInfo servers wlan0 SIXHUNDRED ::1");
    // Non-numeric lifetime.
    sendMessage("615 DnsInfo servers wlan0 2001:db8::1");
    // Missing lifetime.
    sendMessage("615 DnsInfo servers wlan0 3600");
    // No servers.
    sendMessage("615 DnsInfo servers 3600 wlan0 2001:db8::1,2001:db8::2");
    // Non-numeric lifetime.
    sendMessage("615 DnsInfo wlan0 7200 2001:db8::1,2001:db8::2");
    // Invalid tokens.
    sendMessage("666 DnsInfo servers wlan0 5400 2001:db8::1");
    // Invalid code.
    // No syntax checking on the addresses.
    sendMessage("615 DnsInfo servers wlan0 600 ,::,,foo,::1,");
    expectSoon(observer).interfaceDnsServerInfo("wlan0", 600, new String[] { "", "::", "", "foo", "::1" });
    // Make sure nothing else was called.
    verifyNoMoreInteractions(observer);
}
------------------------
Find a functionally equivalent code:android.text.TextLine.drawTextRun:COMMENT
Method Modifier: private     
Comment:/**
 * Render a text run with the set-up paint.
 *
 * @param c the canvas
 * @param wp the paint used to render the text
 * @param start the start of the run
 * @param end the end of the run
 * @param contextStart the start of context for the run
 * @param contextEnd the end of the context for the run
 * @param runIsRtl true if the run is right-to-left
 * @param x the x position of the left edge of the run
 * @param y the baseline of the run
 */

Body of Frist Method:
{
    int flags = runIsRtl ? Canvas.DIRECTION_RTL : Canvas.DIRECTION_LTR;
    if (mCharsValid) {
        int count = end - start;
        int contextCount = contextEnd - contextStart;
        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, flags, wp);
    } else {
        int delta = mStart;
        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, flags, wp);
    }
}
Body of Second Method:
{
    if (mCharsValid) {
        int count = end - start;
        int contextCount = contextEnd - contextStart;
        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, runIsRtl, wp);
    } else {
        int delta = mStart;
        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, runIsRtl, wp);
    }
}
------------------------
Find a functionally equivalent code:android.widget.TextView.paste:COMMENT
Method Modifier: private     
Comment:/**
 * Paste clipboard content between min and max positions.
 */

Body of Frist Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
            if (paste != null) {
                if (!didFirst) {
                    long minMax = prepareSpacesAroundPaste(min, max, paste);
                    min = TextUtils.unpackRangeStartFromLong(minMax);
                    max = TextUtils.unpackRangeEndFromLong(minMax);
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopSelectionActionMode();
        LAST_CUT_OR_COPY_TIME = 0;
    }
}
Body of Second Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopSelectionActionMode();
        LAST_CUT_OR_COPY_TIME = 0;
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.init:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes this instance from another one.
 *
 * @param other The other instance.
 */

Body of Frist Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    mActions = other.mActions;
    mBooleanProperties = other.mBooleanProperties;
    mMovementGranularities = other.mMovementGranularities;
    final int otherChildIdCount = other.mChildNodeIds.size();
    for (int i = 0; i < otherChildIdCount; i++) {
        mChildNodeIds.put(i, other.mChildNodeIds.valueAt(i));
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
Body of Second Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.setCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current minute (0-59).
 */

Body of Frist Method:
{
    if (currentMinute == getCurrentMinute()) {
        return;
    }
    mMinuteSpinner.setValue(currentMinute);
    onTimeChanged();
}
Body of Second Method:
{
    mDelegate.setCurrentMinute(currentMinute);
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */

Body of Frist Method:
{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    PackageUserState state = new PackageUserState();
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
}
Body of Second Method:
{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            parser.collectCertificates(pkg, 0);
            parser.collectManifestDigest(pkg);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.BidiRenderer.setScriptFont:COMMENT
Method Modifier: private     static      
Comment:// TODO: Replace this method with one which returns the font based on the scriptCode.

Body of Frist Method:
{
    for (FontInfo fontInfo : fonts) {
        if (fontInfo.mFont.canDisplayUpTo(text, run.start, run.limit) == -1) {
            run.font = fontInfo;
            return;
        }
    }
    run.font = fonts.get(0);
}
Body of Second Method:
{
    for (Font font : fonts) {
        if (font == null) {
            logFontWarning();
            continue;
        }
        if (font.canDisplayUpTo(text, run.start, run.limit) == -1) {
            run.font = font;
            return;
        }
    }
    run.font = fonts.get(0);
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.preDispatchKeyEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        if (mUseMasterVolume) {
            adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        } else {
            adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        }
    }
}
Body of Second Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + AudioService.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        if (mUseMasterVolume) {
            adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        } else {
            adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.beginPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mTopFullscreenOpaqueWindowState = null;
    mForceStatusBar = false;
    mForceStatusBarFromKeyguard = false;
    mForcingShowNavBar = false;
    mForcingShowNavBarLayer = -1;
    mHideLockScreen = false;
    mAllowLockscreenWhenOn = false;
    mDismissKeyguard = DISMISS_KEYGUARD_NONE;
    mShowingLockscreen = false;
    mShowingDream = false;
}
Body of Second Method:
{
    mTopFullscreenOpaqueWindowState = null;
    mAppsToBeHidden.clear();
    mAppsThatDismissKeyguard.clear();
    mForceStatusBar = false;
    mForceStatusBarFromKeyguard = false;
    mForcingShowNavBar = false;
    mForcingShowNavBarLayer = -1;
    mHideLockScreen = false;
    mAllowLockscreenWhenOn = false;
    mDismissKeyguard = DISMISS_KEYGUARD_NONE;
    mShowingLockscreen = false;
    mShowingDream = false;
    mWinShowWhenLocked = null;
}
------------------------
Find a functionally equivalent code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM) != 0) {
        protLevel += "|system";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM) != 0) {
        protLevel += "|system";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    return protLevel;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.mutate:COMMENT
Method Modifier: public      
Comment:/**
 * A mutable BitmapDrawable still shares its Bitmap with any other Drawable
 * that comes from the same resource.
 *
 * @return This drawable.
 */

Body of Frist Method:
{
    if (!mMutated && super.mutate() == this) {
        mState = new ColorState(mState);
        mMutated = true;
    }
    return this;
}
Body of Second Method:
{
    if (!mMutated && super.mutate() == this) {
        mColorState = new ColorState(mColorState);
        mMutated = true;
    }
    return this;
}
------------------------
Find a functionally equivalent code:android.os.MemoryFile.native_mmap:COMMENT
Method Modifier: private     static      native      
Comment:// returns memory address for ashmem region

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.isConnectedToWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Return true if device is currently connected to Wifi

Body of Frist Method:
{
    return (mNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI);
}
Body of Second Method:
{
    return (mCm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_WIFI);
}
------------------------
Find a functionally equivalent code:android.view.Surface.copyFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy another surface to this one.  This surface now holds a reference
 * to the same data as the original surface, and is -not- the owner.
 * This is for use by the window manager when returning a window surface
 * back from a client, converting it from the representation being managed
 * by the window manager to the representation the client uses to draw
 * in to it.
 * @hide
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    int surfaceControlPtr = other.mNativeObject;
    if (surfaceControlPtr == 0) {
        throw new NullPointerException("SurfaceControl native object is null. Are you using a released SurfaceControl?");
    }
    int newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
        }
        setNativeObjectLocked(newNativeObject);
    }
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    long surfaceControlPtr = other.mNativeObject;
    if (surfaceControlPtr == 0) {
        throw new NullPointerException("SurfaceControl native object is null. Are you using a released SurfaceControl?");
    }
    long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
        }
        setNativeObjectLocked(newNativeObject);
    }
}
------------------------
Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.initiateDownload:COMMENT
Method Modifier: public      
Comment:/**
 * Initiates a download.
 *
 * Queues up a download to the download manager, and saves the DownloadManager's assigned
 * download ID for this download to a file.
 *
 * @throws Exception if unsuccessful
 */

Body of Frist Method:
{
    String filename = DOWNLOAD_5MB_FILENAME;
    mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
    FileOutputStream fileOutput = mContext.openFileOutput(DOWNLOAD_STARTED_FLAG, 0);
    DataOutputStream outputFile = null;
    doCommonDownloadSetup();
    try {
        long dlRequest = -1;
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        assertTrue(dlRequest != -1);
        // Store ID of download for later retrieval
        outputFile = new DataOutputStream(fileOutput);
        outputFile.writeLong(dlRequest);
    } finally {
        if (outputFile != null) {
            outputFile.flush();
            outputFile.close();
        }
    }
}
Body of Second Method:
{
    String filename = DOWNLOAD_FILENAME;
    mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
    FileOutputStream fileOutput = mContext.openFileOutput(DOWNLOAD_STARTED_FLAG, 0);
    DataOutputStream outputFile = null;
    doCommonDownloadSetup();
    try {
        long dlRequest = -1;
        // Make sure there are no pending downloads currently going on
        removeAllCurrentDownloads();
        Uri remoteUri = getExternalFileUri(filename);
        Request request = new Request(remoteUri);
        dlRequest = mDownloadManager.enqueue(request);
        waitForDownloadToStart(dlRequest);
        assertTrue("request id is -1 from download manager", dlRequest != -1);
        // Store ID of download for later retrieval
        outputFile = new DataOutputStream(fileOutput);
        outputFile.writeLong(dlRequest);
    } finally {
        if (outputFile != null) {
            outputFile.flush();
            outputFile.close();
        }
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: 
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

Body of Frist Method:
{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
Body of Second Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:android.net.LocalSocketImpl.accept:COMMENT
Method Modifier: private     native      
Comment:/**
 * Accepts a connection on a server socket.
 *
 * @param fd file descriptor of server socket
 * @param s socket implementation that will become the new socket
 * @return file descriptor of new socket
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.Bundle.putShort:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a short
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putShort(key, value);
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.getNetworkTypeName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a non-localized string representing a given network type.
 * ONLY used for debugging output.
 * @param type the type needing naming
 * @return a String for the given type, or a string version of the type ("87")
 * if no name is known.
 * {@hide}
 */

Body of Frist Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        default:
            return Integer.toString(type);
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        default:
            return Integer.toString(type);
    }
}
------------------------
Find a functionally equivalent code:android.view.Window.setDefaultWindowFormat:COMMENT
Method Modifier: protected   
Comment:/**
 * Set the default format of window, as per the PixelFormat types.  This
 * is the format that will be used unless the client specifies in explicit
 * format with setFormat();
 *
 * @param format The new window format (see PixelFormat).
 *
 * @see #setFormat
 * @see PixelFormat
 */

Body of Frist Method:
{
    mDefaultWindowFormat = format;
    if (!mHaveWindowFormat) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.format = format;
        if (mCallback != null) {
            mCallback.onWindowAttributesChanged(attrs);
        }
    }
}
Body of Second Method:
{
    mDefaultWindowFormat = format;
    if (!mHaveWindowFormat) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.format = format;
        dispatchWindowAttributesChanged(attrs);
    }
}
------------------------
Find a functionally equivalent code:android.content.ContentResolver.getSyncStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the status that matches the authority.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return the SyncStatusInfo for the authority, or null if none exists
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncStatus(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncStatus(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onBootCompleted:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onBootCompleted()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when boot completed.
 *
 * Note, this callback will only be received if boot complete occurs after registering with
 * KeyguardUpdateMonitor.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onDevicePolicyManagerStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDevicePolicyManagerStateChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the device policy changes.
 * See {@link DevicePolicyManager#ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED}
 */

Body of Frist Method:
{
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.view.MotionEvent.axisToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified axis
 * such as "AXIS_X" or an equivalent numeric constant such as "42" if unknown.
 *
 * @param axis The axis.
 * @return The symbolic name of the specified axis.
 */

Body of Frist Method:
{
    String symbolicName = AXIS_SYMBOLIC_NAMES.get(axis);
    return symbolicName != null ? symbolicName : Integer.toString(axis);
}
Body of Second Method:
{
    String symbolicName = nativeAxisToString(axis);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(axis);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockScreenDisabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Determine if LockScreen can be disabled. This is used, for example, to tell if we should
 * show LockScreen or go straight to the home screen.
 *
 * @return true if lock screen is can be disabled
 */

Body of Frist Method:
{
    return !isSecure() && getLong(DISABLE_LOCKSCREEN_KEY, 0) != 0;
}
Body of Second Method:
{
    if (!isSecure() && getLong(DISABLE_LOCKSCREEN_KEY, 0) != 0) {
        // Check if the number of switchable users forces the lockscreen.
        final List<UserInfo> users = UserManager.get(mContext).getUsers(true);
        final int userCount = users.size();
        int switchableUsers = 0;
        for (int i = 0; i < userCount; i++) {
            if (users.get(i).supportsSwitchTo()) {
                switchableUsers++;
            }
        }
        return switchableUsers < 2;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawTextOnPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the text, with origin at (x,y), using the specified paint, along
 * the specified path. The paint's Align setting determins where along the
 * path to start the text.
 *
 * @param text     The text to be drawn
 * @param path     The path the text should follow for its baseline
 * @param hOffset  The distance along the path to add to the text's
 * starting position
 * @param vOffset  The distance above(-) or below(+) the path to position
 * the text
 * @param paint    The paint used for the text (e.g. color, size, style)
 */

Body of Frist Method:
{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    native_drawTextOnPath(mNativeCanvas, text, index, count, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
}
Body of Second Method:
{
    if (text.length() > 0) {
        native_drawTextOnPath(mNativeCanvasWrapper, text, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    }
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.is24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if this is in 24 hour view else false.
 */

Body of Frist Method:
{
    return mIs24HourView;
}
Body of Second Method:
{
    return mDelegate.is24HourView();
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.show:COMMENT
<com.android.keyguard.KeyguardViewBase: void show()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Called when the view needs to be shown.
 */

Body of Frist Method:

Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "show()");
    mSecurityContainer.showPrimarySecurityScreen(false);
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.attachInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class.
 */

Body of Frist Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, "root", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, "root/*", MATCH_ROOT);
    mMatcher.addURI(mAuthority, "root/*/recent", MATCH_RECENT);
    mMatcher.addURI(mAuthority, "root/*/search", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, "document/*", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, "document/*/children", MATCH_CHILDREN);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException("Provider must be protected by MANAGE_DOCUMENTS");
    }
    super.attachInfo(context, info);
}
Body of Second Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, "root", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, "root/*", MATCH_ROOT);
    mMatcher.addURI(mAuthority, "root/*/recent", MATCH_RECENT);
    mMatcher.addURI(mAuthority, "root/*/search", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, "document/*", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, "document/*/children", MATCH_CHILDREN);
    mMatcher.addURI(mAuthority, "tree/*/document/*", MATCH_DOCUMENT_TREE);
    mMatcher.addURI(mAuthority, "tree/*/document/*/children", MATCH_CHILDREN_TREE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException("Provider must be protected by MANAGE_DOCUMENTS");
    }
    super.attachInfo(context, info);
}
------------------------
Find a functionally equivalent code:android.media.MediaMetadataEditor.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Clears all the pending metadata changes set since the MediaMetadataEditor instance was
 * created or since this method was last called.
 * Note that clearing the metadata doesn't reset the editable keys
 * (use {@link #removeEditableKeys()} instead).
 */

Body of Frist Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't clear a previously applied MediaMetadataEditor");
        return;
    }
    mEditorMetadata.clear();
    mEditorArtwork = null;
}
Body of Second Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't clear a previously applied MediaMetadataEditor");
        return;
    }
    mEditorMetadata.clear();
    mEditorArtwork = null;
    mMetadataBuilder = new MediaMetadata.Builder();
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.selectAnimationLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (PRINT_ANIM)
        Log.i(TAG, "selectAnimation in " + win + ": transit=" + transit);
    if (win == mStatusBar) {
        if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
            return R.anim.dock_top_exit;
        } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
            return R.anim.dock_top_enter;
        }
    } else if (win == mNavigationBar) {
        // This can be on either the bottom or the right.
        if (mNavigationBarOnBottom) {
            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
                return R.anim.dock_bottom_exit;
            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
                return R.anim.dock_bottom_enter;
            }
        } else {
            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
                return R.anim.dock_right_exit;
            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
                return R.anim.dock_right_enter;
            }
        }
    }
    if (transit == TRANSIT_PREVIEW_DONE) {
        if (win.hasAppShownWindows()) {
            if (PRINT_ANIM)
                Log.i(TAG, "**** STARTING EXIT");
            return com.android.internal.R.anim.app_starting_exit;
        }
    } else if (win.getAttrs().type == TYPE_DREAM && mDreamingLockscreen && transit == TRANSIT_ENTER) {
        // to reveal it.
        return -1;
    }
    return 0;
}
Body of Second Method:
{
    if (PRINT_ANIM)
        Log.i(TAG, "selectAnimation in " + win + ": transit=" + transit);
    if (win == mStatusBar) {
        boolean isKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
        if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
            return isKeyguard ? -1 : R.anim.dock_top_exit;
        } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
            return isKeyguard ? -1 : R.anim.dock_top_enter;
        }
    } else if (win == mNavigationBar) {
        // This can be on either the bottom or the right.
        if (mNavigationBarOnBottom) {
            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
                return R.anim.dock_bottom_exit;
            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
                return R.anim.dock_bottom_enter;
            }
        } else {
            if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
                return R.anim.dock_right_exit;
            } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
                return R.anim.dock_right_enter;
            }
        }
    }
    if (transit == TRANSIT_PREVIEW_DONE) {
        if (win.hasAppShownWindows()) {
            if (PRINT_ANIM)
                Log.i(TAG, "**** STARTING EXIT");
            return com.android.internal.R.anim.app_starting_exit;
        }
    } else if (win.getAttrs().type == TYPE_DREAM && mDreamingLockscreen && transit == TRANSIT_ENTER) {
        // to reveal it.
        return -1;
    }
    return 0;
}
------------------------
Find a functionally equivalent code:android.widget.SuggestionsAdapter.getDrawableFromResourceValue:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a drawable given a value provided by a suggestion provider.
 *
 * This value could be just the string value of a resource id
 * (e.g., "2130837524"), in which case we will try to retrieve a drawable from
 * the provider's resources. If the value is not an integer, it is
 * treated as a Uri and opened with
 * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
 *
 * All resources and URIs are read using the suggestion provider's context.
 *
 * If the string is not formatted as expected, or no drawable can be found for
 * the provided value, this method returns null.
 *
 * @param drawableId a string like "2130837524",
 * "android.resource://com.android.alarmclock/2130837524",
 * or "content://contacts/photos/253".
 * @return a Drawable, or null if none found
 */

Body of Frist Method:
{
    if (drawableId == null || drawableId.length() == 0 || "0".equals(drawableId)) {
        return null;
    }
    try {
        // First, see if it's just an integer
        int resourceId = Integer.parseInt(drawableId);
        // It's an int, look for it in the cache
        String drawableUri = ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + mProviderContext.getPackageName() + "/" + resourceId;
        // Must use URI as cache key, since ints are app-specific
        Drawable drawable = checkIconCache(drawableUri);
        if (drawable != null) {
            return drawable;
        }
        // Not cached, find it by resource ID
        drawable = mProviderContext.getResources().getDrawable(resourceId);
        // Stick it in the cache, using the URI as key
        storeInIconCache(drawableUri, drawable);
        return drawable;
    } catch (NumberFormatException nfe) {
        // It's not an integer, use it as a URI
        Drawable drawable = checkIconCache(drawableId);
        if (drawable != null) {
            return drawable;
        }
        Uri uri = Uri.parse(drawableId);
        drawable = getDrawable(uri);
        storeInIconCache(drawableId, drawable);
        return drawable;
    } catch (Resources.NotFoundException nfe) {
        // It was an integer, but it couldn't be found, bail out
        Log.w(LOG_TAG, "Icon resource not found: " + drawableId);
        return null;
    }
}
Body of Second Method:
{
    if (drawableId == null || drawableId.length() == 0 || "0".equals(drawableId)) {
        return null;
    }
    try {
        // First, see if it's just an integer
        int resourceId = Integer.parseInt(drawableId);
        // It's an int, look for it in the cache
        String drawableUri = ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + mProviderContext.getPackageName() + "/" + resourceId;
        // Must use URI as cache key, since ints are app-specific
        Drawable drawable = checkIconCache(drawableUri);
        if (drawable != null) {
            return drawable;
        }
        // Not cached, find it by resource ID
        drawable = mProviderContext.getDrawable(resourceId);
        // Stick it in the cache, using the URI as key
        storeInIconCache(drawableUri, drawable);
        return drawable;
    } catch (NumberFormatException nfe) {
        // It's not an integer, use it as a URI
        Drawable drawable = checkIconCache(drawableId);
        if (drawable != null) {
            return drawable;
        }
        Uri uri = Uri.parse(drawableId);
        drawable = getDrawable(uri);
        storeInIconCache(drawableId, drawable);
        return drawable;
    } catch (Resources.NotFoundException nfe) {
        // It was an integer, but it couldn't be found, bail out
        Log.w(LOG_TAG, "Icon resource not found: " + drawableId);
        return null;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.createHomeDockIntent:COMMENT
Method Modifier: internal    
Comment:/**
 * Return an Intent to launch the currently active dock app as home.  Returns
 * null if the standard home should be launched, which is the case if any of the following is
 * true:
 * <ul>
 * <li>The device is not in either car mode or desk mode
 * <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
 * <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
 * <li>The device is in car mode but there's no CAR_DOCK app with METADATA_DOCK_HOME
 * <li>The device is in desk mode but there's no DESK_DOCK app with METADATA_DOCK_HOME
 * </ul>
 * @return A dock intent.
 */

Body of Frist Method:
{
    Intent intent = null;
    // of whether we are actually in a car dock.
    if (mUiMode == Configuration.UI_MODE_TYPE_CAR) {
        if (ENABLE_CAR_DOCK_HOME_CAPTURE) {
            intent = mCarDockIntent;
        }
    } else if (mUiMode == Configuration.UI_MODE_TYPE_DESK) {
        if (ENABLE_DESK_DOCK_HOME_CAPTURE) {
            intent = mDeskDockIntent;
        }
    }
    if (intent == null) {
        return null;
    }
    ActivityInfo ai = null;
    ResolveInfo info = mContext.getPackageManager().resolveActivityAsUser(intent, PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_META_DATA, mCurrentUserId);
    if (info != null) {
        ai = info.activityInfo;
    }
    if (ai != null && ai.metaData != null && ai.metaData.getBoolean(Intent.METADATA_DOCK_HOME)) {
        intent = new Intent(intent);
        intent.setClassName(ai.packageName, ai.name);
        return intent;
    }
    return null;
}
Body of Second Method:
{
    Intent intent = null;
    // of whether we are actually in a car dock.
    if (mUiMode == Configuration.UI_MODE_TYPE_CAR) {
        if (ENABLE_CAR_DOCK_HOME_CAPTURE) {
            intent = mCarDockIntent;
        }
    } else if (mUiMode == Configuration.UI_MODE_TYPE_DESK) {
        if (ENABLE_DESK_DOCK_HOME_CAPTURE) {
            intent = mDeskDockIntent;
        }
    } else if (mUiMode == Configuration.UI_MODE_TYPE_WATCH && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK)) {
        // Always launch dock home from home when watch is docked, if it exists.
        intent = mDeskDockIntent;
    }
    if (intent == null) {
        return null;
    }
    ActivityInfo ai = null;
    ResolveInfo info = mContext.getPackageManager().resolveActivityAsUser(intent, PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_META_DATA, mCurrentUserId);
    if (info != null) {
        ai = info.activityInfo;
    }
    if (ai != null && ai.metaData != null && ai.metaData.getBoolean(Intent.METADATA_DOCK_HOME)) {
        intent = new Intent(intent);
        intent.setClassName(ai.packageName, ai.name);
        return intent;
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.app.ActivityThread.getTopLevelResources:COMMENT
Method Modifier: 
Comment:/**
 * Creates the top level resources for the given package.
 */

Body of Frist Method:
{
    return mResourcesManager.getTopLevelResources(resDir, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
}
Body of Second Method:
{
    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
}
------------------------
Find a functionally equivalent code:android.util.LongSparseLongArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        growKeyAndValueArrays(pos + 1);
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:android.security.KeyChain.choosePrivateKeyAlias:COMMENT
Method Modifier: public      static      
Comment:/**
 * Launches an {@code Activity} for the user to select the alias
 * for a private key and certificate pair for authentication. The
 * selected alias or null will be returned via the
 * KeyChainAliasCallback callback.
 *
 * <p>{@code keyTypes} and {@code issuers} may be used to
 * highlight suggested choices to the user, although to cope with
 * sometimes erroneous values provided by servers, the user may be
 * able to override these suggestions.
 *
 * <p>{@code host} and {@code port} may be used to give the user
 * more context about the server requesting the credentials.
 *
 * <p>{@code alias} allows the chooser to preselect an existing
 * alias which will still be subject to user confirmation.
 *
 * @param activity The {@link Activity} context to use for
 * launching the new sub-Activity to prompt the user to select
 * a private key; used only to call startActivity(); must not
 * be null.
 * @param response Callback to invoke when the request completes;
 * must not be null
 * @param keyTypes The acceptable types of asymmetric keys such as
 * "RSA" or "DSA", or a null array.
 * @param issuers The acceptable certificate issuers for the
 * certificate matching the private key, or null.
 * @param host The host name of the server requesting the
 * certificate, or null if unavailable.
 * @param port The port number of the server requesting the
 * certificate, or -1 if unavailable.
 * @param alias The alias to preselect if available, or null if
 * unavailable.
 */

Body of Frist Method:
{
    /*
         * TODO currently keyTypes, issuers are unused. They are meant
         * to follow the semantics and purpose of X509KeyManager
         * method arguments.
         *
         * keyTypes would allow the list to be filtered and typically
         * will be set correctly by the server. In practice today,
         * most all users will want only RSA, rarely DSA, and usually
         * only a small number of certs will be available.
         *
         * issuers is typically not useful. Some servers historically
         * will send the entire list of public CAs known to the
         * server. Others will send none. If this is used, if there
         * are no matches after applying the constraint, it should be
         * ignored.
         */
    if (activity == null) {
        throw new NullPointerException("activity == null");
    }
    if (response == null) {
        throw new NullPointerException("response == null");
    }
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_RESPONSE, new AliasResponse(response));
    intent.putExtra(EXTRA_HOST, host);
    intent.putExtra(EXTRA_PORT, port);
    intent.putExtra(EXTRA_ALIAS, alias);
    // the PendingIntent is used to get calling package name
    intent.putExtra(EXTRA_SENDER, PendingIntent.getActivity(activity, 0, new Intent(), 0));
    activity.startActivity(intent);
}
Body of Second Method:
{
    /*
         * TODO currently keyTypes, issuers are unused. They are meant
         * to follow the semantics and purpose of X509KeyManager
         * method arguments.
         *
         * keyTypes would allow the list to be filtered and typically
         * will be set correctly by the server. In practice today,
         * most all users will want only RSA, rarely DSA, and usually
         * only a small number of certs will be available.
         *
         * issuers is typically not useful. Some servers historically
         * will send the entire list of public CAs known to the
         * server. Others will send none. If this is used, if there
         * are no matches after applying the constraint, it should be
         * ignored.
         */
    if (activity == null) {
        throw new NullPointerException("activity == null");
    }
    if (response == null) {
        throw new NullPointerException("response == null");
    }
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.setPackage(KEYCHAIN_PACKAGE);
    intent.putExtra(EXTRA_RESPONSE, new AliasResponse(response));
    intent.putExtra(EXTRA_HOST, host);
    intent.putExtra(EXTRA_PORT, port);
    intent.putExtra(EXTRA_ALIAS, alias);
    // the PendingIntent is used to get calling package name
    intent.putExtra(EXTRA_SENDER, PendingIntent.getActivity(activity, 0, new Intent(), 0));
    activity.startActivity(intent);
}
------------------------
Find a functionally equivalent code:com.android.systemui.SearchPanelView.isShowing:COMMENT
Method Modifier: public      
Comment:/**
 * Whether the panel is showing, or, if it's animating, whether it will be
 * when the animation is done.
 */

Body of Frist Method:
{
    return mShowing;
}
Body of Second Method:
{
    return getVisibility() == View.VISIBLE && !mCircle.isAnimatingOut();
}
------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.getValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method gets the value of the named property from the View object.
 *
 * @param propertyConstant The property whose value should be returned
 * @return float The value of the named property
 */

Body of Frist Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return info.mTranslationX;
        case TRANSLATION_Y:
            return info.mTranslationY;
        case ROTATION:
            return info.mRotation;
        case ROTATION_X:
            return info.mRotationX;
        case ROTATION_Y:
            return info.mRotationY;
        case SCALE_X:
            return info.mScaleX;
        case SCALE_Y:
            return info.mScaleY;
        case X:
            return mView.mLeft + info.mTranslationX;
        case Y:
            return mView.mTop + info.mTranslationY;
        case ALPHA:
            return info.mAlpha;
    }
    return 0;
}
Body of Second Method:
{
    final RenderNode node = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return node.getTranslationX();
        case TRANSLATION_Y:
            return node.getTranslationY();
        case TRANSLATION_Z:
            return node.getTranslationZ();
        case ROTATION:
            return node.getRotation();
        case ROTATION_X:
            return node.getRotationX();
        case ROTATION_Y:
            return node.getRotationY();
        case SCALE_X:
            return node.getScaleX();
        case SCALE_Y:
            return node.getScaleY();
        case X:
            return mView.mLeft + node.getTranslationX();
        case Y:
            return mView.mTop + node.getTranslationY();
        case Z:
            return node.getElevation() + node.getTranslationZ();
        case ALPHA:
            return mView.mTransformationInfo.mAlpha;
    }
    return 0;
}
------------------------
Find a functionally equivalent code:android.widget.TabWidget.setLeftStripDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the drawable to use as the left part of the strip below the
 * tab indicators.
 * @param drawable the left strip drawable
 */

Body of Frist Method:
{
    mLeftStrip = drawable;
    requestLayout();
    invalidate();
}
Body of Second Method:
{
    mLeftStrip = drawable;
    requestLayout();
    invalidate();
}
------------------------
Find a functionally equivalent code:android.widget.Switch.setTrackDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param track Track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

Body of Frist Method:
{
    mTrackDrawable = track;
    requestLayout();
}
Body of Second Method:
{
    if (mTrackDrawable != null) {
        mTrackDrawable.setCallback(null);
    }
    mTrackDrawable = track;
    if (track != null) {
        track.setCallback(this);
    }
    requestLayout();
}
------------------------
Find a functionally equivalent code:android.app.ActivityThread.ApplicationThread.scheduleLaunchActivity:COMMENT
Method Modifier: public      final       
Comment:// activity itself back to the activity manager. (matters more with ipc)

Body of Frist Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profileFile = profileName;
    r.profileFd = profileFd;
    r.autoStopProfiler = autoStopProfiler;
    updatePendingConfiguration(curConfig);
    queueOrSendMessage(H.LAUNCH_ACTIVITY, r);
}
Body of Second Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Completely replace the current matrix with the specified matrix. If the
 * matrix parameter is null, then the current matrix is reset to identity.
 *
 * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},
 * {@link #scale(float, float)}, {@link #translate(float, float)} and
 * {@link #rotate(float)} instead of this method.
 *
 * @param matrix The matrix to replace the current matrix with. If it is
 * null, set the current matrix to identity.
 *
 * @see #concat(Matrix)
 */

Body of Frist Method:
{
    native_setMatrix(mNativeCanvas, matrix == null ? 0 : matrix.native_instance);
}
Body of Second Method:
{
    native_setMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolumeMax:COMMENT
Method Modifier: public      
Comment:/**
 * Defines the maximum volume at which the playback associated with this route is performed
 * (for user feedback purposes). This information is only used when the playback is not
 * local.
 * @param volumeMax
 */

Body of Frist Method:
{
    if (mVolumeMax != volumeMax) {
        mVolumeMax = volumeMax;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_MAX, volumeMax);
    }
}
Body of Second Method:
{
    if (mVolumeMax != volumeMax) {
        mVolumeMax = volumeMax;
        configureSessionVolume();
    }
}
------------------------
Find a functionally equivalent code:android.app.backup.BackupAgent.waitForSharedPrefs:COMMENT
Method Modifier: private     
Comment:// Syncing shared preferences deferred writes needs to happen on the main looper thread

Body of Frist Method:
{
    if (mHandler == null) {
        mHandler = new Handler(Looper.getMainLooper());
    }
    final SharedPrefsSynchronizer s = new SharedPrefsSynchronizer();
    mHandler.postAtFrontOfQueue(s);
    try {
        s.mLatch.await();
    } catch (InterruptedException e) {
    /* ignored */
    }
}
Body of Second Method:
{
    Handler h = getHandler();
    final SharedPrefsSynchronizer s = new SharedPrefsSynchronizer();
    h.postAtFrontOfQueue(s);
    try {
        s.mLatch.await();
    } catch (InterruptedException e) {
    /* ignored */
    }
}
------------------------
Find a functionally equivalent code:com.android.tools.layoutlib.create.RenameClassAdapter.renameInternalType:COMMENT
Method Modifier: protected   
Comment:/**
 * Renames an internal type name, e.g. "com.package.MyClass".
 * If the type doesn't need to be renamed, returns the input string as-is.
 * <p/>
 * The internal type of some of the MethodVisitor turns out to be a type
 * descriptor sometimes so descriptors are renamed too.
 */

Body of Frist Method:
{
    if (type == null) {
        return null;
    }
    if (type.equals(mOldName)) {
        return mNewName;
    }
    if (mOldBase != mOldName && type.equals(mOldBase)) {
        return mNewBase;
    }
    int pos = type.indexOf('$');
    if (pos == mOldBase.length() && type.startsWith(mOldBase)) {
        return mNewBase + type.substring(pos);
    }
    return type;
}
Body of Second Method:
{
    if (type == null) {
        return null;
    }
    if (type.equals(mOldName)) {
        return mNewName;
    }
    if (!mOldBase.equals(mOldName) && type.equals(mOldBase)) {
        return mNewBase;
    }
    int pos = type.indexOf('$');
    if (pos == mOldBase.length() && type.startsWith(mOldBase)) {
        return mNewBase + type.substring(pos);
    }
    return type;
}
------------------------
Find a functionally equivalent code:android.telephony.SignalStrength.getDbm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal strength as dBm
 *
 * @hide
 */

Body of Frist Method:
{
    int dBm;
    if (isGsm()) {
        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            dBm = getGsmDbm();
        } else {
            dBm = getLteDbm();
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
Body of Second Method:
{
    int dBm;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            dBm = getGsmDbm();
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.requestChildFocus:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DBG) {
        System.out.println(this + " requestChildFocus()");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus();
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus();
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}
Body of Second Method:
{
    if (DBG) {
        System.out.println(this + " requestChildFocus()");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus(focused);
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus(focused);
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}
------------------------
Find a functionally equivalent code:android.app.admin.DevicePolicyManager.setActiveAdmin:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.setActiveAdmin(policyReceiver, refreshing, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.setActiveAdmin(policyReceiver, refreshing, userHandle);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.text.GraphicsOperations.getTextRunCursor:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Paint#getTextRunCursor}.
 * @hide
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.util.ArraySet.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

Body of Frist Method:
{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    }
}
Body of Second Method:
{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.RuntimeInit.wrapperInit:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * The main function called when an application is started through a
 * wrapper process.
 *
 * When the wrapper starts, the runtime starts {@link RuntimeInit#main}
 * which calls {@link WrapperInit#main} which then calls this method.
 * So we don't need to call commonInit() here.
 *
 * @param targetSdkVersion target SDK version
 * @param argv arg strings
 */

Body of Frist Method:
{
    if (DEBUG)
        Slog.d(TAG, "RuntimeInit: Starting application from wrapper");
    applicationInit(targetSdkVersion, argv);
}
Body of Second Method:
{
    if (DEBUG)
        Slog.d(TAG, "RuntimeInit: Starting application from wrapper");
    applicationInit(targetSdkVersion, argv, null);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Serializable value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Serializable object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putSerializable(key, value);
}
------------------------
Find a functionally equivalent code:android.hardware.SystemSensorManager.unregisterListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Trigger Sensors should use the cancelTriggerSensor call.
    if (sensor != null && Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
        return;
    }
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, true);
            }
            if (result && !queue.hasSensors()) {
                mSensorListeners.remove(listener);
                queue.dispose();
            }
        }
    }
}
Body of Second Method:
{
    // Trigger Sensors should use the cancelTriggerSensor call.
    if (sensor != null && sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
        return;
    }
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, true);
            }
            if (result && !queue.hasSensors()) {
                mSensorListeners.remove(listener);
                queue.dispose();
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * set master mute state.
 *
 * @hide
 */

Body of Frist Method:
{
    setMasterMute(state, FLAG_SHOW_UI);
}
Body of Second Method:
{
    setMasterMute(state, FLAG_SHOW_UI);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.setNewRcClientGenerationOnClients_syncRcsCurrc:COMMENT
Method Modifier: private     
Comment:/**
 * Update the remote control clients with the new "focused" client generation
 */

Body of Frist Method:
{
    // (using an iterator on the stack so we can safely remove an entry if needed,
    // traversal order doesn't matter here as we update all entries)
    Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
    while (stackIterator.hasNext()) {
        RemoteControlStackEntry se = stackIterator.next();
        if ((se != null) && (se.mRcClient != null)) {
            try {
                se.mRcClient.setCurrentClientGenerationId(newClientGeneration);
            } catch (RemoteException e) {
                Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()", e);
                stackIterator.remove();
                se.unlinkToRcClientDeath();
            }
        }
    }
}
Body of Second Method:
{
    // (using an iterator on the stack so we can safely remove an entry if needed,
    // traversal order doesn't matter here as we update all entries)
    Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
    while (stackIterator.hasNext()) {
        PlayerRecord se = stackIterator.next();
        if ((se != null) && (se.getRcc() != null)) {
            try {
                se.getRcc().setCurrentClientGenerationId(newClientGeneration);
            } catch (RemoteException e) {
                Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()", e);
                stackIterator.remove();
                se.unlinkToRcClientDeath();
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the album / artwork picture to be displayed on the remote control.
 * @param key the identifier of the bitmap to set. The only valid value is
 * {@link #BITMAP_KEY_ARTWORK}
 * @param bitmap The bitmap for the artwork, or null if there isn't any.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 * @see android.graphics.Bitmap
 */

Body of Frist Method:
{
    super.putBitmap(key, bitmap);
    return this;
}
Body of Second Method:
{
    super.putBitmap(key, bitmap);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putBitmap(metadataKey, bitmap);
        }
    }
    return this;
}
------------------------
Find a functionally equivalent code:android.provider.Settings.Global.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, "Global.putString(name=" + name + ", value=" + value + " for " + userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, "Global.putString(name=" + name + ", value=" + value + " for " + userHandle);
    }
    // Global and Secure have the same access policy so we can forward writes
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, value is unchanged.");
        return Secure.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
------------------------
Find a functionally equivalent code:android.util.ArraySet.remove:COMMENT
Method Modifier: public      
Comment:/**
 * Removes the specified object from this set.
 *
 * @param object the object to remove.
 * @return {@code true} if this set was modified, {@code false} otherwise.
 */

Body of Frist Method:
{
    int index = object == null ? indexOfNull() : indexOf(object, object.hashCode());
    if (index >= 0) {
        removeAt(index);
        return true;
    }
    return false;
}
Body of Second Method:
{
    final int index = indexOf(object);
    if (index >= 0) {
        removeAt(index);
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.sendAccessibilityEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */

Body of Frist Method:
{
    if (!mIsEnabled) {
        throw new IllegalStateException("Accessibility off. Did you forget to check that?");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event, mUserId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + " sent");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error during sending " + event + " ", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}
Body of Second Method:
{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException("Accessibility off. Did you forget to check that?");
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + " sent");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error during sending " + event + " ", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.playSoundEffectVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#playSoundEffect(int, float)
 */

Body of Frist Method:
{
    sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE, effectType, (int) (volume * 1000), null, 0);
}
Body of Second Method:
{
    if (effectType >= AudioManager.NUM_SOUND_EFFECTS || effectType < 0) {
        Log.w(TAG, "AudioService effectType value " + effectType + " out of range");
        return;
    }
    sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE, effectType, (int) (volume * 1000), null, 0);
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the paint to its default settings.
 */

Body of Frist Method:
{
    native_reset(mNativePaint);
    setFlags(DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mTypeface = null;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    hasShadow = false;
    shadowDx = 0;
    shadowDy = 0;
    shadowRadius = 0;
    shadowColor = 0;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
}
Body of Second Method:
{
    native_reset(mNativePaint);
    setFlags(DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mTypeface = null;
    mNativeTypeface = 0;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
    setElegantTextHeight(false);
    mFontFeatureSettings = null;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getPhoneOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been on while the device was
 * running on battery.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.ViewGroup.unFocus:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DBG) {
        System.out.println(this + " unFocus()");
    }
    if (mFocused == null) {
        super.unFocus();
    } else {
        mFocused.unFocus();
        mFocused = null;
    }
}
Body of Second Method:
{
    if (DBG) {
        System.out.println(this + " unFocus()");
    }
    if (mFocused == null) {
        super.unFocus(focused);
    } else {
        mFocused.unFocus(focused);
        mFocused = null;
    }
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putLong:COMMENT
Method Modifier: public      
Comment:/**
 * Adds numerical information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key the identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_CD_TRACK_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DISC_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DURATION} (with a value
 * expressed in milliseconds),
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_YEAR}.
 * @param value The long value for the given key
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    super.putLong(key, value);
    return this;
}
Body of Second Method:
{
    super.putLong(key, value);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putLong(metadataKey, value);
        }
    }
    return this;
}
------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.startAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the underlying Animator for a set of properties. We use a single animator that
 * simply runs from 0 to 1, and then use that fractional value to set each property
 * value accordingly.
 */

Body of Frist Method:
{
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
Body of Second Method:
{
    if (mRTBackend != null && mRTBackend.startAnimation(this)) {
        return;
    }
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothDevice.fetchUuidsWithSdp:COMMENT
Method Modifier: public      
Comment:/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */

Body of Frist Method:
{
    try {
        return sService.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot fetchUuidsWithSdp");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.widget.ListPopupWindow.setModal:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether this window should be modal when shown.
 *
 * <p>If a popup window is modal, it will receive all touch and key input.
 * If the user touches outside the popup window's content area the popup window
 * will be dismissed.
 *
 * @param modal {@code true} if the popup window should be modal, {@code false} otherwise.
 */

Body of Frist Method:
{
    mModal = true;
    mPopup.setFocusable(modal);
}
Body of Second Method:
{
    mModal = modal;
    mPopup.setFocusable(modal);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.unregisterRemoteControlClient:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterRemoteControlClient(PendingIntent pi, ...)
 * rcClient is guaranteed non-null
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Unregister remote control client rcClient=" + rcClient);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            boolean topRccChange = false;
            try {
                for (int index = mRCStack.size() - 1; index >= 0; index--) {
                    final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                    if ((rcse.mMediaIntent.equals(mediaIntent)) && rcClient.equals(rcse.mRcClient)) {
                        // we found the IRemoteControlClient to unregister
                        // stop monitoring its death
                        rcse.unlinkToRcClientDeath();
                        // reset the client-related fields
                        rcse.mRcClient = null;
                        rcse.mCallingPackageName = null;
                        topRccChange = (index == mRCStack.size() - 1);
                        // there can only be one matching RCC in the RC stack, we're done
                        break;
                    }
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                // not expected to happen, indicates improper concurrent modification
                Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
            }
            if (topRccChange) {
                // no more RCC for the RCD, check for potential refresh of the remote controls
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Unregister remote control client rcClient=" + rcClient);
    synchronized (mPRStack) {
        boolean topRccChange = false;
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if ((prse.hasMatchingMediaButtonIntent(mediaIntent)) && rcClient.equals(prse.getRcc())) {
                    // we found the IRemoteControlClient to unregister
                    prse.resetControllerInfoForNoRcc();
                    topRccChange = (index == mPRStack.size() - 1);
                    // there can only be one matching RCC in the RC stack, we're done
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
        if (topRccChange) {
            // no more RCC for the RCD, check for potential refresh of the remote controls
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setColors:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the colors used to draw the gradient. Each color is specified as an
 * ARGB integer and the array must contain at least 2 colors.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param colors 2 or more ARGB colors
 *
 * @see #mutate()
 * @see #setColor(int)
 */

Body of Frist Method:
{
    mGradientState.setColors(colors);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setColors(colors);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.view.textservice.TextInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeString(mText);
    dest.writeInt(mCookie);
    dest.writeInt(mSequence);
}
Body of Second Method:
{
    TextUtils.writeToParcel(mCharSequence, dest, flags);
    dest.writeInt(mCookie);
    dest.writeInt(mSequenceNumber);
}
------------------------
Find a functionally equivalent code:android.app.ApplicationErrorReport.CrashInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a CrashInfo instance to a parcel.
 */

Body of Frist Method:
{
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
}
Body of Second Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a functionally equivalent code:com.android.documentsui.SortingCursorWrapper.binarySort:COMMENT
Method Modifier: private     static      
Comment:/**
 * Borrowed from TimSort.binarySort(), but modified to sort two column
 * dataset.
 */

Body of Frist Method:
{
    final int count = position.length;
    for (int start = 1; start < count; start++) {
        final int pivotPosition = position[start];
        final long pivotValue = value[start];
        int left = 0;
        int right = start;
        while (left < right) {
            int mid = (left + right) >>> 1;
            final long lhs = pivotValue;
            final long rhs = value[mid];
            final int compare = Long.compare(lhs, rhs);
            if (compare > 0) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        int n = start - left;
        switch(n) {
            case 2:
                position[left + 2] = position[left + 1];
                value[left + 2] = value[left + 1];
            case 1:
                position[left + 1] = position[left];
                value[left + 1] = value[left];
                break;
            default:
                System.arraycopy(position, left, position, left + 1, n);
                System.arraycopy(value, left, value, left + 1, n);
        }
        position[left] = pivotPosition;
        value[left] = pivotValue;
    }
}
Body of Second Method:
{
    final int count = position.length;
    for (int start = 1; start < count; start++) {
        final int pivotPosition = position[start];
        final long pivotValue = value[start];
        int left = 0;
        int right = start;
        while (left < right) {
            int mid = (left + right) >>> 1;
            final long lhs = pivotValue;
            final long rhs = value[mid];
            final int compare = Long.compare(lhs, rhs);
            if (compare > 0) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        int n = start - left;
        switch(n) {
            case 2:
                position[left + 2] = position[left + 1];
                value[left + 2] = value[left + 1];
            case 1:
                position[left + 1] = position[left];
                value[left + 1] = value[left];
                break;
            default:
                System.arraycopy(position, left, position, left + 1, n);
                System.arraycopy(value, left, value, left + 1, n);
        }
        position[left] = pivotPosition;
        value[left] = pivotValue;
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Flatten this notification from a parcel.
 */

Body of Frist Method:
{
    parcel.writeInt(1);
    parcel.writeLong(when);
    parcel.writeInt(icon);
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (largeIcon != null) {
        parcel.writeInt(1);
        largeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    // ok for null
    parcel.writeStringArray(kind);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
}
Body of Second Method:
{
    parcel.writeInt(1);
    parcel.writeLong(when);
    parcel.writeInt(icon);
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (largeIcon != null) {
        parcel.writeInt(1);
        largeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    if (audioAttributes != null) {
        parcel.writeInt(1);
        audioAttributes.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    parcel.writeString(category);
    parcel.writeString(mGroupKey);
    parcel.writeString(mSortKey);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (headsUpContentView != null) {
        parcel.writeInt(1);
        headsUpContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(visibility);
    if (publicVersion != null) {
        parcel.writeInt(1);
        publicVersion.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(color);
}
------------------------
Find a functionally equivalent code:android.graphics.Paint.setTypeface:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the typeface object.
 * <p />
 * Pass null to clear any previous typeface.
 * As a convenience, the parameter passed is also returned.
 *
 * @param typeface May be null. The typeface to be installed in the paint
 * @return         typeface
 */

Body of Frist Method:
{
    int typefaceNative = 0;
    if (typeface != null) {
        typefaceNative = typeface.native_instance;
    }
    native_setTypeface(mNativePaint, typefaceNative);
    mTypeface = typeface;
    return typeface;
}
Body of Second Method:
{
    long typefaceNative = 0;
    if (typeface != null) {
        typefaceNative = typeface.native_instance;
    }
    native_setTypeface(mNativePaint, typefaceNative);
    mTypeface = typeface;
    mNativeTypeface = typefaceNative;
    return typeface;
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.handleChildProc:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Handles post-fork setup of child proc, closing sockets as appropriate,
 * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller
 * if successful or returning if failed.
 *
 * @param parsedArgs non-null; zygote args
 * @param descriptors null-ok; new file descriptors for stdio if available.
 * @param pipeFd null-ok; pipe for communication back to Zygote.
 * @param newStderr null-ok; stream to use for stderr until stdio
 * is reopened.
 *
 * @throws ZygoteInit.MethodAndArgsCaller on success to
 * trampoline to code that invokes static main.
 */

Body of Frist Method:
{
    closeSocket();
    ZygoteInit.closeServerSocket();
    if (descriptors != null) {
        try {
            ZygoteInit.reopenStdio(descriptors[0], descriptors[1], descriptors[2]);
            for (FileDescriptor fd : descriptors) {
                IoUtils.closeQuietly(fd);
            }
            newStderr = System.err;
        } catch (IOException ex) {
            Log.e(TAG, "Error reopening stdio", ex);
        }
    }
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    if (parsedArgs.runtimeInit) {
        if (parsedArgs.invokeWith != null) {
            WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, pipeFd, parsedArgs.remainingArgs);
        } else {
            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
        }
    } else {
        String className;
        try {
            className = parsedArgs.remainingArgs[0];
        } catch (ArrayIndexOutOfBoundsException ex) {
            logAndPrintError(newStderr, "Missing required class name argument", null);
            return;
        }
        String[] mainArgs = new String[parsedArgs.remainingArgs.length - 1];
        System.arraycopy(parsedArgs.remainingArgs, 1, mainArgs, 0, mainArgs.length);
        if (parsedArgs.invokeWith != null) {
            WrapperInit.execStandalone(parsedArgs.invokeWith, parsedArgs.classpath, className, mainArgs);
        } else {
            ClassLoader cloader;
            if (parsedArgs.classpath != null) {
                cloader = new PathClassLoader(parsedArgs.classpath, ClassLoader.getSystemClassLoader());
            } else {
                cloader = ClassLoader.getSystemClassLoader();
            }
            try {
                ZygoteInit.invokeStaticMain(cloader, className, mainArgs);
            } catch (RuntimeException ex) {
                logAndPrintError(newStderr, "Error starting.", ex);
            }
        }
    }
}
Body of Second Method:
{
    /**
     * By the time we get here, the native code has closed the two actual Zygote
     * socket connections, and substituted /dev/null in their place.  The LocalSocket
     * objects still need to be closed properly.
     */
    closeSocket();
    ZygoteInit.closeServerSocket();
    if (descriptors != null) {
        try {
            ZygoteInit.reopenStdio(descriptors[0], descriptors[1], descriptors[2]);
            for (FileDescriptor fd : descriptors) {
                IoUtils.closeQuietly(fd);
            }
            newStderr = System.err;
        } catch (IOException ex) {
            Log.e(TAG, "Error reopening stdio", ex);
        }
    }
    if (parsedArgs.niceName != null) {
        Process.setArgV0(parsedArgs.niceName);
    }
    if (parsedArgs.runtimeInit) {
        if (parsedArgs.invokeWith != null) {
            WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, pipeFd, parsedArgs.remainingArgs);
        } else {
            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null);
        }
    } else {
        String className;
        try {
            className = parsedArgs.remainingArgs[0];
        } catch (ArrayIndexOutOfBoundsException ex) {
            logAndPrintError(newStderr, "Missing required class name argument", null);
            return;
        }
        String[] mainArgs = new String[parsedArgs.remainingArgs.length - 1];
        System.arraycopy(parsedArgs.remainingArgs, 1, mainArgs, 0, mainArgs.length);
        if (parsedArgs.invokeWith != null) {
            WrapperInit.execStandalone(parsedArgs.invokeWith, parsedArgs.classpath, className, mainArgs);
        } else {
            ClassLoader cloader;
            if (parsedArgs.classpath != null) {
                cloader = new PathClassLoader(parsedArgs.classpath, ClassLoader.getSystemClassLoader());
            } else {
                cloader = ClassLoader.getSystemClassLoader();
            }
            try {
                ZygoteInit.invokeStaticMain(cloader, className, mainArgs);
            } catch (RuntimeException ex) {
                logAndPrintError(newStderr, "Error starting.", ex);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawBitmapMesh:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the bitmap through the mesh, where mesh vertices are evenly
 * distributed across the bitmap. There are meshWidth+1 vertices across, and
 * meshHeight+1 vertices down. The verts array is accessed in row-major
 * order, so that the first meshWidth+1 vertices are distributed across the
 * top of the bitmap from left to right. A more general version of this
 * method is drawVertices().
 *
 * @param bitmap The bitmap to draw using the mesh
 * @param meshWidth The number of columns in the mesh. Nothing is drawn if
 * this is 0
 * @param meshHeight The number of rows in the mesh. Nothing is drawn if
 * this is 0
 * @param verts Array of x,y pairs, specifying where the mesh should be
 * drawn. There must be at least
 * (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values
 * in the array
 * @param vertOffset Number of verts elements to skip before drawing
 * @param colors May be null. Specifies a color at each vertex, which is
 * interpolated across the cell, and whose values are
 * multiplied by the corresponding bitmap colors. If not null,
 * there must be at least (meshWidth+1) * (meshHeight+1) +
 * colorOffset values in the array.
 * @param colorOffset Number of color elements to skip before drawing
 * @param paint  May be null. The paint used to draw the bitmap
 */

Body of Frist Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvas, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
}
Body of Second Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a float[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (float[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "float[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getFloatArray(key);
}
------------------------
Find a functionally equivalent code:android.util.LongSparseLongArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            growKeyAndValueArrays(mSize + 1);
        }
        if (mSize - i != 0) {
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testWifiStateChange:COMMENT
Method Modifier: public      
Comment:// Test case 8: test wifi state change while connecting/disconnecting to/from an AP

Body of Frist Method:
{
    assertNotNull("SSID is null", mTestAccessPoint);
    // Connect to mTestAccessPoint
    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    assertNotNull("Not associated with any AP", mWifiManager.getConnectionInfo().getBSSID());
    try {
        Thread.sleep(SHORT_TIMEOUT);
    } catch (Exception e) {
        log("exception: " + e.toString());
    }
    // Disconnect from the current AP
    log("disconnect from the AP");
    if (!disconnectAP()) {
        log("failed to disconnect from " + mTestAccessPoint);
    }
    // Verify the connectivity state for Wifi is DISCONNECTED
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
    if (!disableWifi()) {
        log("disable Wifi failed");
        return;
    }
    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
}
Body of Second Method:
{
    assertNotNull("SSID is null", mSsid);
    // enable WiFi
    assertTrue("failed to enable wifi", enableWifi());
    // wait for wifi enable
    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
    // connect to Wifi
    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    assertNotNull("not associated with any AP", mWifiManager.getConnectionInfo().getBSSID());
    // disconnect from the current AP
    assertTrue("failed to disconnect from AP", disconnectAP());
    // below check disbabled since we have bug in what ConnectivityManager returns
    // Verify the connectivity state for Wifi is DISCONNECTED
    // assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI,
    // State.DISCONNECTED, LONG_TIMEOUT));
    // disable WiFi
    assertTrue("failed to disable wifi", disableWifi());
    assertTrue("wifi state not disabled", waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.onCreate:COMMENT
Method Modifier: public      
Comment:/**
 * Called when this Dream is constructed.
 */

Body of Frist Method:
{
    if (mDebug)
        Slog.v(TAG, "onCreate() on thread " + Thread.currentThread().getId());
    super.onCreate();
}
Body of Second Method:
{
    if (mDebug)
        Slog.v(TAG, "onCreate()");
    super.onCreate();
}
------------------------
Find a functionally equivalent code:android.app.Notification.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */

Body of Frist Method:
{
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}
Body of Second Method:
{
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}
------------------------
Find a functionally equivalent code:android.graphics.NinePatch.getTransparentRegion:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns a {@link Region} representing the parts of the NinePatch that are
 * completely transparent.
 *
 * @param bounds The location and size of the NinePatch.
 *
 * @return null if the NinePatch has no transparent region to
 * report, else a {@link Region} holding the parts of the specified bounds
 * that are transparent.
 */

Body of Frist Method:
{
    int r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
Body of Second Method:
{
    long r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
------------------------
Find a functionally equivalent code:android.media.MediaPlayer.start:COMMENT
Method Modifier: public      
Comment:/**
 * Starts or resumes playback. If playback had previously been paused,
 * playback will continue from where it was paused. If playback had
 * been stopped, or never started before, playback will start at the
 * beginning.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

Body of Frist Method:
{
    stayAwake(true);
    _start();
}
Body of Second Method:
{
    if (isRestricted()) {
        _setVolume(0, 0);
    }
    stayAwake(true);
    _start();
}
------------------------
Find a functionally equivalent code:android.util.SparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        Object[] nvalues = new Object[n];
        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.BaseStatusBar.handleNotificationError:COMMENT
Method Modifier: 
Comment:/**
 * Cancel this notification and tell the StatusBarManagerService / NotificationManagerService
 * about the failure.
 *
 * WARNING: this will call back into us.  Don't hold any locks.
 */

Body of Frist Method:
{
    removeNotification(key);
    try {
        mBarService.onNotificationError(n.getPackageName(), n.getTag(), n.getId(), n.getUid(), n.getInitialPid(), message);
    } catch (RemoteException ex) {
    // The end is nigh.
    }
}
Body of Second Method:
{
    removeNotification(n.getKey(), null);
    try {
        mBarService.onNotificationError(n.getPackageName(), n.getTag(), n.getId(), n.getUid(), n.getInitialPid(), message, n.getUserId());
    } catch (RemoteException ex) {
    // The end is nigh.
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.getAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the alpha value of this drawable's color.
 *
 * @return A value between 0 and 255.
 */

Body of Frist Method:
{
    return mState.mUseColor >>> 24;
}
Body of Second Method:
{
    return mColorState.mUseColor >>> 24;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    mSupplicantState.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    dest.writeInt(badRssiCount);
    dest.writeInt(lowRssiCount);
    mSupplicantState.writeToParcel(dest, flags);
}
------------------------
Find a functionally equivalent code:android.transition.Transition.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resumes this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mPaused) {
        if (!mEnded) {
            ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
            int numOldAnims = runningAnimators.size();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                Animator anim = runningAnimators.keyAt(i);
                anim.resume();
            }
            if (mListeners != null && mListeners.size() > 0) {
                ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onTransitionResume(this);
                }
            }
        }
        mPaused = false;
    }
}
Body of Second Method:
{
    if (mPaused) {
        if (!mEnded) {
            ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
            int numOldAnims = runningAnimators.size();
            WindowId windowId = sceneRoot.getWindowId();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                AnimationInfo info = runningAnimators.valueAt(i);
                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
                    Animator anim = runningAnimators.keyAt(i);
                    anim.resume();
                }
            }
            if (mListeners != null && mListeners.size() > 0) {
                ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onTransitionResume(this);
                }
            }
        }
        mPaused = false;
    }
}
------------------------
Find a functionally equivalent code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

Body of Frist Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Up and not canceled, also checks the switch has not been disabled during the drag
    boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    cancelSuperTouch(ev);
    if (commitChange) {
        boolean newState;
        mVelocityTracker.computeCurrentVelocity(1000);
        float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
        animateThumbToCheckedState(newState);
    } else {
        animateThumbToCheckedState(isChecked());
    }
}
Body of Second Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = isChecked();
    }
    setChecked(newState);
    cancelSuperTouch(ev);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.waitForTetherStateChange:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: int waitForTetherStateChange(long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Wait for the wifi tethering result:
 * @param timeout is the maximum waiting time
 * @return SUCCESS if tethering result is successful
 * FAILURE if tethering result returns error.
 */

Body of Frist Method:
{
    long startTime = System.currentTimeMillis();
    while (true) {
        if ((System.currentTimeMillis() - startTime) > timeout) {
            return mWifiTetherResult;
        }
        log("Wait for wifi tethering result.");
        synchronized (this) {
            try {
                this.wait(SHORT_TIMEOUT);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (mWifiTetherResult == INIT) {
                continue;
            } else {
                return mWifiTetherResult;
            }
        }
    }
}
Body of Second Method:
{
    long startTime = SystemClock.uptimeMillis();
    String[] wifiRegexes = mCm.getTetherableWifiRegexs();
    while (true) {
        if ((SystemClock.uptimeMillis() - startTime) > timeout) {
            return false;
        }
        String[] active = mCm.getTetheredIfaces();
        String[] error = mCm.getTetheringErroredIfaces();
        for (String iface : active) {
            for (String regex : wifiRegexes) {
                if (iface.matches(regex)) {
                    return true;
                }
            }
        }
        for (String iface : error) {
            for (String regex : wifiRegexes) {
                if (iface.matches(regex)) {
                    return false;
                }
            }
        }
        SystemClock.sleep(SHORT_TIMEOUT);
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes and acquires the scene, creating various Android objects such as context,
 * inflater, and parser.
 *
 * @param timeout the time to wait if another rendering is happening.
 *
 * @return whether the scene was prepared
 *
 * @see #acquire(long)
 * @see #release()
 */

Body of Frist Method:
{
    Result result = super.init(timeout);
    if (result.isSuccess() == false) {
        return result;
    }
    SessionParams params = getParams();
    BridgeContext context = getContext();
    RenderResources resources = getParams().getResources();
    DisplayMetrics metrics = getContext().getMetrics();
    // use default of true in case it's not found to use alpha by default
    mIsAlphaChannelImage = getBooleanThemeValue(resources, "windowIsFloating", true);
    mWindowIsFloating = getBooleanThemeValue(resources, "windowIsFloating", true);
    findBackground(resources);
    findStatusBar(resources, metrics);
    findActionBar(resources, metrics);
    findNavigationBar(resources, metrics);
    // FIXME: find those out, and possibly add them to the render params
    boolean hasNavigationBar = true;
    IWindowManager iwm = new IWindowManagerImpl(getContext().getConfiguration(), metrics, Surface.ROTATION_0, hasNavigationBar);
    WindowManagerGlobal_Delegate.setWindowManagerService(iwm);
    // build the inflater and parser.
    mInflater = new BridgeInflater(context, params.getProjectCallback());
    context.setBridgeInflater(mInflater);
    mBlockParser = new BridgeXmlBlockParser(params.getLayoutDescription(), context, false);
    return SUCCESS.createResult();
}
Body of Second Method:
{
    Result result = super.init(timeout);
    if (!result.isSuccess()) {
        return result;
    }
    SessionParams params = getParams();
    BridgeContext context = getContext();
    RenderResources resources = getParams().getResources();
    DisplayMetrics metrics = getContext().getMetrics();
    // use default of true in case it's not found to use alpha by default
    mIsAlphaChannelImage = getBooleanThemeValue(resources, "windowIsFloating", true);
    mWindowIsFloating = getBooleanThemeValue(resources, "windowIsFloating", true);
    findBackground(resources);
    findStatusBar(resources, metrics);
    findActionBar(resources, metrics);
    findNavigationBar(resources, metrics);
    // FIXME: find those out, and possibly add them to the render params
    boolean hasNavigationBar = true;
    // noinspection ConstantConditions
    IWindowManager iwm = new IWindowManagerImpl(getContext().getConfiguration(), metrics, Surface.ROTATION_0, hasNavigationBar);
    WindowManagerGlobal_Delegate.setWindowManagerService(iwm);
    // build the inflater and parser.
    mInflater = new BridgeInflater(context, params.getProjectCallback());
    context.setBridgeInflater(mInflater);
    mBlockParser = new BridgeXmlBlockParser(params.getLayoutDescription(), context, false);
    return SUCCESS.createResult();
}
------------------------
Find a functionally equivalent code:android.content.res.XmlBlock.nativeNext:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.util.SparseBooleanArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        boolean[] nvalues = new boolean[n];
        // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a functionally equivalent code:android.widget.Switch.setTrackResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param resId Resource ID of a track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

Body of Frist Method:
{
    setTrackDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setTrackDrawable(getContext().getDrawable(resId));
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.ensureStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    if (mStringBlocks == null) {
        synchronized (this) {
            if (mStringBlocks == null) {
                makeStringBlocks(true);
            }
        }
    }
}
Body of Second Method:
{
    if (mStringBlocks == null) {
        synchronized (this) {
            if (mStringBlocks == null) {
                makeStringBlocks(sSystem.mStringBlocks);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recent.RecentTasksLoader.createTaskDescription:COMMENT
Method Modifier: 
Comment:// Create an TaskDescription, returning null if the title or icon is null

Body of Frist Method:
{
    Intent intent = new Intent(baseIntent);
    if (origActivity != null) {
        intent.setComponent(origActivity);
    }
    final PackageManager pm = mContext.getPackageManager();
    intent.setFlags((intent.getFlags() & ~Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) | Intent.FLAG_ACTIVITY_NEW_TASK);
    final ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
    if (resolveInfo != null) {
        final ActivityInfo info = resolveInfo.activityInfo;
        final String title = info.loadLabel(pm).toString();
        if (title != null && title.length() > 0) {
            if (DEBUG)
                Log.v(TAG, "creating activity desc for id=" + persistentTaskId + ", label=" + title);
            TaskDescription item = new TaskDescription(taskId, persistentTaskId, resolveInfo, baseIntent, info.packageName, description);
            item.setLabel(title);
            return item;
        } else {
            if (DEBUG)
                Log.v(TAG, "SKIPPING item " + persistentTaskId);
        }
    }
    return null;
}
Body of Second Method:
{
    Intent intent = new Intent(baseIntent);
    if (origActivity != null) {
        intent.setComponent(origActivity);
    }
    final PackageManager pm = mContext.getPackageManager();
    final IPackageManager ipm = AppGlobals.getPackageManager();
    intent.setFlags((intent.getFlags() & ~Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) | Intent.FLAG_ACTIVITY_NEW_TASK);
    ResolveInfo resolveInfo = null;
    try {
        resolveInfo = ipm.resolveIntent(intent, null, 0, userId);
    } catch (RemoteException re) {
    }
    if (resolveInfo != null) {
        final ActivityInfo info = resolveInfo.activityInfo;
        final String title = info.loadLabel(pm).toString();
        if (title != null && title.length() > 0) {
            if (DEBUG)
                Log.v(TAG, "creating activity desc for id=" + persistentTaskId + ", label=" + title);
            TaskDescription item = new TaskDescription(taskId, persistentTaskId, resolveInfo, baseIntent, info.packageName, description, userId);
            item.setLabel(title);
            return item;
        } else {
            if (DEBUG)
                Log.v(TAG, "SKIPPING item " + persistentTaskId);
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.calculateValue:COMMENT
Method Modifier: 
Comment:/**
 * Function used to calculate the value according to the evaluator set up for
 * this PropertyValuesHolder object. This function is called by ValueAnimator.animateValue().
 *
 * @param fraction The elapsed, interpolated fraction of the animation.
 */

Body of Frist Method:
{
    mAnimatedValue = mKeyframeSet.getValue(fraction);
}
Body of Second Method:
{
    Object value = mKeyframes.getValue(fraction);
    mAnimatedValue = mConverter == null ? value : mConverter.convert(value);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.getSaveCount:COMMENT
<android.graphics.Canvas: int getSaveCount()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the number of matrix/clip states on the Canvas' private stack.
 * This will equal # save() calls - # restore() calls.
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getSaveCount(mNativeCanvasWrapper);
}
------------------------
Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.setComposingText:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    mIMM.notifyUserAction();
    return true;
}
------------------------
Find a functionally equivalent code:android.view.HardwareRenderer.trimMemory:COMMENT
Method Modifier: default     static      
Comment:/**
 * Invoke this method when the system is running out of memory. This
 * method will attempt to recover as much memory as possible, based on
 * the specified hint.
 *
 * @param level Hint about the amount of memory that should be trimmed,
 * see {@link android.content.ComponentCallbacks}
 */

Body of Frist Method:
{
    startTrimMemory(level);
    endTrimMemory();
}
Body of Second Method:
{
    ThreadedRenderer.trimMemory(level);
}
------------------------
Find a functionally equivalent code:android.app.backup.BackupAgent.onRestoreFile:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Only specialized platform agents should overload this entry point to support
 * restores to crazy non-app locations.
 * @hide
 */

Body of Frist Method:
{
    String basePath = null;
    if (DEBUG)
        Log.d(TAG, "onRestoreFile() size=" + size + " type=" + type + " domain=" + domain + " relpath=" + path + " mode=" + mode + " mtime=" + mtime);
    // Parse out the semantic domains into the correct physical location
    if (domain.equals(FullBackup.DATA_TREE_TOKEN)) {
        basePath = getFilesDir().getCanonicalPath();
    } else if (domain.equals(FullBackup.DATABASE_TREE_TOKEN)) {
        basePath = getDatabasePath("foo").getParentFile().getCanonicalPath();
    } else if (domain.equals(FullBackup.ROOT_TREE_TOKEN)) {
        basePath = new File(getApplicationInfo().dataDir).getCanonicalPath();
    } else if (domain.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
        basePath = getSharedPrefsFile("foo").getParentFile().getCanonicalPath();
    } else if (domain.equals(FullBackup.CACHE_TREE_TOKEN)) {
        basePath = getCacheDir().getCanonicalPath();
    } else if (domain.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
        // make sure we can try to restore here before proceeding
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                basePath = getExternalFilesDir(null).getCanonicalPath();
                // < 0 is a token to skip attempting a chmod()
                mode = -1;
            }
        }
    } else {
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domain);
    }
    // Now that we've figured out where the data goes, send it on its way
    if (basePath != null) {
        // Canonicalize the nominal path and verify that it lies within the stated domain
        File outFile = new File(basePath, path);
        String outPath = outFile.getCanonicalPath();
        if (outPath.startsWith(basePath + File.separatorChar)) {
            if (DEBUG)
                Log.i(TAG, "[" + domain + " : " + path + "] mapped to " + outPath);
            onRestoreFile(data, size, outFile, type, mode, mtime);
            return;
        } else {
            // Attempt to restore to a path outside the file's nominal domain.
            if (DEBUG) {
                Log.e(TAG, "Cross-domain restore attempt: " + outPath);
            }
        }
    }
    // with a null destination.
    if (DEBUG)
        Log.i(TAG, "[ skipping file " + path + "]");
    FullBackup.restoreFile(data, size, type, mode, mtime, null);
}
Body of Second Method:
{
    String basePath = null;
    if (DEBUG)
        Log.d(TAG, "onRestoreFile() size=" + size + " type=" + type + " domain=" + domain + " relpath=" + path + " mode=" + mode + " mtime=" + mtime);
    // Parse out the semantic domains into the correct physical location
    if (domain.equals(FullBackup.DATA_TREE_TOKEN)) {
        basePath = getFilesDir().getCanonicalPath();
    } else if (domain.equals(FullBackup.DATABASE_TREE_TOKEN)) {
        basePath = getDatabasePath("foo").getParentFile().getCanonicalPath();
    } else if (domain.equals(FullBackup.ROOT_TREE_TOKEN)) {
        basePath = new File(getApplicationInfo().dataDir).getCanonicalPath();
    } else if (domain.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
        basePath = getSharedPrefsFile("foo").getParentFile().getCanonicalPath();
    } else if (domain.equals(FullBackup.CACHE_TREE_TOKEN)) {
        basePath = getCacheDir().getCanonicalPath();
    } else if (domain.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
        // make sure we can try to restore here before proceeding
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                basePath = getExternalFilesDir(null).getCanonicalPath();
                // < 0 is a token to skip attempting a chmod()
                mode = -1;
            }
        }
    } else if (domain.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
        basePath = getNoBackupFilesDir().getCanonicalPath();
    } else {
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domain);
    }
    // Now that we've figured out where the data goes, send it on its way
    if (basePath != null) {
        // Canonicalize the nominal path and verify that it lies within the stated domain
        File outFile = new File(basePath, path);
        String outPath = outFile.getCanonicalPath();
        if (outPath.startsWith(basePath + File.separatorChar)) {
            if (DEBUG)
                Log.i(TAG, "[" + domain + " : " + path + "] mapped to " + outPath);
            onRestoreFile(data, size, outFile, type, mode, mtime);
            return;
        } else {
            // Attempt to restore to a path outside the file's nominal domain.
            if (DEBUG) {
                Log.e(TAG, "Cross-domain restore attempt: " + outPath);
            }
        }
    }
    // with a null destination.
    if (DEBUG)
        Log.i(TAG, "[ skipping file " + path + "]");
    FullBackup.restoreFile(data, size, type, mode, mtime, null);
}
------------------------
Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.getDlgIntent:COMMENT
Method Modifier: private     internal    
Comment:// notification and takes user input

Body of Frist Method:
{
    Intent intent = new Intent();
    String title = getDialogTitle(notif, mContext);
    String message = getDialogMessage(notif, mContext);
    // directly bring up the NI activity
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    intent.setClass(mContext, com.android.internal.app.NetInitiatedActivity.class);
    // put data in the intent
    intent.putExtra(NI_INTENT_KEY_NOTIF_ID, notif.notificationId);
    intent.putExtra(NI_INTENT_KEY_TITLE, title);
    intent.putExtra(NI_INTENT_KEY_MESSAGE, message);
    intent.putExtra(NI_INTENT_KEY_TIMEOUT, notif.timeout);
    intent.putExtra(NI_INTENT_KEY_DEFAULT_RESPONSE, notif.defaultResponse);
    if (DEBUG)
        Log.d(TAG, "generateIntent, title: " + title + ", message: " + message + ", timeout: " + notif.timeout);
    return intent;
}
Body of Second Method:
{
    Intent intent = new Intent();
    String title = getDialogTitle(notif, mContext);
    String message = getDialogMessage(notif, mContext);
    // directly bring up the NI activity
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    intent.setClass(mContext, com.android.internal.app.NetInitiatedActivity.class);
    // put data in the intent
    intent.putExtra(NI_INTENT_KEY_NOTIF_ID, notif.notificationId);
    intent.putExtra(NI_INTENT_KEY_TITLE, title);
    intent.putExtra(NI_INTENT_KEY_MESSAGE, message);
    intent.putExtra(NI_INTENT_KEY_TIMEOUT, notif.timeout);
    intent.putExtra(NI_INTENT_KEY_DEFAULT_RESPONSE, notif.defaultResponse);
    if (DEBUG)
        Log.d(TAG, "generateIntent, title: " + title + ", message: " + message + ", timeout: " + notif.timeout);
    return intent;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.sendMasterMuteUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumePanel.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
Body of Second Method:
{
    mVolumeController.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.saveLayerAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Helper for saveLayerAlpha() that takes 4 values instead of a RectF.
 */

Body of Frist Method:
{
    return native_saveLayerAlpha(mNativeCanvas, left, top, right, bottom, alpha, saveFlags);
}
Body of Second Method:
{
    alpha = Math.min(255, Math.max(0, alpha));
    return native_saveLayerAlpha(mNativeCanvasWrapper, left, top, right, bottom, alpha, saveFlags);
}
------------------------
Find a functionally equivalent code:android.widget.AutoCompleteTextView.setAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the list of data used for auto completion. The provided list
 * must be a filterable list adapter.</p>
 *
 * <p>The caller is still responsible for managing any resources used by the adapter.
 * Notably, when the AutoCompleteTextView is closed or released, the adapter is not notified.
 * A common case is the use of {@link android.widget.CursorAdapter}, which
 * contains a {@link android.database.Cursor} that must be closed.  This can be done
 * automatically (see
 * {@link android.app.Activity#startManagingCursor(android.database.Cursor)
 * startManagingCursor()}),
 * or by manually closing the cursor when the AutoCompleteTextView is dismissed.</p>
 *
 * @param adapter the adapter holding the auto completion data
 *
 * @see #getAdapter()
 * @see android.widget.Filterable
 * @see android.widget.ListAdapter
 */

Body of Frist Method:
{
    if (mObserver == null) {
        mObserver = new PopupDataSetObserver();
    } else if (mAdapter != null) {
        mAdapter.unregisterDataSetObserver(mObserver);
    }
    mAdapter = adapter;
    if (mAdapter != null) {
        // noinspection unchecked
        mFilter = ((Filterable) mAdapter).getFilter();
        adapter.registerDataSetObserver(mObserver);
    } else {
        mFilter = null;
    }
    mPopup.setAdapter(mAdapter);
}
Body of Second Method:
{
    if (mObserver == null) {
        mObserver = new PopupDataSetObserver(this);
    } else if (mAdapter != null) {
        mAdapter.unregisterDataSetObserver(mObserver);
    }
    mAdapter = adapter;
    if (mAdapter != null) {
        // noinspection unchecked
        mFilter = ((Filterable) mAdapter).getFilter();
        adapter.registerDataSetObserver(mObserver);
    } else {
        mFilter = null;
    }
    mPopup.setAdapter(mAdapter);
}
------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    }
    throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testDataConnectionWithWifiToAMToWifi:COMMENT
Method Modifier: public      
Comment:// Test case 7: test connectivity while transit from Wifi->AM->Wifi

Body of Frist Method:
{
    if (mWifiOnlyFlag) {
        Log.v(TAG, this.getName() + " is excluded for wifi-only test");
        return;
    }
    // Connect to mTestAccessPoint
    assertNotNull("SSID is null", mTestAccessPoint);
    // Connect to Wifi
    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    try {
        Thread.sleep(SHORT_TIMEOUT);
    } catch (Exception e) {
        log("exception: " + e.toString());
    }
    // Enable airplane mode without clearing Wifi
    mCM.setAirplaneMode(true);
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
    try {
        Thread.sleep(SHORT_TIMEOUT);
    } catch (Exception e) {
        log("exception: " + e.toString());
    }
    // Prepare for state validation
    NetworkInfo networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
    assertEquals(State.DISCONNECTED, networkInfo.getState());
    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.TO_CONNECTION, State.CONNECTED);
    // Disable airplane mode
    mCM.setAirplaneMode(false);
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    if (!mWifiOnlyFlag) {
        assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
    }
    // validate the state transition
    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
        log("Wifi state transition validation failed.");
        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
        assertTrue(false);
    }
}
Body of Second Method:
{
    // connect to mTestAccessPoint
    assertNotNull("SSID is null", mSsid);
    // enable WiFi
    assertTrue("failed to enable wifi", enableWifi());
    // wait for wifi enable
    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
    // connect to Wifi
    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // enable airplane mode without clearing Wifi
    mCm.setAirplaneMode(true);
    // assert there is active network connection after airplane mode disabled
    assertTrue("still has active network connection", waitUntilNoActiveNetworkConnection(LONG_TIMEOUT));
    // disable airplane mode
    mCm.setAirplaneMode(false);
    // assert there is active network connection after airplane mode disabled
    assertTrue("no active network connection after airplane mode disable", waitForActiveNetworkConnection(LONG_TIMEOUT));
    // assert that we have a Wifi connection
    assertTrue("wifi not connected after airplane mode disable", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // verify that connection actually works
    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.canHideNavigationBar:COMMENT
Method Modifier: private     internal    
Comment:/**
 * @return whether the navigation bar can be hidden, e.g. the device has a
 * navigation bar and touch exploration is not enabled
 */

Body of Frist Method:
{
    return mHasNavigationBar && !mTouchExplorationEnabled;
}
Body of Second Method:
{
    return mHasNavigationBar && !mAccessibilityManager.isTouchExplorationEnabled();
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.keyAt:COMMENT
Method Modifier: public      
Comment:/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 */

Body of Frist Method:
{
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}
Body of Second Method:
{
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.removeCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the specified callback. It will no longer receive events about media routing.
 *
 * @param cb Callback to remove
 */

Body of Frist Method:
{
    int index = findCallbackInfo(cb);
    if (index >= 0) {
        CallbackInfo info = sStatic.mCallbacks.remove(index);
        if ((info.flags & CALLBACK_FLAG_PERFORM_ACTIVE_SCAN) != 0) {
            sStatic.updateActiveScan();
        }
    } else {
        Log.w(TAG, "removeCallback(" + cb + "): callback not registered");
    }
}
Body of Second Method:
{
    int index = findCallbackInfo(cb);
    if (index >= 0) {
        sStatic.mCallbacks.remove(index);
        sStatic.updateDiscoveryRequest();
    } else {
        Log.w(TAG, "removeCallback(" + cb + "): callback not registered");
    }
}
------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerIsSignalClipping:COMMENT
Method Modifier: private     static      native      
Comment:// SR_RecognizerLockFunction function, void* data);

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.Activity.getActionBar:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a reference to this activity's ActionBar.
 *
 * @return The Activity's ActionBar, or null if it does not have one.
 */

Body of Frist Method:
{
    initActionBar();
    return mActionBar;
}
Body of Second Method:
{
    initWindowDecorActionBar();
    return mActionBar;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.readDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.widget.FastScroller.startPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Delays dragging until after the framework has determined that the user is
 * scrolling, rather than tapping.
 */

Body of Frist Method:
{
    mHasPendingDrag = true;
    mList.postDelayed(mDeferStartDrag, TAP_TIMEOUT);
}
Body of Second Method:
{
    mPendingDrag = SystemClock.uptimeMillis() + TAP_TIMEOUT;
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.getInstalledAccessibilityServiceList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */

Body of Frist Method:
{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getInstalledAccessibilityServiceList(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, "Installed AccessibilityServices " + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while obtaining the installed AccessibilityServices. ", re);
    }
    return Collections.unmodifiableList(services);
}
Body of Second Method:
{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getInstalledAccessibilityServiceList(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, "Installed AccessibilityServices " + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while obtaining the installed AccessibilityServices. ", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}
------------------------
Find a functionally equivalent code:android.database.ContentObserver.dispatchChange:COMMENT
Method Modifier: public      final       deprecated  
Comment:/**
 * Dispatches a change notification to the observer.
 * <p>
 * If a {@link Handler} was supplied to the {@link ContentObserver} constructor,
 * then a call to the {@link #onChange} method is posted to the handler's message queue.
 * Otherwise, the {@link #onChange} method is invoked immediately on this thread.
 * </p>
 *
 * @param selfChange True if this is a self-change notification.
 *
 * @deprecated Use {@link #dispatchChange(boolean, Uri)} instead.
 */

Body of Frist Method:
{
    dispatchChange(selfChange, null);
}
Body of Second Method:
{
    dispatchChange(selfChange, null);
}
------------------------
Find a functionally equivalent code:android.widget.CalendarView.setFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

Body of Frist Method:
{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    setUpHeader();
}
Body of Second Method:
{
    mDelegate.setFirstDayOfWeek(firstDayOfWeek);
}
------------------------
Find a functionally equivalent code:android.content.res.AssetManager.openXmlBlockAsset:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        int xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException("Asset XML file: " + fileName);
}
Body of Second Method:
{
    return openXmlBlockAsset(0, fileName);
}
------------------------
Find a functionally equivalent code:android.view.HardwareLayer.copyInto:COMMENT
<android.view.HardwareLayer: boolean copyInto(Bitmap)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Copies this layer into the specified bitmap.
 *
 * @param bitmap The bitmap to copy they layer into
 *
 * @return True if the copy was successful, false otherwise
 */

Body of Frist Method:

Body of Second Method:
{
    return mRenderer.copyLayerInto(this, bitmap);
}
------------------------
Find a functionally equivalent code:android.service.dreams.DreamService.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on keyEvent");
        safelyFinish();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, "Finishing on back key");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}
Body of Second Method:
{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on keyEvent");
        wakeUp();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, "Waking up on back key");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}
------------------------
Find a functionally equivalent code:android.media.RemoteControlClient.editMetadata:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link MetadataEditor}.
 * @param startEmpty Set to false if you want the MetadataEditor to contain the metadata that
 * was previously applied to the RemoteControlClient, or true if it is to be created empty.
 * @return a new MetadataEditor instance.
 */

Body of Frist Method:
{
    MetadataEditor editor = new MetadataEditor();
    if (startEmpty) {
        editor.mEditorMetadata = new Bundle();
        editor.mEditorArtwork = null;
        editor.mMetadataChanged = true;
        editor.mArtworkChanged = true;
        editor.mEditableKeys = 0;
    } else {
        editor.mEditorMetadata = new Bundle(mMetadata);
        editor.mEditorArtwork = mOriginalArtwork;
        editor.mMetadataChanged = false;
        editor.mArtworkChanged = false;
    }
    return editor;
}
Body of Second Method:
{
    MetadataEditor editor = new MetadataEditor();
    if (startEmpty) {
        editor.mEditorMetadata = new Bundle();
        editor.mEditorArtwork = null;
        editor.mMetadataChanged = true;
        editor.mArtworkChanged = true;
        editor.mEditableKeys = 0;
    } else {
        editor.mEditorMetadata = new Bundle(mMetadata);
        editor.mEditorArtwork = mOriginalArtwork;
        editor.mMetadataChanged = false;
        editor.mArtworkChanged = false;
    }
    // USE_SESSIONS
    if (startEmpty || mMediaMetadata == null) {
        editor.mMetadataBuilder = new MediaMetadata.Builder();
    } else {
        editor.mMetadataBuilder = new MediaMetadata.Builder(mMediaMetadata);
    }
    return editor;
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.setTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible title for the entry.
 * @param title the user-visible title for the entry.
 */

Body of Frist Method:
{
    this.title = title;
}
Body of Second Method:
{
    this.mTitle = title;
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.getNumberFromIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extracts the phone number from an Intent.
 *
 * @param intent the intent to get the number of
 * @param context a context to use for database access
 *
 * @return the phone number that would be called by the intent, or
 * <code>null</code> if the number cannot be found.
 */

Body of Frist Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    // CALL_PRIVILEGED permission).
    if (scheme.equals("voicemail")) {
        return TelephonyManager.getDefault().getCompleteVoiceMailNumber();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    final Cursor c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        } finally {
            c.close();
        }
    }
    return number;
}
Body of Second Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    final Cursor c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        } finally {
            c.close();
        }
    }
    return number;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getShort:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a short value
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Short) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "Short", defaultValue, e);
        return defaultValue;
    }
}
Body of Second Method:
{
    return super.getShort(key, defaultValue);
}
------------------------
Find a functionally equivalent code:android.content.pm.ComponentInfo.loadDefaultIcon:COMMENT
<android.content.pm.ComponentInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return applicationInfo.loadIcon(pm);
}
Body of Second Method:
{
    return applicationInfo.loadIcon(pm);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.stress.WifiStressTest.testWifiReconnectionAfterSleep:COMMENT
Method Modifier: public      
Comment:// Stress Wifi reconnection to secure net after sleep

Body of Frist Method:
{
    int value = Settings.Global.getInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, -1);
    log("wifi sleep policy is: " + value);
    if (value != Settings.Global.WIFI_SLEEP_POLICY_DEFAULT) {
        Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_DEFAULT);
        log("set wifi sleep policy to default value");
    }
    Settings.Global.putLong(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_IDLE_MS, WIFI_IDLE_MS);
    // Connect to a Wi-Fi network
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = mSsid;
    config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
    if (mPassword.matches("[0-9A-Fa-f]{64}")) {
        config.preSharedKey = mPassword;
    } else {
        config.preSharedKey = '"' + mPassword + '"';
    }
    config.ipAssignment = IpAssignment.DHCP;
    config.proxySettings = ProxySettings.NONE;
    assertTrue("Failed to connect to Wi-Fi network: " + mSsid, connectToWifiWithConfiguration(config));
    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // Run ping test to verify the data connection
    assertTrue("Wi-Fi is connected, but no data connection.", pingTest(null));
    int i;
    long sum = 0;
    for (i = 0; i < mReconnectIterations; i++) {
        // 1. Put device into sleep mode
        // 2. Wait for the device to sleep for sometime, verify wi-fi is off and mobile is on.
        // 3. Maintain the sleep mode for some time,
        // 4. Verify the Wi-Fi is still off, and data is on
        // 5. Wake up the device, verify Wi-Fi is enabled and connected.
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
        log("iteration: " + i);
        turnScreenOff();
        PowerManager pm = (PowerManager) mRunner.getContext().getSystemService(Context.POWER_SERVICE);
        assertFalse(pm.isScreenOn());
        sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY, "Interruped while wait for wifi to be idle");
        assertTrue("Wait for Wi-Fi to idle timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, 6 * SHORT_TIMEOUT));
        if (!mWifiOnlyFlag) {
            // use long timeout as the pppd startup may take several retries.
            assertTrue("Wait for cellular connection timeout", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
        }
        sleep(mWifiSleepTime, "Interrupted while device is in sleep mode");
        // Verify the wi-fi is still off and data connection is on
        assertEquals("Wi-Fi is reconnected", State.DISCONNECTED, mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI).getState());
        if (!mWifiOnlyFlag) {
            assertEquals("Cellular connection is down", State.CONNECTED, mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
            assertTrue("Mobile is connected, but no data connection.", pingTest(null));
        }
        // Turn screen on again
        turnScreenOn();
        // Wait for 2 seconds for the lock screen
        sleep(2 * 1000, "wait 2 seconds for lock screen");
        // Disable lock screen by inject menu key event
        mRunner.sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);
        // Measure the time for Wi-Fi to get connected
        long startTime = System.currentTimeMillis();
        assertTrue("Wait for Wi-Fi enable timeout after wake up", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
        assertTrue("Wait for Wi-Fi connection timeout after wake up", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
        long connectionTime = System.currentTimeMillis() - startTime;
        sum += connectionTime;
        log("average reconnection time is: " + sum / (i + 1));
        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest(null));
    }
    if (i == mReconnectIterations) {
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
    }
}
Body of Second Method:
{
    // set always scan to false
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0);
    // set wifi sleep policy to never on while in sleep
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_NEVER);
    // set idle timeout for wifi to 15s
    Settings.Global.putLong(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_IDLE_MS, WIFI_IDLE_MS);
    WifiConfiguration config;
    if (mPassword == null) {
        config = WifiConfigurationHelper.createOpenConfig(mSsid);
    } else {
        config = WifiConfigurationHelper.createPskConfig(mSsid, mPassword);
    }
    assertTrue("Failed to connect to Wi-Fi network: " + mSsid, connectToWifiWithConfiguration(config));
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // Run ping test to verify the data connection
    assertTrue("Wi-Fi is connected, but no data connection.", pingTest());
    long i, sum = 0, avgReconnectTime = 0;
    for (i = 1; i <= mReconnectIterations; i++) {
        // 1. Put device into sleep mode
        // 2. Wait for the device to sleep for sometime, verify wi-fi is off and mobile is on.
        // 3. Maintain the sleep mode for some time,
        // 4. Verify the Wi-Fi is still off, and data is on
        // 5. Wake up the device, verify Wi-Fi is enabled and connected.
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
        logv("iteration: " + i);
        turnScreenOff();
        // Use clock time since boot for intervals.
        long start = SystemClock.uptimeMillis();
        PowerManager pm = (PowerManager) mRunner.getContext().getSystemService(Context.POWER_SERVICE);
        while (pm.isInteractive() && ((SystemClock.uptimeMillis() - start) < SCREEN_OFF_TIMER)) {
            SystemClock.sleep(100);
        }
        assertFalse("screen still on", pm.isInteractive());
        // wait for WiFi timeout
        SystemClock.sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY);
        // 6 * SHORT_TIMEOUT));
        if (mWifiOnlyFlag) {
            assertTrue("expected wifi disconnect, still has active connection", waitUntilNoActiveNetworkConnection(2 * LONG_TIMEOUT));
        } else {
            // use long timeout as the pppd startup may take several retries.
            assertTrue("no fallback on mobile or wifi didn't disconnect", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
        }
        SystemClock.sleep(mWifiSleepTime);
        // verify the wi-fi is still off and either we have no connectivity or fallback on mobile
        if (mWifiOnlyFlag) {
            NetworkInfo ni = mCm.getActiveNetworkInfo();
            if (ni != null) {
                Log.e(mLogTag, "has active network while in wifi sleep: " + ni.toString());
                fail("active network detected");
            }
        } else {
            assertEquals("mobile not connected", State.CONNECTED, mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
            assertTrue("no connectivity over mobile", pingTest());
        }
        // Turn screen on again
        turnScreenOn();
        // Measure the time for Wi-Fi to get connected
        long startTime = SystemClock.uptimeMillis();
        assertTrue("screen on: wifi not enabled before timeout", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
        assertTrue("screen on: wifi not connected before timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, LONG_TIMEOUT));
        long connectionTime = SystemClock.uptimeMillis() - startTime;
        sum += connectionTime;
        avgReconnectTime = sum / i;
        logv("average reconnection time is: " + avgReconnectTime);
        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest());
    }
    Bundle result = new Bundle();
    result.putLong("actual-iterations", i - 1);
    result.putLong("avg-reconnect-time", avgReconnectTime);
    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
    if (i == mReconnectIterations + 1) {
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
    }
}
------------------------
Find a functionally equivalent code:android.security.KeyChain.bind:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide for reuse by CertInstaller and Settings.
 *
 * Caller should call unbindService on the result when finished.
 */

Body of Frist Method:
{
    if (context == null) {
        throw new NullPointerException("context == null");
    }
    ensureNotOnMainThread(context);
    final BlockingQueue<IKeyChainService> q = new LinkedBlockingQueue<IKeyChainService>(1);
    ServiceConnection keyChainServiceConnection = new ServiceConnection() {

        volatile boolean mConnectedAtLeastOnce = false;

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            if (!mConnectedAtLeastOnce) {
                mConnectedAtLeastOnce = true;
                try {
                    q.put(IKeyChainService.Stub.asInterface(service));
                } catch (InterruptedException e) {
                // will never happen, since the queue starts with one available slot
                }
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };
    Intent intent = new Intent(IKeyChainService.class.getName());
    ComponentName comp = intent.resolveSystemService(context.getPackageManager(), 0);
    intent.setComponent(comp);
    boolean isBound = context.bindService(intent, keyChainServiceConnection, Context.BIND_AUTO_CREATE);
    if (!isBound) {
        throw new AssertionError("could not bind to KeyChainService");
    }
    return new KeyChainConnection(context, keyChainServiceConnection, q.take());
}
Body of Second Method:
{
    return bindAsUser(context, Process.myUserHandle());
}
------------------------
Find a functionally equivalent code:android.graphics.Path.toggleInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Toggles the INVERSE state of the filltype
 */

Body of Frist Method:
{
    int ft = native_getFillType(mNativePath);
    ft ^= 2;
    native_setFillType(mNativePath, ft);
}
Body of Second Method:
{
    int ft = native_getFillType(mNativePath);
    ft ^= FillType.INVERSE_WINDING.nativeInt;
    native_setFillType(mNativePath, ft);
}
------------------------
Find a functionally equivalent code:android.content.RestrictionEntry.getChoiceEntries:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of strings, set earlier, that will be presented as choices to the user.
 * @return the list of choices presented to the user.
 */

Body of Frist Method:
{
    return choices;
}
Body of Second Method:
{
    return mChoiceEntries;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.checkAddPermission:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int type = attrs.type;
    outAppOp[0] = AppOpsManager.OP_NONE;
    if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
        return WindowManagerGlobal.ADD_OKAY;
    }
    String permission = null;
    switch(type) {
        case TYPE_TOAST:
            // monitor/control what they are doing.
            break;
        case TYPE_DREAM:
        case TYPE_INPUT_METHOD:
        case TYPE_WALLPAPER:
        case TYPE_PRIVATE_PRESENTATION:
            // The window manager will check these.
            break;
        case TYPE_PHONE:
        case TYPE_PRIORITY_PHONE:
        case TYPE_SYSTEM_ALERT:
        case TYPE_SYSTEM_ERROR:
        case TYPE_SYSTEM_OVERLAY:
            permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
            outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW;
            break;
        default:
            permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
    }
    if (permission != null) {
        if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
    }
    return WindowManagerGlobal.ADD_OKAY;
}
Body of Second Method:
{
    int type = attrs.type;
    outAppOp[0] = AppOpsManager.OP_NONE;
    if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
        return WindowManagerGlobal.ADD_OKAY;
    }
    String permission = null;
    switch(type) {
        case TYPE_TOAST:
            // XXX right now the app process has complete control over
            // this...  should introduce a token to let the system
            // monitor/control what they are doing.
            outAppOp[0] = AppOpsManager.OP_TOAST_WINDOW;
            break;
        case TYPE_DREAM:
        case TYPE_INPUT_METHOD:
        case TYPE_WALLPAPER:
        case TYPE_PRIVATE_PRESENTATION:
        case TYPE_VOICE_INTERACTION:
            // The window manager will check these.
            break;
        case TYPE_PHONE:
        case TYPE_PRIORITY_PHONE:
        case TYPE_SYSTEM_ALERT:
        case TYPE_SYSTEM_ERROR:
        case TYPE_SYSTEM_OVERLAY:
            permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
            outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW;
            break;
        default:
            permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
    }
    if (permission != null) {
        if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
    }
    return WindowManagerGlobal.ADD_OKAY;
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisMapXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashMap object from an XmlPullParser.  The XML data could
 * previously have been generated by writeMapXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the map.
 *
 * @param parser The XmlPullParser from which to read the map data.
 * @param endTag Name of the tag that will end the map, usually "map".
 * @param name An array of one string, used to return the name attribute
 * of the map's tag.
 *
 * @return HashMap The newly generated map.
 *
 * @see #readMapXml
 */

Body of Frist Method:
{
    HashMap map = new HashMap();
    int eventType = parser.getEventType();
    do {
        if (eventType == parser.START_TAG) {
            Object val = readThisValueXml(parser, name);
            if (name[0] != null) {
                // System.out.println("Adding to map: " + name + " -> " + val);
                map.put(name[0], val);
            } else {
                throw new XmlPullParserException("Map value without name attribute: " + parser.getName());
            }
        } else if (eventType == parser.END_TAG) {
            if (parser.getName().equals(endTag)) {
                return map;
            }
            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
        }
        eventType = parser.next();
    } while (eventType != parser.END_DOCUMENT);
    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
}
Body of Second Method:
{
    return readThisMapXml(parser, endTag, name, null);
}
------------------------
Find a functionally equivalent code:android.media.ImageReader.getNumPlanesFromFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used, when
 * reading YUV, JPEG or raw sensor data (for example, from camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
            return 1;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
Body of Second Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW10:
            return 1;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

Body of Frist Method:
{
    AudioSystem.muteMicrophone(on);
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.disconnectAP:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disconnectAP()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/*
     * Disconnect from the current AP and remove configured networks.
     */

Body of Frist Method:
{
    // remove saved networks
    if (!mWifiManager.isWifiEnabled()) {
        log("Enabled wifi before remove configured networks");
        mWifiManager.setWifiEnabled(true);
        sleep(SHORT_TIMEOUT);
    }
    List<WifiConfiguration> wifiConfigList = mWifiManager.getConfiguredNetworks();
    if (wifiConfigList == null) {
        log("no configuration list is null");
        return true;
    }
    log("size of wifiConfigList: " + wifiConfigList.size());
    for (WifiConfiguration wifiConfig : wifiConfigList) {
        log("remove wifi configuration: " + wifiConfig.networkId);
        int netId = wifiConfig.networkId;
        mWifiManager.forget(netId, new WifiManager.ActionListener() {

            public void onSuccess() {
            }

            public void onFailure(int reason) {
                log("Failed to forget " + reason);
            }
        });
    }
    return true;
}
Body of Second Method:
{
    // remove saved networks
    if (!mWifiManager.isWifiEnabled()) {
        logv("Enabled wifi before remove configured networks");
        mWifiManager.setWifiEnabled(true);
        SystemClock.sleep(SHORT_TIMEOUT);
    }
    List<WifiConfiguration> wifiConfigList = mWifiManager.getConfiguredNetworks();
    if (wifiConfigList == null) {
        logv("no configuration list is null");
        return true;
    }
    logv("size of wifiConfigList: " + wifiConfigList.size());
    for (WifiConfiguration wifiConfig : wifiConfigList) {
        logv("remove wifi configuration: " + wifiConfig.networkId);
        int netId = wifiConfig.networkId;
        mWifiManager.forget(netId, new WifiManager.ActionListener() {

            @Override
            public void onSuccess() {
            }

            @Override
            public void onFailure(int reason) {
                logv("Failed to forget " + reason);
            }
        });
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteAllHosts:COMMENT
Method Modifier: public      static      
Comment:/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

Body of Frist Method:
{
    deleteAllHosts(UserHandle.myUserId());
}
Body of Second Method:
{
    try {
        sService.deleteAllHosts();
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.widget.TimePicker.setIs24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */

Body of Frist Method:
{
    if (mIs24HourView == is24HourView) {
        return;
    }
    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
    int currentHour = getCurrentHour();
    // Order is important here.
    mIs24HourView = is24HourView;
    getHourFormatData();
    updateHourControl();
    // set value after spinner range is updated - be aware that because mIs24HourView has
    // changed then getCurrentHour() is not equal to the currentHour we cached before so
    // explicitly ask for *not* propagating any onTimeChanged()
    setCurrentHour(currentHour, false);
    updateMinuteControl();
    updateAmPmControl();
}
Body of Second Method:
{
    mDelegate.setIs24HourView(is24HourView);
}
------------------------
Find a functionally equivalent code:android.printservice.PrintServiceInfo.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new instance.
 *
 * @param resolveInfo The service resolve info.
 * @param context Context for accessing resources.
 * @throws XmlPullParserException If a XML parsing error occurs.
 * @throws IOException If a I/O error occurs.
 */

Body of Frist Method:
{
    String settingsActivityName = null;
    String addPrintersActivityName = null;
    XmlResourceParser parser = null;
    PackageManager packageManager = context.getPackageManager();
    parser = resolveInfo.serviceInfo.loadXmlMetaData(packageManager, PrintService.SERVICE_META_DATA);
    if (parser != null) {
        try {
            int type = 0;
            while (type != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
                type = parser.next();
            }
            String nodeName = parser.getName();
            if (!TAG_PRINT_SERVICE.equals(nodeName)) {
                Log.e(LOG_TAG, "Ignoring meta-data that does not start with " + TAG_PRINT_SERVICE + " tag");
            } else {
                Resources resources = packageManager.getResourcesForApplication(resolveInfo.serviceInfo.applicationInfo);
                AttributeSet allAttributes = Xml.asAttributeSet(parser);
                TypedArray attributes = resources.obtainAttributes(allAttributes, com.android.internal.R.styleable.PrintService);
                settingsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_settingsActivity);
                addPrintersActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_addPrintersActivity);
                attributes.recycle();
            }
        } catch (IOException ioe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + ioe);
        } catch (XmlPullParserException xppe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + xppe);
        } catch (NameNotFoundException e) {
            Log.e(LOG_TAG, "Unable to load resources for: " + resolveInfo.serviceInfo.packageName);
        } finally {
            if (parser != null) {
                parser.close();
            }
        }
    }
    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName);
}
Body of Second Method:
{
    String settingsActivityName = null;
    String addPrintersActivityName = null;
    String advancedPrintOptionsActivityName = null;
    XmlResourceParser parser = null;
    PackageManager packageManager = context.getPackageManager();
    parser = resolveInfo.serviceInfo.loadXmlMetaData(packageManager, PrintService.SERVICE_META_DATA);
    if (parser != null) {
        try {
            int type = 0;
            while (type != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
                type = parser.next();
            }
            String nodeName = parser.getName();
            if (!TAG_PRINT_SERVICE.equals(nodeName)) {
                Log.e(LOG_TAG, "Ignoring meta-data that does not start with " + TAG_PRINT_SERVICE + " tag");
            } else {
                Resources resources = packageManager.getResourcesForApplication(resolveInfo.serviceInfo.applicationInfo);
                AttributeSet allAttributes = Xml.asAttributeSet(parser);
                TypedArray attributes = resources.obtainAttributes(allAttributes, com.android.internal.R.styleable.PrintService);
                settingsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_settingsActivity);
                addPrintersActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_addPrintersActivity);
                advancedPrintOptionsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_advancedPrintOptionsActivity);
                attributes.recycle();
            }
        } catch (IOException ioe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + ioe);
        } catch (XmlPullParserException xppe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + xppe);
        } catch (NameNotFoundException e) {
            Log.e(LOG_TAG, "Unable to load resources for: " + resolveInfo.serviceInfo.packageName);
        } finally {
            if (parser != null) {
                parser.close();
            }
        }
    }
    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName, advancedPrintOptionsActivityName);
}
------------------------
Find a functionally equivalent code:android.view.ViewPropertyAnimator.AnimatorEventListener.onAnimationUpdate:COMMENT
Method Modifier: public      
Comment:/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */

Body of Frist Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
Body of Second Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
------------------------
Find a functionally equivalent code:android.view.PointerIcon.loadCustomIcon:COMMENT
Method Modifier: public      static      
Comment:/**
 * Loads a custom pointer icon from an XML resource.
 * <p>
 * The XML resource should have the following form:
 * <code>
 * &lt;?xml version="1.0" encoding="utf-8"?&gt;
 * &lt;pointer-icon xmlns:android="http://schemas.android.com/apk/res/android"
 * android:bitmap="@drawable/my_pointer_bitmap"
 * android:hotSpotX="24"
 * android:hotSpotY="24" /&gt;
 * </code>
 * </p>
 *
 * @param resources The resources object.
 * @param resourceId The resource id.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if resources is null.
 * @throws Resources.NotFoundException if the resource was not found or the drawable
 * linked in the resource was not found.
 */

Body of Frist Method:
{
    if (resources == null) {
        throw new IllegalArgumentException("resources must not be null");
    }
    PointerIcon icon = new PointerIcon(STYLE_CUSTOM);
    icon.loadResource(resources, resourceId);
    return icon;
}
Body of Second Method:
{
    if (resources == null) {
        throw new IllegalArgumentException("resources must not be null");
    }
    PointerIcon icon = new PointerIcon(STYLE_CUSTOM);
    icon.loadResource(null, resources, resourceId);
    return icon;
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCCStack:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control stack, focusing
 * on RemoteControlClient data
 */

Body of Frist Method:
{
    pw.println("\nRemote Control Client stack entries (last is top of stack):");
    synchronized (mRCStack) {
        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            RemoteControlStackEntry rcse = stackIterator.next();
            pw.println("  uid: " + rcse.mCallingUid + "  -- id: " + rcse.mRccId + "  -- type: " + rcse.mPlaybackType + "  -- state: " + rcse.mPlaybackState + "  -- vol handling: " + rcse.mPlaybackVolumeHandling + "  -- vol: " + rcse.mPlaybackVolume + "  -- volMax: " + rcse.mPlaybackVolumeMax + "  -- volObs: " + rcse.mRemoteVolumeObs);
        }
        synchronized (mCurrentRcLock) {
            pw.println("\nCurrent remote control generation ID = " + mCurrentRcClientGen);
        }
    }
    synchronized (mMainRemote) {
        pw.println("\nRemote Volume State:");
        pw.println("  has remote: " + mHasRemotePlayback);
        pw.println("  is remote active: " + mMainRemoteIsActive);
        pw.println("  rccId: " + mMainRemote.mRccId);
        pw.println("  volume handling: " + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ? "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
        pw.println("  volume: " + mMainRemote.mVolume);
        pw.println("  volume steps: " + mMainRemote.mVolumeMax);
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control Client stack entries (last is top of stack):");
    synchronized (mPRStack) {
        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw, false);
        }
        synchronized (mCurrentRcLock) {
            pw.println("\nCurrent remote control generation ID = " + mCurrentRcClientGen);
        }
    }
    synchronized (mMainRemote) {
        pw.println("\nRemote Volume State:");
        pw.println("  has remote: " + mHasRemotePlayback);
        pw.println("  is remote active: " + mMainRemoteIsActive);
        pw.println("  rccId: " + mMainRemote.mRccId);
        pw.println("  volume handling: " + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ? "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
        pw.println("  volume: " + mMainRemote.mVolume);
        pw.println("  volume steps: " + mMainRemote.mVolumeMax);
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHostView.getDefaultView:COMMENT
Method Modifier: protected   
Comment:/**
 * Inflate and return the default layout requested by AppWidget provider.
 */

Body of Frist Method:
{
    if (LOGD) {
        Log.d(TAG, "getDefaultView");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContextAsUser(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED, mUser);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, "can't inflate defaultView because mInfo is missing");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, "Error inflating AppWidget " + mInfo + ": " + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, "getDefaultView couldn't find any view, so inflating error");
        defaultView = getErrorView();
    }
    return defaultView;
}
Body of Second Method:
{
    if (LOGD) {
        Log.d(TAG, "getDefaultView");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, "can't inflate defaultView because mInfo is missing");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, "Error inflating AppWidget " + mInfo + ": " + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, "getDefaultView couldn't find any view, so inflating error");
        defaultView = getErrorView();
    }
    return defaultView;
}
------------------------
Find a functionally equivalent code:android.graphics.RadialGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final RadialGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
            copy = new RadialGradient(mX, mY, mRadius, mColor0, mColor1, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final RadialGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
            copy = new RadialGradient(mX, mY, mRadius, mCenterColor, mEdgeColor, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");
    }
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a functionally equivalent code:android.os.StrictMode.ViolationInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a ViolationInfo instance to a parcel.
 */

Body of Frist Method:
{
    crashInfo.writeToParcel(dest, flags);
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
}
Body of Second Method:
{
    crashInfo.writeToParcel(dest, flags);
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a functionally equivalent code:android.os.Parcel.readArrayMapInternal:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        Object key = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.append(key, value);
        N--;
    }
}
Body of Second Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
    }
    int startPos;
    while (N > 0) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        String key = readString();
        Object value = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read #" + (N - 1) + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString((key != null ? key.hashCode() : 0)) + " " + key);
        outVal.append(key, value);
        N--;
    }
    outVal.validate();
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.handleFocusGainInternal:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mFocused != null) {
        mFocused.unFocus();
        mFocused = null;
    }
    super.handleFocusGainInternal(direction, previouslyFocusedRect);
}
Body of Second Method:
{
    if (mFocused != null) {
        mFocused.unFocus(this);
        mFocused = null;
    }
    super.handleFocusGainInternal(direction, previouslyFocusedRect);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.unregisterMediaButtonIntent:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterMediaButtonIntent(PendingIntent mediaIntent)
 * precondition: mediaIntent != null, eventReceiver != null
 */

Body of Frist Method:
{
    Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
            removeMediaButtonReceiver_syncAfRcs(mediaIntent);
            if (topOfStackWillChange) {
                // current RC client will change, assume every type of info needs to be queried
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    }
}
Body of Second Method:
{
    Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
    synchronized (mPRStack) {
        boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
        removeMediaButtonReceiver_syncPrs(mediaIntent);
        if (topOfStackWillChange) {
            // current RC client will change, assume every type of info needs to be queried
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.loadColorStateList:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadColorStateList", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException("Resource is not a ColorStateList (color or path): " + value);
    }
    String file = value.string.toString();
    if (file.endsWith(".xml")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException("File " + file + " from color state list resource ID #0x" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id) + ": .xml extension required");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, "Saving cached color state list @ #" +
                // Integer.toHexString(key.intValue())
                // + " in " + this + ": " + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadColorStateList", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException("Resource is not a ColorStateList (color or path): " + value);
    }
    final String file = value.string.toString();
    if (file.endsWith(".xml")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            final XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException("File " + file + " from color state list resource ID #0x" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id) + ": .xml extension required");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, "Saving cached color state list @ #" +
                // Integer.toHexString(key.intValue())
                // + " in " + this + ": " + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}
------------------------
Find a functionally equivalent code:android.widget.DatePicker.setCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the {@link CalendarView} is shown.
 *
 * @param shown True if the calendar view is to be shown.
 */

Body of Frist Method:
{
    mCalendarView.setVisibility(shown ? VISIBLE : GONE);
}
Body of Second Method:
{
    mDelegate.setCalendarViewShown(shown);
}
------------------------
Find a functionally equivalent code:android.text.SpannableStringBuilder.drawTextRun:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Canvas to use internally.
 * {@hide}
 */

Body of Frist Method:
{
    checkRange("drawTextRun", start, end);
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (contextEnd <= mGapStart) {
        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, flags, p);
    } else if (contextStart >= mGapStart) {
        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, flags, p);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, flags, p);
        TextUtils.recycle(buf);
    }
}
Body of Second Method:
{
    checkRange("drawTextRun", start, end);
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (contextEnd <= mGapStart) {
        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, isRtl, p);
    } else if (contextStart >= mGapStart) {
        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, isRtl, p);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, isRtl, p);
        TextUtils.recycle(buf);
    }
}
------------------------
Find a functionally equivalent code:android.provider.Browser.truncateHistory:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */

Body of Frist Method:
{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + " ASC");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                iconDb.releaseIconForPageUrl(cursor.getString(1));
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "truncateHistory", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
Body of Second Method:
{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + " ASC");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "truncateHistory", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
------------------------
Find a functionally equivalent code:android.os.RecoverySystem.installPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */

Body of Frist Method:
{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    String arg = "--update_package=" + filename + "\n--locale=" + Locale.getDefault().toString();
    bootCommand(context, arg);
}
Body of Second Method:
{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    final String filenameArg = "--update_package=" + filename;
    final String localeArg = "--locale=" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.drawPoint:COMMENT
<android.graphics.Canvas: void drawPoint(float,float,Paint)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Helper for drawPoints() for drawing a single point.
 */

Body of Frist Method:

Body of Second Method:
{
    native_drawPoint(mNativeCanvasWrapper, x, y, paint.mNativePaint);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.CaptioningManager.addCaptioningChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a listener for changes in the user's preferred captioning enabled
 * state and visual properties.
 *
 * @param listener the listener to add
 */

Body of Frist Method:
{
    synchronized (mListeners) {
        if (mListeners.isEmpty()) {
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_ENABLED);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_LOCALE);
        }
        mListeners.add(listener);
    }
}
Body of Second Method:
{
    synchronized (mListeners) {
        if (mListeners.isEmpty()) {
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_ENABLED);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_LOCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_PRESET);
        }
        mListeners.add(listener);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.flushCookieStore:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Flushes all cookies managed by the Chrome HTTP stack to flash.
 *
 * @hide Package level api, called from CookieSyncManager
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:
{
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.createPrinterDiscoverySession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return new PrinterDiscoverySession(mService, mContext, mUserId);
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    return new PrinterDiscoverySession(mService, mContext, mUserId);
}
------------------------
Find a functionally equivalent code:android.print.PrintManager.getPrintJobs:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */

Body of Frist Method:
{
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print jobs", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print jobs", re);
    }
    return Collections.emptyList();
}
------------------------
Find a functionally equivalent code:android.os.StrictMode.decrementExpectedActivityCount:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (klass == null) {
        return;
    }
    final int limit;
    synchronized (StrictMode.class) {
        if ((sVmPolicy.mask & DETECT_VM_ACTIVITY_LEAKS) == 0) {
            return;
        }
        Integer expected = sExpectedActivityInstanceCount.get(klass);
        int newExpected = (expected == null || expected == 0) ? 0 : expected - 1;
        if (newExpected == 0) {
            sExpectedActivityInstanceCount.remove(klass);
        } else {
            sExpectedActivityInstanceCount.put(klass, newExpected);
        }
        // Note: adding 1 here to give some breathing room during
        // orientation changes.  (shouldn't be necessary, though?)
        limit = newExpected + 1;
    }
    // Quick check.
    int actual = InstanceTracker.getInstanceCount(klass);
    if (actual <= limit) {
        return;
    }
    // Do a GC and explicit count to double-check.
    // This is the work that we are trying to avoid by tracking the object instances
    // explicity.  Running an explicit GC can be expensive (80ms) and so can walking
    // the heap to count instance (30ms).  This extra work can make the system feel
    // noticeably less responsive during orientation changes when activities are
    // being restarted.  Granted, it is only a problem when StrictMode is enabled
    // but it is annoying.
    Runtime.getRuntime().gc();
    long instances = VMDebug.countInstancesOfClass(klass, false);
    if (instances > limit) {
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
Body of Second Method:
{
    if (klass == null) {
        return;
    }
    final int limit;
    synchronized (StrictMode.class) {
        if ((sVmPolicy.mask & DETECT_VM_ACTIVITY_LEAKS) == 0) {
            return;
        }
        Integer expected = sExpectedActivityInstanceCount.get(klass);
        int newExpected = (expected == null || expected == 0) ? 0 : expected - 1;
        if (newExpected == 0) {
            sExpectedActivityInstanceCount.remove(klass);
        } else {
            sExpectedActivityInstanceCount.put(klass, newExpected);
        }
        // Note: adding 1 here to give some breathing room during
        // orientation changes.  (shouldn't be necessary, though?)
        limit = newExpected + 1;
    }
    // Quick check.
    int actual = InstanceTracker.getInstanceCount(klass);
    if (actual <= limit) {
        return;
    }
    // Do a GC and explicit count to double-check.
    // This is the work that we are trying to avoid by tracking the object instances
    // explicity.  Running an explicit GC can be expensive (80ms) and so can walking
    // the heap to count instance (30ms).  This extra work can make the system feel
    // noticeably less responsive during orientation changes when activities are
    // being restarted.  Granted, it is only a problem when StrictMode is enabled
    // but it is annoying.
    System.gc();
    System.runFinalization();
    System.gc();
    long instances = VMDebug.countInstancesOfClass(klass, false);
    if (instances > limit) {
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.nativeWriteToParcel:COMMENT
Method Modifier: private     static      native      
Comment:// returns true on success

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.speech.srec.MicrophoneInputStream.AudioRecordNew:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.res.TypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to float: " + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, "getFloat of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to float: " + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, "getFloat of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a functionally equivalent code:android.app.Notification.cloneInto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members
 * of this into that.
 * @hide
 */

Body of Frist Method:
{
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    final String[] thiskind = this.kind;
    if (thiskind != null) {
        final int N = thiskind.length;
        final String[] thatkind = that.kind = new String[N];
        System.arraycopy(thiskind, 0, thatkind, 0, N);
    }
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
Body of Second Method:
{
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    if (this.audioAttributes != null) {
        that.audioAttributes = new AudioAttributes.Builder(this.audioAttributes).build();
    }
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    that.category = this.category;
    that.mGroupKey = this.mGroupKey;
    that.mSortKey = this.mSortKey;
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (heavy && this.headsUpContentView != null) {
        that.headsUpContentView = this.headsUpContentView.clone();
    }
    that.visibility = this.visibility;
    if (this.publicVersion != null) {
        that.publicVersion = new Notification();
        this.publicVersion.cloneInto(that.publicVersion, heavy);
    }
    that.color = this.color;
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */

Body of Frist Method:
{
    final int userId = mContext.getUserId();
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setUserId(userId);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId, userId);
        if (views != null) {
            views.setUser(new UserHandle(mContext.getUserId()));
        }
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
Body of Second Method:
{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String value = mResourceData[index].getValue();
    if (value == null) {
        return defValue;
    }
    if (ResourceHelper.parseFloatAttribute(mNames[index], value, mValue, false)) {
        return mValue.getFraction(base, pbase);
    }
    // looks like we were unable to resolve the fraction value
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to a fraction.", value, mNames[index]), null);
    return defValue;
}
Body of Second Method:
{
    String value = getString(index);
    if (value == null) {
        return defValue;
    }
    if (ResourceHelper.parseFloatAttribute(mNames[index], value, mValue, false)) {
        return mValue.getFraction(base, pbase);
    }
    // looks like we were unable to resolve the fraction value
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to a fraction.", value, mNames[index]), null);
    return defValue;
}
------------------------
Find a functionally equivalent code:android.os.Bundle.getSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "Serializable", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getSerializable(key);
}
------------------------
Find a functionally equivalent code:android.view.MotionEvent.PointerCoords.setAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

Body of Frist Method:
{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                final int index = Long.bitCount(bits & (axisBit - 1L));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}
Body of Second Method:
{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}
------------------------
Find a functionally equivalent code:android.util.Log.wtfStack:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Like {@link #wtf(String, String)}, but also writes to the log the full
 * call stack.
 * @hide
 */

Body of Frist Method:
{
    return wtf(LOG_ID_MAIN, tag, msg, null, true);
}
Body of Second Method:
{
    return wtf(LOG_ID_MAIN, tag, msg, null, true, false);
}
------------------------
Find a functionally equivalent code:android.os.Bundle.putBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a boolean array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a boolean array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putBooleanArray(key, value);
}
------------------------
Find a functionally equivalent code:com.android.internal.content.NativeLibraryHelper.removeNativeBinariesLI:COMMENT
Method Modifier: public      static      internal    
Comment:// Convenience method to call removeNativeBinariesFromDirLI(File)

Body of Frist Method:
{
    return removeNativeBinariesFromDirLI(new File(nativeLibraryPath));
}
Body of Second Method:
{
    if (nativeLibraryPath == null)
        return;
    removeNativeBinariesFromDirLI(new File(nativeLibraryPath), false);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable's color value.
 *
 * @return int The color to draw.
 */

Body of Frist Method:
{
    return mState.mUseColor;
}
Body of Second Method:
{
    return mColorState.mUseColor;
}
------------------------
Find a functionally equivalent code:android.transition.Transition.animate:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This is a utility method used by subclasses to handle standard parts of
 * setting up and running an Animator: it sets the {@link #getDuration()
 * duration} and the {@link #getStartDelay() startDelay}, starts the
 * animation, and, when the animator ends, calls {@link #end()}.
 *
 * @param animator The Animator to be run during this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    // TODO: maybe pass auto-end as a boolean parameter?
    if (animator == null) {
        end();
    } else {
        if (getDuration() >= 0) {
            animator.setDuration(getDuration());
        }
        if (getStartDelay() >= 0) {
            animator.setStartDelay(getStartDelay());
        }
        if (getInterpolator() != null) {
            animator.setInterpolator(getInterpolator());
        }
        animator.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                end();
                animation.removeListener(this);
            }
        });
        animator.start();
    }
}
Body of Second Method:
{
    // TODO: maybe pass auto-end as a boolean parameter?
    if (animator == null) {
        end();
    } else {
        if (getDuration() >= 0) {
            animator.setDuration(getDuration());
        }
        if (getStartDelay() >= 0) {
            animator.setStartDelay(getStartDelay() + animator.getStartDelay());
        }
        if (getInterpolator() != null) {
            animator.setInterpolator(getInterpolator());
        }
        animator.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                end();
                animation.removeListener(this);
            }
        });
        animator.start();
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    if (RenderResources.REFERENCE_NULL.equals(resValue.getValue())) {
        return defValue;
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue = null;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue.intValue();
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a functionally equivalent code:android.media.MediaDrm.getProvisionRequest:COMMENT
<android.media.MediaDrm: ProvisionRequest getProvisionRequest()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * A provision request/response exchange occurs between the app and a provisioning
 * server to retrieve a device certificate.  If provisionining is required, the
 * EVENT_PROVISION_REQUIRED event will be sent to the event handler.
 * getProvisionRequest is used to obtain the opaque provision request byte array that
 * should be delivered to the provisioning server. The provision request byte array
 * is returned in ProvisionRequest.data. The recommended URL to deliver the provision
 * request to is returned in ProvisionRequest.defaultUrl.
 */

Body of Frist Method:

Body of Second Method:
{
    return getProvisionRequestNative(CERTIFICATE_TYPE_NONE, "");
}
------------------------
Find a functionally equivalent code:android.view.KeyEvent.keyCodeFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets a keycode by its symbolic name such as "KEYCODE_A" or an equivalent
 * numeric constant such as "1001".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */

Body of Frist Method:
{
    if (symbolicName == null) {
        throw new IllegalArgumentException("symbolicName must not be null");
    }
    final int count = KEYCODE_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(KEYCODE_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}
Body of Second Method:
{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int keyCode = nativeKeyCodeFromString(symbolicName);
        if (keyCode > 0) {
            return keyCode;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}
------------------------
Find a functionally equivalent code:android.widget.CheckedTextView.setCheckMarkDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the checkmark to a given Drawable. This will be drawn when {@link #isChecked()} is true.
 *
 * @param d The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(int)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */

Body of Frist Method:
{
    if (mCheckMarkDrawable != null) {
        mCheckMarkDrawable.setCallback(null);
        unscheduleDrawable(mCheckMarkDrawable);
    }
    mNeedRequestlayout = (d != mCheckMarkDrawable);
    if (d != null) {
        d.setCallback(this);
        d.setVisible(getVisibility() == VISIBLE, false);
        d.setState(CHECKED_STATE_SET);
        setMinHeight(d.getIntrinsicHeight());
        mCheckMarkWidth = d.getIntrinsicWidth();
        d.setState(getDrawableState());
    } else {
        mCheckMarkWidth = 0;
    }
    mCheckMarkDrawable = d;
    // Do padding resolution. This will call internalSetPadding() and do a requestLayout() if needed.
    resolvePadding();
}
Body of Second Method:
{
    if (mCheckMarkDrawable != null) {
        mCheckMarkDrawable.setCallback(null);
        unscheduleDrawable(mCheckMarkDrawable);
    }
    mNeedRequestlayout = (d != mCheckMarkDrawable);
    if (d != null) {
        d.setCallback(this);
        d.setVisible(getVisibility() == VISIBLE, false);
        d.setState(CHECKED_STATE_SET);
        setMinHeight(d.getIntrinsicHeight());
        mCheckMarkWidth = d.getIntrinsicWidth();
        d.setState(getDrawableState());
        applyCheckMarkTint();
    } else {
        mCheckMarkWidth = 0;
    }
    mCheckMarkDrawable = d;
    // Do padding resolution. This will call internalSetPadding() and do a
    // requestLayout() if needed.
    resolvePadding();
}
------------------------
Find a functionally equivalent code:android.app.backup.BackupManager.requestRestore:COMMENT
Method Modifier: public      
Comment:/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */

Body of Frist Method:
{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.w(TAG, "restoreSelf() unable to contact service");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}
Body of Second Method:
{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "restoreSelf() unable to contact service");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.os.BatteryStats.getPhoneDataConnectionTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been running with
 * the given data connection.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerResultGetWaveform:COMMENT
Method Modifier: private     static      native      
Comment:// 

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.handleBootCompleted:COMMENT
Method Modifier: protected   
Comment:/**
 * Handle {@link #MSG_BOOT_COMPLETED}
 */

Body of Frist Method:
{
    if (mBootCompleted)
        return;
    mBootCompleted = true;
    mAudioManager = new AudioManager(mContext);
    mAudioManager.registerRemoteControlDisplay(mRemoteControlDisplay);
    for (int i = 0; i < mCallbacks.size(); i++) {
        KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
        if (cb != null) {
            cb.onBootCompleted();
        }
    }
}
Body of Second Method:
{
    if (mBootCompleted)
        return;
    mBootCompleted = true;
    for (int i = 0; i < mCallbacks.size(); i++) {
        KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
        if (cb != null) {
            cb.onBootCompleted();
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.start:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Starts the animation, looping if necessary. This method has no effect
 * if the animation is running. Do not call this in the {@link android.app.Activity#onCreate}
 * method of your activity, because the {@link android.graphics.drawable.AnimationDrawable} is
 * not yet fully attached to the window. If you want to play
 * the animation immediately, without requiring interaction, then you might want to call it
 * from the {@link android.app.Activity#onWindowFocusChanged} method in your activity,
 * which will get called when Android brings your window into focus.</p>
 *
 * @see #isRunning()
 * @see #stop()
 */

Body of Frist Method:
{
    if (!isRunning()) {
        run();
    }
}
Body of Second Method:
{
    mAnimating = true;
    if (!isRunning()) {
        run();
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Picture.getHeight:COMMENT
<android.graphics.Picture: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the height of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:

Body of Second Method:
{
    return nativeGetHeight(mNativePicture);
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.waitForWifiState:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean waitForWifiState(int,long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// WIFI_STATE_ENALBING, WIFI_STATE_UNKNOWN

Body of Frist Method:
{
    long startTime = System.currentTimeMillis();
    while (true) {
        if ((System.currentTimeMillis() - startTime) > timeout) {
            if (mWifiState != expectedState) {
                return false;
            } else {
                return true;
            }
        }
        log("Wait for wifi state to be: " + expectedState);
        synchronized (wifiObject) {
            try {
                wifiObject.wait(SHORT_TIMEOUT);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (mWifiState != expectedState) {
                log("Wifi state is: " + mWifiState);
                continue;
            }
            return true;
        }
    }
}
Body of Second Method:
{
    long startTime = SystemClock.uptimeMillis();
    while (true) {
        int state = mWifiManager.getWifiState();
        if (state == expectedState) {
            logv("waitForWifiState success: state=" + state);
            return true;
        }
        if ((SystemClock.uptimeMillis() - startTime) > timeout) {
            logv("waitForWifiState timeout: expected=%d, actual=%d", expectedState, state);
            return false;
        }
        logv("waitForWifiState interim: expected=%d, actual=%d", expectedState, state);
        SystemClock.sleep(SHORT_TIMEOUT);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaRouter.clearUserRoutes:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all app-specified routes from the MediaRouter.
 *
 * @see #removeUserRoute(UserRouteInfo)
 */

Body of Frist Method:
{
    for (int i = 0; i < sStatic.mRoutes.size(); i++) {
        final RouteInfo info = sStatic.mRoutes.get(i);
        // The code below will need to change if this assumption does.
        if (info instanceof UserRouteInfo || info instanceof RouteGroup) {
            removeRouteAt(i);
            i--;
        }
    }
}
Body of Second Method:
{
    for (int i = 0; i < sStatic.mRoutes.size(); i++) {
        final RouteInfo info = sStatic.mRoutes.get(i);
        // The code below will need to change if this assumption does.
        if (info instanceof UserRouteInfo || info instanceof RouteGroup) {
            removeRouteStatic(info);
            i--;
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.play:COMMENT
Method Modifier: public      
Comment:/**
 * Starts playing an AudioTrack.
 * If track's creation mode is {@link #MODE_STATIC}, you must have called write() prior.
 *
 * @throws IllegalStateException
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("play() called on uninitialized AudioTrack.");
    }
    synchronized (mPlayStateLock) {
        native_start();
        mPlayState = PLAYSTATE_PLAYING;
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("play() called on uninitialized AudioTrack.");
    }
    if (isRestricted()) {
        setVolume(0);
    }
    synchronized (mPlayStateLock) {
        native_start();
        mPlayState = PLAYSTATE_PLAYING;
    }
}
------------------------
