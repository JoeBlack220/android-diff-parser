Find a functionally equivalent code:com.android.systemui.statusbar.phone.StatusBarKeyguardViewManager.showBouncerOrKeyguard:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the notification keyguard or the bouncer depending on
 * {@link KeyguardBouncer#needsFullscreenBouncer()}.
 */

Body of Frist Method:
{
    if (mBouncer.needsFullscreenBouncer()) {
        // The keyguard might be showing (already). So we need to hide it.
        mPhoneStatusBar.hideKeyguard();
        mBouncer.show();
    } else {
        mPhoneStatusBar.showKeyguard();
        mBouncer.hide(false);
        mBouncer.prepare();
    }
}
Body of Second Method:
{
    if (mBouncer.needsFullscreenBouncer()) {
        // The keyguard might be showing (already). So we need to hide it.
        mPhoneStatusBar.hideKeyguard();
        mBouncer.show(true);
    } else {
        mPhoneStatusBar.showKeyguard();
        mBouncer.hide(false);
        mBouncer.prepare();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.applyPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        mForceStatusBarFromKeyguard = true;
    }
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mShowingLockscreen = true;
        }
        boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
        final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
        final boolean secureKeyguard = isKeyguardSecure();
        if (appWindow) {
            final IApplicationToken appToken = win.getAppToken();
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty() && isKeyguardSecureIncludingHidden()) {
                    mWinShowWhenLocked = win;
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
            } else if (dismissKeyguard) {
                if (secureKeyguard) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && secureKeyguard;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken()) {
                win.hideLw(false);
            }
        }
    }
}
Body of Second Method:
{
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        mForceStatusBarFromKeyguard = true;
    }
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mShowingLockscreen = true;
        }
        boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
        final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken()) {
                win.hideLw(false);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.RadialTimePickerView.setCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current hour in 24-hour time.
 *
 * @param hour the current hour between 0 and 23 (inclusive)
 */

Body of Frist Method:
{
    final int degrees = (hour % 12) * DEGREES_FOR_ONE_HOUR;
    mSelectionDegrees[HOURS] = degrees;
    mSelectionDegrees[HOURS_INNER] = degrees;
    // 0 is 12 AM (midnight) and 12 is 12 PM (noon).
    mAmOrPm = (hour == 0 || (hour % 24) < 12) ? AM : PM;
    if (mIs24HourMode) {
        // Inner circle is 1 through 12.
        mIsOnInnerCircle = hour >= 1 && hour <= 12;
    } else {
        mIsOnInnerCircle = false;
    }
    initData();
    updateLayoutData();
    invalidate();
}
Body of Second Method:
{
    setCurrentHourInternal(hour, true, false);
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext);
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext, mTheme);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setBuiltInZoomControls:COMMENT
<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:// {@link WebView#getZoomControls}, which is now hidden.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.res.Resources.loadDrawable:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this, theme);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        final Drawable clonedDr = cs.newDrawable(this);
        if (theme != null) {
            dr = clonedDr.mutate();
            dr.applyTheme(theme);
            dr.clearMutated();
        } else {
            dr = clonedDr;
        }
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on service state.
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putBoolean("roaming", Boolean.valueOf(mRoaming));
    m.putString("operator-alpha-long", mOperatorAlphaLong);
    m.putString("operator-alpha-short", mOperatorAlphaShort);
    m.putString("operator-numeric", mOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
}
Body of Second Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setLoadsImagesAutomatically:COMMENT
<android.webkit.WebSettings: void setLoadsImagesAutomatically(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should load image resources. Note that this method
 * controls loading of all images, including those embedded using the data
 * URI scheme. Use {@link #setBlockNetworkImage} to control loading only
 * of images specified using network URI schemes. Note that if the value of this
 * setting is changed from false to true, all images resources referenced
 * by content currently displayed by the WebView are loaded automatically.
 * The default is true.
 *
 * @param flag whether the WebView should load image resources
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.NativeDaemonEvent.parseRawEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parse the given raw event into {@link NativeDaemonEvent} instance.
 *
 * @throws IllegalArgumentException when line doesn't match format expected
 * from native side.
 */

Body of Frist Method:
{
    final String[] parsed = rawEvent.split(" ");
    if (parsed.length < 2) {
        throw new IllegalArgumentException("Insufficient arguments");
    }
    int skiplength = 0;
    final int code;
    try {
        code = Integer.parseInt(parsed[0]);
        skiplength = parsed[0].length() + 1;
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("problem parsing code", e);
    }
    int cmdNumber = -1;
    if (isClassUnsolicited(code) == false) {
        if (parsed.length < 3) {
            throw new IllegalArgumentException("Insufficient arguemnts");
        }
        try {
            cmdNumber = Integer.parseInt(parsed[1]);
            skiplength += parsed[1].length() + 1;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("problem parsing cmdNumber", e);
        }
    }
    final String message = rawEvent.substring(skiplength);
    return new NativeDaemonEvent(cmdNumber, code, message, rawEvent);
}
Body of Second Method:
{
    final String[] parsed = rawEvent.split(" ");
    if (parsed.length < 2) {
        throw new IllegalArgumentException("Insufficient arguments");
    }
    int skiplength = 0;
    final int code;
    try {
        code = Integer.parseInt(parsed[0]);
        skiplength = parsed[0].length() + 1;
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("problem parsing code", e);
    }
    int cmdNumber = -1;
    if (isClassUnsolicited(code) == false) {
        if (parsed.length < 3) {
            throw new IllegalArgumentException("Insufficient arguemnts");
        }
        try {
            cmdNumber = Integer.parseInt(parsed[1]);
            skiplength += parsed[1].length() + 1;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("problem parsing cmdNumber", e);
        }
    }
    String logMessage = rawEvent;
    if (parsed.length > 2 && parsed[2].equals(SENSITIVE_MARKER)) {
        skiplength += parsed[2].length() + 1;
        logMessage = parsed[0] + " " + parsed[1] + " {}";
    }
    final String message = rawEvent.substring(skiplength);
    return new NativeDaemonEvent(cmdNumber, code, message, rawEvent, logMessage);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.PanelView.startUnlockHintAnimationPhase1:COMMENT
Method Modifier: private     
Comment:/**
 * Phase 1: Move everything upwards.
 */

Body of Frist Method:
{
    float target = Math.max(0, getMaxPanelHeight() - mHintDistance);
    ValueAnimator animator = createHeightAnimator(target);
    animator.setDuration(250);
    animator.setInterpolator(mFastOutSlowInInterpolator);
    animator.addListener(new AnimatorListenerAdapter() {

        private boolean mCancelled;

        @Override
        public void onAnimationCancel(Animator animation) {
            mCancelled = true;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            if (mCancelled) {
                mHeightAnimator = null;
                onAnimationFinished.run();
            } else {
                startUnlockHintAnimationPhase2(onAnimationFinished);
            }
        }
    });
    animator.start();
    mHeightAnimator = animator;
    mOriginalIndicationY = mKeyguardBottomArea.getIndicationView().getY();
    mKeyguardBottomArea.getIndicationView().animate().y(mOriginalIndicationY - mHintDistance).setDuration(250).setInterpolator(mFastOutSlowInInterpolator).withEndAction(new Runnable() {

        @Override
        public void run() {
            mKeyguardBottomArea.getIndicationView().animate().y(mOriginalIndicationY).setDuration(450).setInterpolator(mBounceInterpolator).start();
        }
    }).start();
}
Body of Second Method:
{
    float target = Math.max(0, getMaxPanelHeight() - mHintDistance);
    ValueAnimator animator = createHeightAnimator(target);
    animator.setDuration(250);
    animator.setInterpolator(mFastOutSlowInInterpolator);
    animator.addListener(new AnimatorListenerAdapter() {

        private boolean mCancelled;

        @Override
        public void onAnimationCancel(Animator animation) {
            mCancelled = true;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            if (mCancelled) {
                mHeightAnimator = null;
                onAnimationFinished.run();
            } else {
                startUnlockHintAnimationPhase2(onAnimationFinished);
            }
        }
    });
    animator.start();
    mHeightAnimator = animator;
    mKeyguardBottomArea.getIndicationView().animate().translationY(-mHintDistance).setDuration(250).setInterpolator(mFastOutSlowInInterpolator).withEndAction(new Runnable() {

        @Override
        public void run() {
            mKeyguardBottomArea.getIndicationView().animate().translationY(0).setDuration(450).setInterpolator(mBounceInterpolator).start();
        }
    }).start();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewScroller.stopBoundScrollAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Aborts any current stack scrolls
 */

Body of Frist Method:
{
    if (mScrollAnimator != null) {
        mScrollAnimator.removeAllListeners();
        mScrollAnimator.cancel();
    }
}
Body of Second Method:
{
    Utilities.cancelAnimationWithoutCallbacks(mScrollAnimator);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleDrawable.tryBackgroundEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Creates an active hotspot at the specified location.
 */

Body of Frist Method:
{
    if (mBackground == null) {
        mBackground = new RippleBackground(this, mHotspotBounds);
    }
    final int color = mState.mColor.getColorForState(getState(), Color.TRANSPARENT);
    mBackground.setup(mState.mMaxRadius, color, mDensity);
    mBackground.enter();
}
Body of Second Method:
{
    if (mBackground == null) {
        mBackground = new RippleBackground(this, mHotspotBounds);
    }
    mBackground.setup(mState.mMaxRadius, mDensity);
    mBackground.enter(focused);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.clearMatches:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the highlighting surrounding text matches created by
 * {@link #findAllAsync}.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "clearMatches");
    mProvider.clearMatches();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "clearMatches");
    mProvider.clearMatches();
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowState.isOnScreen:COMMENT
Method Modifier: 
Comment:/**
 * Is this window currently on-screen?  It is on-screen either if it
 * is visible or it is currently running an animation before no longer
 * being visible.
 */

Body of Frist Method:
{
    if (!mHasSurface || !mPolicyVisibility || mDestroying) {
        return false;
    }
    final AppWindowToken atoken = mAppToken;
    if (atoken != null) {
        return ((!mAttachedHidden && !atoken.hiddenRequested) || mWinAnimator.mAnimation != null || atoken.mAppAnimator.animation != null);
    }
    return !mAttachedHidden || mWinAnimator.mAnimation != null;
}
Body of Second Method:
{
    return mPolicyVisibility && isOnScreenIgnoringKeyguard();
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyDownPanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Called when the panel key is pushed down.
 * @param featureId The feature ID of the relevant panel (defaults to FEATURE_OPTIONS_PANEL}.
 * @param event The key event.
 * @return Whether the key was handled.
 */

Body of Frist Method:
{
    final int keyCode = event.getKeyCode();
    if (event.getRepeatCount() == 0) {
        // The panel key was pushed, so set the chording key
        mPanelChordingKey = keyCode;
        PanelFeatureState st = getPanelState(featureId, true);
        if (!st.isOpen) {
            return preparePanel(st, event);
        }
    }
    return false;
}
Body of Second Method:
{
    final int keyCode = event.getKeyCode();
    if (event.getRepeatCount() == 0) {
        // The panel key was pushed, so set the chording key
        mPanelChordingKey = keyCode;
        PanelFeatureState st = getPanelState(featureId, false);
        if (st != null && !st.isOpen) {
            return preparePanel(st, event);
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.internal.util.XmlUtils.writeValueXml:COMMENT
Method Modifier: private     static      final       internal    
Comment:/**
 * Flatten an object's value into an XmlSerializer.  The value can later
 * be read back with readThisValueXml().
 *
 * Currently supported value types are: null, String, Integer, Long,
 * Float, Double Boolean, Map, List.
 *
 * @param v The object to be flattened.
 * @param name Name attribute to include with this value's tag, or null
 * for none.
 * @param out XmlSerializer to write the object into.
 * @param callback Handler for Object types not recognized.
 *
 * @see #writeMapXml
 * @see #writeListXml
 * @see #readValueXml
 */

Body of Frist Method:
{
    String typeStr;
    if (v == null) {
        out.startTag(null, "null");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.endTag(null, "null");
        return;
    } else if (v instanceof String) {
        out.startTag(null, "string");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.text(v.toString());
        out.endTag(null, "string");
        return;
    } else if (v instanceof Integer) {
        typeStr = "int";
    } else if (v instanceof Long) {
        typeStr = "long";
    } else if (v instanceof Float) {
        typeStr = "float";
    } else if (v instanceof Double) {
        typeStr = "double";
    } else if (v instanceof Boolean) {
        typeStr = "boolean";
    } else if (v instanceof byte[]) {
        writeByteArrayXml((byte[]) v, name, out);
        return;
    } else if (v instanceof int[]) {
        writeIntArrayXml((int[]) v, name, out);
        return;
    } else if (v instanceof long[]) {
        writeLongArrayXml((long[]) v, name, out);
        return;
    } else if (v instanceof double[]) {
        writeDoubleArrayXml((double[]) v, name, out);
        return;
    } else if (v instanceof String[]) {
        writeStringArrayXml((String[]) v, name, out);
        return;
    } else if (v instanceof Map) {
        writeMapXml((Map) v, name, out);
        return;
    } else if (v instanceof List) {
        writeListXml((List) v, name, out);
        return;
    } else if (v instanceof Set) {
        writeSetXml((Set) v, name, out);
        return;
    } else if (v instanceof CharSequence) {
        // XXX This is to allow us to at least write something if
        // we encounter styled text...  but it means we will drop all
        // of the styling information. :(
        out.startTag(null, "string");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.text(v.toString());
        out.endTag(null, "string");
        return;
    } else if (callback != null) {
        callback.writeUnknownObject(v, name, out);
        return;
    } else {
        throw new RuntimeException("writeValueXml: unable to write value " + v);
    }
    out.startTag(null, typeStr);
    if (name != null) {
        out.attribute(null, "name", name);
    }
    out.attribute(null, "value", v.toString());
    out.endTag(null, typeStr);
}
Body of Second Method:
{
    String typeStr;
    if (v == null) {
        out.startTag(null, "null");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.endTag(null, "null");
        return;
    } else if (v instanceof String) {
        out.startTag(null, "string");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.text(v.toString());
        out.endTag(null, "string");
        return;
    } else if (v instanceof Integer) {
        typeStr = "int";
    } else if (v instanceof Long) {
        typeStr = "long";
    } else if (v instanceof Float) {
        typeStr = "float";
    } else if (v instanceof Double) {
        typeStr = "double";
    } else if (v instanceof Boolean) {
        typeStr = "boolean";
    } else if (v instanceof byte[]) {
        writeByteArrayXml((byte[]) v, name, out);
        return;
    } else if (v instanceof int[]) {
        writeIntArrayXml((int[]) v, name, out);
        return;
    } else if (v instanceof long[]) {
        writeLongArrayXml((long[]) v, name, out);
        return;
    } else if (v instanceof double[]) {
        writeDoubleArrayXml((double[]) v, name, out);
        return;
    } else if (v instanceof String[]) {
        writeStringArrayXml((String[]) v, name, out);
        return;
    } else if (v instanceof boolean[]) {
        writeBooleanArrayXml((boolean[]) v, name, out);
        return;
    } else if (v instanceof Map) {
        writeMapXml((Map) v, name, out);
        return;
    } else if (v instanceof List) {
        writeListXml((List) v, name, out);
        return;
    } else if (v instanceof Set) {
        writeSetXml((Set) v, name, out);
        return;
    } else if (v instanceof CharSequence) {
        // XXX This is to allow us to at least write something if
        // we encounter styled text...  but it means we will drop all
        // of the styling information. :(
        out.startTag(null, "string");
        if (name != null) {
            out.attribute(null, "name", name);
        }
        out.text(v.toString());
        out.endTag(null, "string");
        return;
    } else if (callback != null) {
        callback.writeUnknownObject(v, name, out);
        return;
    } else {
        throw new RuntimeException("writeValueXml: unable to write value " + v);
    }
    out.startTag(null, typeStr);
    if (name != null) {
        out.attribute(null, "name", name);
    }
    out.attribute(null, "value", v.toString());
    out.endTag(null, typeStr);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Ripple.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draws the ripple centered at (0,0) using the specified paint.
 */

Body of Frist Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && mHardwareAnimating) {
        hasContent = drawHardware((HardwareCanvas) c);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
Body of Second Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && (mHardwareAnimating || mHasPendingHardwareExit)) {
        hasContent = drawHardware((HardwareCanvas) c, p);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setGeolocationEnabled:COMMENT
<android.webkit.WebSettings: void setGeolocationEnabled(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether Geolocation is enabled. The default is true.
 * <p>
 * Please note that in order for the Geolocation API to be usable
 * by a page in the WebView, the following requirements must be met:
 * <ul>
 * <li>an application must have permission to access the device location,
 * see {@link android.Manifest.permission#ACCESS_COARSE_LOCATION},
 * {@link android.Manifest.permission#ACCESS_FINE_LOCATION};
 * <li>an application must provide an implementation of the
 * {@link WebChromeClient#onGeolocationPermissionsShowPrompt} callback
 * to receive notifications that a page is requesting access to location
 * via the JavaScript Geolocation API.
 * </ul>
 * <p>
 * As an option, it is possible to store previous locations and web origin
 * permissions in a database. See {@link #setGeolocationDatabasePath}.
 *
 * @param flag whether Geolocation should be enabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewHeader.rebindToTask:COMMENT
Method Modifier: public      
Comment:/**
 * Binds the bar view to the task
 */

Body of Frist Method:
{
    // otherwise, we fall back to the application icon
    if (t.activityIcon != null) {
        mApplicationIcon.setImageDrawable(t.activityIcon);
    } else if (t.applicationIcon != null) {
        mApplicationIcon.setImageDrawable(t.applicationIcon);
    }
    mApplicationIcon.setContentDescription(t.activityLabel);
    if (!mActivityDescription.getText().toString().equals(t.activityLabel)) {
        mActivityDescription.setText(t.activityLabel);
    }
    // Try and apply the system ui tint
    int existingBgColor = (getBackground() instanceof ColorDrawable) ? ((ColorDrawable) getBackground()).getColor() : 0;
    if (existingBgColor != t.colorPrimary) {
        mBackgroundColorDrawable.setColor(t.colorPrimary);
        mBackgroundColor = t.colorPrimary;
    }
    mCurrentPrimaryColor = t.colorPrimary;
    mCurrentPrimaryColorIsDark = t.useLightOnPrimaryColor;
    mActivityDescription.setTextColor(t.useLightOnPrimaryColor ? mConfig.taskBarViewLightTextColor : mConfig.taskBarViewDarkTextColor);
    mDismissButton.setImageDrawable(t.useLightOnPrimaryColor ? mLightDismissDrawable : mDarkDismissDrawable);
    mDismissButton.setContentDescription(getContext().getString(R.string.accessibility_recents_item_will_be_dismissed, t.activityLabel));
}
Body of Second Method:
{
    // otherwise, we fall back to the application icon
    if (t.activityIcon != null) {
        mApplicationIcon.setImageDrawable(t.activityIcon);
    } else if (t.applicationIcon != null) {
        mApplicationIcon.setImageDrawable(t.applicationIcon);
    }
    mApplicationIcon.setContentDescription(t.activityLabel);
    if (!mActivityDescription.getText().toString().equals(t.activityLabel)) {
        mActivityDescription.setText(t.activityLabel);
    }
    // Try and apply the system ui tint
    int existingBgColor = (getBackground() instanceof ColorDrawable) ? ((ColorDrawable) getBackground()).getColor() : 0;
    if (existingBgColor != t.colorPrimary) {
        mBackgroundColorDrawable.setColor(t.colorPrimary);
        mBackgroundColor = t.colorPrimary;
    }
    mCurrentPrimaryColor = t.colorPrimary;
    mCurrentPrimaryColorIsDark = t.useLightOnPrimaryColor;
    mActivityDescription.setTextColor(t.useLightOnPrimaryColor ? mConfig.taskBarViewLightTextColor : mConfig.taskBarViewDarkTextColor);
    mDismissButton.setImageDrawable(t.useLightOnPrimaryColor ? mLightDismissDrawable : mDarkDismissDrawable);
    mDismissButton.setContentDescription(String.format(mDismissContentDescription, t.activityLabel));
}
------------------------
Find a functionally equivalent code:android.media.AudioService.registerAudioPolicy:COMMENT
Method Modifier: public      
Comment:// ==========================================================================================

Body of Frist Method:
{
    // Log.v(TAG, "registerAudioPolicy for " + cb + " got policy:" + policyConfig);
    boolean hasPermissionForPolicy = (PackageManager.PERMISSION_GRANTED == mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING));
    if (!hasPermissionForPolicy) {
        Slog.w(TAG, "Can't register audio policy for pid " + Binder.getCallingPid() + " / uid " + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
        return false;
    }
    synchronized (mAudioPolicies) {
        AudioPolicyProxy app = new AudioPolicyProxy(policyConfig, cb);
        try {
            cb.linkToDeath(app, 0);
            mAudioPolicies.put(cb, app);
        } catch (RemoteException e) {
            // audio policy owner has already died!
            Slog.w(TAG, "Audio policy registration failed, could not link to " + cb + " binder death", e);
            return false;
        }
    }
    // TODO implement registration with native audio policy (including permission check)
    return true;
}
Body of Second Method:
{
    if (DEBUG_AP)
        Log.d(TAG, "registerAudioPolicy for " + pcb.asBinder() + " with config:" + policyConfig);
    String regId = null;
    // error handling
    boolean hasPermissionForPolicy = (PackageManager.PERMISSION_GRANTED == mContext.checkCallingPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING));
    if (!hasPermissionForPolicy) {
        Slog.w(TAG, "Can't register audio policy for pid " + Binder.getCallingPid() + " / uid " + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
        return null;
    }
    synchronized (mAudioPolicies) {
        try {
            if (mAudioPolicies.containsKey(pcb.asBinder())) {
                Slog.e(TAG, "Cannot re-register policy");
                return null;
            }
            AudioPolicyProxy app = new AudioPolicyProxy(policyConfig, pcb, hasFocusListener);
            pcb.asBinder().linkToDeath(app, 0);
            regId = app.getRegistrationId();
            mAudioPolicies.put(pcb.asBinder(), app);
        } catch (RemoteException e) {
            // audio policy owner has already died!
            Slog.w(TAG, "Audio policy registration failed, could not link to " + pcb + " binder death", e);
            return null;
        }
    }
    return regId;
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.setProcessDefaultNetwork:COMMENT
Method Modifier: public      static      
Comment:/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */

Body of Frist Method:
{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Set HTTP proxy system properties to match network.
        // TODO: Deprecate this static method and replace it with a non-static version.
        Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.view.Window.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flags of the window, as per the
 * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
 * flags.
 *
 * <p>Note that some flags must be set before the window decoration is
 * created (by the first call to
 * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
 * {@link #getDecorView()}:
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
 * will be set for you based on the {@link android.R.attr#windowIsFloating}
 * attribute.
 *
 * @param flags The new window flags (see WindowManager.LayoutParams).
 * @param mask Which of the window flag bits to modify.
 * @see #addFlags
 * @see #clearFlags
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a functionally equivalent code:android.media.session.MediaSession.setPlaybackToRemote:COMMENT
Method Modifier: public      
Comment:/**
 * Configure this session to use remote volume handling. This must be called
 * to receive volume button events, otherwise the system will adjust the
 * appropriate stream volume for this session. If
 * {@link #setPlaybackToLocal} was previously called the system will stop
 * handling volume changes for this session and pass them to the volume
 * provider instead.
 *
 * @param volumeProvider The provider that will handle volume changes. May
 * not be null.
 */

Body of Frist Method:
{
    if (volumeProvider == null) {
        throw new IllegalArgumentException("volumeProvider may not be null!");
    }
    mVolumeProvider = volumeProvider;
    volumeProvider.setCallback(new VolumeProvider.Callback() {

        @Override
        public void onVolumeChanged(VolumeProvider volumeProvider) {
            notifyRemoteVolumeChanged(volumeProvider);
        }
    });
    try {
        mBinder.setPlaybackToRemote(volumeProvider.getVolumeControl(), volumeProvider.getMaxVolume());
        mBinder.setCurrentVolume(volumeProvider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Failure in setPlaybackToRemote.", e);
    }
}
Body of Second Method:
{
    if (volumeProvider == null) {
        throw new IllegalArgumentException("volumeProvider may not be null!");
    }
    synchronized (mLock) {
        mVolumeProvider = volumeProvider;
    }
    volumeProvider.setCallback(new VolumeProvider.Callback() {

        @Override
        public void onVolumeChanged(VolumeProvider volumeProvider) {
            notifyRemoteVolumeChanged(volumeProvider);
        }
    });
    try {
        mBinder.setPlaybackToRemote(volumeProvider.getVolumeControl(), volumeProvider.getMaxVolume());
        mBinder.setCurrentVolume(volumeProvider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Failure in setPlaybackToRemote.", e);
    }
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.removeFocusStackEntry:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove a focus listener from the focus stack.
 * @param clientToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
 * focus, notify the next item in the stack it gained focus.
 */

Body of Frist Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
Body of Second Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (notifyFocusFollowers) {
            final AudioFocusInfo afi = fr.toAudioFocusInfo();
            afi.clearLossReceived();
            notifyExtPolicyFocusLoss_syncAf(afi, false);
        }
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.pm.UserManagerService.initDefaultGuestRestrictions:COMMENT
Method Modifier: private     
Comment:/**
 * If default guest restrictions haven't been initialized yet, add the basic
 * restrictions.
 */

Body of Frist Method:
{
    if (mGuestRestrictions.isEmpty()) {
        mGuestRestrictions.putBoolean(UserManager.DISALLOW_OUTGOING_CALLS, true);
        writeUserListLocked();
    }
}
Body of Second Method:
{
    if (mGuestRestrictions.isEmpty()) {
        mGuestRestrictions.putBoolean(UserManager.DISALLOW_OUTGOING_CALLS, true);
        mGuestRestrictions.putBoolean(UserManager.DISALLOW_SMS, true);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.saveLockPassword:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Save a lock password.  Does not ensure that the password is as good
 * as the requested mode, but will adjust the mode to be as good as the
 * pattern.
 * @param password The password to save
 * @param quality {@see DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}
 * @param isFallback Specifies if this is a fallback to biometric weak
 */

Body of Frist Method:
{
    saveLockPassword(password, quality, isFallback, getCurrentOrCallingUserId());
}
Body of Second Method:
{
    saveLockPassword(password, quality, isFallback, getCurrentOrCallingUserId());
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.SystemBarScrimViews.startExitRecentsAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Starts animating the scrim views when leaving Recents (either via launching a task, or
 * going home).
 */

Body of Frist Method:
{
    if (mHasStatusBarScrim && mShouldAnimateStatusBarScrim) {
        mStatusBarScrimView.animate().translationY(-mStatusBarScrimView.getMeasuredHeight()).setStartDelay(0).setDuration(mConfig.taskBarExitAnimDuration).setInterpolator(mConfig.fastOutSlowInInterpolator).start();
    }
    if (mHasNavBarScrim && mShouldAnimateNavBarScrim) {
        mNavBarScrimView.animate().translationY(mNavBarScrimView.getMeasuredHeight()).setStartDelay(0).setDuration(mConfig.taskBarExitAnimDuration).setInterpolator(mConfig.fastOutSlowInInterpolator).start();
    }
}
Body of Second Method:
{
    if (mHasStatusBarScrim && mShouldAnimateStatusBarScrim) {
        mStatusBarScrimView.animate().translationY(-mStatusBarScrimView.getMeasuredHeight()).setStartDelay(0).setDuration(mConfig.taskViewExitToAppDuration).setInterpolator(mConfig.fastOutSlowInInterpolator).start();
    }
    if (mHasNavBarScrim && mShouldAnimateNavBarScrim) {
        mNavBarScrimView.animate().translationY(mNavBarScrimView.getMeasuredHeight()).setStartDelay(0).setDuration(mConfig.taskViewExitToAppDuration).setInterpolator(mConfig.fastOutSlowInInterpolator).start();
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.closeOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Progammatically closes the options menu. If the options menu is already
 * closed, this method does nothing.
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.acceptCookie:COMMENT
<android.webkit.CookieManager: boolean acceptCookie()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the application's {@link WebView} instances send and accept
 * cookies.
 *
 * @return true if {@link WebView} instances send and accept cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.initFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityNodeInfo}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mTraversalBefore = parcel.readLong();
    mTraversalAfter = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeQueueing:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? mKeyguardDelegate.isShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            mPowerManager.wakeUp(event.getEventTime());
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeDownKeyTriggered = true;
                            mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                    if ((result & ACTION_PASS_TO_USER) == 0) {
                        // If we aren't passing to the user and no one else
                        // handled it send it to the session manager to figure
                        // out.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    interceptPowerKeyDown(!interactive || hungUp);
                } else {
                    if (interceptPowerKeyUp(canceled)) {
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                            if (goHome()) {
                                break;
                            }
                        }
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                            mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                            isWakeKey = false;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
                    if (panic) {
                        mHandler.post(mRequestTransientNav);
                    }
                    if (interactive && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mPowerKeyTriggered = true;
                        mPowerKeyTime = event.getDownTime();
                        interceptScreenshotChord();
                    }
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // Pressing Power while there's a ringing incoming
                            // call should silence the ringer.
                            telecomManager.silenceRinger();
                        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
                            // Otherwise, if "Power button ends call" is enabled,
                            // the Power button will hang up any current active call.
                            hungUp = telecomManager.endCall();
                        }
                    }
                    interceptPowerKeyDown(!interactive || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                } else {
                    mPowerKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
                        if (mScreenOnEarly && !mScreenOnFully) {
                            Slog.i(TAG, "Suppressed redundant power key press while " + "already in the process of turning the screen on.");
                        } else {
                            powerShortPress(event.getEventTime());
                        }
                        isWakeKey = false;
                    }
                    mPendingPowerKeyUpCanceled = false;
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                isWakeKey = false;
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        mPowerManager.wakeUp(event.getEventTime());
    }
    return result;
}
Body of Second Method:
{
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                    if ((result & ACTION_PASS_TO_USER) == 0) {
                        // If we aren't passing to the user and no one else
                        // handled it send it to the session manager to figure
                        // out.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                isWakeKey = false;
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey);
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.fillActiveViews:COMMENT
Method Modifier: 
Comment:/**
 * Fill ActiveViews with all of the children of the AbsListView.
 *
 * @param childCount The minimum number of views mActiveViews should hold
 * @param firstActivePosition The position of the first view that will be stored in
 * mActiveViews
 */

Body of Frist Method:
{
    if (mActiveViews.length < childCount) {
        mActiveViews = new View[childCount];
    }
    mFirstActivePosition = firstActivePosition;
    // noinspection MismatchedReadAndWriteOfArray
    final View[] activeViews = mActiveViews;
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
        // Don't put header or footer views into the scrap heap
        if (lp != null && lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.
            // However, we will NOT place them into scrap views.
            activeViews[i] = child;
        }
    }
}
Body of Second Method:
{
    if (mActiveViews.length < childCount) {
        mActiveViews = new View[childCount];
    }
    mFirstActivePosition = firstActivePosition;
    // noinspection MismatchedReadAndWriteOfArray
    final View[] activeViews = mActiveViews;
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
        // Don't put header or footer views into the scrap heap
        if (lp != null && lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.
            // However, we will NOT place them into scrap views.
            activeViews[i] = child;
            // Remember the position so that setupChild() doesn't reset state.
            lp.scrappedFromPosition = firstActivePosition + i;
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.setInputType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the input type on the query text field.
 *
 * @see TextView#setInputType(int)
 * @param inputType the input type to set on the query text field
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */

Body of Frist Method:
{
    mQueryTextView.setInputType(inputType);
}
Body of Second Method:
{
    mSearchSrcTextView.setInputType(inputType);
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.positionSelectorLikeTouch:COMMENT
Method Modifier: 
Comment:/**
 * Positions the selector in a way that mimics touch.
 */

Body of Frist Method:
{
    positionSelectorLikeFocus(position, sel);
    if (mSelector != null && position != INVALID_POSITION) {
        mSelector.setHotspot(x, y);
    }
}
Body of Second Method:
{
    positionSelector(position, sel, true, x, y);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setBlockNetworkLoads:COMMENT
<android.webkit.WebSettings: void setBlockNetworkLoads(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should not load resources from the network.
 * Use {@link #setBlockNetworkImage} to only avoid loading
 * image resources. Note that if the value of this setting is
 * changed from true to false, network resources referenced by content
 * currently displayed by the WebView are not fetched until
 * {@link android.webkit.WebView#reload} is called.
 * If the application does not have the
 * {@link android.Manifest.permission#INTERNET} permission, attempts to set
 * a value of false will cause a {@link java.lang.SecurityException}
 * to be thrown. The default value is false if the application has the
 * {@link android.Manifest.permission#INTERNET} permission, otherwise it is
 * true.
 *
 * @param flag whether the WebView should not load any resources from the
 * network
 * @see android.webkit.WebView#reload
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mLabeledById);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDefaultTextEncodingName:COMMENT
<android.webkit.WebSettings: String getDefaultTextEncodingName()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default text encoding name.
 *
 * @return the default text encoding name as a string
 * @see #setDefaultTextEncodingName
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.clone:COMMENT
<android.webkit.WebHistoryItem: WebHistoryItem clone()>
Method Modifier: protected   abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clone the history item for use by clients of WebView.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.BaseBundle.putBoolean:COMMENT
<android.os.BaseBundle: void putBoolean(String,boolean)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Inserts a Boolean value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Boolean, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
}
------------------------
Find a functionally equivalent code:android.content.ContentProvider.enforceReadPermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return;
    }
    // last chance, check against any uri grants
    final int callingUserId = UserHandle.getUserId(uid);
    final Uri userUri = (mSingleUser && !UserHandle.isSameUser(mMyUid, uid)) ? maybeAddUserId(uri, callingUserId) : uri;
    if (context.checkUriPermission(userUri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.updateRecentsTasks:COMMENT
Method Modifier: 
Comment:/**
 * Updates the set of recent tasks
 */

Body of Frist Method:
{
    // Update the configuration based on the launch intent
    boolean fromSearchHome = launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_SEARCH_HOME, false);
    mConfig.launchedFromHome = fromSearchHome || launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_HOME, false);
    mConfig.launchedFromAppWithThumbnail = launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_THUMBNAIL, false);
    mConfig.launchedFromAppWithScreenshot = launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_FULL_SCREENSHOT, false);
    mConfig.launchedToTaskId = launchIntent.getIntExtra(AlternateRecentsComponent.EXTRA_FROM_TASK_ID, -1);
    mConfig.launchedWithAltTab = launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_TRIGGERED_FROM_ALT_TAB, false);
    // Load all the tasks
    RecentsTaskLoader loader = RecentsTaskLoader.getInstance();
    SpaceNode root = loader.reload(this, Constants.Values.RecentsTaskLoader.PreloadFirstTasksCount, mConfig.launchedFromHome);
    ArrayList<TaskStack> stacks = root.getStacks();
    if (!stacks.isEmpty()) {
        mRecentsView.setTaskStacks(root.getStacks());
    }
    mConfig.launchedWithNoRecentTasks = !root.hasTasks();
    // Create the home intent runnable
    Intent homeIntent = new Intent(Intent.ACTION_MAIN, null);
    homeIntent.addCategory(Intent.CATEGORY_HOME);
    homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mFinishLaunchHomeRunnable = new FinishRecentsRunnable(homeIntent, ActivityOptions.makeCustomAnimation(this, fromSearchHome ? R.anim.recents_to_search_launcher_enter : R.anim.recents_to_launcher_enter, fromSearchHome ? R.anim.recents_to_search_launcher_exit : R.anim.recents_to_launcher_exit));
    // Mark the task that is the launch target
    int taskStackCount = stacks.size();
    if (mConfig.launchedToTaskId != -1) {
        for (int i = 0; i < taskStackCount; i++) {
            TaskStack stack = stacks.get(i);
            ArrayList<Task> tasks = stack.getTasks();
            int taskCount = tasks.size();
            for (int j = 0; j < taskCount; j++) {
                Task t = tasks.get(j);
                if (t.key.id == mConfig.launchedToTaskId) {
                    t.isLaunchTarget = true;
                    break;
                }
            }
        }
    }
    // Update the top level view's visibilities
    if (mConfig.launchedWithNoRecentTasks) {
        if (mEmptyView == null) {
            mEmptyView = mEmptyViewStub.inflate();
        }
        mEmptyView.setVisibility(View.VISIBLE);
        mRecentsView.setSearchBarVisibility(View.GONE);
    } else {
        if (mEmptyView != null) {
            mEmptyView.setVisibility(View.GONE);
        }
        if (mRecentsView.hasSearchBar()) {
            mRecentsView.setSearchBarVisibility(View.VISIBLE);
        } else {
            addSearchBarAppWidgetView();
        }
    }
    // Animate the SystemUI scrims into view
    mScrimViews.prepareEnterRecentsAnimation();
}
Body of Second Method:
{
    // If AlternateRecentsComponent has preloaded a load plan, then use that to prevent
    // reconstructing the task stack
    RecentsTaskLoader loader = RecentsTaskLoader.getInstance();
    RecentsTaskLoadPlan plan = AlternateRecentsComponent.consumeInstanceLoadPlan();
    if (plan == null) {
        plan = loader.createLoadPlan(this);
    }
    // Start loading tasks according to the load plan
    if (plan.getTaskStack() == null) {
        loader.preloadTasks(plan, mConfig.launchedFromHome);
    }
    RecentsTaskLoadPlan.Options loadOpts = new RecentsTaskLoadPlan.Options();
    loadOpts.runningTaskId = mConfig.launchedToTaskId;
    loadOpts.numVisibleTasks = mConfig.launchedNumVisibleTasks;
    loadOpts.numVisibleTaskThumbnails = mConfig.launchedNumVisibleThumbnails;
    loader.loadTasks(this, plan, loadOpts);
    SpaceNode root = plan.getSpaceNode();
    ArrayList<TaskStack> stacks = root.getStacks();
    boolean hasTasks = root.hasTasks();
    if (hasTasks) {
        mRecentsView.setTaskStacks(stacks);
    }
    mConfig.launchedWithNoRecentTasks = !hasTasks;
    // Create the home intent runnable
    Intent homeIntent = new Intent(Intent.ACTION_MAIN, null);
    homeIntent.addCategory(Intent.CATEGORY_HOME);
    homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mFinishLaunchHomeRunnable = new FinishRecentsRunnable(homeIntent, ActivityOptions.makeCustomAnimation(this, mConfig.launchedFromSearchHome ? R.anim.recents_to_search_launcher_enter : R.anim.recents_to_launcher_enter, mConfig.launchedFromSearchHome ? R.anim.recents_to_search_launcher_exit : R.anim.recents_to_launcher_exit));
    // Mark the task that is the launch target
    int taskStackCount = stacks.size();
    if (mConfig.launchedToTaskId != -1) {
        for (int i = 0; i < taskStackCount; i++) {
            TaskStack stack = stacks.get(i);
            ArrayList<Task> tasks = stack.getTasks();
            int taskCount = tasks.size();
            for (int j = 0; j < taskCount; j++) {
                Task t = tasks.get(j);
                if (t.key.id == mConfig.launchedToTaskId) {
                    t.isLaunchTarget = true;
                    break;
                }
            }
        }
    }
    // Update the top level view's visibilities
    if (mConfig.launchedWithNoRecentTasks) {
        if (mEmptyView == null) {
            mEmptyView = mEmptyViewStub.inflate();
        }
        mEmptyView.setVisibility(View.VISIBLE);
        mRecentsView.setSearchBarVisibility(View.GONE);
    } else {
        if (mEmptyView != null) {
            mEmptyView.setVisibility(View.GONE);
        }
        if (mRecentsView.hasSearchBar()) {
            mRecentsView.setSearchBarVisibility(View.VISIBLE);
        } else {
            addSearchBarAppWidgetView();
        }
    }
    // Animate the SystemUI scrims into view
    mScrimViews.prepareEnterRecentsAnimation();
}
------------------------
Find a functionally equivalent code:com.android.server.am.ActivityStack.finishActivityLocked:COMMENT
Method Modifier: default     final       
Comment:/**
 * @return Returns true if this activity has been removed from the history
 * list, or false if it is still in the list and will be removed later.
 */

Body of Frist Method:
{
    if (r.finishing) {
        Slog.w(TAG, "Duplicate finish request for " + r);
        return false;
    }
    r.makeFinishing();
    final TaskRecord task = r.task;
    EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY, r.userId, System.identityHashCode(r), task.taskId, r.shortComponentName, reason);
    final ArrayList<ActivityRecord> activities = task.mActivities;
    final int index = activities.indexOf(r);
    if (index < (activities.size() - 1)) {
        task.setFrontOfTask();
        if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
            // If the caller asked that this activity (and all above it)
            // be cleared when the task is reset, don't lose that information,
            // but propagate it up to the next activity.
            ActivityRecord next = activities.get(index + 1);
            next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        }
    }
    r.pauseKeyDispatchingLocked();
    adjustFocusedActivityLocked(r);
    finishActivityResultsLocked(r, resultCode, resultData);
    if (mResumedActivity == r) {
        boolean endTask = index <= 0;
        if (DEBUG_VISBILITY || DEBUG_TRANSITION)
            Slog.v(TAG, "Prepare close transition: finishing " + r);
        mWindowManager.prepareAppTransition(endTask ? AppTransition.TRANSIT_TASK_CLOSE : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);
        // Tell window manager to prepare for this one to be removed.
        mWindowManager.setAppVisibility(r.appToken, false);
        if (mPausingActivity == null) {
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Finish needs to pause: " + r);
            if (DEBUG_USER_LEAVING)
                Slog.v(TAG, "finish() => pause with userLeaving=false");
            startPausingLocked(false, false, false, false);
        }
        if (endTask) {
            mStackSupervisor.endLockTaskModeIfTaskEnding(task);
        }
    } else if (r.state != ActivityState.PAUSING) {
        // it is done pausing; else we can just directly finish it here.
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Finish not pausing: " + r);
        return finishCurrentActivityLocked(r, FINISH_AFTER_PAUSE, oomAdj) == null;
    } else {
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Finish waiting for pause of: " + r);
    }
    return false;
}
Body of Second Method:
{
    if (r.finishing) {
        Slog.w(TAG, "Duplicate finish request for " + r);
        return false;
    }
    r.makeFinishing();
    final TaskRecord task = r.task;
    EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY, r.userId, System.identityHashCode(r), task.taskId, r.shortComponentName, reason);
    final ArrayList<ActivityRecord> activities = task.mActivities;
    final int index = activities.indexOf(r);
    if (index < (activities.size() - 1)) {
        task.setFrontOfTask();
        if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) {
            // If the caller asked that this activity (and all above it)
            // be cleared when the task is reset, don't lose that information,
            // but propagate it up to the next activity.
            ActivityRecord next = activities.get(index + 1);
            next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        }
    }
    r.pauseKeyDispatchingLocked();
    adjustFocusedActivityLocked(r, "finishActivity");
    finishActivityResultsLocked(r, resultCode, resultData);
    if (mResumedActivity == r) {
        boolean endTask = index <= 0;
        if (DEBUG_VISBILITY || DEBUG_TRANSITION)
            Slog.v(TAG, "Prepare close transition: finishing " + r);
        mWindowManager.prepareAppTransition(endTask ? AppTransition.TRANSIT_TASK_CLOSE : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);
        // Tell window manager to prepare for this one to be removed.
        mWindowManager.setAppVisibility(r.appToken, false);
        if (mPausingActivity == null) {
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Finish needs to pause: " + r);
            if (DEBUG_USER_LEAVING)
                Slog.v(TAG, "finish() => pause with userLeaving=false");
            startPausingLocked(false, false, false, false);
        }
        if (endTask) {
            mStackSupervisor.endLockTaskModeIfTaskEnding(task);
        }
    } else if (r.state != ActivityState.PAUSING) {
        // it is done pausing; else we can just directly finish it here.
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Finish not pausing: " + r);
        return finishCurrentActivityLocked(r, FINISH_AFTER_PAUSE, oomAdj) == null;
    } else {
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Finish waiting for pause of: " + r);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.shouldVibrate:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#shouldVibrate(int)
 */

Body of Frist Method:
{
    if (!mHasVibrator)
        return false;
    switch(getVibrateSetting(vibrateType)) {
        case AudioManager.VIBRATE_SETTING_ON:
            return getRingerMode() != AudioManager.RINGER_MODE_SILENT;
        case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
            return getRingerMode() == AudioManager.RINGER_MODE_VIBRATE;
        case AudioManager.VIBRATE_SETTING_OFF:
            // return false, even for incoming calls
            return false;
        default:
            return false;
    }
}
Body of Second Method:
{
    if (!mHasVibrator)
        return false;
    switch(getVibrateSetting(vibrateType)) {
        case AudioManager.VIBRATE_SETTING_ON:
            return getRingerModeExternal() != AudioManager.RINGER_MODE_SILENT;
        case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
            return getRingerModeExternal() == AudioManager.RINGER_MODE_VIBRATE;
        case AudioManager.VIBRATE_SETTING_OFF:
            // return false, even for incoming calls
            return false;
        default:
            return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.RecentsView.startEnterRecentsAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Requests all task stacks to start their enter-recents animation
 */

Body of Frist Method:
{
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.startEnterRecentsAnimation(ctx);
        }
    }
}
Body of Second Method:
{
    // We have to increment/decrement the post animation trigger in case there are no children
    // to ensure that it runs
    ctx.postAnimationTrigger.increment();
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.startEnterRecentsAnimation(ctx);
        }
    }
    ctx.postAnimationTrigger.decrement();
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Stop listening to changes for this AppWidget.
 */

Body of Frist Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContextOpPackageName, appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
------------------------
Find a functionally equivalent code:android.provider.MediaStore.InternalThumbnails.getThumbnail:COMMENT
Method Modifier: default     static      
Comment:/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */

Body of Frist Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
Body of Second Method:
{
    Bitmap bitmap = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (c != null)
                c.close();
            c = cr.query(uri, PROJECTION, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return null;
            }
            String filePath = c.getString(1);
            if (filePath != null) {
                if (isVideo) {
                    bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
                } else {
                    bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
                }
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
------------------------
Find a functionally equivalent code:com.android.server.display.DisplayDevice.dumpLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Dumps the local state of the display device.
 * Does not need to dump the display device info because that is already dumped elsewhere.
 */

Body of Frist Method:
{
    pw.println("mAdapter=" + mDisplayAdapter.getName());
    pw.println("mDisplayToken=" + mDisplayToken);
    pw.println("mCurrentLayerStack=" + mCurrentLayerStack);
    pw.println("mCurrentOrientation=" + mCurrentOrientation);
    pw.println("mCurrentLayerStackRect=" + mCurrentLayerStackRect);
    pw.println("mCurrentDisplayRect=" + mCurrentDisplayRect);
    pw.println("mCurrentSurface=" + mCurrentSurface);
}
Body of Second Method:
{
    pw.println("mAdapter=" + mDisplayAdapter.getName());
    pw.println("mUniqueId=" + mUniqueId);
    pw.println("mDisplayToken=" + mDisplayToken);
    pw.println("mCurrentLayerStack=" + mCurrentLayerStack);
    pw.println("mCurrentOrientation=" + mCurrentOrientation);
    pw.println("mCurrentLayerStackRect=" + mCurrentLayerStackRect);
    pw.println("mCurrentDisplayRect=" + mCurrentDisplayRect);
    pw.println("mCurrentSurface=" + mCurrentSurface);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDefaultFixedFontSize:COMMENT
<android.webkit.WebSettings: int getDefaultFixedFontSize()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default fixed font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFixedFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyUpPanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Called when the panel key is released.
 * @param featureId The feature ID of the relevant panel (defaults to FEATURE_OPTIONS_PANEL}.
 * @param event The key event.
 */

Body of Frist Method:
{
    // The panel key was released, so clear the chording key
    if (mPanelChordingKey != 0) {
        mPanelChordingKey = 0;
        if (event.isCanceled() || (mDecor != null && mDecor.mActionMode != null)) {
            return;
        }
        boolean playSoundEffect = false;
        final PanelFeatureState st = getPanelState(featureId, true);
        if (featureId == FEATURE_OPTIONS_PANEL && mDecorContentParent != null && mDecorContentParent.canShowOverflowMenu() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
            if (!mDecorContentParent.isOverflowMenuShowing()) {
                if (!isDestroyed() && preparePanel(st, event)) {
                    playSoundEffect = mDecorContentParent.showOverflowMenu();
                }
            } else {
                playSoundEffect = mDecorContentParent.hideOverflowMenu();
            }
        } else {
            if (st.isOpen || st.isHandled) {
                // Play the sound effect if the user closed an open menu (and not if
                // they just released a menu shortcut)
                playSoundEffect = st.isOpen;
                // Close menu
                closePanel(st, true);
            } else if (st.isPrepared) {
                boolean show = true;
                if (st.refreshMenuContent) {
                    // Something may have invalidated the menu since we prepared it.
                    // Re-prepare it to refresh.
                    st.isPrepared = false;
                    show = preparePanel(st, event);
                }
                if (show) {
                    // Write 'menu opened' to event log
                    EventLog.writeEvent(50001, 0);
                    // Show menu
                    openPanel(st, event);
                    playSoundEffect = true;
                }
            }
        }
        if (playSoundEffect) {
            AudioManager audioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
            if (audioManager != null) {
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
            } else {
                Log.w(TAG, "Couldn't get audio manager");
            }
        }
    }
}
Body of Second Method:
{
    // The panel key was released, so clear the chording key
    if (mPanelChordingKey != 0) {
        mPanelChordingKey = 0;
        final PanelFeatureState st = getPanelState(featureId, false);
        if (event.isCanceled() || (mDecor != null && mDecor.mActionMode != null) || (st == null)) {
            return;
        }
        boolean playSoundEffect = false;
        if (featureId == FEATURE_OPTIONS_PANEL && mDecorContentParent != null && mDecorContentParent.canShowOverflowMenu() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
            if (!mDecorContentParent.isOverflowMenuShowing()) {
                if (!isDestroyed() && preparePanel(st, event)) {
                    playSoundEffect = mDecorContentParent.showOverflowMenu();
                }
            } else {
                playSoundEffect = mDecorContentParent.hideOverflowMenu();
            }
        } else {
            if (st.isOpen || st.isHandled) {
                // Play the sound effect if the user closed an open menu (and not if
                // they just released a menu shortcut)
                playSoundEffect = st.isOpen;
                // Close menu
                closePanel(st, true);
            } else if (st.isPrepared) {
                boolean show = true;
                if (st.refreshMenuContent) {
                    // Something may have invalidated the menu since we prepared it.
                    // Re-prepare it to refresh.
                    st.isPrepared = false;
                    show = preparePanel(st, event);
                }
                if (show) {
                    // Write 'menu opened' to event log
                    EventLog.writeEvent(50001, 0);
                    // Show menu
                    openPanel(st, event);
                    playSoundEffect = true;
                }
            }
        }
        if (playSoundEffect) {
            AudioManager audioManager = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);
            if (audioManager != null) {
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
            } else {
                Log.w(TAG, "Couldn't get audio manager");
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setLightTouchEnabled:COMMENT
<android.webkit.WebSettings: void setLightTouchEnabled(boolean)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Enables using light touches to make a selection and activate mouseovers.
 * @deprecated From {@link android.os.Build.VERSION_CODES#JELLY_BEAN} this
 * setting is obsolete and has no effect.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.AppOpsManager.resetAllModes:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.resetAllModes();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.resetAllModes(UserHandle.myUserId(), null);
    } catch (RemoteException e) {
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.checkSendBecomingNoisyIntent:COMMENT
Method Modifier: private     
Comment:// must be called before removing the device from mConnectedDevices

Body of Frist Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
Body of Second Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        synchronized (mLastDeviceConnectMsgTime) {
            long time = SystemClock.uptimeMillis();
            if (mLastDeviceConnectMsgTime > time) {
                delay = (int) (mLastDeviceConnectMsgTime - time) + 30;
            }
        }
    }
    return delay;
}
------------------------
Find a functionally equivalent code:com.android.server.connectivity.Vpn.addVpnUserLocked:COMMENT
Method Modifier: private     
Comment:// Note: This function adds to mVpnUsers but does not publish list to NetworkAgent.

Body of Frist Method:
{
    if (!isRunningLocked()) {
        throw new IllegalStateException("VPN is not active");
    }
    if (mConfig.allowedApplications != null) {
        // Add ranges covering all UIDs for allowedApplications.
        int start = -1, stop = -1;
        for (int uid : getAppsUids(mConfig.allowedApplications, userHandle)) {
            if (start == -1) {
                start = uid;
            } else if (uid != stop + 1) {
                mVpnUsers.add(new UidRange(start, stop));
                start = uid;
            }
            stop = uid;
        }
        if (start != -1)
            mVpnUsers.add(new UidRange(start, stop));
    } else if (mConfig.disallowedApplications != null) {
        // Add all ranges for user skipping UIDs for disallowedApplications.
        final UidRange userRange = UidRange.createForUser(userHandle);
        int start = userRange.start;
        for (int uid : getAppsUids(mConfig.disallowedApplications, userHandle)) {
            if (uid == start) {
                start++;
            } else {
                mVpnUsers.add(new UidRange(start, uid - 1));
                start = uid + 1;
            }
        }
        if (start <= userRange.stop)
            mVpnUsers.add(new UidRange(start, userRange.stop));
    } else {
        // Add all UIDs for the user.
        mVpnUsers.add(UidRange.createForUser(userHandle));
    }
    prepareStatusIntent();
}
Body of Second Method:
{
    if (mVpnUsers == null) {
        throw new IllegalStateException("VPN is not active");
    }
    if (mConfig.allowedApplications != null) {
        // Add ranges covering all UIDs for allowedApplications.
        int start = -1, stop = -1;
        for (int uid : getAppsUids(mConfig.allowedApplications, userHandle)) {
            if (start == -1) {
                start = uid;
            } else if (uid != stop + 1) {
                mVpnUsers.add(new UidRange(start, stop));
                start = uid;
            }
            stop = uid;
        }
        if (start != -1)
            mVpnUsers.add(new UidRange(start, stop));
    } else if (mConfig.disallowedApplications != null) {
        // Add all ranges for user skipping UIDs for disallowedApplications.
        final UidRange userRange = UidRange.createForUser(userHandle);
        int start = userRange.start;
        for (int uid : getAppsUids(mConfig.disallowedApplications, userHandle)) {
            if (uid == start) {
                start++;
            } else {
                mVpnUsers.add(new UidRange(start, uid - 1));
                start = uid + 1;
            }
        }
        if (start <= userRange.stop)
            mVpnUsers.add(new UidRange(start, userRange.stop));
    } else {
        // Add all UIDs for the user.
        mVpnUsers.add(UidRange.createForUser(userHandle));
    }
    prepareStatusIntent();
}
------------------------
Find a functionally equivalent code:android.net.VpnService.Builder.addRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Convenience method to add a network route to the VPN interface
 * using a numeric address string. See {@link InetAddress} for the
 * definitions of numeric address formats.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 * @see #addRoute(InetAddress, int)
 */

Body of Frist Method:
{
    return addRoute(InetAddress.parseNumericAddress(address), prefixLength);
}
Body of Second Method:
{
    return addRoute(InetAddress.parseNumericAddress(address), prefixLength);
}
------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.getOriginalUrl:COMMENT
<android.webkit.WebHistoryItem: String getOriginalUrl()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the original url of this history item. This was the requested
 * url, the final url may be different as there might have been
 * redirects while loading the site.
 * @return The original url of this history item.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.setFocusedTask:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the focused task explicitly. We need a separate flag because requestFocus() won't happen
 * if the view is not currently visible, or we are in touch state (where we still want to keep
 * track of focus).
 */

Body of Frist Method:
{
    mIsFocused = true;
    if (mFocusAnimationsEnabled) {
        // Focus the header bar
        mHeaderView.onTaskViewFocusChanged(true);
    }
    // Update the thumbnail alpha with the focus
    mThumbnailView.onFocusChanged(true);
    // Call the callback
    mCb.onTaskViewFocusChanged(this, true);
    // Workaround, we don't always want it focusable in touch mode, but we want the first task
    // to be focused after the enter-recents animation, which can be triggered from either touch
    // or keyboard
    setFocusableInTouchMode(true);
    requestFocus();
    setFocusableInTouchMode(false);
    invalidate();
}
Body of Second Method:
{
    mIsFocused = true;
    if (mFocusAnimationsEnabled) {
        // Focus the header bar
        mHeaderView.onTaskViewFocusChanged(true, animateFocusedState);
    }
    // Update the thumbnail alpha with the focus
    mThumbnailView.onFocusChanged(true);
    // Call the callback
    if (mCb != null) {
        mCb.onTaskViewFocusChanged(this, true);
    }
    // Workaround, we don't always want it focusable in touch mode, but we want the first task
    // to be focused after the enter-recents animation, which can be triggered from either touch
    // or keyboard
    setFocusableInTouchMode(true);
    requestFocus();
    setFocusableInTouchMode(false);
    invalidate();
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.getChildVisibleRect:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    int dx = child.mLeft - mScrollX;
    int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    if (rect.intersect(0, 0, mRight - mLeft, mBottom - mTop)) {
        if (mParent == null)
            return true;
        r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
        return mParent.getChildVisibleRect(this, r, offset);
    }
    return false;
}
Body of Second Method:
{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    final int dx = child.mLeft - mScrollX;
    final int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    boolean rectIsVisible = true;
    if (mParent == null || (mParent instanceof ViewGroup && ((ViewGroup) mParent).getClipChildren())) {
        // Clip to bounds.
        rectIsVisible = rect.intersect(0, 0, width, height);
    }
    if (rectIsVisible && (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        // Clip to padding.
        rectIsVisible = rect.intersect(mPaddingLeft, mPaddingTop, width - mPaddingRight, height - mPaddingBottom);
    }
    if (rectIsVisible && mClipBounds != null) {
        // Clip to clipBounds.
        rectIsVisible = rect.intersect(mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom);
    }
    r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
    if (rectIsVisible && mParent != null) {
        rectIsVisible = mParent.getChildVisibleRect(this, r, offset);
    }
    return rectIsVisible;
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.updateVoiceButton:COMMENT
Method Modifier: private     
Comment:/**
 * Update the visibility of the voice button.  There are actually two voice search modes,
 * either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the other
 * criteria apply to make the voice button visible.
 */

Body of Frist Method:
{
    int visibility = GONE;
    if (mVoiceButtonEnabled && !isIconified() && empty) {
        visibility = VISIBLE;
        mSubmitButton.setVisibility(GONE);
    }
    mVoiceButton.setVisibility(visibility);
}
Body of Second Method:
{
    int visibility = GONE;
    if (mVoiceButtonEnabled && !isIconified() && empty) {
        visibility = VISIBLE;
        mGoButton.setVisibility(GONE);
    }
    mVoiceButton.setVisibility(visibility);
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.getOperatorNumeric:COMMENT
Method Modifier: public      
Comment:/*
     * The country code can be decoded using
     * {@link com.android.internal.telephony.MccTable#countryCodeForMcc(int)}.
     */

Body of Frist Method:
{
    return mOperatorNumeric;
}
Body of Second Method:
{
    return mVoiceOperatorNumeric;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RotateDrawable.setPivotXRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the X pivot value represents a fraction of the drawable
 * width or an absolute value in pixels.
 *
 * @param relative True if the X pivot represents a fraction of the drawable
 * width, or false if it represents an absolute value in pixels
 *
 * @see #isPivotXRelative()
 */

Body of Frist Method:
{
    if (mState.mPivotXRel == relative) {
        mState.mPivotXRel = relative;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotXRel != relative) {
        mState.mPivotXRel = relative;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getPluginsPath:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Gets the directory that contains the plugin libraries. This method is
 * obsolete since each plugin is now loaded from its own package.
 *
 * @return an empty string
 * @deprecated This method is no longer used as plugins are loaded from
 * their own APK via the system's package manager.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
    // Unconditionally returns empty string, so no need for derived classes to override.
    return "";
}
Body of Second Method:
{
    // Unconditionally returns empty string, so no need for derived classes to override.
    return "";
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.requestAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to request audio focus. Will cause the focus request
 * to be associated with the "voice communication" identifier only used in AudioService
 * to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
 * the establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
 * media applications resume after a call
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(streamType, durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService due to " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.RecentsView.setTaskStacks:COMMENT
Method Modifier: public      
Comment:/**
 * Set/get the bsp root node
 */

Body of Frist Method:
{
    // Remove all TaskStackViews (but leave the search bar)
    int childCount = getChildCount();
    for (int i = childCount - 1; i >= 0; i--) {
        View v = getChildAt(i);
        if (v != mSearchBar) {
            removeViewAt(i);
        }
    }
    // Create and add all the stacks for this partition of space.
    mStacks = stacks;
    int numStacks = mStacks.size();
    for (int i = 0; i < numStacks; i++) {
        TaskStack stack = mStacks.get(i);
        TaskStackView stackView = new TaskStackView(getContext(), stack);
        stackView.setCallbacks(this);
        // Enable debug mode drawing
        if (mConfig.debugModeEnabled) {
            stackView.setDebugOverlay(mDebugOverlay);
        }
        addView(stackView);
    }
    // Reset the launched state
    mAlreadyLaunchingTask = false;
}
Body of Second Method:
{
    int numStacks = stacks.size();
    // Make a list of the stack view children only
    ArrayList<TaskStackView> stackViews = new ArrayList<TaskStackView>();
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            stackViews.add((TaskStackView) child);
        }
    }
    // Remove all/extra stack views
    // Keep no tasks if we are recreating the layout
    int numTaskStacksToKeep = 0;
    if (mConfig.launchedReuseTaskStackViews) {
        numTaskStacksToKeep = Math.min(childCount, numStacks);
    }
    for (int i = stackViews.size() - 1; i >= numTaskStacksToKeep; i--) {
        removeView(stackViews.get(i));
        stackViews.remove(i);
    }
    // Update the stack views that we are keeping
    for (int i = 0; i < numTaskStacksToKeep; i++) {
        TaskStackView tsv = stackViews.get(i);
        // If onRecentsHidden is not triggered, we need to the stack view again here
        tsv.reset();
        tsv.setStack(stacks.get(i));
    }
    // Add remaining/recreate stack views
    mStacks = stacks;
    for (int i = stackViews.size(); i < numStacks; i++) {
        TaskStack stack = stacks.get(i);
        TaskStackView stackView = new TaskStackView(getContext(), stack);
        stackView.setCallbacks(this);
        addView(stackView);
    }
    // Enable debug mode drawing on all the stacks if necessary
    if (mConfig.debugModeEnabled) {
        for (int i = childCount - 1; i >= 0; i--) {
            View v = getChildAt(i);
            if (v != mSearchBar) {
                TaskStackView stackView = (TaskStackView) v;
                stackView.setDebugOverlay(mDebugOverlay);
            }
        }
    }
    // Trigger a new layout
    requestLayout();
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.updateDisplayPowerStateLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the display power state asynchronously.
 * When the update is finished, mDisplayReady will be set to true.  The display
 * controller posts a message to tell us when the actual display power state
 * has been updated so we come back here to double-check and finish up.
 *
 * This function recalculates the display power state each time.
 *
 * @return True if the display became ready.
 */

Body of Frist Method:
{
    final boolean oldDisplayReady = mDisplayReady;
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS)) != 0) {
        mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked();
        int screenBrightness = mScreenBrightnessSettingDefault;
        float screenAutoBrightnessAdjustment = 0.0f;
        boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
        if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) {
            screenBrightness = mScreenBrightnessOverrideFromWindowManager;
            autoBrightness = false;
        } else if (isValidBrightness(mTemporaryScreenBrightnessSettingOverride)) {
            screenBrightness = mTemporaryScreenBrightnessSettingOverride;
        } else if (isValidBrightness(mScreenBrightnessSetting)) {
            screenBrightness = mScreenBrightnessSetting;
        }
        if (autoBrightness) {
            screenBrightness = mScreenBrightnessSettingDefault;
            if (isValidAutoBrightnessAdjustment(mTemporaryScreenAutoBrightnessAdjustmentSettingOverride)) {
                screenAutoBrightnessAdjustment = mTemporaryScreenAutoBrightnessAdjustmentSettingOverride;
            } else if (isValidAutoBrightnessAdjustment(mScreenAutoBrightnessAdjustmentSetting)) {
                screenAutoBrightnessAdjustment = mScreenAutoBrightnessAdjustmentSetting;
            }
        }
        screenBrightness = Math.max(Math.min(screenBrightness, mScreenBrightnessSettingMaximum), mScreenBrightnessSettingMinimum);
        screenAutoBrightnessAdjustment = Math.max(Math.min(screenAutoBrightnessAdjustment, 1.0f), -1.0f);
        mDisplayPowerRequest.screenBrightness = screenBrightness;
        mDisplayPowerRequest.screenAutoBrightnessAdjustment = screenAutoBrightnessAdjustment;
        mDisplayPowerRequest.useAutoBrightness = autoBrightness;
        mDisplayPowerRequest.useProximitySensor = shouldUseProximitySensorLocked();
        mDisplayPowerRequest.lowPowerMode = mLowPowerModeEnabled;
        if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) {
            mDisplayPowerRequest.dozeScreenState = mDozeScreenStateOverrideFromDreamManager;
            mDisplayPowerRequest.dozeScreenBrightness = mDozeScreenBrightnessOverrideFromDreamManager;
        } else {
            mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN;
            mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;
        }
        mDisplayReady = mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest, mRequestWaitForNegativeProximity);
        mRequestWaitForNegativeProximity = false;
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateScreenStateLocked: mDisplayReady=" + mDisplayReady + ", policy=" + mDisplayPowerRequest.policy + ", mWakefulness=" + mWakefulness + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", mBootCompleted=" + mBootCompleted);
        }
    }
    return mDisplayReady && !oldDisplayReady;
}
Body of Second Method:
{
    final boolean oldDisplayReady = mDisplayReady;
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_ACTUAL_DISPLAY_POWER_STATE_UPDATED | DIRTY_BOOT_COMPLETED | DIRTY_SETTINGS | DIRTY_SCREEN_BRIGHTNESS_BOOST)) != 0) {
        mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked();
        // Determine appropriate screen brightness and auto-brightness adjustments.
        int screenBrightness = mScreenBrightnessSettingDefault;
        float screenAutoBrightnessAdjustment = 0.0f;
        boolean autoBrightness = (mScreenBrightnessModeSetting == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
        if (isValidBrightness(mScreenBrightnessOverrideFromWindowManager)) {
            screenBrightness = mScreenBrightnessOverrideFromWindowManager;
            autoBrightness = false;
        } else if (isValidBrightness(mTemporaryScreenBrightnessSettingOverride)) {
            screenBrightness = mTemporaryScreenBrightnessSettingOverride;
        } else if (isValidBrightness(mScreenBrightnessSetting)) {
            screenBrightness = mScreenBrightnessSetting;
        }
        if (autoBrightness) {
            screenBrightness = mScreenBrightnessSettingDefault;
            if (isValidAutoBrightnessAdjustment(mTemporaryScreenAutoBrightnessAdjustmentSettingOverride)) {
                screenAutoBrightnessAdjustment = mTemporaryScreenAutoBrightnessAdjustmentSettingOverride;
            } else if (isValidAutoBrightnessAdjustment(mScreenAutoBrightnessAdjustmentSetting)) {
                screenAutoBrightnessAdjustment = mScreenAutoBrightnessAdjustmentSetting;
            }
        }
        screenBrightness = Math.max(Math.min(screenBrightness, mScreenBrightnessSettingMaximum), mScreenBrightnessSettingMinimum);
        screenAutoBrightnessAdjustment = Math.max(Math.min(screenAutoBrightnessAdjustment, 1.0f), -1.0f);
        // Update display power request.
        mDisplayPowerRequest.screenBrightness = screenBrightness;
        mDisplayPowerRequest.screenAutoBrightnessAdjustment = screenAutoBrightnessAdjustment;
        mDisplayPowerRequest.useAutoBrightness = autoBrightness;
        mDisplayPowerRequest.useProximitySensor = shouldUseProximitySensorLocked();
        mDisplayPowerRequest.lowPowerMode = mLowPowerModeEnabled;
        mDisplayPowerRequest.boostScreenBrightness = mScreenBrightnessBoostInProgress;
        if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DOZE) {
            mDisplayPowerRequest.dozeScreenState = mDozeScreenStateOverrideFromDreamManager;
            mDisplayPowerRequest.dozeScreenBrightness = mDozeScreenBrightnessOverrideFromDreamManager;
        } else {
            mDisplayPowerRequest.dozeScreenState = Display.STATE_UNKNOWN;
            mDisplayPowerRequest.dozeScreenBrightness = PowerManager.BRIGHTNESS_DEFAULT;
        }
        mDisplayReady = mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest, mRequestWaitForNegativeProximity);
        mRequestWaitForNegativeProximity = false;
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateDisplayPowerStateLocked: mDisplayReady=" + mDisplayReady + ", policy=" + mDisplayPowerRequest.policy + ", mWakefulness=" + mWakefulness + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", mBootCompleted=" + mBootCompleted + ", mScreenBrightnessBoostInProgress=" + mScreenBrightnessBoostInProgress);
        }
    }
    return mDisplayReady && !oldDisplayReady;
}
------------------------
Find a functionally equivalent code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(noInternetAccess ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
    dest.writeInt(numNoInternetAccessReports);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mLabelForId);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.SignalClusterView.apply:COMMENT
Method Modifier: private     
Comment:// Run after each indicator change.

Body of Frist Method:
{
    if (mWifiGroup == null)
        return;
    mVpn.setVisibility(mVpnVisible ? View.VISIBLE : View.GONE);
    if (DEBUG)
        Log.d(TAG, String.format("vpn: %s", mVpnVisible ? "VISIBLE" : "GONE"));
    if (mWifiVisible) {
        mWifi.setImageResource(mWifiStrengthId);
        mWifiGroup.setContentDescription(mWifiDescription);
        mWifiGroup.setVisibility(View.VISIBLE);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Log.d(TAG, String.format("wifi: %s sig=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId));
    if (mMobileVisible && !mIsAirplaneMode) {
        mMobile.setImageResource(mMobileStrengthId);
        mMobileType.setImageResource(mMobileTypeId);
        mMobileGroup.setContentDescription(mMobileTypeDescription + " " + mMobileDescription);
        mMobileGroup.setVisibility(View.VISIBLE);
    } else {
        mMobileGroup.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode) {
        mAirplane.setImageResource(mAirplaneIconId);
        mAirplane.setVisibility(View.VISIBLE);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode && mWifiVisible) {
        mWifiAirplaneSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiAirplaneSpacer.setVisibility(View.GONE);
    }
    if (mRoaming && mMobileVisible && mWifiVisible) {
        mWifiSignalSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiSignalSpacer.setVisibility(View.GONE);
    }
    mMobile.setPaddingRelative(mIsMobileTypeIconWide ? mWideTypeIconStartPadding : 0, 0, 0, 0);
    if (DEBUG)
        Log.d(TAG, String.format("mobile: %s sig=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileTypeId));
    mMobileType.setVisibility((mRoaming || mMobileTypeId != 0) ? View.VISIBLE : View.GONE);
}
Body of Second Method:
{
    if (mWifiGroup == null)
        return;
    mVpn.setVisibility(mVpnVisible ? View.VISIBLE : View.GONE);
    if (DEBUG)
        Log.d(TAG, String.format("vpn: %s", mVpnVisible ? "VISIBLE" : "GONE"));
    if (mWifiVisible) {
        mWifi.setImageResource(mWifiStrengthId);
        mWifiGroup.setContentDescription(mWifiDescription);
        mWifiGroup.setVisibility(View.VISIBLE);
    } else {
        mWifiGroup.setVisibility(View.GONE);
    }
    if (DEBUG)
        Log.d(TAG, String.format("wifi: %s sig=%d", (mWifiVisible ? "VISIBLE" : "GONE"), mWifiStrengthId));
    boolean anyMobileVisible = false;
    int firstMobileTypeId = 0;
    for (PhoneState state : mPhoneStates) {
        if (state.apply(anyMobileVisible)) {
            if (!anyMobileVisible) {
                firstMobileTypeId = state.mMobileTypeId;
                anyMobileVisible = true;
            }
        }
    }
    if (mIsAirplaneMode) {
        mAirplane.setImageResource(mAirplaneIconId);
        mAirplane.setContentDescription(mAirplaneContentDescription != 0 ? mContext.getString(mAirplaneContentDescription) : null);
        mAirplane.setVisibility(View.VISIBLE);
    } else {
        mAirplane.setVisibility(View.GONE);
    }
    if (mIsAirplaneMode && mWifiVisible) {
        mWifiAirplaneSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiAirplaneSpacer.setVisibility(View.GONE);
    }
    if (((anyMobileVisible && firstMobileTypeId != 0) || mNoSimsVisible) && mWifiVisible) {
        mWifiSignalSpacer.setVisibility(View.VISIBLE);
    } else {
        mWifiSignalSpacer.setVisibility(View.GONE);
    }
    mNoSims.setVisibility(mNoSimsVisible ? View.VISIBLE : View.GONE);
    boolean anythingVisible = mNoSimsVisible || mWifiVisible || mIsAirplaneMode || anyMobileVisible || mVpnVisible;
    setPaddingRelative(0, 0, anythingVisible ? mEndPadding : mEndPaddingNothingVisible, 0);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.onResume:COMMENT
Method Modifier: public      
Comment:/**
 * Resumes a WebView after a previous call to onPause().
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "onResume");
    mProvider.onResume();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onResume");
    mProvider.onResume();
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowStateAnimator.commitFinishDrawingLocked:COMMENT
Method Modifier: 
Comment:// This must be called while inside a transaction.

Body of Frist Method:
{
    if (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING) {
        Slog.i(TAG, "commitFinishDrawingLocked: " + mWin + " cur mDrawState=" + drawStateToString(mDrawState));
    }
    if (mDrawState != COMMIT_DRAW_PENDING) {
        return false;
    }
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM) {
        Slog.i(TAG, "commitFinishDrawingLocked: mDrawState=READY_TO_SHOW " + mSurfaceControl);
    }
    mDrawState = READY_TO_SHOW;
    final boolean starting = mWin.mAttrs.type == TYPE_APPLICATION_STARTING;
    final AppWindowToken atoken = mWin.mAppToken;
    if (atoken == null || atoken.allDrawn || starting) {
        performShowLocked();
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG_STARTING_WINDOW && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING) {
        Slog.i(TAG, "commitFinishDrawingLocked: " + mWin + " cur mDrawState=" + drawStateToString());
    }
    if (mDrawState != COMMIT_DRAW_PENDING && mDrawState != READY_TO_SHOW) {
        return false;
    }
    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM) {
        Slog.i(TAG, "commitFinishDrawingLocked: mDrawState=READY_TO_SHOW " + mSurfaceControl);
    }
    mDrawState = READY_TO_SHOW;
    final AppWindowToken atoken = mWin.mAppToken;
    if (atoken == null || atoken.allDrawn || mWin.mAttrs.type == TYPE_APPLICATION_STARTING) {
        performShowLocked();
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.getRoaming:COMMENT
Method Modifier: public      
Comment:/**
 * Get current roaming indicator of phone
 * (note: not just decoding from TS 27.007 7.2)
 *
 * @return true if TS 27.007 7.2 roaming is true
 * and ONS is different from SPN
 */

Body of Frist Method:
{
    return mRoaming;
}
Body of Second Method:
{
    return getVoiceRoaming() || getDataRoaming();
}
------------------------
Find a functionally equivalent code:android.app.BackStackRecord.configureTransitions:COMMENT
Method Modifier: private     
Comment:/**
 * Configures custom transitions for a specific fragment container.
 *
 * @param containerId The container ID of the fragments to configure the transition for.
 * @param state The Transition State keeping track of the executing transitions.
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID.
 * @param isBack true if this is popping the back stack or false if this is a
 * forward operation.
 */

Body of Frist Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.findViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        Transition sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            if (namedViews.isEmpty()) {
                sharedElementTargets.add(state.nonExistentView);
            } else {
                sharedElementTargets.addAll(namedViews.values());
            }
            addTargets(sharedElementTransition, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
Body of Second Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.findViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        Transition sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            sharedElementTargets.add(state.nonExistentView);
            sharedElementTargets.addAll(namedViews.values());
            addTargets(sharedElementTransition, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.deleteGallery:COMMENT
Method Modifier: internal    
Comment:/**
 * Calls back SetupFaceLock to delete the gallery file when the lock type is changed
 */

Body of Frist Method:
{
    if (usingBiometricWeak()) {
        Intent intent = new Intent().setAction("com.android.facelock.DELETE_GALLERY");
        intent.putExtra("deleteGallery", true);
        mContext.sendBroadcast(intent);
    }
}
Body of Second Method:
{
    if (usingBiometricWeak(userId)) {
        Intent intent = new Intent().setAction("com.android.facelock.DELETE_GALLERY");
        intent.putExtra("deleteGallery", true);
        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setCursiveFontFamily:COMMENT
<android.webkit.WebSettings: void setCursiveFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the cursive font family name. The default is "cursive".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewHeader.startNoUserInteractionAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Animates this task bar if the user does not interact with the stack after a certain time.
 */

Body of Frist Method:
{
    mDismissButton.setVisibility(View.VISIBLE);
    mDismissButton.setAlpha(0f);
    mDismissButton.animate().alpha(1f).setStartDelay(0).setInterpolator(mConfig.fastOutLinearInInterpolator).setDuration(mConfig.taskBarEnterAnimDuration).withLayer().start();
}
Body of Second Method:
{
    if (mDismissButton.getVisibility() != View.VISIBLE) {
        mDismissButton.setVisibility(View.VISIBLE);
        mDismissButton.setAlpha(0f);
        mDismissButton.animate().alpha(1f).setStartDelay(0).setInterpolator(mConfig.fastOutLinearInInterpolator).setDuration(mConfig.taskViewEnterFromAppDuration).withLayer().start();
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.RegisteredServicesCache.getServiceInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Accessor for the registered authenticators.
 * @param type the account type of the authenticator
 * @return the AuthenticatorInfo that matches the account type or null if none is present
 */

Body of Frist Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(userId);
        }
        return user.services.get(type);
    }
}
Body of Second Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(null, userId);
        }
        return user.services.get(type);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.abandonAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to abandon audio focus, typically after a call or
 * when ringing ends and the call is rejected or not answered.
 * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService due to " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.DrawableContainer.DrawableContainerState.ConstantStateFuture.get:COMMENT
Method Modifier: public      
Comment:/**
 * Obtains and prepares the Drawable represented by this future.
 *
 * @param state the container into which this future will be placed
 * @return a prepared Drawable
 */

Body of Frist Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else if (state.mTheme == null) {
        result = mConstantState.newDrawable(state.mRes);
    } else {
        result = mConstantState.newDrawable(state.mRes, state.mTheme);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
Body of Second Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else {
        result = mConstantState.newDrawable(state.mRes);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setUseDoubleTree:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Controlled a rendering optimization that is no longer present. Setting
 * it now has no effect.
 *
 * @deprecated This setting now has no effect.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
// Specified to do nothing, so no need for derived classes to override.
}
Body of Second Method:
{
// Specified to do nothing, so no need for derived classes to override.
}
------------------------
Find a functionally equivalent code:android.hardware.SensorManager.registerListenerImpl:COMMENT
Method Modifier: protected   abstract    hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.dismissTask:COMMENT
Method Modifier: 
Comment:/**
 * Dismisses this task.
 */

Body of Frist Method:
{
    // Animate out the view and call the callback
    final TaskView tv = this;
    startDeleteTaskAnimation(new Runnable() {

        @Override
        public void run() {
            mCb.onTaskViewDismissed(tv);
        }
    });
    // Hide the footer
    animateFooterVisibility(false, mConfig.taskViewRemoveAnimDuration);
}
Body of Second Method:
{
    // Animate out the view and call the callback
    final TaskView tv = this;
    startDeleteTaskAnimation(new Runnable() {

        @Override
        public void run() {
            if (mCb != null) {
                mCb.onTaskViewDismissed(tv);
            }
        }
    });
}
------------------------
Find a functionally equivalent code:android.content.ContentProviderClient.openFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return openFile(url, mode, null);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.removeStartingWindow:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DEBUG_STARTING_WINDOW) {
        RuntimeException e = new RuntimeException("here");
        e.fillInStackTrace();
        Log.v(TAG, "Removing starting window for " + appToken + ": " + window, e);
    }
    if (window != null) {
        WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        wm.removeView(window);
    }
}
Body of Second Method:
{
    if (DEBUG_STARTING_WINDOW)
        Slog.v(TAG, "Removing starting window for " + appToken + ": " + window + " Callers=" + Debug.getCallers(4));
    if (window != null) {
        WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        wm.removeView(window);
    }
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.getMobileDataEnabled:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated Talk to TelephonyManager directly
 */

Body of Frist Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            return it.getDataEnabled();
        } catch (RemoteException e) {
        }
    }
    return false;
}
Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.getDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
------------------------
Find a functionally equivalent code:android.content.res.Resources.updateConfiguration:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (mAccessLock) {
        if (false) {
            Slog.i(TAG, "**** Updating config of " + this + ": old config is " + mConfiguration + " old compat is " + mCompatibilityInfo);
            Slog.i(TAG, "**** Updating config of " + this + ": new config is " + config + " new compat is " + compat);
        }
        if (compat != null) {
            mCompatibilityInfo = compat;
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
        }
        // NOTE: We should re-arrange this code to create a Display
        // with the CompatibilityInfo that is used everywhere we deal
        // with the display in relation to this app, rather than
        // doing the conversion here.  This impl should be okay because
        // we make sure to return a compatible display in the places
        // where there are public APIs to retrieve the display...  but
        // it would be cleaner and more maintainble to just be
        // consistently dealing with a compatible display everywhere in
        // the framework.
        mCompatibilityInfo.applyToDisplayMetrics(mMetrics);
        int configChanges = 0xfffffff;
        if (config != null) {
            mTmpConfig.setTo(config);
            int density = config.densityDpi;
            if (density == Configuration.DENSITY_DPI_UNDEFINED) {
                density = mMetrics.noncompatDensityDpi;
            }
            mCompatibilityInfo.applyToConfiguration(density, mTmpConfig);
            if (mTmpConfig.locale == null) {
                mTmpConfig.locale = Locale.getDefault();
                mTmpConfig.setLayoutDirection(mTmpConfig.locale);
            }
            configChanges = mConfiguration.updateFrom(mTmpConfig);
            configChanges = ActivityInfo.activityInfoConfigToNative(configChanges);
        }
        if (mConfiguration.locale == null) {
            mConfiguration.locale = Locale.getDefault();
            mConfiguration.setLayoutDirection(mConfiguration.locale);
        }
        if (mConfiguration.densityDpi != Configuration.DENSITY_DPI_UNDEFINED) {
            mMetrics.densityDpi = mConfiguration.densityDpi;
            mMetrics.density = mConfiguration.densityDpi * DisplayMetrics.DENSITY_DEFAULT_SCALE;
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = adjustLanguageTag(mConfiguration.locale.toLanguageTag());
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.KEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, mConfiguration.densityDpi, mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.smallestScreenWidthDp, mConfiguration.screenWidthDp, mConfiguration.screenHeightDp, mConfiguration.screenLayout, mConfiguration.uiMode, Build.VERSION.RESOURCES_SDK_INT);
        if (DEBUG_CONFIG) {
            Slog.i(TAG, "**** Updating config of " + this + ": final config is " + mConfiguration + " final compat is " + mCompatibilityInfo);
        }
        clearDrawableCachesLocked(mDrawableCache, configChanges);
        clearDrawableCachesLocked(mColorDrawableCache, configChanges);
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (sSync) {
        if (mPluralRule != null) {
            mPluralRule = NativePluralRules.forLocale(config.locale);
        }
    }
}
Body of Second Method:
{
    synchronized (mAccessLock) {
        if (false) {
            Slog.i(TAG, "**** Updating config of " + this + ": old config is " + mConfiguration + " old compat is " + mCompatibilityInfo);
            Slog.i(TAG, "**** Updating config of " + this + ": new config is " + config + " new compat is " + compat);
        }
        if (compat != null) {
            mCompatibilityInfo = compat;
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
        }
        // NOTE: We should re-arrange this code to create a Display
        // with the CompatibilityInfo that is used everywhere we deal
        // with the display in relation to this app, rather than
        // doing the conversion here.  This impl should be okay because
        // we make sure to return a compatible display in the places
        // where there are public APIs to retrieve the display...  but
        // it would be cleaner and more maintainble to just be
        // consistently dealing with a compatible display everywhere in
        // the framework.
        mCompatibilityInfo.applyToDisplayMetrics(mMetrics);
        int configChanges = calcConfigChanges(config);
        if (mConfiguration.locale == null) {
            mConfiguration.locale = Locale.getDefault();
            mConfiguration.setLayoutDirection(mConfiguration.locale);
        }
        if (mConfiguration.densityDpi != Configuration.DENSITY_DPI_UNDEFINED) {
            mMetrics.densityDpi = mConfiguration.densityDpi;
            mMetrics.density = mConfiguration.densityDpi * DisplayMetrics.DENSITY_DEFAULT_SCALE;
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = adjustLanguageTag(mConfiguration.locale.toLanguageTag());
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.KEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, mConfiguration.densityDpi, mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.smallestScreenWidthDp, mConfiguration.screenWidthDp, mConfiguration.screenHeightDp, mConfiguration.screenLayout, mConfiguration.uiMode, Build.VERSION.RESOURCES_SDK_INT);
        if (DEBUG_CONFIG) {
            Slog.i(TAG, "**** Updating config of " + this + ": final config is " + mConfiguration + " final compat is " + mCompatibilityInfo);
        }
        clearDrawableCachesLocked(mDrawableCache, configChanges);
        clearDrawableCachesLocked(mColorDrawableCache, configChanges);
        mAnimatorCache.onConfigurationChange(configChanges);
        mStateListAnimatorCache.onConfigurationChange(configChanges);
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (sSync) {
        if (mPluralRule != null) {
            mPluralRule = NativePluralRules.forLocale(config.locale);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.dismissRecentsToFocusedTaskOrHome:COMMENT
Method Modifier: 
Comment:/**
 * Dismisses recents if we are already visible and the intent is to toggle the recents view
 */

Body of Frist Method:
{
    if (mVisible) {
        // If we currently have filtered stacks, then unfilter those first
        if (checkFilteredStackState && mRecentsView.unfilterFilteredStacks())
            return true;
        // If we have a focused Task, launch that Task now
        if (mRecentsView.launchFocusedTask())
            return true;
        // If we launched from Home, then return to Home
        if (mConfig.launchedFromHome) {
            dismissRecentsToHomeRaw(true);
            return true;
        }
        // Otherwise, try and return to the Task that Recents was launched from
        if (mRecentsView.launchPreviousTask())
            return true;
        // If none of the other cases apply, then just go Home
        dismissRecentsToHomeRaw(true);
        return true;
    }
    return false;
}
Body of Second Method:
{
    SystemServicesProxy ssp = RecentsTaskLoader.getInstance().getSystemServicesProxy();
    if (ssp.isRecentsTopMost(ssp.getTopMostTask(), null)) {
        // If we currently have filtered stacks, then unfilter those first
        if (checkFilteredStackState && mRecentsView.unfilterFilteredStacks())
            return true;
        // If we have a focused Task, launch that Task now
        if (mRecentsView.launchFocusedTask())
            return true;
        // If we launched from Home, then return to Home
        if (mConfig.launchedFromHome) {
            dismissRecentsToHomeRaw(true);
            return true;
        }
        // Otherwise, try and return to the Task that Recents was launched from
        if (mRecentsView.launchPreviousTask())
            return true;
        // If none of the other cases apply, then just go Home
        dismissRecentsToHomeRaw(true);
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.requestIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void requestIconForPageUrl(String,IconListener)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Request the Bitmap representing the icon for the given page
 * url. If the icon exists, the listener will be called with the result.
 * @param url The page's url.
 * @param listener An implementation on IconListener to receive the result.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebBackForwardList.clone:COMMENT
<android.webkit.WebBackForwardList: WebBackForwardList clone()>
Method Modifier: protected   abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clone the entire object to be used in the UI thread by clients of
 * WebView. This creates a copy that should never be modified by any of the
 * webkit package classes.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setJavaScriptCanOpenWindowsAutomatically:COMMENT
<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells JavaScript to open windows automatically. This applies to the
 * JavaScript function window.open(). The default is false.
 *
 * @param flag true if JavaScript can open windows automatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.wm.WindowManagerService.handleAppTransitionReadyLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
 * @param windows List of windows on default display.
 * @return bitmap indicating if another pass through layout must be made.
 */

Body of Frist Method:
{
    int changes = 0;
    int i;
    int NN = mOpeningApps.size();
    boolean goodToGo = true;
    if (DEBUG_APP_TRANSITIONS)
        Slog.v(TAG, "Checking " + NN + " opening apps (frozen=" + mDisplayFrozen + " timeout=" + mAppTransition.isTimeout() + ")...");
    if (!mDisplayFrozen && !mAppTransition.isTimeout()) {
        // we'll unfreeze the display when everyone is ready.
        for (i = 0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken = mOpeningApps.valueAt(i);
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Check opening app=" + wtoken + ": allDrawn=" + wtoken.allDrawn + " startingDisplayed=" + wtoken.startingDisplayed + " startingMoved=" + wtoken.startingMoved);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
                goodToGo = false;
            }
        }
    }
    if (goodToGo) {
        if (DEBUG_APP_TRANSITIONS)
            Slog.v(TAG, "**** GOOD TO GO");
        int transit = mAppTransition.getAppTransition();
        if (mSkipAppTransitionAnimation) {
            transit = AppTransition.TRANSIT_UNSET;
        }
        mAppTransition.goodToGo();
        mStartingIconInTransition = false;
        mSkipAppTransitionAnimation = false;
        mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
        rebuildAppWindowListLocked();
        // if wallpaper is animating in or out set oldWallpaper to null else to wallpaper
        WindowState oldWallpaper = mWallpaperTarget != null && mWallpaperTarget.mWinAnimator.isAnimating() && !mWallpaperTarget.mWinAnimator.isDummyAnimation() ? null : mWallpaperTarget;
        mInnerFields.mWallpaperMayChange = false;
        // The top-most window will supply the layout params,
        // and we will determine it below.
        LayoutParams animLp = null;
        int bestAnimLayer = -1;
        boolean fullscreenAnim = false;
        boolean voiceInteraction = false;
        if (DEBUG_APP_TRANSITIONS)
            Slog.v(TAG, "New wallpaper target=" + mWallpaperTarget + ", oldWallpaper=" + oldWallpaper + ", lower target=" + mLowerWallpaperTarget + ", upper target=" + mUpperWallpaperTarget);
        boolean openingAppHasWallpaper = false;
        boolean closingAppHasWallpaper = false;
        final AppWindowToken lowerWallpaperAppToken;
        final AppWindowToken upperWallpaperAppToken;
        if (mLowerWallpaperTarget == null) {
            lowerWallpaperAppToken = upperWallpaperAppToken = null;
        } else {
            lowerWallpaperAppToken = mLowerWallpaperTarget.mAppToken;
            upperWallpaperAppToken = mUpperWallpaperTarget.mAppToken;
        }
        // Do a first pass through the tokens for two
        // things:
        // (1) Determine if both the closing and opening
        // app token sets are wallpaper targets, in which
        // case special animations are needed
        // (since the wallpaper needs to stay static
        // behind them).
        // (2) Find the layout params of the top-most
        // application window in the tokens, which is
        // what will control the animation theme.
        final int NC = mClosingApps.size();
        NN = NC + mOpeningApps.size();
        for (i = 0; i < NN; i++) {
            final AppWindowToken wtoken;
            if (i < NC) {
                wtoken = mClosingApps.valueAt(i);
                if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
                    closingAppHasWallpaper = true;
                }
            } else {
                wtoken = mOpeningApps.valueAt(i - NC);
                if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
                    openingAppHasWallpaper = true;
                }
            }
            voiceInteraction |= wtoken.voiceInteraction;
            if (wtoken.appFullscreen) {
                WindowState ws = wtoken.findMainWindow();
                if (ws != null) {
                    animLp = ws.mAttrs;
                    bestAnimLayer = ws.mLayer;
                    fullscreenAnim = true;
                }
            } else if (!fullscreenAnim) {
                WindowState ws = wtoken.findMainWindow();
                if (ws != null) {
                    if (ws.mLayer > bestAnimLayer) {
                        animLp = ws.mAttrs;
                        bestAnimLayer = ws.mLayer;
                    }
                }
            }
        }
        mAnimateWallpaperWithTarget = false;
        if (closingAppHasWallpaper && openingAppHasWallpaper) {
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Wallpaper animation!");
            switch(transit) {
                case AppTransition.TRANSIT_ACTIVITY_OPEN:
                case AppTransition.TRANSIT_TASK_OPEN:
                case AppTransition.TRANSIT_TASK_TO_FRONT:
                    transit = AppTransition.TRANSIT_WALLPAPER_INTRA_OPEN;
                    break;
                case AppTransition.TRANSIT_ACTIVITY_CLOSE:
                case AppTransition.TRANSIT_TASK_CLOSE:
                case AppTransition.TRANSIT_TASK_TO_BACK:
                    transit = AppTransition.TRANSIT_WALLPAPER_INTRA_CLOSE;
                    break;
            }
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit: " + transit);
        } else if ((oldWallpaper != null) && !mOpeningApps.isEmpty() && !mOpeningApps.contains(oldWallpaper.mAppToken)) {
            // We are transitioning from an activity with
            // a wallpaper to one without.
            transit = AppTransition.TRANSIT_WALLPAPER_CLOSE;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit away from wallpaper: " + transit);
        } else if (mWallpaperTarget != null && mWallpaperTarget.isVisibleLw()) {
            // We are transitioning from an activity without
            // a wallpaper to now showing the wallpaper
            transit = AppTransition.TRANSIT_WALLPAPER_OPEN;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit into wallpaper: " + transit);
        } else {
            mAnimateWallpaperWithTarget = true;
        }
        // the lock screen.
        if (!mPolicy.allowAppAnimationsLw()) {
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Animations disallowed by keyguard or dream.");
            animLp = null;
        }
        AppWindowToken topOpeningApp = null;
        AppWindowToken topClosingApp = null;
        int topOpeningLayer = 0;
        int topClosingLayer = 0;
        NN = mOpeningApps.size();
        for (i = 0; i < NN; i++) {
            AppWindowToken wtoken = mOpeningApps.valueAt(i);
            final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Now opening app" + wtoken);
            appAnimator.clearThumbnail();
            appAnimator.animation = null;
            wtoken.inPendingTransaction = false;
            setTokenVisibilityLocked(wtoken, animLp, true, transit, false, voiceInteraction);
            wtoken.updateReportedVisibilityLocked();
            wtoken.waitingToShow = false;
            appAnimator.mAllAppWinAnimators.clear();
            final int N = wtoken.allAppWindows.size();
            for (int j = 0; j < N; j++) {
                appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
            }
            mAnimator.mAnimating |= appAnimator.showAllWindowsLocked();
            if (animLp != null) {
                int layer = -1;
                for (int j = 0; j < wtoken.windows.size(); j++) {
                    WindowState win = wtoken.windows.get(j);
                    if (win.mWinAnimator.mAnimLayer > layer) {
                        layer = win.mWinAnimator.mAnimLayer;
                    }
                }
                if (topOpeningApp == null || layer > topOpeningLayer) {
                    topOpeningApp = wtoken;
                    topOpeningLayer = layer;
                }
            }
        }
        NN = mClosingApps.size();
        for (i = 0; i < NN; i++) {
            AppWindowToken wtoken = mClosingApps.valueAt(i);
            final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Now closing app " + wtoken);
            appAnimator.clearThumbnail();
            appAnimator.animation = null;
            wtoken.inPendingTransaction = false;
            setTokenVisibilityLocked(wtoken, animLp, false, transit, false, voiceInteraction);
            wtoken.updateReportedVisibilityLocked();
            wtoken.waitingToHide = false;
            // Force the allDrawn flag, because we want to start
            // this guy's animations regardless of whether it's
            // gotten drawn.
            wtoken.allDrawn = true;
            wtoken.deferClearAllDrawn = false;
            // starting windows removed after the animation is complete
            if (wtoken.startingWindow != null && !wtoken.startingWindow.mExiting) {
                scheduleRemoveStartingWindowLocked(wtoken);
            }
            if (animLp != null) {
                int layer = -1;
                for (int j = 0; j < wtoken.windows.size(); j++) {
                    WindowState win = wtoken.windows.get(j);
                    if (win.mWinAnimator.mAnimLayer > layer) {
                        layer = win.mWinAnimator.mAnimLayer;
                    }
                }
                if (topClosingApp == null || layer > topClosingLayer) {
                    topClosingApp = wtoken;
                    topClosingLayer = layer;
                }
            }
        }
        AppWindowAnimator openingAppAnimator = (topOpeningApp == null) ? null : topOpeningApp.mAppAnimator;
        AppWindowAnimator closingAppAnimator = (topClosingApp == null) ? null : topClosingApp.mAppAnimator;
        Bitmap nextAppTransitionThumbnail = mAppTransition.getNextAppTransitionThumbnail();
        if (nextAppTransitionThumbnail != null && openingAppAnimator != null && openingAppAnimator.animation != null && nextAppTransitionThumbnail.getConfig() != Config.ALPHA_8) {
            // This thumbnail animation is very special, we need to have
            // an extra surface with the thumbnail included with the animation.
            Rect dirty = new Rect(0, 0, nextAppTransitionThumbnail.getWidth(), nextAppTransitionThumbnail.getHeight());
            try {
                // TODO(multi-display): support other displays
                final DisplayContent displayContent = getDefaultDisplayContentLocked();
                final Display display = displayContent.getDisplay();
                final DisplayInfo displayInfo = displayContent.getDisplayInfo();
                // Create a new surface for the thumbnail
                SurfaceControl surfaceControl = new SurfaceControl(mFxSession, "thumbnail anim", dirty.width(), dirty.height(), PixelFormat.TRANSLUCENT, SurfaceControl.HIDDEN);
                surfaceControl.setLayerStack(display.getLayerStack());
                if (SHOW_TRANSACTIONS) {
                    Slog.i(TAG, "  THUMBNAIL " + surfaceControl + ": CREATE");
                }
                // Draw the thumbnail onto the surface
                Surface drawSurface = new Surface();
                drawSurface.copyFrom(surfaceControl);
                Canvas c = drawSurface.lockCanvas(dirty);
                c.drawBitmap(nextAppTransitionThumbnail, 0, 0, null);
                drawSurface.unlockCanvasAndPost(c);
                drawSurface.release();
                // Get the thumbnail animation
                Animation anim;
                if (mAppTransition.isNextThumbnailTransitionAspectScaled()) {
                    // For the new aspect-scaled transition, we want it to always show
                    // above the animating opening/closing window, and we want to
                    // synchronize its thumbnail surface with the surface for the
                    // open/close animation (only on the way down)
                    anim = mAppTransition.createThumbnailAspectScaleAnimationLocked(displayInfo.appWidth, displayInfo.appHeight, displayInfo.logicalWidth, transit);
                    openingAppAnimator.thumbnailForceAboveLayer = Math.max(topOpeningLayer, topClosingLayer);
                    openingAppAnimator.deferThumbnailDestruction = !mAppTransition.isNextThumbnailTransitionScaleUp();
                    if (openingAppAnimator.deferThumbnailDestruction) {
                        if (closingAppAnimator != null && closingAppAnimator.animation != null) {
                            closingAppAnimator.deferredThumbnail = surfaceControl;
                        }
                    }
                } else {
                    anim = mAppTransition.createThumbnailScaleAnimationLocked(displayInfo.appWidth, displayInfo.appHeight, transit);
                }
                anim.restrictDuration(MAX_ANIMATION_DURATION);
                anim.scaleCurrentDuration(getTransitionAnimationScaleLocked());
                openingAppAnimator.thumbnail = surfaceControl;
                openingAppAnimator.thumbnailLayer = topOpeningLayer;
                openingAppAnimator.thumbnailAnimation = anim;
                openingAppAnimator.thumbnailX = mAppTransition.getStartingX();
                openingAppAnimator.thumbnailY = mAppTransition.getStartingY();
            } catch (OutOfResourcesException e) {
                Slog.e(TAG, "Can't allocate thumbnail/Canvas surface w=" + dirty.width() + " h=" + dirty.height(), e);
                openingAppAnimator.clearThumbnail();
            }
        }
        mAppTransition.postAnimationCallback();
        mAppTransition.clear();
        mOpeningApps.clear();
        mClosingApps.clear();
        // This has changed the visibility of windows, so perform
        // a new layout to get them all up-to-date.
        changes |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG;
        getDefaultDisplayContentLocked().layoutNeeded = true;
        // TODO(multidisplay): IMEs are only supported on the default display.
        if (windows == getDefaultWindowListLocked() && !moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked(windows);
        }
        updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, true);
        mFocusMayChange = false;
    }
    return changes;
}
Body of Second Method:
{
    int changes = 0;
    int i;
    int NN = mOpeningApps.size();
    boolean goodToGo = true;
    if (DEBUG_APP_TRANSITIONS)
        Slog.v(TAG, "Checking " + NN + " opening apps (frozen=" + mDisplayFrozen + " timeout=" + mAppTransition.isTimeout() + ")...");
    if (!mDisplayFrozen && !mAppTransition.isTimeout()) {
        // we'll unfreeze the display when everyone is ready.
        for (i = 0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken = mOpeningApps.valueAt(i);
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Check opening app=" + wtoken + ": allDrawn=" + wtoken.allDrawn + " startingDisplayed=" + wtoken.startingDisplayed + " startingMoved=" + wtoken.startingMoved);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
                goodToGo = false;
            }
        }
    }
    if (goodToGo) {
        if (DEBUG_APP_TRANSITIONS)
            Slog.v(TAG, "**** GOOD TO GO");
        int transit = mAppTransition.getAppTransition();
        if (mSkipAppTransitionAnimation) {
            transit = AppTransition.TRANSIT_UNSET;
        }
        mAppTransition.goodToGo();
        mStartingIconInTransition = false;
        mSkipAppTransitionAnimation = false;
        mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
        rebuildAppWindowListLocked();
        // if wallpaper is animating in or out set oldWallpaper to null else to wallpaper
        WindowState oldWallpaper = mWallpaperTarget != null && mWallpaperTarget.mWinAnimator.isAnimating() && !mWallpaperTarget.mWinAnimator.isDummyAnimation() ? null : mWallpaperTarget;
        mInnerFields.mWallpaperMayChange = false;
        // The top-most window will supply the layout params,
        // and we will determine it below.
        LayoutParams animLp = null;
        int bestAnimLayer = -1;
        boolean fullscreenAnim = false;
        boolean voiceInteraction = false;
        if (DEBUG_APP_TRANSITIONS)
            Slog.v(TAG, "New wallpaper target=" + mWallpaperTarget + ", oldWallpaper=" + oldWallpaper + ", lower target=" + mLowerWallpaperTarget + ", upper target=" + mUpperWallpaperTarget);
        boolean openingAppHasWallpaper = false;
        boolean closingAppHasWallpaper = false;
        final AppWindowToken lowerWallpaperAppToken;
        final AppWindowToken upperWallpaperAppToken;
        if (mLowerWallpaperTarget == null) {
            lowerWallpaperAppToken = upperWallpaperAppToken = null;
        } else {
            lowerWallpaperAppToken = mLowerWallpaperTarget.mAppToken;
            upperWallpaperAppToken = mUpperWallpaperTarget.mAppToken;
        }
        // Do a first pass through the tokens for two
        // things:
        // (1) Determine if both the closing and opening
        // app token sets are wallpaper targets, in which
        // case special animations are needed
        // (since the wallpaper needs to stay static
        // behind them).
        // (2) Find the layout params of the top-most
        // application window in the tokens, which is
        // what will control the animation theme.
        final int NC = mClosingApps.size();
        NN = NC + mOpeningApps.size();
        for (i = 0; i < NN; i++) {
            final AppWindowToken wtoken;
            if (i < NC) {
                wtoken = mClosingApps.valueAt(i);
                if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
                    closingAppHasWallpaper = true;
                }
            } else {
                wtoken = mOpeningApps.valueAt(i - NC);
                if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
                    openingAppHasWallpaper = true;
                }
            }
            voiceInteraction |= wtoken.voiceInteraction;
            if (wtoken.appFullscreen) {
                WindowState ws = wtoken.findMainWindow();
                if (ws != null) {
                    animLp = ws.mAttrs;
                    bestAnimLayer = ws.mLayer;
                    fullscreenAnim = true;
                }
            } else if (!fullscreenAnim) {
                WindowState ws = wtoken.findMainWindow();
                if (ws != null) {
                    if (ws.mLayer > bestAnimLayer) {
                        animLp = ws.mAttrs;
                        bestAnimLayer = ws.mLayer;
                    }
                }
            }
        }
        mAnimateWallpaperWithTarget = false;
        if (closingAppHasWallpaper && openingAppHasWallpaper) {
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Wallpaper animation!");
            switch(transit) {
                case AppTransition.TRANSIT_ACTIVITY_OPEN:
                case AppTransition.TRANSIT_TASK_OPEN:
                case AppTransition.TRANSIT_TASK_TO_FRONT:
                    transit = AppTransition.TRANSIT_WALLPAPER_INTRA_OPEN;
                    break;
                case AppTransition.TRANSIT_ACTIVITY_CLOSE:
                case AppTransition.TRANSIT_TASK_CLOSE:
                case AppTransition.TRANSIT_TASK_TO_BACK:
                    transit = AppTransition.TRANSIT_WALLPAPER_INTRA_CLOSE;
                    break;
            }
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit: " + transit);
        } else if ((oldWallpaper != null) && !mOpeningApps.isEmpty() && !mOpeningApps.contains(oldWallpaper.mAppToken)) {
            // We are transitioning from an activity with
            // a wallpaper to one without.
            transit = AppTransition.TRANSIT_WALLPAPER_CLOSE;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit away from wallpaper: " + transit);
        } else if (mWallpaperTarget != null && mWallpaperTarget.isVisibleLw()) {
            // We are transitioning from an activity without
            // a wallpaper to now showing the wallpaper
            transit = AppTransition.TRANSIT_WALLPAPER_OPEN;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "New transit into wallpaper: " + transit);
        } else {
            mAnimateWallpaperWithTarget = true;
        }
        // the lock screen.
        if (!mPolicy.allowAppAnimationsLw()) {
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Animations disallowed by keyguard or dream.");
            animLp = null;
        }
        AppWindowToken topOpeningApp = null;
        AppWindowToken topClosingApp = null;
        int topOpeningLayer = 0;
        int topClosingLayer = 0;
        // Process all applications animating in place
        if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
            // Find the focused window
            final WindowState win = findFocusedWindowLocked(getDefaultDisplayContentLocked());
            if (win != null) {
                final AppWindowToken wtoken = win.mAppToken;
                final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
                if (DEBUG_APP_TRANSITIONS)
                    Slog.v(TAG, "Now animating app in place " + wtoken);
                appAnimator.clearThumbnail();
                appAnimator.animation = null;
                updateTokenInPlaceLocked(wtoken, transit);
                wtoken.updateReportedVisibilityLocked();
                appAnimator.mAllAppWinAnimators.clear();
                final int N = wtoken.allAppWindows.size();
                for (int j = 0; j < N; j++) {
                    appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
                }
                mAnimator.mAnimating |= appAnimator.showAllWindowsLocked();
            }
        }
        NN = mOpeningApps.size();
        for (i = 0; i < NN; i++) {
            AppWindowToken wtoken = mOpeningApps.valueAt(i);
            final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Now opening app" + wtoken);
            appAnimator.clearThumbnail();
            appAnimator.animation = null;
            wtoken.inPendingTransaction = false;
            setTokenVisibilityLocked(wtoken, animLp, true, transit, false, voiceInteraction);
            wtoken.updateReportedVisibilityLocked();
            wtoken.waitingToShow = false;
            appAnimator.mAllAppWinAnimators.clear();
            final int N = wtoken.allAppWindows.size();
            for (int j = 0; j < N; j++) {
                appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
            }
            mAnimator.mAnimating |= appAnimator.showAllWindowsLocked();
            if (animLp != null) {
                int layer = -1;
                for (int j = 0; j < wtoken.windows.size(); j++) {
                    WindowState win = wtoken.windows.get(j);
                    if (win.mWinAnimator.mAnimLayer > layer) {
                        layer = win.mWinAnimator.mAnimLayer;
                    }
                }
                if (topOpeningApp == null || layer > topOpeningLayer) {
                    topOpeningApp = wtoken;
                    topOpeningLayer = layer;
                }
            }
        }
        NN = mClosingApps.size();
        for (i = 0; i < NN; i++) {
            AppWindowToken wtoken = mClosingApps.valueAt(i);
            final AppWindowAnimator appAnimator = wtoken.mAppAnimator;
            if (DEBUG_APP_TRANSITIONS)
                Slog.v(TAG, "Now closing app " + wtoken);
            appAnimator.clearThumbnail();
            appAnimator.animation = null;
            wtoken.inPendingTransaction = false;
            setTokenVisibilityLocked(wtoken, animLp, false, transit, false, voiceInteraction);
            wtoken.updateReportedVisibilityLocked();
            wtoken.waitingToHide = false;
            // Force the allDrawn flag, because we want to start
            // this guy's animations regardless of whether it's
            // gotten drawn.
            wtoken.allDrawn = true;
            wtoken.deferClearAllDrawn = false;
            // starting windows removed after the animation is complete
            if (wtoken.startingWindow != null && !wtoken.startingWindow.mExiting) {
                scheduleRemoveStartingWindowLocked(wtoken);
            }
            if (animLp != null) {
                int layer = -1;
                for (int j = 0; j < wtoken.windows.size(); j++) {
                    WindowState win = wtoken.windows.get(j);
                    if (win.mWinAnimator.mAnimLayer > layer) {
                        layer = win.mWinAnimator.mAnimLayer;
                    }
                }
                if (topClosingApp == null || layer > topClosingLayer) {
                    topClosingApp = wtoken;
                    topClosingLayer = layer;
                }
            }
        }
        AppWindowAnimator openingAppAnimator = (topOpeningApp == null) ? null : topOpeningApp.mAppAnimator;
        AppWindowAnimator closingAppAnimator = (topClosingApp == null) ? null : topClosingApp.mAppAnimator;
        Bitmap nextAppTransitionThumbnail = mAppTransition.getNextAppTransitionThumbnail();
        if (nextAppTransitionThumbnail != null && openingAppAnimator != null && openingAppAnimator.animation != null && nextAppTransitionThumbnail.getConfig() != Config.ALPHA_8) {
            // This thumbnail animation is very special, we need to have
            // an extra surface with the thumbnail included with the animation.
            Rect dirty = new Rect(0, 0, nextAppTransitionThumbnail.getWidth(), nextAppTransitionThumbnail.getHeight());
            try {
                // TODO(multi-display): support other displays
                final DisplayContent displayContent = getDefaultDisplayContentLocked();
                final Display display = displayContent.getDisplay();
                final DisplayInfo displayInfo = displayContent.getDisplayInfo();
                // Create a new surface for the thumbnail
                SurfaceControl surfaceControl = new SurfaceControl(mFxSession, "thumbnail anim", dirty.width(), dirty.height(), PixelFormat.TRANSLUCENT, SurfaceControl.HIDDEN);
                surfaceControl.setLayerStack(display.getLayerStack());
                if (SHOW_TRANSACTIONS) {
                    Slog.i(TAG, "  THUMBNAIL " + surfaceControl + ": CREATE");
                }
                // Draw the thumbnail onto the surface
                Surface drawSurface = new Surface();
                drawSurface.copyFrom(surfaceControl);
                Canvas c = drawSurface.lockCanvas(dirty);
                c.drawBitmap(nextAppTransitionThumbnail, 0, 0, null);
                drawSurface.unlockCanvasAndPost(c);
                drawSurface.release();
                // Get the thumbnail animation
                Animation anim;
                if (mAppTransition.isNextThumbnailTransitionAspectScaled()) {
                    // For the new aspect-scaled transition, we want it to always show
                    // above the animating opening/closing window, and we want to
                    // synchronize its thumbnail surface with the surface for the
                    // open/close animation (only on the way down)
                    anim = mAppTransition.createThumbnailAspectScaleAnimationLocked(displayInfo.appWidth, displayInfo.appHeight, displayInfo.logicalWidth, transit);
                    openingAppAnimator.thumbnailForceAboveLayer = Math.max(topOpeningLayer, topClosingLayer);
                    openingAppAnimator.deferThumbnailDestruction = !mAppTransition.isNextThumbnailTransitionScaleUp();
                } else {
                    anim = mAppTransition.createThumbnailScaleAnimationLocked(displayInfo.appWidth, displayInfo.appHeight, transit);
                }
                anim.restrictDuration(MAX_ANIMATION_DURATION);
                anim.scaleCurrentDuration(getTransitionAnimationScaleLocked());
                openingAppAnimator.thumbnail = surfaceControl;
                openingAppAnimator.thumbnailLayer = topOpeningLayer;
                openingAppAnimator.thumbnailAnimation = anim;
                openingAppAnimator.thumbnailX = mAppTransition.getStartingX();
                openingAppAnimator.thumbnailY = mAppTransition.getStartingY();
            } catch (OutOfResourcesException e) {
                Slog.e(TAG, "Can't allocate thumbnail/Canvas surface w=" + dirty.width() + " h=" + dirty.height(), e);
                openingAppAnimator.clearThumbnail();
            }
        }
        mAppTransition.postAnimationCallback();
        mAppTransition.clear();
        mOpeningApps.clear();
        mClosingApps.clear();
        // This has changed the visibility of windows, so perform
        // a new layout to get them all up-to-date.
        changes |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG;
        getDefaultDisplayContentLocked().layoutNeeded = true;
        // TODO(multidisplay): IMEs are only supported on the default display.
        if (windows == getDefaultWindowListLocked() && !moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked(windows);
        }
        updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, true);
        mFocusMayChange = false;
        notifyActivityDrawnForKeyguard();
    }
    return changes;
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.registerAudioPortUpdateListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Register an audio port list update listener.
 * @hide
 */

Body of Frist Method:
{
    mAudioPortEventHandler.registerListener(l);
}
Body of Second Method:
{
    sAudioPortEventHandler.registerListener(l);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleDrawable.tryRippleEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an enter animation for the active hotspot. Fails if
 * there are too many animating ripples.
 */

Body of Frist Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new Ripple(this, mHotspotBounds, x, y);
    }
    final int color = mState.mColor.getColorForState(getState(), Color.TRANSPARENT);
    mRipple.setup(mState.mMaxRadius, color, mDensity);
    mRipple.enter();
}
Body of Second Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new Ripple(this, mHotspotBounds, x, y);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter();
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.legacy.SurfaceTextureRenderer.drawIntoSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */

Body of Frist Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            drawFrame(mSurfaceTexture, holder.width, holder.height);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
Body of Second Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mParentNodeId);
}
------------------------
Find a functionally equivalent code:android.view.DisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", uniqueId \"");
    sb.append(uniqueId);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.getBluetoothLeAdvertiser:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */

Body of Frist Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
Body of Second Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "bluetooth le advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.clearUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: void clearUsernamePassword()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Clears any saved username/password pairs for web forms.
 * Note that these are unrelated to HTTP authentication credentials.
 *
 * @see WebView#savePassword
 * @see #hasUsernamePassword
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.RadialTimePickerView.getCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current hour in 24-hour time.
 *
 * @return the current hour between 0 and 23 (inclusive)
 */

Body of Frist Method:
{
    int hour = (mSelectionDegrees[mIsOnInnerCircle ? HOURS_INNER : HOURS] / DEGREES_FOR_ONE_HOUR) % 12;
    if (mIs24HourMode) {
        // selector is positioned.
        if (mIsOnInnerCircle && hour == 0) {
            // Inner circle is 1 through 12.
            hour = 12;
        } else if (!mIsOnInnerCircle && hour != 0) {
            // Outer circle is 13 through 23 and 0.
            hour += 12;
        }
    } else if (mAmOrPm == PM) {
        hour += 12;
    }
    return hour;
}
Body of Second Method:
{
    return getHourForDegrees(mSelectionDegrees[mIsOnInnerCircle ? HOURS_INNER : HOURS], mIsOnInnerCircle);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.systemReady:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);
    mKeyguardDelegate.onSystemReady();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
    }
}
Body of Second Method:
{
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext);
    mKeyguardDelegate.onSystemReady();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setUserAgentString:COMMENT
<android.webkit.WebSettings: void setUserAgentString(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the WebView's user-agent string. If the string is null or empty,
 * the system default value will be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.lowLevelReboot:COMMENT
Method Modifier: public      static      
Comment:/**
 * Low-level function to reboot the device. On success, this
 * function doesn't return. If more than 20 seconds passes from
 * the time a reboot is requested (120 seconds for reboot to
 * recovery), this method returns.
 *
 * @param reason code to pass to the kernel (e.g. "recovery"), or null.
 */

Body of Frist Method:
{
    if (reason == null) {
        reason = "";
    }
    long duration;
    if (reason.equals(PowerManager.REBOOT_RECOVERY)) {
        // If we are rebooting to go into recovery, instead of
        // setting sys.powerctl directly we'll start the
        // pre-recovery service which will do some preparation for
        // recovery and then reboot for us.
        // 
        // This preparation can take more than 20 seconds if
        // there's a very large update package, so lengthen the
        // timeout.
        SystemProperties.set("ctl.start", "pre-recovery");
        duration = 120 * 1000L;
    } else {
        SystemProperties.set("sys.powerctl", "reboot," + reason);
        duration = 20 * 1000L;
    }
    try {
        Thread.sleep(duration);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
Body of Second Method:
{
    if (reason == null) {
        reason = "";
    }
    long duration;
    if (reason.equals(PowerManager.REBOOT_RECOVERY)) {
        // If we are rebooting to go into recovery, instead of
        // setting sys.powerctl directly we'll start the
        // pre-recovery service which will do some preparation for
        // recovery and then reboot for us.
        // 
        // This preparation can take more than 20 seconds if
        // there's a very large update package, so lengthen the
        // timeout.  We have seen 750MB packages take 3-4 minutes
        SystemProperties.set("ctl.start", "pre-recovery");
        duration = 300 * 1000L;
    } else {
        SystemProperties.set("sys.powerctl", "reboot," + reason);
        duration = 20 * 1000L;
    }
    try {
        Thread.sleep(duration);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.getRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current ringtone mode.
 *
 * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #setRingerMode(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerMode();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getRingerMode", e);
        return RINGER_MODE_NORMAL;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getRingerMode", e);
        return RINGER_MODE_NORMAL;
    }
}
------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.stopUsingNetworkFeature:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */

Body of Frist Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " + feature);
        return -1;
    }
    NetworkCallback networkCallback = removeRequestForFeature(netCap);
    if (networkCallback != null) {
        Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
        unregisterNetworkCallback(networkCallback);
    }
    return 1;
}
Body of Second Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " + feature);
        return -1;
    }
    if (removeRequestForFeature(netCap)) {
        Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
    }
    return 1;
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.animationFrame:COMMENT
Method Modifier: 
Comment:/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */

Body of Frist Method:
{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}
Body of Second Method:
{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (mDuration == 0 && mRepeatCount != INFINITE) {
                // Skip to the end
                mCurrentIteration = mRepeatCount;
                if (!mReversing) {
                    mPlayingBackwards = false;
                }
            }
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAppCacheEnabled:COMMENT
<android.webkit.WebSettings: void setAppCacheEnabled(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the Application Caches API should be enabled. The default
 * is false. Note that in order for the Application Caches API to be
 * enabled, a valid database path must also be supplied to
 * {@link #setAppCachePath}.
 *
 * @param flag true if the WebView should enable Application Caches
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.startLaunchTaskAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Animates this task view as it exits recents
 */

Body of Frist Method:
{
    if (isLaunchingTask) {
        // Animate the thumbnail alpha back into full opacity for the window animation out
        mThumbnailView.startLaunchTaskAnimation(postAnimRunnable);
        // Animate the dim
        if (mDim > 0) {
            ObjectAnimator anim = ObjectAnimator.ofInt(this, "dim", 0);
            anim.setDuration(mConfig.taskBarExitAnimDuration);
            anim.setInterpolator(mConfig.fastOutLinearInInterpolator);
            anim.start();
        }
        // Animate the action button away
        if (!lockToTask) {
            float toScale = 0.9f;
            mActionButtonView.animate().scaleX(toScale).scaleY(toScale);
        }
        mActionButtonView.animate().alpha(0f).setStartDelay(0).setDuration(mConfig.taskBarExitAnimDuration).setInterpolator(mConfig.fastOutLinearInInterpolator).withLayer().start();
    } else {
        // Hide the dismiss button
        mHeaderView.startLaunchTaskDismissAnimation();
        // animate it away first
        if (occludesLaunchTarget) {
            animate().alpha(0f).translationY(getTranslationY() + mConfig.taskViewAffiliateGroupEnterOffsetPx).setStartDelay(0).setUpdateListener(null).setInterpolator(mConfig.fastOutLinearInInterpolator).setDuration(mConfig.taskBarExitAnimDuration).start();
        }
    }
}
Body of Second Method:
{
    if (isLaunchingTask) {
        // Animate the thumbnail alpha back into full opacity for the window animation out
        mThumbnailView.startLaunchTaskAnimation(postAnimRunnable);
        // Animate the dim
        if (mDimAlpha > 0) {
            ObjectAnimator anim = ObjectAnimator.ofInt(this, "dim", 0);
            anim.setDuration(mConfig.taskViewExitToAppDuration);
            anim.setInterpolator(mConfig.fastOutLinearInInterpolator);
            anim.start();
        }
        // Animate the action button away
        if (!lockToTask) {
            float toScale = 0.9f;
            mActionButtonView.animate().scaleX(toScale).scaleY(toScale);
        }
        mActionButtonView.animate().alpha(0f).setStartDelay(0).setDuration(mConfig.taskViewExitToAppDuration).setInterpolator(mConfig.fastOutLinearInInterpolator).withLayer().start();
    } else {
        // Hide the dismiss button
        mHeaderView.startLaunchTaskDismissAnimation();
        // animate it away first
        if (occludesLaunchTarget) {
            animate().alpha(0f).translationY(getTranslationY() + mConfig.taskViewAffiliateGroupEnterOffsetPx).setStartDelay(0).setUpdateListener(null).setInterpolator(mConfig.fastOutLinearInInterpolator).setDuration(mConfig.taskViewExitToAppDuration).start();
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.Canvas.saveLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Helper version of saveLayer() that takes 4 values rather than a RectF.
 */

Body of Frist Method:
{
    return native_saveLayer(mNativeCanvasWrapper, left, top, right, bottom, paint != null ? paint.mNativePaint : 0, saveFlags);
}
Body of Second Method:
{
    return native_saveLayer(mNativeCanvasWrapper, left, top, right, bottom, paint != null ? paint.mNativePaint : 0, saveFlags);
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.retainIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void retainIconForPageUrl(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Retain the icon for the given page url.
 * @param url The page's url.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setFixedFontFamily:COMMENT
<android.webkit.WebSettings: void setFixedFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the fixed font family name. The default is "monospace".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.prepareEnterRecentsAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Prepares this task view for the enter-recents animations.  This is called earlier in the
 * first layout because the actual animation into recents may take a long time.
 */

Body of Frist Method:
{
    int initialDim = getDim();
    if (mConfig.launchedFromAppWithScreenshot) {
        if (isTaskViewLaunchTargetTask) {
            // Hide the footer during the transition in, and animate it out afterwards?
            if (mFooterView != null) {
                mFooterView.animateFooterVisibility(false, 0);
            }
        } else {
        // Don't do anything for the side views when animating in
        }
    } else if (mConfig.launchedFromAppWithThumbnail) {
        if (isTaskViewLaunchTargetTask) {
            // Hide the action button if it exists
            mActionButtonView.setAlpha(0f);
            // Set the dim to 0 so we can animate it in
            initialDim = 0;
        } else if (occludesLaunchTarget) {
            // Move the task view off screen (below) so we can animate it in
            setTranslationY(offscreenY);
        }
    } else if (mConfig.launchedFromHome) {
        // Move the task view off screen (below) so we can animate it in
        setTranslationY(offscreenY);
        setTranslationZ(0);
        setScaleX(1f);
        setScaleY(1f);
    }
    // Apply the current dim
    setDim(initialDim);
    // Prepare the thumbnail view alpha
    mThumbnailView.prepareEnterRecentsAnimation(isTaskViewLaunchTargetTask);
}
Body of Second Method:
{
    int initialDim = getDim();
    if (mConfig.launchedHasConfigurationChanged) {
    // Just load the views as-is
    } else if (mConfig.launchedFromAppWithThumbnail) {
        if (isTaskViewLaunchTargetTask) {
            // Set the dim to 0 so we can animate it in
            initialDim = 0;
            // Hide the action button
            mActionButtonView.setAlpha(0f);
        } else if (occludesLaunchTarget) {
            // Move the task view off screen (below) so we can animate it in
            setTranslationY(offscreenY);
        }
    } else if (mConfig.launchedFromHome) {
        // Move the task view off screen (below) so we can animate it in
        setTranslationY(offscreenY);
        setTranslationZ(0);
        setScaleX(1f);
        setScaleY(1f);
    }
    // Apply the current dim
    setDim(initialDim);
    // Prepare the thumbnail view alpha
    mThumbnailView.prepareEnterRecentsAnimation(isTaskViewLaunchTargetTask);
}
------------------------
Find a functionally equivalent code:android.util.PathParser.extract:COMMENT
Method Modifier: private     static      
Comment:/**
 * Calculate the position of the next comma or space or negative sign
 * @param s the string to search
 * @param start the position to start searching
 * @param result the result of the extraction, including the position of the
 * the starting position of next number, whether it is ending with a '-'.
 */

Body of Frist Method:
{
    // Now looking for ' ', ',' or '-' from the start.
    int currentIndex = start;
    boolean foundSeparator = false;
    result.mEndWithNegSign = false;
    for (; currentIndex < s.length(); currentIndex++) {
        char currentChar = s.charAt(currentIndex);
        switch(currentChar) {
            case ' ':
            case ',':
                foundSeparator = true;
                break;
            case '-':
                if (currentIndex != start) {
                    foundSeparator = true;
                    result.mEndWithNegSign = true;
                }
                break;
        }
        if (foundSeparator) {
            break;
        }
    }
    // When there is nothing found, then we put the end position to the end
    // of the string.
    result.mEndPosition = currentIndex;
}
Body of Second Method:
{
    // Now looking for ' ', ',', '.' or '-' from the start.
    int currentIndex = start;
    boolean foundSeparator = false;
    result.mEndWithNegOrDot = false;
    boolean secondDot = false;
    boolean isExponential = false;
    for (; currentIndex < s.length(); currentIndex++) {
        boolean isPrevExponential = isExponential;
        isExponential = false;
        char currentChar = s.charAt(currentIndex);
        switch(currentChar) {
            case ' ':
            case ',':
                foundSeparator = true;
                break;
            case '-':
                // The negative sign following a 'e' or 'E' is not a separator.
                if (currentIndex != start && !isPrevExponential) {
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case '.':
                if (!secondDot) {
                    secondDot = true;
                } else {
                    // This is the second dot, and it is considered as a separator.
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case 'e':
            case 'E':
                isExponential = true;
                break;
        }
        if (foundSeparator) {
            break;
        }
    }
    // When there is nothing found, then we put the end position to the end
    // of the string.
    result.mEndPosition = currentIndex;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getUserAgentString:COMMENT
<android.webkit.WebSettings: String getUserAgentString()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the WebView's user-agent string.
 *
 * @return the WebView's user-agent string
 * @see #setUserAgentString
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.AsyncTask.publishProgress:COMMENT
Method Modifier: protected   final       
Comment:/**
 * This method can be invoked from {@link #doInBackground} to
 * publish updates on the UI thread while the background computation is
 * still running. Each call to this method will trigger the execution of
 * {@link #onProgressUpdate} on the UI thread.
 *
 * {@link #onProgressUpdate} will not be called if the task has been
 * canceled.
 *
 * @param values The progress values to update the UI with.
 *
 * @see #onProgressUpdate
 * @see #doInBackground
 */

Body of Frist Method:
{
    if (!isCancelled()) {
        sHandler.obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult<Progress>(this, values)).sendToTarget();
    }
}
Body of Second Method:
{
    if (!isCancelled()) {
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult<Progress>(this, values)).sendToTarget();
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.setupTabHost:COMMENT
Method Modifier: private     
Comment:/**
 * Sets up a {@link TabHost} object.
 * @param tabHost the TabHost to setup.
 * @param projectCallback The project callback object to access the project R class.
 * @throws PostInflateException
 */

Body of Frist Method:
{
    // look for the TabWidget, and the FrameLayout. They have their own specific names
    View v = tabHost.findViewById(android.R.id.tabs);
    if (v == null) {
        throw new PostInflateException("TabHost requires a TabWidget with id \"android:id/tabs\".\n");
    }
    if (!(v instanceof TabWidget)) {
        throw new PostInflateException(String.format("TabHost requires a TabWidget with id \"android:id/tabs\".\n" + "View found with id 'tabs' is '%s'", v.getClass().getCanonicalName()));
    }
    v = tabHost.findViewById(android.R.id.tabcontent);
    if (v == null) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException("TabHost requires a FrameLayout with id \"android:id/tabcontent\".");
    }
    if (!(v instanceof FrameLayout)) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException(String.format("TabHost requires a FrameLayout with id \"android:id/tabcontent\".\n" + "View found with id 'tabcontent' is '%s'", v.getClass().getCanonicalName()));
    }
    FrameLayout content = (FrameLayout) v;
    // now process the content of the frameLayout and dynamically create tabs for it.
    final int count = content.getChildCount();
    // this must be called before addTab() so that the TabHost searches its TabWidget
    // and FrameLayout.
    tabHost.setup();
    if (count == 0) {
        // Create a dummy child to get a single tab
        TabSpec spec = tabHost.newTabSpec("tag").setIndicator("Tab Label", tabHost.getResources().getDrawable(android.R.drawable.ic_menu_info_details)).setContent(new TabHost.TabContentFactory() {

            @Override
            public View createTabContent(String tag) {
                return new LinearLayout(getContext());
            }
        });
        tabHost.addTab(spec);
    } else {
        // for each child of the frameLayout, add a new TabSpec
        for (int i = 0; i < count; i++) {
            View child = content.getChildAt(i);
            String tabSpec = String.format("tab_spec%d", i + 1);
            int id = child.getId();
            @SuppressWarnings("deprecation") Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
            String name;
            if (resource != null) {
                name = resource.getSecond();
            } else {
                // default name if id is unresolved.
                name = String.format("Tab %d", i + 1);
            }
            tabHost.addTab(tabHost.newTabSpec(tabSpec).setIndicator(name).setContent(id));
        }
    }
}
Body of Second Method:
{
    // look for the TabWidget, and the FrameLayout. They have their own specific names
    View v = tabHost.findViewById(android.R.id.tabs);
    if (v == null) {
        throw new PostInflateException("TabHost requires a TabWidget with id \"android:id/tabs\".\n");
    }
    if (!(v instanceof TabWidget)) {
        throw new PostInflateException(String.format("TabHost requires a TabWidget with id \"android:id/tabs\".\n" + "View found with id 'tabs' is '%s'", v.getClass().getCanonicalName()));
    }
    v = tabHost.findViewById(android.R.id.tabcontent);
    if (v == null) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException("TabHost requires a FrameLayout with id \"android:id/tabcontent\".");
    }
    if (!(v instanceof FrameLayout)) {
        // noinspection SpellCheckingInspection
        throw new PostInflateException(String.format("TabHost requires a FrameLayout with id \"android:id/tabcontent\".\n" + "View found with id 'tabcontent' is '%s'", v.getClass().getCanonicalName()));
    }
    FrameLayout content = (FrameLayout) v;
    // now process the content of the frameLayout and dynamically create tabs for it.
    final int count = content.getChildCount();
    // this must be called before addTab() so that the TabHost searches its TabWidget
    // and FrameLayout.
    tabHost.setup();
    if (count == 0) {
        // Create a dummy child to get a single tab
        TabSpec spec = tabHost.newTabSpec("tag").setIndicator("Tab Label", tabHost.getResources().getDrawable(android.R.drawable.ic_menu_info_details)).setContent(new TabHost.TabContentFactory() {

            @Override
            public View createTabContent(String tag) {
                return new LinearLayout(getContext());
            }
        });
        tabHost.addTab(spec);
    } else {
        // for each child of the frameLayout, add a new TabSpec
        for (int i = 0; i < count; i++) {
            View child = content.getChildAt(i);
            String tabSpec = String.format("tab_spec%d", i + 1);
            // child cannot be null.
            @SuppressWarnings("ConstantConditions") int id = child.getId();
            @SuppressWarnings("deprecation") Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
            String name;
            if (resource != null) {
                name = resource.getSecond();
            } else {
                // default name if id is unresolved.
                name = String.format("Tab %d", i + 1);
            }
            tabHost.addTab(tabHost.newTabSpec(tabSpec).setIndicator(name).setContent(id));
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getMediaPlaybackRequiresUserGesture:COMMENT
<android.webkit.WebSettings: boolean getMediaPlaybackRequiresUserGesture()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView requires a user gesture to play media.
 *
 * @return true if the WebView requires a user gesture to play media
 * @see #setMediaPlaybackRequiresUserGesture
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.doAnimationFrame:COMMENT
Method Modifier: default     final       
Comment:/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */

Body of Frist Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = frameTime;
        } else {
            mStartTime = frameTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
Body of Second Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
------------------------
Find a functionally equivalent code:com.android.server.net.NetworkStatsRecorder.getOrLoadCompleteLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Load complete history represented by {@link FileRotator}. Caches
 * internally as a {@link WeakReference}, and updated with future
 * {@link #recordSnapshotLocked(NetworkStats, Map, long)} snapshots as long
 * as reference is valid.
 */

Body of Frist Method:
{
    NetworkStatsCollection complete = mComplete != null ? mComplete.get() : null;
    if (complete == null) {
        if (LOGD)
            Slog.d(TAG, "getOrLoadCompleteLocked() reading from disk for " + mCookie);
        try {
            complete = new NetworkStatsCollection(mBucketDuration);
            mRotator.readMatching(complete, Long.MIN_VALUE, Long.MAX_VALUE);
            complete.recordCollection(mPending);
            mComplete = new WeakReference<NetworkStatsCollection>(complete);
        } catch (IOException e) {
            Log.wtf(TAG, "problem completely reading network stats", e);
            recoverFromWtf();
        } catch (OutOfMemoryError e) {
            Log.wtf(TAG, "problem completely reading network stats", e);
            recoverFromWtf();
        }
    }
    return complete;
}
Body of Second Method:
{
    NetworkStatsCollection res = mComplete != null ? mComplete.get() : null;
    if (res == null) {
        res = loadLocked(Long.MIN_VALUE, Long.MAX_VALUE);
        mComplete = new WeakReference<NetworkStatsCollection>(res);
    }
    return res;
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.ExpandableNotificationRow.isClearable:COMMENT
Method Modifier: public      
Comment:/**
 * @return Can the underlying notification be cleared?
 */

Body of Frist Method:
{
    return mClearable;
}
Body of Second Method:
{
    return mStatusBarNotification != null && mStatusBarNotification.isClearable();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.setDim:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current dim.
 */

Body of Frist Method:
{
    mDim = dim;
    if (mDimAnimator != null) {
        mDimAnimator.removeAllListeners();
        mDimAnimator.cancel();
    }
    if (mConfig.useHardwareLayers) {
        // Defer setting hardware layers if we have not yet measured, or there is no dim to draw
        if (getMeasuredWidth() > 0 && getMeasuredHeight() > 0) {
            if (mDimAnimator != null) {
                mDimAnimator.removeAllListeners();
                mDimAnimator.cancel();
            }
            int inverse = 255 - mDim;
            mDimColorFilter.setColor(Color.argb(0xFF, inverse, inverse, inverse));
            mLayerPaint.setColorFilter(mDimColorFilter);
            mContent.setLayerType(LAYER_TYPE_HARDWARE, mLayerPaint);
        }
    } else {
        float dimAlpha = mDim / 255.0f;
        if (mThumbnailView != null) {
            mThumbnailView.setDimAlpha(dimAlpha);
        }
        if (mHeaderView != null) {
            mHeaderView.setDimAlpha(dim);
        }
    }
}
Body of Second Method:
{
    mDimAlpha = dim;
    if (mConfig.useHardwareLayers) {
        // Defer setting hardware layers if we have not yet measured, or there is no dim to draw
        if (getMeasuredWidth() > 0 && getMeasuredHeight() > 0) {
            mDimColorFilter.setColor(Color.argb(mDimAlpha, 0, 0, 0));
            mDimLayerPaint.setColorFilter(mDimColorFilter);
            mContent.setLayerType(LAYER_TYPE_HARDWARE, mDimLayerPaint);
        }
    } else {
        float dimAlpha = mDimAlpha / 255.0f;
        if (mThumbnailView != null) {
            mThumbnailView.setDimAlpha(dimAlpha);
        }
        if (mHeaderView != null) {
            mHeaderView.setDimAlpha(dim);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.Bridge.getResourceId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the integer id of a framework resource, from a given resource type and resource name.
 * @param type the type of the resource
 * @param name the name of the resource.
 * @return an {@link Integer} containing the resource id, or null if no resource were found.
 */

Body of Frist Method:
{
    Map<String, Integer> map = sRevRMap.get(type);
    Integer value = null;
    if (map != null) {
        value = map.get(name);
    }
    if (value == null) {
        value = sDynamicIds.getId(type, name);
    }
    return value;
}
Body of Second Method:
{
    Map<String, Integer> map = sRevRMap.get(type);
    Integer value = null;
    if (map != null) {
        value = map.get(name);
    }
    return value == null ? sDynamicIds.getId(type, name) : value;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGattCharacteristic.getStringValue:COMMENT
Method Modifier: public      
Comment:/**
 * Return the stored value of this characteristic.
 * <p>See {@link #getValue} for details.
 *
 * @param offset Offset at which the string value can be found.
 * @return Cached value of the characteristic
 */

Body of Frist Method:
{
    if (offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}
Body of Second Method:
{
    if (mValue == null || offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.acceptThirdPartyCookies:COMMENT
<android.webkit.CookieManager: boolean acceptThirdPartyCookies(WebView)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the {@link WebView} should allow third party cookies to be set.
 *
 * @param webview the {@link WebView} instance to get the cookie policy for
 * @return true if the {@link WebView} accepts third party cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.getHitTestResult:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the "extra" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the "extra" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the "extra" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the "extra" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the "extra" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "getHitTestResult");
    return mProvider.getHitTestResult();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "getHitTestResult");
    return mProvider.getHitTestResult();
}
------------------------
Find a functionally equivalent code:android.media.tv.TvInputManager.Session.selectTrack:COMMENT
Method Modifier: public      
Comment:/**
 * Selects a track.
 *
 * @param type The type of the track to select. The type can be
 * {@link TvTrackInfo#TYPE_AUDIO}, {@link TvTrackInfo#TYPE_VIDEO} or
 * {@link TvTrackInfo#TYPE_SUBTITLE}.
 * @param trackId The ID of the track to select. When {@code null}, the currently selected
 * track of the given type will be unselected.
 * @see #getTracks
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        if (trackId != null && !containsTrack(mAudioTracks, trackId)) {
            Log.w(TAG, "Invalid audio trackId: " + trackId);
            return;
        }
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        if (trackId != null && !containsTrack(mVideoTracks, trackId)) {
            Log.w(TAG, "Invalid video trackId: " + trackId);
            return;
        }
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        if (trackId != null && !containsTrack(mSubtitleTracks, trackId)) {
            Log.w(TAG, "Invalid subtitle trackId: " + trackId);
            return;
        }
    } else {
        throw new IllegalArgumentException("invalid type: " + type);
    }
    if (mToken == null) {
        Log.w(TAG, "The session has been already released");
        return;
    }
    try {
        mService.selectTrack(mToken, type, trackId, mUserId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            if (trackId != null && !containsTrack(mAudioTracks, trackId)) {
                Log.w(TAG, "Invalid audio trackId: " + trackId);
                return;
            }
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            if (trackId != null && !containsTrack(mVideoTracks, trackId)) {
                Log.w(TAG, "Invalid video trackId: " + trackId);
                return;
            }
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            if (trackId != null && !containsTrack(mSubtitleTracks, trackId)) {
                Log.w(TAG, "Invalid subtitle trackId: " + trackId);
                return;
            }
        } else {
            throw new IllegalArgumentException("invalid type: " + type);
        }
    }
    if (mToken == null) {
        Log.w(TAG, "The session has been already released");
        return;
    }
    try {
        mService.selectTrack(mToken, type, trackId, mUserId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.setNetworkAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * Informs WebView of the network state. This is used to set
 * the JavaScript property window.navigator.isOnline and
 * generates the online/offline event as specified in HTML5, sec. 5.7.7
 *
 * @param networkUp a boolean indicating if network is available
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setNetworkAvailable=" + networkUp);
    mProvider.setNetworkAvailable(networkUp);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setNetworkAvailable=" + networkUp);
    mProvider.setNetworkAvailable(networkUp);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.GlobalKeyManager.handleGlobalKey:COMMENT
Method Modifier: internal    
Comment:/**
 * Broadcasts an intent if the keycode is part of the global key mapping.
 *
 * @param context context used to broadcast the event
 * @param keyCode keyCode which triggered this function
 * @param event keyEvent which trigged this function
 * @return {@code true} if this was handled
 */

Body of Frist Method:
{
    if (mKeyMapping.size() > 0) {
        ComponentName component = mKeyMapping.get(keyCode);
        if (component != null) {
            Intent intent = new Intent(Intent.ACTION_GLOBAL_BUTTON).setComponent(component).putExtra(Intent.EXTRA_KEY_EVENT, event);
            context.sendBroadcastAsUser(intent, UserHandle.CURRENT, null);
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (mKeyMapping.size() > 0) {
        ComponentName component = mKeyMapping.get(keyCode);
        if (component != null) {
            Intent intent = new Intent(Intent.ACTION_GLOBAL_BUTTON).setComponent(component).setFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(Intent.EXTRA_KEY_EVENT, event);
            context.sendBroadcastAsUser(intent, UserHandle.CURRENT, null);
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.allDefaultsSelected:COMMENT
<android.telephony.SubscriptionManager: boolean allDefaultsSelected()>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getDefaultDataSubId() == INVALID_SUB_ID) {
        return false;
    }
    if (getDefaultSmsSubId() == INVALID_SUB_ID) {
        return false;
    }
    if (getDefaultVoiceSubId() == INVALID_SUB_ID) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(getDefaultDataSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultSmsSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultVoiceSubId())) {
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.server.wm.DragState.register:COMMENT
Method Modifier: 
Comment:/**
 * @param display The Display that the window being dragged is on.
 */

Body of Frist Method:
{
    mDisplay = display;
    if (WindowManagerService.DEBUG_DRAG)
        Slog.d(WindowManagerService.TAG, "registering drag input channel");
    if (mClientChannel != null) {
        Slog.e(WindowManagerService.TAG, "Duplicate register of drag input channel");
    } else {
        InputChannel[] channels = InputChannel.openInputChannelPair("drag");
        mServerChannel = channels[0];
        mClientChannel = channels[1];
        mService.mInputManager.registerInputChannel(mServerChannel, null);
        mInputEventReceiver = mService.new DragInputEventReceiver(mClientChannel, mService.mH.getLooper());
        mDragApplicationHandle = new InputApplicationHandle(null);
        mDragApplicationHandle.name = "drag";
        mDragApplicationHandle.dispatchingTimeoutNanos = WindowManagerService.DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
        mDragWindowHandle = new InputWindowHandle(mDragApplicationHandle, null, mDisplay.getDisplayId());
        mDragWindowHandle.name = "drag";
        mDragWindowHandle.inputChannel = mServerChannel;
        mDragWindowHandle.layer = getDragLayerLw();
        mDragWindowHandle.layoutParamsFlags = 0;
        mDragWindowHandle.layoutParamsPrivateFlags = 0;
        mDragWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_DRAG;
        mDragWindowHandle.dispatchingTimeoutNanos = WindowManagerService.DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
        mDragWindowHandle.visible = true;
        mDragWindowHandle.canReceiveKeys = false;
        mDragWindowHandle.hasFocus = true;
        mDragWindowHandle.hasWallpaper = false;
        mDragWindowHandle.paused = false;
        mDragWindowHandle.ownerPid = Process.myPid();
        mDragWindowHandle.ownerUid = Process.myUid();
        mDragWindowHandle.inputFeatures = 0;
        mDragWindowHandle.scaleFactor = 1.0f;
        // The drag window cannot receive new touches.
        mDragWindowHandle.touchableRegion.setEmpty();
        // The drag window covers the entire display
        mDragWindowHandle.frameLeft = 0;
        mDragWindowHandle.frameTop = 0;
        Point p = new Point();
        mDisplay.getRealSize(p);
        mDragWindowHandle.frameRight = p.x;
        mDragWindowHandle.frameBottom = p.y;
        // Pause rotations before a drag.
        if (WindowManagerService.DEBUG_ORIENTATION) {
            Slog.d(WindowManagerService.TAG, "Pausing rotation during drag");
        }
        mService.pauseRotationLocked();
    }
}
Body of Second Method:
{
    mDisplay = display;
    if (WindowManagerService.DEBUG_DRAG)
        Slog.d(WindowManagerService.TAG, "registering drag input channel");
    if (mClientChannel != null) {
        Slog.e(WindowManagerService.TAG, "Duplicate register of drag input channel");
    } else {
        InputChannel[] channels = InputChannel.openInputChannelPair("drag");
        mServerChannel = channels[0];
        mClientChannel = channels[1];
        mService.mInputManager.registerInputChannel(mServerChannel, null);
        mInputEventReceiver = mService.new DragInputEventReceiver(mClientChannel, mService.mH.getLooper());
        mDragApplicationHandle = new InputApplicationHandle(null);
        mDragApplicationHandle.name = "drag";
        mDragApplicationHandle.dispatchingTimeoutNanos = WindowManagerService.DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
        mDragWindowHandle = new InputWindowHandle(mDragApplicationHandle, null, mDisplay.getDisplayId());
        mDragWindowHandle.name = "drag";
        mDragWindowHandle.inputChannel = mServerChannel;
        mDragWindowHandle.layer = getDragLayerLw();
        mDragWindowHandle.layoutParamsFlags = 0;
        mDragWindowHandle.layoutParamsType = WindowManager.LayoutParams.TYPE_DRAG;
        mDragWindowHandle.dispatchingTimeoutNanos = WindowManagerService.DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
        mDragWindowHandle.visible = true;
        mDragWindowHandle.canReceiveKeys = false;
        mDragWindowHandle.hasFocus = true;
        mDragWindowHandle.hasWallpaper = false;
        mDragWindowHandle.paused = false;
        mDragWindowHandle.ownerPid = Process.myPid();
        mDragWindowHandle.ownerUid = Process.myUid();
        mDragWindowHandle.inputFeatures = 0;
        mDragWindowHandle.scaleFactor = 1.0f;
        // The drag window cannot receive new touches.
        mDragWindowHandle.touchableRegion.setEmpty();
        // The drag window covers the entire display
        mDragWindowHandle.frameLeft = 0;
        mDragWindowHandle.frameTop = 0;
        Point p = new Point();
        mDisplay.getRealSize(p);
        mDragWindowHandle.frameRight = p.x;
        mDragWindowHandle.frameBottom = p.y;
        // Pause rotations before a drag.
        if (WindowManagerService.DEBUG_ORIENTATION) {
            Slog.d(WindowManagerService.TAG, "Pausing rotation during drag");
        }
        mService.pauseRotationLocked();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.setLockPatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Set whether the lock pattern is enabled.
 */

Body of Frist Method:
{
    setBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, enabled);
}
Body of Second Method:
{
    setBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, enabled, userHandle);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDomStorageEnabled:COMMENT
<android.webkit.WebSettings: boolean getDomStorageEnabled()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the DOM Storage APIs are enabled.
 *
 * @return true if the DOM Storage APIs are enabled
 * @see #setDomStorageEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.isValidPhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // value is invalid.
    return phoneId != INVALID_PHONE_ID && phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
}
Body of Second Method:
{
    return phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.updateWakeLockSummaryLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the value of mWakeLockSummary to summarize the state of all active wake locks.
 * Note that most wake-locks are ignored when the system is asleep.
 *
 * This function must have no other side-effects.
 */

Body of Frist Method:
{
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_WAKEFULNESS)) != 0) {
        mWakeLockSummary = 0;
        final int numWakeLocks = mWakeLocks.size();
        for (int i = 0; i < numWakeLocks; i++) {
            final WakeLock wakeLock = mWakeLocks.get(i);
            switch(wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) {
                case PowerManager.PARTIAL_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_CPU;
                    break;
                case PowerManager.FULL_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_BUTTON_BRIGHT;
                    break;
                case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT;
                    break;
                case PowerManager.SCREEN_DIM_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_DIM;
                    break;
                case PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_PROXIMITY_SCREEN_OFF;
                    break;
                case PowerManager.DOZE_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_DOZE;
                    break;
            }
        }
        // Cancel wake locks that make no sense based on the current state.
        if (mWakefulness != WAKEFULNESS_DOZING) {
            mWakeLockSummary &= ~WAKE_LOCK_DOZE;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || (mWakeLockSummary & WAKE_LOCK_DOZE) != 0) {
            mWakeLockSummary &= ~(WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM | WAKE_LOCK_BUTTON_BRIGHT);
            if (mWakefulness == WAKEFULNESS_ASLEEP) {
                mWakeLockSummary &= ~WAKE_LOCK_PROXIMITY_SCREEN_OFF;
            }
        }
        // Infer implied wake locks where necessary based on the current state.
        if ((mWakeLockSummary & (WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM)) != 0) {
            if (mWakefulness == WAKEFULNESS_AWAKE) {
                mWakeLockSummary |= WAKE_LOCK_CPU | WAKE_LOCK_STAY_AWAKE;
            } else if (mWakefulness == WAKEFULNESS_DREAMING) {
                mWakeLockSummary |= WAKE_LOCK_CPU;
            }
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateWakeLockSummaryLocked: mWakefulness=" + wakefulnessToString(mWakefulness) + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary));
        }
    }
}
Body of Second Method:
{
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_WAKEFULNESS)) != 0) {
        mWakeLockSummary = 0;
        final int numWakeLocks = mWakeLocks.size();
        for (int i = 0; i < numWakeLocks; i++) {
            final WakeLock wakeLock = mWakeLocks.get(i);
            switch(wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) {
                case PowerManager.PARTIAL_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_CPU;
                    break;
                case PowerManager.FULL_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_BUTTON_BRIGHT;
                    break;
                case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT;
                    break;
                case PowerManager.SCREEN_DIM_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_SCREEN_DIM;
                    break;
                case PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_PROXIMITY_SCREEN_OFF;
                    break;
                case PowerManager.DOZE_WAKE_LOCK:
                    mWakeLockSummary |= WAKE_LOCK_DOZE;
                    break;
            }
        }
        // Cancel wake locks that make no sense based on the current state.
        if (mWakefulness != WAKEFULNESS_DOZING) {
            mWakeLockSummary &= ~WAKE_LOCK_DOZE;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || (mWakeLockSummary & WAKE_LOCK_DOZE) != 0) {
            mWakeLockSummary &= ~(WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM | WAKE_LOCK_BUTTON_BRIGHT);
            if (mWakefulness == WAKEFULNESS_ASLEEP) {
                mWakeLockSummary &= ~WAKE_LOCK_PROXIMITY_SCREEN_OFF;
            }
        }
        // Infer implied wake locks where necessary based on the current state.
        if ((mWakeLockSummary & (WAKE_LOCK_SCREEN_BRIGHT | WAKE_LOCK_SCREEN_DIM)) != 0) {
            if (mWakefulness == WAKEFULNESS_AWAKE) {
                mWakeLockSummary |= WAKE_LOCK_CPU | WAKE_LOCK_STAY_AWAKE;
            } else if (mWakefulness == WAKEFULNESS_DREAMING) {
                mWakeLockSummary |= WAKE_LOCK_CPU;
            }
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateWakeLockSummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mWakeLockSummary=0x" + Integer.toHexString(mWakeLockSummary));
        }
    }
}
------------------------
Find a functionally equivalent code:android.view.Surface.unlockCanvasAndPost:COMMENT
Method Modifier: public      
Comment:/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */

Body of Frist Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Long.toHexString(mNativeObject) + ") != mLockedObject (0x" + Long.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext != null) {
            mHwuiContext.unlockAndPost(canvas);
        } else {
            unlockSwCanvasAndPost(canvas);
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.onActionViewExpanded:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mQueryTextView.getImeOptions();
    mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mQueryTextView.setText("");
    setIconified(false);
}
Body of Second Method:
{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mSearchSrcTextView.getImeOptions();
    mSearchSrcTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mSearchSrcTextView.setText("");
    setIconified(false);
}
------------------------
Find a functionally equivalent code:android.provider.DocumentsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */

Body of Frist Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
Body of Second Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.clearHttpAuthUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: void clearHttpAuthUsernamePassword()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clears any saved credentials for HTTP authentication.
 *
 * @see WebView#getHttpAuthUsernamePassword
 * @see WebView#setHttpAuthUsernamePassword
 * @see #hasHttpAuthUsernamePassword
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setUserAgent:COMMENT
<android.webkit.WebSettings: void setUserAgent(int)>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets the user-agent string using an integer code.
 * <ul>
 * <li>0 means the WebView should use an Android user-agent string</li>
 * <li>1 means the WebView should use a desktop user-agent string</li>
 * </ul>
 * Other values are ignored. The default is an Android user-agent string,
 * i.e. code value 0.
 *
 * @param ua the integer code for the user-agent string
 * @deprecated Please use {@link #setUserAgentString} instead.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebBackForwardList.getSize:COMMENT
<android.webkit.WebBackForwardList: int getSize()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the total size of the back/forward list.
 * @return The size of the list.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.ViewTreeObserver.merge:COMMENT
Method Modifier: 
Comment:/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */

Body of Frist Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    observer.kill();
}
Body of Second Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    observer.kill();
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteInit.preloadClasses:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Performs Zygote process initialization. Loads and initializes
 * commonly used classes.
 *
 * Most classes only cause a few hundred bytes to be allocated, but
 * a few will allocate a dozen Kbytes (in one case, 500+K).
 */

Body of Frist Method:
{
    final VMRuntime runtime = VMRuntime.getRuntime();
    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(PRELOADED_CLASSES);
    if (is == null) {
        Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
    } else {
        Log.i(TAG, "Preloading classes...");
        long startTime = SystemClock.uptimeMillis();
        // Drop root perms while running static initializers.
        setEffectiveGroup(UNPRIVILEGED_GID);
        setEffectiveUser(UNPRIVILEGED_UID);
        // Alter the target heap utilization.  With explicit GCs this
        // is not likely to have any effect.
        float defaultUtilization = runtime.getTargetHeapUtilization();
        runtime.setTargetHeapUtilization(0.8f);
        // Start with a clean slate.
        System.gc();
        runtime.runFinalizationSync();
        Debug.startAllocCounting();
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(is), 256);
            int count = 0;
            String line;
            while ((line = br.readLine()) != null) {
                // Skip comments and blank lines.
                line = line.trim();
                if (line.startsWith("#") || line.equals("")) {
                    continue;
                }
                try {
                    if (false) {
                        Log.v(TAG, "Preloading " + line + "...");
                    }
                    Class.forName(line);
                    if (Debug.getGlobalAllocSize() > PRELOAD_GC_THRESHOLD) {
                        if (false) {
                            Log.v(TAG, " GC at " + Debug.getGlobalAllocSize());
                        }
                        System.gc();
                        runtime.runFinalizationSync();
                        Debug.resetGlobalAllocSize();
                    }
                    count++;
                } catch (ClassNotFoundException e) {
                    Log.w(TAG, "Class not found for preloading: " + line);
                } catch (UnsatisfiedLinkError e) {
                    Log.w(TAG, "Problem preloading " + line + ": " + e);
                } catch (Throwable t) {
                    Log.e(TAG, "Error preloading " + line + ".", t);
                    if (t instanceof Error) {
                        throw (Error) t;
                    }
                    if (t instanceof RuntimeException) {
                        throw (RuntimeException) t;
                    }
                    throw new RuntimeException(t);
                }
            }
            Log.i(TAG, "...preloaded " + count + " classes in " + (SystemClock.uptimeMillis() - startTime) + "ms.");
        } catch (IOException e) {
            Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
        } finally {
            IoUtils.closeQuietly(is);
            // Restore default.
            runtime.setTargetHeapUtilization(defaultUtilization);
            // Fill in dex caches with classes, fields, and methods brought in by preloading.
            runtime.preloadDexCaches();
            Debug.stopAllocCounting();
            // Bring back root. We'll need it later.
            setEffectiveUser(ROOT_UID);
            setEffectiveGroup(ROOT_GID);
        }
    }
}
Body of Second Method:
{
    final VMRuntime runtime = VMRuntime.getRuntime();
    InputStream is;
    try {
        is = new FileInputStream(PRELOADED_CLASSES);
    } catch (FileNotFoundException e) {
        Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
        return;
    }
    Log.i(TAG, "Preloading classes...");
    long startTime = SystemClock.uptimeMillis();
    // Drop root perms while running static initializers.
    setEffectiveGroup(UNPRIVILEGED_GID);
    setEffectiveUser(UNPRIVILEGED_UID);
    // Alter the target heap utilization.  With explicit GCs this
    // is not likely to have any effect.
    float defaultUtilization = runtime.getTargetHeapUtilization();
    runtime.setTargetHeapUtilization(0.8f);
    // Start with a clean slate.
    System.gc();
    runtime.runFinalizationSync();
    Debug.startAllocCounting();
    try {
        BufferedReader br = new BufferedReader(new InputStreamReader(is), 256);
        int count = 0;
        String line;
        while ((line = br.readLine()) != null) {
            // Skip comments and blank lines.
            line = line.trim();
            if (line.startsWith("#") || line.equals("")) {
                continue;
            }
            try {
                if (false) {
                    Log.v(TAG, "Preloading " + line + "...");
                }
                Class.forName(line);
                if (Debug.getGlobalAllocSize() > PRELOAD_GC_THRESHOLD) {
                    if (false) {
                        Log.v(TAG, " GC at " + Debug.getGlobalAllocSize());
                    }
                    System.gc();
                    runtime.runFinalizationSync();
                    Debug.resetGlobalAllocSize();
                }
                count++;
            } catch (ClassNotFoundException e) {
                Log.w(TAG, "Class not found for preloading: " + line);
            } catch (UnsatisfiedLinkError e) {
                Log.w(TAG, "Problem preloading " + line + ": " + e);
            } catch (Throwable t) {
                Log.e(TAG, "Error preloading " + line + ".", t);
                if (t instanceof Error) {
                    throw (Error) t;
                }
                if (t instanceof RuntimeException) {
                    throw (RuntimeException) t;
                }
                throw new RuntimeException(t);
            }
        }
        Log.i(TAG, "...preloaded " + count + " classes in " + (SystemClock.uptimeMillis() - startTime) + "ms.");
    } catch (IOException e) {
        Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
    } finally {
        IoUtils.closeQuietly(is);
        // Restore default.
        runtime.setTargetHeapUtilization(defaultUtilization);
        // Fill in dex caches with classes, fields, and methods brought in by preloading.
        runtime.preloadDexCaches();
        Debug.stopAllocCounting();
        // Bring back root. We'll need it later.
        setEffectiveUser(ROOT_UID);
        setEffectiveGroup(ROOT_GID);
    }
}
------------------------
Find a functionally equivalent code:android.widget.TextClock.is24HourModeEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Indicates whether the system is currently using the 24-hour mode.
 *
 * When the system is in 24-hour mode, this view will use the pattern
 * returned by {@link #getFormat24Hour()}. In 12-hour mode, the pattern
 * returned by {@link #getFormat12Hour()} is used instead.
 *
 * If either one of the formats is null, the other format is used. If
 * both formats are null, the default formats for the current locale are used.
 *
 * @return true if time should be displayed in 24-hour format, false if it
 * should be displayed in 12-hour format.
 *
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */

Body of Frist Method:
{
    return DateFormat.is24HourFormat(getContext());
}
Body of Second Method:
{
    if (mShowCurrentUserTime) {
        return DateFormat.is24HourFormat(getContext(), ActivityManager.getCurrentUser());
    } else {
        return DateFormat.is24HourFormat(getContext());
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.isValidRingerMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks valid ringer mode values.
 *
 * @return true if the ringer mode indicated is valid, false otherwise.
 *
 * @see #setRingerMode(int)
 * @hide
 */

Body of Frist Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isValidRingerMode", e);
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.widget.DayPickerView.goTo:COMMENT
<android.widget.DayPickerView: boolean goTo(Calendar,boolean,boolean,boolean)>
Method Modifier: public      private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * This moves to the specified time in the view. If the time is not already
 * in range it will move the list so that the first of the month containing
 * the time is at the top of the view. If the new time is already in view
 * the list will not be scrolled unless forceScroll is true. This time may
 * optionally be highlighted as selected as well.
 *
 * @param day The day to move to
 * @param animate Whether to scroll to the given time or just redraw at the
 * new location
 * @param setSelected Whether to set the given time as selected
 * @param forceScroll Whether to recenter even if the time is already
 * visible
 * @return Whether or not the view animated to the new location
 */

Body of Frist Method:
{
    // Set the selected day
    if (setSelected) {
        mSelectedDay.setTimeInMillis(day.getTimeInMillis());
    }
    mTempDay.setTimeInMillis(day.getTimeInMillis());
    final int position = getPositionFromDay(day);
    View child;
    int i = 0;
    int top = 0;
    // Find a child that's completely in the view
    do {
        child = getChildAt(i++);
        if (child == null) {
            break;
        }
        top = child.getTop();
    } while (top < 0);
    // Compute the first and last position visible
    int selectedPosition;
    if (child != null) {
        selectedPosition = getPositionForView(child);
    } else {
        selectedPosition = 0;
    }
    if (setSelected) {
        mAdapter.setSelectedDay(mSelectedDay);
    }
    // and if so scroll to the month that contains it
    if (position != selectedPosition || forceScroll) {
        setMonthDisplayed(mTempDay);
        mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;
        if (animate) {
            smoothScrollToPositionFromTop(position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);
            return true;
        } else {
            postSetSelection(position);
        }
    } else if (setSelected) {
        setMonthDisplayed(mSelectedDay);
    }
    return false;
}
Body of Second Method:
{
    // Set the selected day
    if (setSelected) {
        mSelectedDay.setTimeInMillis(day);
    }
    mTempDay.setTimeInMillis(day);
    final int position = getPositionFromDay(day);
    View child;
    int i = 0;
    int top = 0;
    // Find a child that's completely in the view
    do {
        child = getChildAt(i++);
        if (child == null) {
            break;
        }
        top = child.getTop();
    } while (top < 0);
    // Compute the first and last position visible
    int selectedPosition;
    if (child != null) {
        selectedPosition = getPositionForView(child);
    } else {
        selectedPosition = 0;
    }
    if (setSelected) {
        mAdapter.setSelectedDay(mSelectedDay);
    }
    // and if so scroll to the month that contains it
    if (position != selectedPosition || forceScroll) {
        setMonthDisplayed(mTempDay);
        mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;
        if (animate) {
            smoothScrollToPositionFromTop(position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);
            return true;
        } else {
            postSetSelection(position);
        }
    } else if (setSelected) {
        setMonthDisplayed(mSelectedDay);
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.close:COMMENT
<android.webkit.WebIconDatabase: void close()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Close the shared instance of the icon database.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
Body of Second Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mTraversalBefore = ROOT_NODE_ID;
    mTraversalAfter = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getFantasyFontFamily:COMMENT
<android.webkit.WebSettings: String getFantasyFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the fantasy font family name.
 *
 * @return the fantasy font family name as a string
 * @see #setFantasyFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.hdmi.HdmiCecKeycode.isSupportedKeycode:COMMENT
Method Modifier: default     static      
Comment:/**
 * Returns {@code true} if given Android keycode is supported, otherwise {@code false}.
 */

Body of Frist Method:
{
    return HdmiCecKeycode.androidKeyToCecKey(androidKeycode) != HdmiCecKeycode.UNSUPPORTED_KEYCODE;
}
Body of Second Method:
{
    return HdmiCecKeycode.androidKeyToCecKey(androidKeycode) != null;
}
------------------------
Find a functionally equivalent code:com.android.server.display.LogicalDisplay.updateLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Updates the state of the logical display based on the available display devices.
 * The logical display might become invalid if it is attached to a display device
 * that no longer exists.
 *
 * @param devices The list of all connected display devices.
 */

Body of Frist Method:
{
    // Nothing to update if already invalid.
    if (mPrimaryDisplayDevice == null) {
        return;
    }
    // Check whether logical display has become invalid.
    if (!devices.contains(mPrimaryDisplayDevice)) {
        mPrimaryDisplayDevice = null;
        return;
    }
    // Bootstrap the logical display using its associated primary physical display.
    // We might use more elaborate configurations later.  It's possible that the
    // configuration of several physical displays might be used to determine the
    // logical display that they are sharing.  (eg. Adjust size for pixel-perfect
    // mirroring over HDMI.)
    DisplayDeviceInfo deviceInfo = mPrimaryDisplayDevice.getDisplayDeviceInfoLocked();
    if (!Objects.equal(mPrimaryDisplayDeviceInfo, deviceInfo)) {
        mBaseDisplayInfo.layerStack = mLayerStack;
        mBaseDisplayInfo.flags = 0;
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_SUPPORTS_PROTECTED_BUFFERS;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_SECURE) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_SECURE;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_PRIVATE) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_PRIVATE;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_PRESENTATION) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_PRESENTATION;
        }
        mBaseDisplayInfo.type = deviceInfo.type;
        mBaseDisplayInfo.address = deviceInfo.address;
        mBaseDisplayInfo.name = deviceInfo.name;
        mBaseDisplayInfo.appWidth = deviceInfo.width;
        mBaseDisplayInfo.appHeight = deviceInfo.height;
        mBaseDisplayInfo.logicalWidth = deviceInfo.width;
        mBaseDisplayInfo.logicalHeight = deviceInfo.height;
        mBaseDisplayInfo.rotation = Surface.ROTATION_0;
        mBaseDisplayInfo.refreshRate = deviceInfo.refreshRate;
        mBaseDisplayInfo.supportedRefreshRates = Arrays.copyOf(deviceInfo.supportedRefreshRates, deviceInfo.supportedRefreshRates.length);
        mBaseDisplayInfo.logicalDensityDpi = deviceInfo.densityDpi;
        mBaseDisplayInfo.physicalXDpi = deviceInfo.xDpi;
        mBaseDisplayInfo.physicalYDpi = deviceInfo.yDpi;
        mBaseDisplayInfo.appVsyncOffsetNanos = deviceInfo.appVsyncOffsetNanos;
        mBaseDisplayInfo.presentationDeadlineNanos = deviceInfo.presentationDeadlineNanos;
        mBaseDisplayInfo.state = deviceInfo.state;
        mBaseDisplayInfo.smallestNominalAppWidth = deviceInfo.width;
        mBaseDisplayInfo.smallestNominalAppHeight = deviceInfo.height;
        mBaseDisplayInfo.largestNominalAppWidth = deviceInfo.width;
        mBaseDisplayInfo.largestNominalAppHeight = deviceInfo.height;
        mBaseDisplayInfo.ownerUid = deviceInfo.ownerUid;
        mBaseDisplayInfo.ownerPackageName = deviceInfo.ownerPackageName;
        mPrimaryDisplayDeviceInfo = deviceInfo;
        mInfo = null;
    }
}
Body of Second Method:
{
    // Nothing to update if already invalid.
    if (mPrimaryDisplayDevice == null) {
        return;
    }
    // Check whether logical display has become invalid.
    if (!devices.contains(mPrimaryDisplayDevice)) {
        mPrimaryDisplayDevice = null;
        return;
    }
    // Bootstrap the logical display using its associated primary physical display.
    // We might use more elaborate configurations later.  It's possible that the
    // configuration of several physical displays might be used to determine the
    // logical display that they are sharing.  (eg. Adjust size for pixel-perfect
    // mirroring over HDMI.)
    DisplayDeviceInfo deviceInfo = mPrimaryDisplayDevice.getDisplayDeviceInfoLocked();
    if (!Objects.equal(mPrimaryDisplayDeviceInfo, deviceInfo)) {
        mBaseDisplayInfo.layerStack = mLayerStack;
        mBaseDisplayInfo.flags = 0;
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_SUPPORTS_PROTECTED_BUFFERS) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_SUPPORTS_PROTECTED_BUFFERS;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_SECURE) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_SECURE;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_PRIVATE) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_PRIVATE;
        }
        if ((deviceInfo.flags & DisplayDeviceInfo.FLAG_PRESENTATION) != 0) {
            mBaseDisplayInfo.flags |= Display.FLAG_PRESENTATION;
        }
        mBaseDisplayInfo.type = deviceInfo.type;
        mBaseDisplayInfo.address = deviceInfo.address;
        mBaseDisplayInfo.name = deviceInfo.name;
        mBaseDisplayInfo.uniqueId = deviceInfo.uniqueId;
        mBaseDisplayInfo.appWidth = deviceInfo.width;
        mBaseDisplayInfo.appHeight = deviceInfo.height;
        mBaseDisplayInfo.logicalWidth = deviceInfo.width;
        mBaseDisplayInfo.logicalHeight = deviceInfo.height;
        mBaseDisplayInfo.rotation = Surface.ROTATION_0;
        mBaseDisplayInfo.refreshRate = deviceInfo.refreshRate;
        mBaseDisplayInfo.supportedRefreshRates = Arrays.copyOf(deviceInfo.supportedRefreshRates, deviceInfo.supportedRefreshRates.length);
        mBaseDisplayInfo.logicalDensityDpi = deviceInfo.densityDpi;
        mBaseDisplayInfo.physicalXDpi = deviceInfo.xDpi;
        mBaseDisplayInfo.physicalYDpi = deviceInfo.yDpi;
        mBaseDisplayInfo.appVsyncOffsetNanos = deviceInfo.appVsyncOffsetNanos;
        mBaseDisplayInfo.presentationDeadlineNanos = deviceInfo.presentationDeadlineNanos;
        mBaseDisplayInfo.state = deviceInfo.state;
        mBaseDisplayInfo.smallestNominalAppWidth = deviceInfo.width;
        mBaseDisplayInfo.smallestNominalAppHeight = deviceInfo.height;
        mBaseDisplayInfo.largestNominalAppWidth = deviceInfo.width;
        mBaseDisplayInfo.largestNominalAppHeight = deviceInfo.height;
        mBaseDisplayInfo.ownerUid = deviceInfo.ownerUid;
        mBaseDisplayInfo.ownerPackageName = deviceInfo.ownerPackageName;
        mPrimaryDisplayDeviceInfo = deviceInfo;
        mInfo = null;
    }
}
------------------------
Find a functionally equivalent code:android.telephony.SignalStrength.getLteLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get LTE as level 0..4
 *
 * @hide
 */

Body of Frist Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > -44)
        rsrpIconLevel = -1;
    else if (mLteRsrp >= -85)
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= -95)
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= -105)
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= -115)
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= -140)
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
Body of Second Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int rsrpThreshType = Resources.getSystem().getInteger(com.android.internal.R.integer.config_LTE_RSRP_threshold_type);
    int[] threshRsrp;
    if (rsrpThreshType == RSRP_THRESH_TYPE_STRICT) {
        threshRsrp = RSRP_THRESH_STRICT;
    } else {
        threshRsrp = RSRP_THRESH_LENIENT;
    }
    if (mLteRsrp > threshRsrp[5])
        rsrpIconLevel = -1;
    else if (mLteRsrp >= threshRsrp[4])
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= threshRsrp[3])
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= threshRsrp[2])
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= threshRsrp[1])
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= threshRsrp[0])
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.onActionViewCollapsed:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    setQuery("", false);
    clearFocus();
    updateViewsVisibility(true);
    mQueryTextView.setImeOptions(mCollapsedImeOptions);
    mExpandedInActionView = false;
}
Body of Second Method:
{
    setQuery("", false);
    clearFocus();
    updateViewsVisibility(true);
    mSearchSrcTextView.setImeOptions(mCollapsedImeOptions);
    mExpandedInActionView = false;
}
------------------------
Find a functionally equivalent code:android.app.Dialog.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#invalidateOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a functionally equivalent code:com.android.server.am.ActivityStack.destroyActivityLocked:COMMENT
Method Modifier: default     final       
Comment:/**
 * Destroy the current CLIENT SIDE instance of an activity.  This may be
 * called both when actually finishing an activity, or when performing
 * a configuration switch where we destroy the current client-side object
 * but then create a new client-side object for this same HistoryRecord.
 */

Body of Frist Method:
{
    if (DEBUG_SWITCH || DEBUG_CLEANUP)
        Slog.v(TAG, "Removing activity from " + reason + ": token=" + r + ", app=" + (r.app != null ? r.app.processName : "(null)"));
    EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY, r.userId, System.identityHashCode(r), r.task.taskId, r.shortComponentName, reason);
    boolean removedFromHistory = false;
    cleanUpActivityLocked(r, false, false);
    final boolean hadApp = r.app != null;
    if (hadApp) {
        if (removeFromApp) {
            r.app.activities.remove(r);
            if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
                mService.mHeavyWeightProcess = null;
                mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
            }
            if (r.app.activities.isEmpty()) {
                // Update any services we are bound to that might care about whether
                // their client may have activities.
                mService.mServices.updateServiceConnectionActivitiesLocked(r.app);
                // No longer have activities, so update LRU list and oom adj.
                mService.updateLruProcessLocked(r.app, false, null);
                mService.updateOomAdjLocked();
            }
        }
        boolean skipDestroy = false;
        try {
            if (DEBUG_SWITCH)
                Slog.i(TAG, "Destroying: " + r);
            r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags);
        } catch (Exception e) {
            // Slog.w(TAG, "Exception thrown during finish", e);
            if (r.finishing) {
                removeActivityFromHistoryLocked(r);
                removedFromHistory = true;
                skipDestroy = true;
            }
        }
        r.nowVisible = false;
        // list.
        if (r.finishing && !skipDestroy) {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYING: " + r + " (destroy requested)");
            r.state = ActivityState.DESTROYING;
            Message msg = mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r);
            mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT);
        } else {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYED: " + r + " (destroy skipped)");
            r.state = ActivityState.DESTROYED;
            if (DEBUG_APP)
                Slog.v(TAG, "Clearing app during destroy for activity " + r);
            r.app = null;
        }
    } else {
        // remove this record from the history.
        if (r.finishing) {
            removeActivityFromHistoryLocked(r);
            removedFromHistory = true;
        } else {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYED: " + r + " (no app)");
            r.state = ActivityState.DESTROYED;
            if (DEBUG_APP)
                Slog.v(TAG, "Clearing app during destroy for activity " + r);
            r.app = null;
        }
    }
    r.configChangeFlags = 0;
    if (!mLRUActivities.remove(r) && hadApp) {
        Slog.w(TAG, "Activity " + r + " being finished, but not in LRU list");
    }
    return removedFromHistory;
}
Body of Second Method:
{
    if (DEBUG_SWITCH || DEBUG_CLEANUP)
        Slog.v(TAG, "Removing activity from " + reason + ": token=" + r + ", app=" + (r.app != null ? r.app.processName : "(null)"));
    EventLog.writeEvent(EventLogTags.AM_DESTROY_ACTIVITY, r.userId, System.identityHashCode(r), r.task.taskId, r.shortComponentName, reason);
    boolean removedFromHistory = false;
    cleanUpActivityLocked(r, false, false);
    final boolean hadApp = r.app != null;
    if (hadApp) {
        if (removeFromApp) {
            r.app.activities.remove(r);
            if (mService.mHeavyWeightProcess == r.app && r.app.activities.size() <= 0) {
                mService.mHeavyWeightProcess = null;
                mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);
            }
            if (r.app.activities.isEmpty()) {
                // Update any services we are bound to that might care about whether
                // their client may have activities.
                mService.mServices.updateServiceConnectionActivitiesLocked(r.app);
                // No longer have activities, so update LRU list and oom adj.
                mService.updateLruProcessLocked(r.app, false, null);
                mService.updateOomAdjLocked();
            }
        }
        boolean skipDestroy = false;
        try {
            if (DEBUG_SWITCH)
                Slog.i(TAG, "Destroying: " + r);
            r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags);
        } catch (Exception e) {
            // Slog.w(TAG, "Exception thrown during finish", e);
            if (r.finishing) {
                removeActivityFromHistoryLocked(r, reason + " exceptionInScheduleDestroy");
                removedFromHistory = true;
                skipDestroy = true;
            }
        }
        r.nowVisible = false;
        // list.
        if (r.finishing && !skipDestroy) {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYING: " + r + " (destroy requested)");
            r.state = ActivityState.DESTROYING;
            Message msg = mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r);
            mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT);
        } else {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYED: " + r + " (destroy skipped)");
            r.state = ActivityState.DESTROYED;
            if (DEBUG_APP)
                Slog.v(TAG, "Clearing app during destroy for activity " + r);
            r.app = null;
        }
    } else {
        // remove this record from the history.
        if (r.finishing) {
            removeActivityFromHistoryLocked(r, reason + " hadNoApp");
            removedFromHistory = true;
        } else {
            if (DEBUG_STATES)
                Slog.v(TAG, "Moving to DESTROYED: " + r + " (no app)");
            r.state = ActivityState.DESTROYED;
            if (DEBUG_APP)
                Slog.v(TAG, "Clearing app during destroy for activity " + r);
            r.app = null;
        }
    }
    r.configChangeFlags = 0;
    if (!mLRUActivities.remove(r) && hadApp) {
        Slog.w(TAG, "Activity " + r + " being finished, but not in LRU list");
    }
    return removedFromHistory;
}
------------------------
Find a functionally equivalent code:android.media.audiofx.AudioEffect.isEffectTypeAvailable:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if the device implements the specified effect type.
 * @param type the requested effect type.
 * @return true if the device implements the specified effect type, false otherwise.
 * @hide
 */

Body of Frist Method:
{
    AudioEffect.Descriptor[] desc = AudioEffect.queryEffects();
    for (int i = 0; i < desc.length; i++) {
        if (desc[i].type.equals(type)) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    AudioEffect.Descriptor[] desc = AudioEffect.queryEffects();
    if (desc == null) {
        return false;
    }
    for (int i = 0; i < desc.length; i++) {
        if (desc[i].type.equals(type)) {
            return true;
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getDefaultSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @return the "system" defaultSubId on a voice capable device this
 * will be getDefaultVoiceSubId() and on a data only device it will be
 * getDefaultDataSubId().
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultSubId=" + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultSubId=" + subId);
    return subId;
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSlotId(slotId)) {
        logd("[getSubId]- fail");
        return null;
    }
    long[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
Body of Second Method:
{
    if (!isValidSlotId(slotId)) {
        logd("[getSubId]- fail");
        return null;
    }
    int[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
------------------------
Find a functionally equivalent code:android.animation.StateListAnimator.addState:COMMENT
Method Modifier: public      
Comment:/**
 * Associates the given animator with the provided drawable state specs so that it will be run
 * when the View's drawable state matches the specs.
 *
 * @param specs The drawable state specs to match against
 * @param animator The animator to run when the specs match
 */

Body of Frist Method:
{
    Tuple tuple = new Tuple(specs, animator);
    tuple.mAnimator.addListener(mAnimatorListener);
    mTuples.add(tuple);
}
Body of Second Method:
{
    Tuple tuple = new Tuple(specs, animator);
    tuple.mAnimator.addListener(mAnimatorListener);
    mTuples.add(tuple);
    mChangingConfigurations |= animator.getChangingConfigurations();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.model.RecentsPackageMonitor.unregister:COMMENT
Method Modifier: public      
Comment:/**
 * Unregisters the broadcast receivers.
 */

Body of Frist Method:
{
    try {
        super.unregister();
    } catch (IllegalStateException e) {
        e.printStackTrace();
    }
    mSystemServicesProxy = null;
    mCb = null;
    mTasks.clear();
}
Body of Second Method:
{
    try {
        super.unregister();
    } catch (IllegalStateException e) {
        e.printStackTrace();
    }
    mSystemServicesProxy = null;
    mCb = null;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setGeolocationDatabasePath:COMMENT
<android.webkit.WebSettings: void setGeolocationDatabasePath(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:// This will update WebCore when the Sync runs in the C++ side.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchSomeCerts2:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with two certificates cannot be upgraded by
     * an app signed with the last certificate.
     */

Body of Frist Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT2, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT2, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchSomeCerts1:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with two certificates cannot be upgraded by
     * an app signed with a subset of initial certificates.
     */

Body of Frist Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT1, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT1, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Handles the key down event for dealing with action keys.
 *
 * @param keyCode This is the keycode of the typed key, and is the same value as
 * found in the KeyEvent parameter.
 * @param event The complete event record for the typed key
 *
 * @return true if the event was handled here, or false if not.
 */

Body of Frist Method:
{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mQueryTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
Body of Second Method:
{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mSearchSrcTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.model.RecentsTaskLoader.getAndUpdateActivityIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the activity icon using as many cached values as we can.
 */

Body of Frist Method:
{
    // Return the cached activity icon if it exists
    Drawable icon = mApplicationIconCache.getAndInvalidateIfModified(taskKey);
    if (icon != null) {
        return icon;
    }
    // activity icon
    if (preloadTask) {
        // Return and cache the task description icon if it exists
        Drawable tdDrawable = mLoader.getTaskDescriptionIcon(taskKey, td.getInMemoryIcon(), td.getIconFilename(), ssp, res);
        if (tdDrawable != null) {
            mApplicationIconCache.put(taskKey, tdDrawable);
            return tdDrawable;
        }
        // Load the icon from the activity info and cache it
        if (infoHandle.info == null) {
            infoHandle.info = ssp.getActivityInfo(taskKey.baseIntent.getComponent(), taskKey.userId);
        }
        if (infoHandle.info != null) {
            icon = ssp.getActivityIcon(infoHandle.info, taskKey.userId);
            if (icon != null) {
                mApplicationIconCache.put(taskKey, icon);
                return icon;
            }
        }
    }
    // If we couldn't load any icon, return null
    return null;
}
Body of Second Method:
{
    // Return the cached activity icon if it exists
    Drawable icon = mApplicationIconCache.getAndInvalidateIfModified(taskKey);
    if (icon != null) {
        return icon;
    }
    if (loadIfNotCached) {
        // Return and cache the task description icon if it exists
        Drawable tdDrawable = mLoader.getTaskDescriptionIcon(taskKey, td.getInMemoryIcon(), td.getIconFilename(), ssp, res);
        if (tdDrawable != null) {
            mApplicationIconCache.put(taskKey, tdDrawable);
            return tdDrawable;
        }
        // Load the icon from the activity info and cache it
        if (infoHandle.info == null) {
            infoHandle.info = ssp.getActivityInfo(taskKey.baseIntent.getComponent(), taskKey.userId);
        }
        if (infoHandle.info != null) {
            icon = ssp.getActivityIcon(infoHandle.info, taskKey.userId);
            if (icon != null) {
                mApplicationIconCache.put(taskKey, icon);
                return icon;
            }
        }
    }
    // We couldn't load any icon
    return null;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.AlternateRecentsComponent.startAlternateRecentsActivity:COMMENT
Method Modifier: 
Comment:/**
 * Starts the recents activity
 */

Body of Frist Method:
{
    Intent intent = new Intent(sToggleRecentsAction);
    intent.setClassName(sRecentsPackage, sRecentsActivity);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
    if (extraFlag != null) {
        intent.putExtra(extraFlag, true);
    }
    intent.putExtra(EXTRA_TRIGGERED_FROM_ALT_TAB, mTriggeredFromAltTab);
    intent.putExtra(EXTRA_FROM_TASK_ID, (topTask != null) ? topTask.id : -1);
    if (opts != null) {
        mContext.startActivityAsUser(intent, opts.toBundle(), UserHandle.CURRENT);
    } else {
        mContext.startActivityAsUser(intent, UserHandle.CURRENT);
    }
}
Body of Second Method:
{
    // Update the configuration based on the launch options
    mConfig.launchedFromHome = fromSearchHome || fromHome;
    mConfig.launchedFromSearchHome = fromSearchHome;
    mConfig.launchedFromAppWithThumbnail = fromThumbnail;
    mConfig.launchedToTaskId = (topTask != null) ? topTask.id : -1;
    mConfig.launchedWithAltTab = mTriggeredFromAltTab;
    mConfig.launchedReuseTaskStackViews = mCanReuseTaskStackViews;
    mConfig.launchedNumVisibleTasks = vr.numVisibleTasks;
    mConfig.launchedNumVisibleThumbnails = vr.numVisibleThumbnails;
    mConfig.launchedHasConfigurationChanged = false;
    Intent intent = new Intent(sToggleRecentsAction);
    intent.setClassName(sRecentsPackage, sRecentsActivity);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
    if (opts != null) {
        mContext.startActivityAsUser(intent, opts.toBundle(), UserHandle.CURRENT);
    } else {
        mContext.startActivityAsUser(intent, UserHandle.CURRENT);
    }
    mCanReuseTaskStackViews = true;
}
------------------------
Find a functionally equivalent code:com.android.server.usb.UsbHostManager.usbDeviceRemoved:COMMENT
Method Modifier: private     
Comment:/* Called from JNI in monitorUsbHostBus to report USB device removal */

Body of Frist Method:
{
    if (DEBUG_AUDIO) {
        Slog.d(TAG, "usb:UsbHostManager.usbDeviceRemoved() nm:" + deviceName);
    }
    if (mConnectedUsbCard != -1 && mConnectedUsbDeviceNum != -1) {
        sendDeviceNotification(mConnectedUsbCard, mConnectedUsbDeviceNum, false, mConnectedHasPlayback, mConnectedHasCapture, mConnectedHasMIDI);
        mConnectedUsbCard = -1;
        mConnectedUsbDeviceNum = -1;
        mConnectedHasPlayback = false;
        mConnectedHasCapture = false;
        mConnectedHasMIDI = false;
    }
    synchronized (mLock) {
        UsbDevice device = mDevices.remove(deviceName);
        if (device != null) {
            getCurrentSettings().deviceDetached(device);
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        UsbDevice device = mDevices.remove(deviceName);
        if (device != null) {
            mUsbAudioManager.deviceRemoved(device);
            getCurrentSettings().deviceDetached(device);
        }
    }
}
------------------------
Find a functionally equivalent code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleBackground.cancelHardwareAnimations:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels any running hardware animations.
 */

Body of Frist Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        runningAnimations.get(i).cancel();
    }
    runningAnimations.clear();
    if (cancelPending && !mPendingAnimations.isEmpty()) {
        mPendingAnimations.clear();
    }
    mHardwareAnimating = false;
}
Body of Second Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        if (jumpToEnd) {
            runningAnimations.get(i).end();
        } else {
            runningAnimations.get(i).cancel();
        }
    }
    runningAnimations.clear();
    if (mHasPendingHardwareExit) {
        // If we had a pending hardware exit, jump to the end state.
        mHasPendingHardwareExit = false;
        if (jumpToEnd) {
            mOuterOpacity = 0;
        }
    }
    mHardwareAnimating = false;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.prepareAddWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Preflight adding a window to the system.
 *
 * Currently enforces that three window types are singletons:
 * <ul>
 * <li>STATUS_BAR_TYPE</li>
 * <li>KEYGUARD_TYPE</li>
 * </ul>
 *
 * @param win The window to be added
 * @param attrs Information about the window to be added
 *
 * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons,
 * WindowManagerImpl.ADD_MULTIPLE_SINGLETON
 */

Body of Frist Method:
{
    switch(attrs.type) {
        case TYPE_STATUS_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mStatusBar != null) {
                if (mStatusBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mStatusBar = win;
            mStatusBarController.setWindow(win);
            mKeyguardDelegate.hideScrim();
            break;
        case TYPE_NAVIGATION_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mNavigationBar != null) {
                if (mNavigationBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mNavigationBar = win;
            mNavigationBarController.setWindow(win);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
            break;
        case TYPE_NAVIGATION_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_SUB_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_KEYGUARD_SCRIM:
            if (mKeyguardScrim != null) {
                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
            }
            mKeyguardScrim = win;
            break;
    }
    return WindowManagerGlobal.ADD_OKAY;
}
Body of Second Method:
{
    switch(attrs.type) {
        case TYPE_STATUS_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mStatusBar != null) {
                if (mStatusBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mStatusBar = win;
            mStatusBarController.setWindow(win);
            break;
        case TYPE_NAVIGATION_BAR:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            if (mNavigationBar != null) {
                if (mNavigationBar.isAlive()) {
                    return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
                }
            }
            mNavigationBar = win;
            mNavigationBarController.setWindow(win);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
            break;
        case TYPE_NAVIGATION_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_STATUS_BAR_SUB_PANEL:
            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
            break;
        case TYPE_KEYGUARD_SCRIM:
            if (mKeyguardScrim != null) {
                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
            }
            mKeyguardScrim = win;
            break;
    }
    return WindowManagerGlobal.ADD_OKAY;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleBackground.exit:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the exit animation.
 */

Body of Frist Method:
{
    cancel();
    // Scale the outer max opacity and opacity velocity based
    // on the size of the outer radius.
    final int opacityDuration = (int) (1000 / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    final float outerSizeInfluence = MathUtils.constrain((mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity) / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity), 0, 1);
    final float outerOpacityVelocity = MathUtils.lerp(WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN, WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX, outerSizeInfluence);
    // Determine at what time the inner and outer opacity intersect.
    // inner(t) = mOpacity - t * WAVE_OPACITY_DECAY_VELOCITY / 1000
    // outer(t) = mOuterOpacity + t * WAVE_OUTER_OPACITY_VELOCITY / 1000
    final int inflectionDuration = Math.max(0, (int) (1000 * (1 - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
    final int inflectionOpacity = (int) (mColorAlpha * (mOuterOpacity + inflectionDuration * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
    if (mCanUseHardware) {
        exitHardware(opacityDuration, inflectionDuration, inflectionOpacity);
    } else {
        exitSoftware(opacityDuration, inflectionDuration, inflectionOpacity);
    }
}
Body of Second Method:
{
    cancel();
    // Scale the outer max opacity and opacity velocity based
    // on the size of the outer radius.
    final int opacityDuration = (int) (1000 / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    final float outerSizeInfluence = MathUtils.constrain((mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity) / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity), 0, 1);
    final float outerOpacityVelocity = MathUtils.lerp(WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN, WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX, outerSizeInfluence);
    // Determine at what time the inner and outer opacity intersect.
    // inner(t) = mOpacity - t * WAVE_OPACITY_DECAY_VELOCITY / 1000
    // outer(t) = mOuterOpacity + t * WAVE_OUTER_OPACITY_VELOCITY / 1000
    final int inflectionDuration = Math.max(0, (int) (1000 * (1 - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
    final int inflectionOpacity = (int) (Color.alpha(mColor) * (mOuterOpacity + inflectionDuration * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
    if (mCanUseHardware) {
        createPendingHardwareExit(opacityDuration, inflectionDuration, inflectionOpacity);
    } else {
        exitSoftware(opacityDuration, inflectionDuration, inflectionOpacity);
    }
}
------------------------
Find a functionally equivalent code:android.widget.OverScroller.SplineOverScroller.update:COMMENT
Method Modifier: 
Comment:/*
         * Update the current position and velocity for current time. Returns
         * true if update has been done and false if animation duration has been
         * reached.
         */

Body of Frist Method:
{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}
Body of Second Method:
{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime == 0) {
        // Skip work but report that we're still going if we have a nonzero duration.
        return mDuration > 0;
    }
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDefaultFontSize:COMMENT
<android.webkit.WebSettings: void setDefaultFontSize(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.drawable.InsetDrawable.setLayoutDirection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    mInsetState.mDrawable.setLayoutDirection(layoutDirection);
}
Body of Second Method:
{
    mState.mDrawable.setLayoutDirection(layoutDirection);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getFixedFontFamily:COMMENT
<android.webkit.WebSettings: String getFixedFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the fixed font family name.
 *
 * @return the fixed font family name as a string
 * @see #setFixedFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.AlternateRecentsComponent.toggleRecentsActivity:COMMENT
Method Modifier: 
Comment:/**
 * Toggles the recents activity
 */

Body of Frist Method:
{
    // NOTE: Ideally, the screenshot mechanism would take the window transform into account
    if (System.currentTimeMillis() - mLastToggleTime < sMinToggleDelay) {
        return;
    }
    // If Recents is the front most activity, then we should just communicate with it directly
    // to launch the first task or dismiss itself
    ActivityManager.RunningTaskInfo topTask = getTopMostTask();
    AtomicBoolean isTopTaskHome = new AtomicBoolean();
    if (isRecentsTopMost(topTask, isTopTaskHome)) {
        // Notify recents to toggle itself
        Intent intent = new Intent(ACTION_TOGGLE_RECENTS_ACTIVITY);
        intent.setPackage(mContext.getPackageName());
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_FOREGROUND);
        mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT);
        mLastToggleTime = System.currentTimeMillis();
        return;
    } else {
        // Otherwise, start the recents activity
        startRecentsActivity(topTask, isTopTaskHome.get());
    }
}
Body of Second Method:
{
    // NOTE: Ideally, the screenshot mechanism would take the window transform into account
    if ((SystemClock.elapsedRealtime() - mLastToggleTime) < sMinToggleDelay) {
        return;
    }
    // If Recents is the front most activity, then we should just communicate with it directly
    // to launch the first task or dismiss itself
    ActivityManager.RunningTaskInfo topTask = mSystemServicesProxy.getTopMostTask();
    AtomicBoolean isTopTaskHome = new AtomicBoolean(true);
    if (topTask != null && mSystemServicesProxy.isRecentsTopMost(topTask, isTopTaskHome)) {
        // Notify recents to toggle itself
        Intent intent = createLocalBroadcastIntent(mContext, ACTION_TOGGLE_RECENTS_ACTIVITY);
        mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT);
        mLastToggleTime = SystemClock.elapsedRealtime();
        return;
    } else {
        // Otherwise, start the recents activity
        startRecentsActivity(topTask, isTopTaskHome.get());
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.volume.ZenModePanel.setRequestingConditions:COMMENT
Method Modifier: private     
Comment:/**
 * Start or stop requesting relevant zen mode exit conditions
 */

Body of Frist Method:
{
    if (mRequestingConditions == requesting)
        return;
    if (DEBUG)
        Log.d(mTag, "setRequestingConditions " + requesting);
    mRequestingConditions = requesting;
    if (mController != null) {
        mController.requestConditions(mRequestingConditions);
    }
    if (mRequestingConditions) {
        mTimeCondition = parseExistingTimeCondition(mExitCondition);
        if (mTimeCondition != null) {
            mBucketIndex = -1;
        } else {
            mBucketIndex = DEFAULT_BUCKET_INDEX;
            mTimeCondition = ZenModeConfig.toTimeCondition(MINUTE_BUCKETS[mBucketIndex]);
        }
        if (DEBUG)
            Log.d(mTag, "Initial bucket index: " + mBucketIndex);
        // reset conditions
        mConditions = null;
        handleUpdateConditions();
    } else {
        mZenConditions.removeAllViews();
    }
}
Body of Second Method:
{
    if (mRequestingConditions == requesting)
        return;
    if (DEBUG)
        Log.d(mTag, "setRequestingConditions " + requesting);
    mRequestingConditions = requesting;
    if (mController != null) {
        AsyncTask.execute(new Runnable() {

            @Override
            public void run() {
                mController.requestConditions(requesting);
            }
        });
    }
    if (mRequestingConditions) {
        mTimeCondition = parseExistingTimeCondition(mExitCondition);
        if (mTimeCondition != null) {
            mBucketIndex = -1;
        } else {
            mBucketIndex = DEFAULT_BUCKET_INDEX;
            mTimeCondition = ZenModeConfig.toTimeCondition(mContext, MINUTE_BUCKETS[mBucketIndex], ActivityManager.getCurrentUser());
        }
        if (DEBUG)
            Log.d(mTag, "Initial bucket index: " + mBucketIndex);
        // reset conditions
        mConditions = null;
        handleUpdateConditions();
    } else {
        hideAllConditions();
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.drawSoftware:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if drawing was successful, false if an error occurred
 */

Body of Frist Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
Body of Second Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Ripple.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all animations. The caller is responsible for removing
 * the ripple from the list of animating ripples.
 */

Body of Frist Method:
{
    mCanceled = true;
    cancelSoftwareAnimations();
    cancelHardwareAnimations(true);
    mCanceled = false;
}
Body of Second Method:
{
    mCanceled = true;
    cancelSoftwareAnimations();
    cancelHardwareAnimations(false);
    mCanceled = false;
}
------------------------
Find a functionally equivalent code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            ArrayList<Uri> validUris = new ArrayList<Uri>();
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    continue;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    continue;
                }
                uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                validUris.add(uri);
            }
            uris = validUris.toArray(new Uri[validUris.size()]);
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, UserHandle.CURRENT, flags);
}
------------------------
Find a functionally equivalent code:com.android.server.connectivity.Tethering.sendTetherStateChangedBroadcast:COMMENT
Method Modifier: private     
Comment:// to clarify what needs synchronized protection.

Body of Frist Method:
{
    if (!getConnectivityManager().isTetheringSupported())
        return;
    ArrayList<String> availableList = new ArrayList<String>();
    ArrayList<String> activeList = new ArrayList<String>();
    ArrayList<String> erroredList = new ArrayList<String>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    synchronized (mPublicSync) {
        Set ifaces = mIfaces.keySet();
        for (Object iface : ifaces) {
            TetherInterfaceSM sm = mIfaces.get(iface);
            if (sm != null) {
                if (sm.isErrored()) {
                    erroredList.add((String) iface);
                } else if (sm.isAvailable()) {
                    availableList.add((String) iface);
                } else if (sm.isTethered()) {
                    if (isUsb((String) iface)) {
                        usbTethered = true;
                    } else if (isWifi((String) iface)) {
                        wifiTethered = true;
                    } else if (isBluetooth((String) iface)) {
                        bluetoothTethered = true;
                    }
                    activeList.add((String) iface);
                }
            }
        }
    }
    Intent broadcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    broadcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, activeList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(broadcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, "sendTetherStateChangedBroadcast " + availableList.size() + ", " + activeList.size() + ", " + erroredList.size());
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_wifi);
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
Body of Second Method:
{
    if (!getConnectivityManager().isTetheringSupported())
        return;
    ArrayList<String> availableList = new ArrayList<String>();
    ArrayList<String> activeList = new ArrayList<String>();
    ArrayList<String> erroredList = new ArrayList<String>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    synchronized (mPublicSync) {
        Set ifaces = mIfaces.keySet();
        for (Object iface : ifaces) {
            TetherInterfaceSM sm = mIfaces.get(iface);
            if (sm != null) {
                if (sm.isErrored()) {
                    erroredList.add((String) iface);
                } else if (sm.isAvailable()) {
                    availableList.add((String) iface);
                } else if (sm.isTethered()) {
                    if (isUsb((String) iface)) {
                        usbTethered = true;
                    } else if (isWifi((String) iface)) {
                        wifiTethered = true;
                    } else if (isBluetooth((String) iface)) {
                        bluetoothTethered = true;
                    }
                    activeList.add((String) iface);
                }
            }
        }
    }
    Intent broadcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    broadcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, activeList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(broadcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, "sendTetherStateChangedBroadcast " + availableList.size() + ", " + activeList.size() + ", " + erroredList.size());
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setPluginState:COMMENT
<android.webkit.WebSettings: void setPluginState(PluginState)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Tells the WebView to enable, disable, or have plugins on demand. On
 * demand mode means that if a plugin exists that can handle the embedded
 * content, a placeholder icon will be shown instead of the plugin. When
 * the placeholder is clicked, the plugin will be enabled. The default is
 * {@link PluginState#OFF}.
 *
 * @param state a PluginState value
 * @deprecated Plugins will not be supported in future, and should not be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.savedPasswordExists:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Check to see if the user has stored a lock pattern.
 * @return Whether a saved pattern exists.
 */

Body of Frist Method:
{
    try {
        return getLockSettings().havePassword(getCurrentOrCallingUserId());
    } catch (RemoteException re) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return getLockSettings().havePassword(userId);
    } catch (RemoteException re) {
        return false;
    }
}
------------------------
Find a functionally equivalent code:android.view.SurfaceView.updateWindow:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    mReportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
Body of Second Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    mReportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      
Comment:/**
 * We have one child
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                    case WindowManagerGlobal.ADD_INVALID_TYPE:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified window type is not valid");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDatabaseEnabled:COMMENT
<android.webkit.WebSettings: void setDatabaseEnabled(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the database storage API is enabled. The default value is
 * false. See also {@link #setDatabasePath} for how to correctly set up the
 * database storage API.
 *
 * This setting is global in effect, across all WebView instances in a process.
 * Note you should only modify this setting prior to making <b>any</b> WebView
 * page load within a given process, as the WebView implementation may ignore
 * changes to this setting after that point.
 *
 * @param flag true if the WebView should use the database storage API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getMinimumLogicalFontSize:COMMENT
<android.webkit.WebSettings: int getMinimumLogicalFontSize()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the minimum logical font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumLogicalFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setNavDump:COMMENT
<android.webkit.WebSettings: void setNavDump(boolean)>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Enables dumping the pages navigation cache to a text file. The default
 * is false.
 *
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.Image.setCropRect:COMMENT
Method Modifier: public      
Comment:/**
 * Set the crop rectangle associated with this frame.
 * <p>
 * The crop rectangle specifies the region of valid pixels in the image,
 * using coordinates in the largest-resolution plane.
 */

Body of Frist Method:
{
    // make a copy
    cropRect = new Rect(cropRect);
    cropRect.intersect(0, 0, getWidth(), getHeight());
    mCropRect = cropRect;
}
Body of Second Method:
{
    if (cropRect != null) {
        // make a copy
        cropRect = new Rect(cropRect);
        cropRect.intersect(0, 0, getWidth(), getHeight());
    }
    mCropRect = cropRect;
}
------------------------
Find a functionally equivalent code:android.app.Notification.Action.WearableExtender.extend:COMMENT
Method Modifier: public      
Comment:/**
 * Apply wearable extensions to a notification action that is being built. This is
 * typically called by the {@link android.app.Notification.Action.Builder#extend}
 * method of {@link android.app.Notification.Action.Builder}.
 */

Body of Frist Method:
{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
Body of Second Method:
{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mInProgressLabel != null) {
        wearableBundle.putCharSequence(KEY_IN_PROGRESS_LABEL, mInProgressLabel);
    }
    if (mConfirmLabel != null) {
        wearableBundle.putCharSequence(KEY_CONFIRM_LABEL, mConfirmLabel);
    }
    if (mCancelLabel != null) {
        wearableBundle.putCharSequence(KEY_CANCEL_LABEL, mCancelLabel);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getSansSerifFontFamily:COMMENT
<android.webkit.WebSettings: String getSansSerifFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the sans-serif font family name.
 *
 * @return the sans-serif font family name as a string
 * @see #setSansSerifFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.removeJavascriptInterface:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a previously injected Java object from this WebView. Note that
 * the removal will not be reflected in JavaScript until the page is next
 * (re)loaded. See {@link #addJavascriptInterface}.
 *
 * @param name the name used to expose the object in JavaScript
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "removeJavascriptInterface=" + name);
    mProvider.removeJavascriptInterface(name);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "removeJavascriptInterface=" + name);
    mProvider.removeJavascriptInterface(name);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setLoadWithOverviewMode:COMMENT
<android.webkit.WebSettings: void setLoadWithOverviewMode(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView loads pages in overview mode, that is,
 * zooms out the content to fit on screen by width. This setting is
 * taken into account when the content width is greater than the width
 * of the WebView control, for example, when {@link #getUseWideViewPort}
 * is enabled. The default is false.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSupportZoom:COMMENT
<android.webkit.WebSettings: void setSupportZoom(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should support zooming using its on-screen zoom
 * controls and gestures. The particular zoom mechanisms that should be used
 * can be set with {@link #setBuiltInZoomControls}. This setting does not
 * affect zooming performed using the {@link WebView#zoomIn()} and
 * {@link WebView#zoomOut()} methods. The default is true.
 *
 * @param support whether the WebView should support zoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.tv.TvInputManager.Session.tune:COMMENT
Method Modifier: public      
Comment:/**
 * Tunes to a given channel.
 *
 * @param channelUri The URI of a channel.
 * @throws IllegalArgumentException if the argument is {@code null}.
 */

Body of Frist Method:
{
    tune(channelUri, null);
}
Body of Second Method:
{
    tune(channelUri, null);
}
------------------------
Find a functionally equivalent code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

Body of Frist Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
Body of Second Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.  At this point we know that mDesiredMinWidth is the
                    // smallest dimension, regardless of current orientation, so we can
                    // safely require that the candidate's width and height both exceed
                    // that hard minimum.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || options.outHeight < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.resetViewProperties:COMMENT
Method Modifier: 
Comment:/**
 * Resets this view's properties
 */

Body of Frist Method:
{
    setDim(0);
    TaskViewTransform.reset(this);
}
Body of Second Method:
{
    setDim(0);
    setLayerType(View.LAYER_TYPE_NONE, null);
    TaskViewTransform.reset(this);
    if (mActionButtonView != null) {
        mActionButtonView.setScaleX(1f);
        mActionButtonView.setScaleY(1f);
        mActionButtonView.setAlpha(1f);
        mActionButtonView.setTranslationZ(mActionButtonTranslationZ);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewLayoutAlgorithm.computeMinMaxScroll:COMMENT
Method Modifier: 
Comment:/**
 * Computes the minimum and maximum scroll progress values.  This method may be called before
 * the RecentsConfiguration is set, so we need to pass in the alt-tab state.
 */

Body of Frist Method:
{
    // Clear the progress map
    mTaskProgressMap.clear();
    // Return early if we have no tasks
    if (tasks.isEmpty()) {
        mMinScrollP = mMaxScrollP = 0;
        return;
    }
    // Note that we should account for the scale difference of the offsets at the screen bottom
    int taskHeight = mTaskRect.height();
    float pAtBottomOfStackRect = screenYToCurveProgress(mStackVisibleRect.bottom);
    float pWithinAffiliateTop = screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset);
    float scale = curveProgressToScale(pWithinAffiliateTop);
    int scaleYOffset = (int) (((1f - scale) * taskHeight) / 2);
    pWithinAffiliateTop = screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset + scaleYOffset);
    float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop;
    float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - mBetweenAffiliationOffset);
    float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - taskHeight);
    float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - (mStackVisibleRect.bottom - mStackRect.bottom));
    // Update the task offsets
    float pAtBackMostCardTop = 0.5f;
    float pAtFrontMostCardTop = pAtBackMostCardTop;
    float pAtSecondFrontMostCardTop = pAtBackMostCardTop;
    int taskCount = tasks.size();
    for (int i = 0; i < taskCount; i++) {
        Task task = tasks.get(i);
        mTaskProgressMap.put(task.key, pAtFrontMostCardTop);
        if (i < (taskCount - 1)) {
            // Increment the peek height
            float pPeek = task.group.isFrontMostTask(task) ? pBetweenAffiliateOffset : pWithinAffiliateOffset;
            pAtSecondFrontMostCardTop = pAtFrontMostCardTop;
            pAtFrontMostCardTop += pPeek;
        }
    }
    mMaxScrollP = pAtFrontMostCardTop - ((1f - pTaskHeightOffset - pNavBarOffset));
    mMinScrollP = tasks.size() == 1 ? Math.max(mMaxScrollP, 0f) : 0f;
    if (launchedWithAltTab) {
        if (launchedFromHome) {
            // Center the top most task, since that will be focused first
            mInitialScrollP = pAtSecondFrontMostCardTop - 0.5f;
        } else {
            // Center the second top most task, since that will be focused first
            mInitialScrollP = pAtSecondFrontMostCardTop - 0.5f;
        }
    } else {
        mInitialScrollP = pAtFrontMostCardTop - 0.825f;
    }
    mInitialScrollP = Math.max(0, mInitialScrollP);
}
Body of Second Method:
{
    // Clear the progress map
    mTaskProgressMap.clear();
    // Return early if we have no tasks
    if (tasks.isEmpty()) {
        mMinScrollP = mMaxScrollP = 0;
        return;
    }
    // Note that we should account for the scale difference of the offsets at the screen bottom
    int taskHeight = mTaskRect.height();
    float pAtBottomOfStackRect = screenYToCurveProgress(mStackVisibleRect.bottom);
    float pWithinAffiliateTop = screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset);
    float scale = curveProgressToScale(pWithinAffiliateTop);
    int scaleYOffset = (int) (((1f - scale) * taskHeight) / 2);
    pWithinAffiliateTop = screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset + scaleYOffset);
    float pWithinAffiliateOffset = pAtBottomOfStackRect - pWithinAffiliateTop;
    float pBetweenAffiliateOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - mBetweenAffiliationOffset);
    float pTaskHeightOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - taskHeight);
    float pNavBarOffset = pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - (mStackVisibleRect.bottom - mStackRect.bottom));
    // Update the task offsets
    float pAtBackMostCardTop = 0.5f;
    float pAtFrontMostCardTop = pAtBackMostCardTop;
    int taskCount = tasks.size();
    for (int i = 0; i < taskCount; i++) {
        Task task = tasks.get(i);
        mTaskProgressMap.put(task.key, pAtFrontMostCardTop);
        if (i < (taskCount - 1)) {
            // Increment the peek height
            float pPeek = task.group.isFrontMostTask(task) ? pBetweenAffiliateOffset : pWithinAffiliateOffset;
            pAtFrontMostCardTop += pPeek;
        }
    }
    mMaxScrollP = pAtFrontMostCardTop - ((1f - pTaskHeightOffset - pNavBarOffset));
    mMinScrollP = tasks.size() == 1 ? Math.max(mMaxScrollP, 0f) : 0f;
    if (launchedWithAltTab && launchedFromHome) {
        // Center the top most task, since that will be focused first
        mInitialScrollP = mMaxScrollP;
    } else {
        mInitialScrollP = pAtFrontMostCardTop - 0.825f;
    }
    mInitialScrollP = Math.min(mMaxScrollP, Math.max(0, mInitialScrollP));
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.getDim:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current dim.
 */

Body of Frist Method:
{
    return mDim;
}
Body of Second Method:
{
    return mDimAlpha;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.RecentsView.startExitToHomeAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Requests all task stacks to start their exit-recents animation
 */

Body of Frist Method:
{
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.startExitToHomeAnimation(ctx);
        }
    }
    // Notify of the exit animation
    mCb.onExitToHomeAnimationTriggered();
}
Body of Second Method:
{
    // We have to increment/decrement the post animation trigger in case there are no children
    // to ensure that it runs
    ctx.postAnimationTrigger.increment();
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.startExitToHomeAnimation(ctx);
        }
    }
    ctx.postAnimationTrigger.decrement();
    // Notify of the exit animation
    mCb.onExitToHomeAnimationTriggered();
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.setCertificate:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the SSL certificate for the main top-level page.
 *
 * @deprecated Calling this function has no useful effect, and will be
 * ignored in future releases.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setCertificate=" + certificate);
    mProvider.setCertificate(certificate);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setCertificate=" + certificate);
    mProvider.setCertificate(certificate);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */

Body of Frist Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
Body of Second Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeLong(mTraversalBefore);
    parcel.writeLong(mTraversalAfter);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.clearFocus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mClearingFocus = true;
    setImeVisibility(false);
    super.clearFocus();
    mQueryTextView.clearFocus();
    mClearingFocus = false;
}
Body of Second Method:
{
    mClearingFocus = true;
    setImeVisibility(false);
    super.clearFocus();
    mSearchSrcTextView.clearFocus();
    mClearingFocus = false;
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.findAllAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Finds all instances of find on the page and highlights them,
 * asynchronously. Notifies any registered {@link FindListener}.
 * Successive calls to this will cancel any pending searches.
 *
 * @param find the string to find.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findAllAsync");
    mProvider.findAllAsync(find);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAllAsync");
    mProvider.findAllAsync(find);
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.updateSuspendBlockerLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the suspend blocker that keeps the CPU alive.
 *
 * This function must have no other side-effects.
 */

Body of Frist Method:
{
    final boolean needWakeLockSuspendBlocker = ((mWakeLockSummary & WAKE_LOCK_CPU) != 0);
    final boolean needDisplaySuspendBlocker = needDisplaySuspendBlockerLocked();
    final boolean autoSuspend = !needDisplaySuspendBlocker;
    // Disable auto-suspend if needed.
    if (!autoSuspend) {
        if (mDecoupleHalAutoSuspendModeFromDisplayConfig) {
            setHalAutoSuspendModeLocked(false);
        }
        if (mDecoupleHalInteractiveModeFromDisplayConfig) {
            setHalInteractiveModeLocked(true);
        }
    }
    // First acquire suspend blockers if needed.
    if (needWakeLockSuspendBlocker && !mHoldingWakeLockSuspendBlocker) {
        mWakeLockSuspendBlocker.acquire();
        mHoldingWakeLockSuspendBlocker = true;
    }
    if (needDisplaySuspendBlocker && !mHoldingDisplaySuspendBlocker) {
        mDisplaySuspendBlocker.acquire();
        mHoldingDisplaySuspendBlocker = true;
    }
    // Then release suspend blockers if needed.
    if (!needWakeLockSuspendBlocker && mHoldingWakeLockSuspendBlocker) {
        mWakeLockSuspendBlocker.release();
        mHoldingWakeLockSuspendBlocker = false;
    }
    if (!needDisplaySuspendBlocker && mHoldingDisplaySuspendBlocker) {
        mDisplaySuspendBlocker.release();
        mHoldingDisplaySuspendBlocker = false;
    }
    // Enable auto-suspend if needed.
    if (autoSuspend) {
        if (mDecoupleHalInteractiveModeFromDisplayConfig) {
            setHalInteractiveModeLocked(false);
        }
        if (mDecoupleHalAutoSuspendModeFromDisplayConfig) {
            setHalAutoSuspendModeLocked(true);
        }
    }
}
Body of Second Method:
{
    final boolean needWakeLockSuspendBlocker = ((mWakeLockSummary & WAKE_LOCK_CPU) != 0);
    final boolean needDisplaySuspendBlocker = needDisplaySuspendBlockerLocked();
    final boolean autoSuspend = !needDisplaySuspendBlocker;
    final boolean interactive = mDisplayPowerRequest.isBrightOrDim();
    // we already hold the necessary wakelocks.
    if (!autoSuspend && mDecoupleHalAutoSuspendModeFromDisplayConfig) {
        setHalAutoSuspendModeLocked(false);
    }
    // First acquire suspend blockers if needed.
    if (needWakeLockSuspendBlocker && !mHoldingWakeLockSuspendBlocker) {
        mWakeLockSuspendBlocker.acquire();
        mHoldingWakeLockSuspendBlocker = true;
    }
    if (needDisplaySuspendBlocker && !mHoldingDisplaySuspendBlocker) {
        mDisplaySuspendBlocker.acquire();
        mHoldingDisplaySuspendBlocker = true;
    }
    // Refer to getDesiredScreenPolicyLocked() for details.
    if (mDecoupleHalInteractiveModeFromDisplayConfig) {
        // too tangled over here...
        if (interactive || mDisplayReady) {
            setHalInteractiveModeLocked(interactive);
        }
    }
    // Then release suspend blockers if needed.
    if (!needWakeLockSuspendBlocker && mHoldingWakeLockSuspendBlocker) {
        mWakeLockSuspendBlocker.release();
        mHoldingWakeLockSuspendBlocker = false;
    }
    if (!needDisplaySuspendBlocker && mHoldingDisplaySuspendBlocker) {
        mDisplaySuspendBlocker.release();
        mHoldingDisplaySuspendBlocker = false;
    }
    // Enable auto-suspend if needed.
    if (autoSuspend && mDecoupleHalAutoSuspendModeFromDisplayConfig) {
        setHalAutoSuspendModeLocked(true);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.ExploreByTouchHelper.createNodeForChild:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Constructs and returns an {@link AccessibilityNodeInfo} for the
 * specified item. Automatically manages accessibility focus actions.
 * <p>
 * Allows the implementing class to specify most node properties, but
 * overrides the following:
 * <ul>
 * <li>{@link AccessibilityNodeInfo#setPackageName}
 * <li>{@link AccessibilityNodeInfo#setClassName}
 * <li>{@link AccessibilityNodeInfo#setParent(View)}
 * <li>{@link AccessibilityNodeInfo#setSource(View, int)}
 * <li>{@link AccessibilityNodeInfo#setVisibleToUser}
 * <li>{@link AccessibilityNodeInfo#setBoundsInScreen(Rect)}
 * </ul>
 * <p>
 * Uses the bounds of the parent view and the parent-relative bounding
 * rectangle specified by
 * {@link AccessibilityNodeInfo#getBoundsInParent} to automatically
 * update the following properties:
 * <ul>
 * <li>{@link AccessibilityNodeInfo#setVisibleToUser}
 * <li>{@link AccessibilityNodeInfo#setBoundsInParent}
 * </ul>
 *
 * @param virtualViewId The virtual view id for item for which to construct
 * a node.
 * @return An {@link AccessibilityNodeInfo} for the specified item.
 */

Body of Frist Method:
{
    final AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain();
    // Ensure the client has good defaults.
    node.setEnabled(true);
    node.setClassName(DEFAULT_CLASS_NAME);
    // Allow the client to populate the node.
    onPopulateNodeForVirtualView(virtualViewId, node);
    // Make sure the developer is following the rules.
    if ((node.getText() == null) && (node.getContentDescription() == null)) {
        throw new RuntimeException("Callbacks must add text or a content description in " + "populateNodeForVirtualViewId()");
    }
    node.getBoundsInParent(mTempParentRect);
    if (mTempParentRect.isEmpty()) {
        throw new RuntimeException("Callbacks must set parent bounds in " + "populateNodeForVirtualViewId()");
    }
    final int actions = node.getActions();
    if ((actions & AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS) != 0) {
        throw new RuntimeException("Callbacks must not add ACTION_ACCESSIBILITY_FOCUS in " + "populateNodeForVirtualViewId()");
    }
    if ((actions & AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS) != 0) {
        throw new RuntimeException("Callbacks must not add ACTION_CLEAR_ACCESSIBILITY_FOCUS in " + "populateNodeForVirtualViewId()");
    }
    // Don't allow the client to override these properties.
    node.setPackageName(mView.getContext().getPackageName());
    node.setSource(mView, virtualViewId);
    node.setParent(mView);
    // Manage internal accessibility focus state.
    if (mFocusedVirtualViewId == virtualViewId) {
        node.setAccessibilityFocused(true);
        node.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    } else {
        node.setAccessibilityFocused(false);
        node.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    }
    // Set the visibility based on the parent bound.
    if (intersectVisibleToUser(mTempParentRect)) {
        node.setVisibleToUser(true);
        node.setBoundsInParent(mTempParentRect);
    }
    // Calculate screen-relative bound.
    mView.getLocationOnScreen(mTempGlobalRect);
    final int offsetX = mTempGlobalRect[0];
    final int offsetY = mTempGlobalRect[1];
    mTempScreenRect.set(mTempParentRect);
    mTempScreenRect.offset(offsetX, offsetY);
    node.setBoundsInScreen(mTempScreenRect);
    return node;
}
Body of Second Method:
{
    ensureTempRects();
    final Rect tempParentRect = mTempParentRect;
    final int[] tempGlobalRect = mTempGlobalRect;
    final Rect tempScreenRect = mTempScreenRect;
    final AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain();
    // Ensure the client has good defaults.
    node.setEnabled(true);
    node.setClassName(DEFAULT_CLASS_NAME);
    node.setBoundsInParent(INVALID_PARENT_BOUNDS);
    // Allow the client to populate the node.
    onPopulateNodeForVirtualView(virtualViewId, node);
    // Make sure the developer is following the rules.
    if ((node.getText() == null) && (node.getContentDescription() == null)) {
        throw new RuntimeException("Callbacks must add text or a content description in " + "populateNodeForVirtualViewId()");
    }
    node.getBoundsInParent(tempParentRect);
    if (tempParentRect.equals(INVALID_PARENT_BOUNDS)) {
        throw new RuntimeException("Callbacks must set parent bounds in " + "populateNodeForVirtualViewId()");
    }
    final int actions = node.getActions();
    if ((actions & AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS) != 0) {
        throw new RuntimeException("Callbacks must not add ACTION_ACCESSIBILITY_FOCUS in " + "populateNodeForVirtualViewId()");
    }
    if ((actions & AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS) != 0) {
        throw new RuntimeException("Callbacks must not add ACTION_CLEAR_ACCESSIBILITY_FOCUS in " + "populateNodeForVirtualViewId()");
    }
    // Don't allow the client to override these properties.
    node.setPackageName(mView.getContext().getPackageName());
    node.setSource(mView, virtualViewId);
    node.setParent(mView);
    // Manage internal accessibility focus state.
    if (mFocusedVirtualViewId == virtualViewId) {
        node.setAccessibilityFocused(true);
        node.addAction(AccessibilityAction.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    } else {
        node.setAccessibilityFocused(false);
        node.addAction(AccessibilityAction.ACTION_ACCESSIBILITY_FOCUS);
    }
    // Set the visibility based on the parent bound.
    if (intersectVisibleToUser(tempParentRect)) {
        node.setVisibleToUser(true);
        node.setBoundsInParent(tempParentRect);
    }
    // Calculate screen-relative bound.
    mView.getLocationOnScreen(tempGlobalRect);
    final int offsetX = tempGlobalRect[0];
    final int offsetY = tempGlobalRect[1];
    tempScreenRect.set(tempParentRect);
    tempScreenRect.offset(offsetX, offsetY);
    node.setBoundsInScreen(tempScreenRect);
    return node;
}
------------------------
Find a functionally equivalent code:android.os.Debug.MemoryInfo.getOtherLabel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(which) {
        case 0:
            return "Dalvik Other";
        case 1:
            return "Stack";
        case 2:
            return "Cursor";
        case 3:
            return "Ashmem";
        case 4:
            return "Other dev";
        case 5:
            return ".so mmap";
        case 6:
            return ".jar mmap";
        case 7:
            return ".apk mmap";
        case 8:
            return ".ttf mmap";
        case 9:
            return ".dex mmap";
        case 10:
            return "code mmap";
        case 11:
            return "image mmap";
        case 12:
            return "Other mmap";
        case 13:
            return "Graphics";
        case 14:
            return "GL";
        case 15:
            return "Memtrack";
        case 16:
            return ".Heap";
        case 17:
            return ".LOS";
        case 18:
            return ".LinearAlloc";
        case 19:
            return ".GC";
        case 20:
            return ".JITCache";
        default:
            return "????";
    }
}
Body of Second Method:
{
    switch(which) {
        case 0:
            return "Dalvik Other";
        case 1:
            return "Stack";
        case 2:
            return "Cursor";
        case 3:
            return "Ashmem";
        case 4:
            return "Gfx dev";
        case 5:
            return "Other dev";
        case 6:
            return ".so mmap";
        case 7:
            return ".jar mmap";
        case 8:
            return ".apk mmap";
        case 9:
            return ".ttf mmap";
        case 10:
            return ".dex mmap";
        case 11:
            return ".oat mmap";
        case 12:
            return ".art mmap";
        case 13:
            return "Other mmap";
        case 14:
            return "EGL mtrack";
        case 15:
            return "GL mtrack";
        case 16:
            return "Other mtrack";
        case 17:
            return ".Heap";
        case 18:
            return ".LOS";
        case 19:
            return ".LinearAlloc";
        case 20:
            return ".GC";
        case 21:
            return ".JITCache";
        case 22:
            return ".Zygote";
        case 23:
            return ".NonMoving";
        case 24:
            return ".IndirectRef";
        default:
            return "????";
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.InsetDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    return Insets.of(contentInsets.left + mInsetState.mInsetLeft, contentInsets.top + mInsetState.mInsetTop, contentInsets.right + mInsetState.mInsetRight, contentInsets.bottom + mInsetState.mInsetBottom);
}
Body of Second Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    return Insets.of(contentInsets.left + mState.mInsetLeft, contentInsets.top + mState.mInsetTop, contentInsets.right + mState.mInsetRight, contentInsets.bottom + mState.mInsetBottom);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getUserAgent:COMMENT
<android.webkit.WebSettings: int getUserAgent()>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets the user-agent as an integer code.
 * <ul>
 * <li>-1 means the WebView is using a custom user-agent string set with
 * {@link #setUserAgentString}</li>
 * <li>0 means the WebView should use an Android user-agent string</li>
 * <li>1 means the WebView should use a desktop user-agent string</li>
 * </ul>
 *
 * @return the integer code for the user-agent string
 * @see #setUserAgent
 * @deprecated Please use {@link #getUserAgentString} instead.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.stack.StackScrollState.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Apply the properties saved in {@link #mStateMap} to the children of the {@link #mHostView}.
 * The properties are only applied if they effectively changed.
 */

Body of Frist Method:
{
    int numChildren = mHostView.getChildCount();
    for (int i = 0; i < numChildren; i++) {
        ExpandableView child = (ExpandableView) mHostView.getChildAt(i);
        ViewState state = mStateMap.get(child);
        if (state == null) {
            Log.wtf(CHILD_NOT_FOUND_TAG, "No child state was found when applying this state " + "to the hostView");
            continue;
        }
        if (!state.gone) {
            float alpha = child.getAlpha();
            float yTranslation = child.getTranslationY();
            float xTranslation = child.getTranslationX();
            float zTranslation = child.getTranslationZ();
            float scale = child.getScaleX();
            int height = child.getActualHeight();
            float newAlpha = state.alpha;
            float newYTranslation = state.yTranslation;
            float newZTranslation = state.zTranslation;
            float newScale = state.scale;
            int newHeight = state.height;
            boolean becomesInvisible = newAlpha == 0.0f;
            if (alpha != newAlpha && xTranslation == 0) {
                // apply layer type
                boolean becomesFullyVisible = newAlpha == 1.0f;
                boolean newLayerTypeIsHardware = !becomesInvisible && !becomesFullyVisible;
                int layerType = child.getLayerType();
                int newLayerType = newLayerTypeIsHardware ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
                if (layerType != newLayerType) {
                    child.setLayerType(newLayerType, null);
                }
                // apply alpha
                if (!becomesInvisible) {
                    child.setAlpha(newAlpha);
                }
            }
            // apply visibility
            int oldVisibility = child.getVisibility();
            int newVisibility = becomesInvisible ? View.INVISIBLE : View.VISIBLE;
            if (newVisibility != oldVisibility) {
                child.setVisibility(newVisibility);
            }
            // apply yTranslation
            if (yTranslation != newYTranslation) {
                child.setTranslationY(newYTranslation);
            }
            // apply zTranslation
            if (zTranslation != newZTranslation) {
                child.setTranslationZ(newZTranslation);
            }
            // apply scale
            if (scale != newScale) {
                child.setScaleX(newScale);
                child.setScaleY(newScale);
            }
            // apply height
            if (height != newHeight) {
                child.setActualHeight(newHeight, false);
            }
            // apply dimming
            child.setDimmed(state.dimmed, false);
            // apply dark
            child.setDark(state.dark, false);
            // apply hiding sensitive
            child.setHideSensitive(state.hideSensitive, false, /* animated */
            0, /* delay */
            0);
            // apply speed bump state
            child.setBelowSpeedBump(state.belowSpeedBump);
            // apply clipping
            float oldClipTopAmount = child.getClipTopAmount();
            if (oldClipTopAmount != state.clipTopAmount) {
                child.setClipTopAmount(state.clipTopAmount);
            }
            updateChildClip(child, newHeight, state.topOverLap);
            if (child instanceof SpeedBumpView) {
                performSpeedBumpAnimation(i, (SpeedBumpView) child, state, 0);
            } else if (child instanceof DismissView) {
                DismissView dismissView = (DismissView) child;
                boolean visible = state.topOverLap < mClearAllTopPadding;
                dismissView.performVisibilityAnimation(visible && !dismissView.willBeGone());
            } else if (child instanceof EmptyShadeView) {
                EmptyShadeView emptyShadeView = (EmptyShadeView) child;
                boolean visible = state.topOverLap <= 0;
                emptyShadeView.performVisibilityAnimation(visible && !emptyShadeView.willBeGone());
            }
        }
    }
}
Body of Second Method:
{
    int numChildren = mHostView.getChildCount();
    for (int i = 0; i < numChildren; i++) {
        ExpandableView child = (ExpandableView) mHostView.getChildAt(i);
        ViewState state = mStateMap.get(child);
        if (state == null) {
            Log.wtf(CHILD_NOT_FOUND_TAG, "No child state was found when applying this state " + "to the hostView");
            continue;
        }
        if (!state.gone) {
            float alpha = child.getAlpha();
            float yTranslation = child.getTranslationY();
            float xTranslation = child.getTranslationX();
            float zTranslation = child.getTranslationZ();
            float scale = child.getScaleX();
            int height = child.getActualHeight();
            float newAlpha = state.alpha;
            float newYTranslation = state.yTranslation;
            float newZTranslation = state.zTranslation;
            float newScale = state.scale;
            int newHeight = state.height;
            boolean becomesInvisible = newAlpha == 0.0f;
            if (alpha != newAlpha && xTranslation == 0) {
                // apply layer type
                boolean becomesFullyVisible = newAlpha == 1.0f;
                boolean newLayerTypeIsHardware = !becomesInvisible && !becomesFullyVisible;
                int layerType = child.getLayerType();
                int newLayerType = newLayerTypeIsHardware ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
                if (layerType != newLayerType) {
                    child.setLayerType(newLayerType, null);
                }
                // apply alpha
                child.setAlpha(newAlpha);
            }
            // apply visibility
            int oldVisibility = child.getVisibility();
            int newVisibility = becomesInvisible ? View.INVISIBLE : View.VISIBLE;
            if (newVisibility != oldVisibility) {
                child.setVisibility(newVisibility);
            }
            // apply yTranslation
            if (yTranslation != newYTranslation) {
                child.setTranslationY(newYTranslation);
            }
            // apply zTranslation
            if (zTranslation != newZTranslation) {
                child.setTranslationZ(newZTranslation);
            }
            // apply scale
            if (scale != newScale) {
                child.setScaleX(newScale);
                child.setScaleY(newScale);
            }
            // apply height
            if (height != newHeight) {
                child.setActualHeight(newHeight, false);
            }
            // apply dimming
            child.setDimmed(state.dimmed, false);
            // apply dark
            child.setDark(state.dark, false, /* animate */
            0);
            // apply hiding sensitive
            child.setHideSensitive(state.hideSensitive, false, /* animated */
            0, /* delay */
            0);
            // apply speed bump state
            child.setBelowSpeedBump(state.belowSpeedBump);
            // apply clipping
            float oldClipTopAmount = child.getClipTopAmount();
            if (oldClipTopAmount != state.clipTopAmount) {
                child.setClipTopAmount(state.clipTopAmount);
            }
            updateChildClip(child, newHeight, state.topOverLap);
            if (child instanceof SpeedBumpView) {
                performSpeedBumpAnimation(i, (SpeedBumpView) child, state, 0);
            } else if (child instanceof DismissView) {
                DismissView dismissView = (DismissView) child;
                boolean visible = state.topOverLap < mClearAllTopPadding;
                dismissView.performVisibilityAnimation(visible && !dismissView.willBeGone());
            } else if (child instanceof EmptyShadeView) {
                EmptyShadeView emptyShadeView = (EmptyShadeView) child;
                boolean visible = state.topOverLap <= 0;
                emptyShadeView.performVisibilityAnimation(visible && !emptyShadeView.willBeGone());
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.focusTask:COMMENT
Method Modifier: 
Comment:/**
 * Focuses the task at the specified index in the stack
 */

Body of Frist Method:
{
    // Return early if the task is already focused
    if (taskIndex == mFocusedTaskIndex)
        return;
    if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
        mFocusedTaskIndex = taskIndex;
        // Focus the view if possible, otherwise, focus the view after we scroll into position
        Task t = mStack.getTasks().get(taskIndex);
        TaskView tv = getChildViewForTask(t);
        Runnable postScrollRunnable = null;
        if (tv != null) {
            tv.setFocusedTask();
        } else {
            postScrollRunnable = new Runnable() {

                @Override
                public void run() {
                    Task t = mStack.getTasks().get(mFocusedTaskIndex);
                    TaskView tv = getChildViewForTask(t);
                    if (tv != null) {
                        tv.setFocusedTask();
                    }
                }
            };
        }
        // Scroll the view into position (just center it in the curve)
        if (scrollToNewPosition) {
            float newScroll = mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
            newScroll = mStackScroller.getBoundedStackScroll(newScroll);
            mStackScroller.animateScroll(mStackScroller.getStackScroll(), newScroll, postScrollRunnable);
        } else {
            if (postScrollRunnable != null) {
                postScrollRunnable.run();
            }
        }
    }
}
Body of Second Method:
{
    // Return early if the task is already focused
    if (taskIndex == mFocusedTaskIndex)
        return;
    if (0 <= taskIndex && taskIndex < mStack.getTaskCount()) {
        mFocusedTaskIndex = taskIndex;
        // Focus the view if possible, otherwise, focus the view after we scroll into position
        Task t = mStack.getTasks().get(taskIndex);
        TaskView tv = getChildViewForTask(t);
        Runnable postScrollRunnable = null;
        if (tv != null) {
            tv.setFocusedTask(animateFocusedState);
        } else {
            postScrollRunnable = new Runnable() {

                @Override
                public void run() {
                    Task t = mStack.getTasks().get(mFocusedTaskIndex);
                    TaskView tv = getChildViewForTask(t);
                    if (tv != null) {
                        tv.setFocusedTask(animateFocusedState);
                    }
                }
            };
        }
        // Scroll the view into position (just center it in the curve)
        if (scrollToNewPosition) {
            float newScroll = mLayoutAlgorithm.getStackScrollForTask(t) - 0.5f;
            newScroll = mStackScroller.getBoundedStackScroll(newScroll);
            mStackScroller.animateScroll(mStackScroller.getStackScroll(), newScroll, postScrollRunnable);
        } else {
            if (postScrollRunnable != null) {
                postScrollRunnable.run();
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.finishPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mWinShowWhenLocked != null && mWinShowWhenLocked != mTopFullscreenOpaqueWindowState) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        if (mForceStatusBar || mForceStatusBarFromKeyguard) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !isKeyguardSecure()) {
            mKeyguardHidden = true;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            // This is the case of keyguard isSecure() and not mHideLockScreen.
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                mKeyguardHidden = false;
                if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            mKeyguardHidden = false;
            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
Body of Second Method:
{
    if (mWinShowWhenLocked != null && mWinShowWhenLocked != mTopFullscreenOpaqueWindowState) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        if (mForceStatusBar || mForceStatusBarFromKeyguard) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardSecure) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            // This is the case of keyguard isSecure() and not mHideLockScreen.
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                mKeyguardHidden = false;
                if (setKeyguardOccludedLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDatabasePath:COMMENT
<android.webkit.WebSettings: void setDatabasePath(String)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:// once.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.Dialog.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#openOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.unsetFocusedTask:COMMENT
Method Modifier: 
Comment:/**
 * Unsets the focused task explicitly.
 */

Body of Frist Method:
{
    mIsFocused = false;
    if (mFocusAnimationsEnabled) {
        // Un-focus the header bar
        mHeaderView.onTaskViewFocusChanged(false);
    }
    // Update the thumbnail alpha with the focus
    mThumbnailView.onFocusChanged(false);
    // Call the callback
    mCb.onTaskViewFocusChanged(this, false);
    invalidate();
}
Body of Second Method:
{
    mIsFocused = false;
    if (mFocusAnimationsEnabled) {
        // Un-focus the header bar
        mHeaderView.onTaskViewFocusChanged(false, true);
    }
    // Update the thumbnail alpha with the focus
    mThumbnailView.onFocusChanged(false);
    // Call the callback
    if (mCb != null) {
        mCb.onTaskViewFocusChanged(this, false);
    }
    invalidate();
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.removeExpiredCookie:COMMENT
<android.webkit.CookieManager: void removeExpiredCookie()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all expired cookies.
 * @deprecated The WebView handles removing expired cookies automatically.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.needDisplaySuspendBlockerLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Return true if we must keep a suspend blocker active on behalf of the display.
 * We do so if the screen is on or is in transition between states.
 */

Body of Frist Method:
{
    if (!mDisplayReady) {
        return true;
    }
    if (mDisplayPowerRequest.isBrightOrDim()) {
        // sensor may not be correctly configured as a wake-up source.
        if (!mDisplayPowerRequest.useProximitySensor || !mProximityPositive || !mSuspendWhenScreenOffDueToProximityConfig) {
            return true;
        }
    }
    // Let the system suspend if the screen is off or dozing.
    return false;
}
Body of Second Method:
{
    if (!mDisplayReady) {
        return true;
    }
    if (mDisplayPowerRequest.isBrightOrDim()) {
        // sensor may not be correctly configured as a wake-up source.
        if (!mDisplayPowerRequest.useProximitySensor || !mProximityPositive || !mSuspendWhenScreenOffDueToProximityConfig) {
            return true;
        }
    }
    if (mScreenBrightnessBoostInProgress) {
        return true;
    }
    // Let the system suspend if the screen is off or dozing.
    return false;
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormatCount:COMMENT
Method Modifier: private     
Comment:/**
 * Count the number of publicly-visible output formats
 */

Body of Frist Method:
{
    HashMap<Integer, Integer> formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED)) {
        size -= 1;
    }
    return size;
}
Body of Second Method:
{
    HashMap<Integer, Integer> formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED)) {
        size -= 1;
    }
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_RAW_OPAQUE)) {
        size -= 1;
    }
    return size;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.InsetDrawable.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the drawable wrapped by this InsetDrawable. May be null.
 */

Body of Frist Method:
{
    return mInsetState.mDrawable;
}
Body of Second Method:
{
    return mState.mDrawable;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setUseWebViewBackgroundForOverscrollBackground:COMMENT
<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.AudioService.setStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamMute(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                if (streamType == AudioSystem.STREAM_MUSIC && mHdmiTvClient != null) {
                    synchronized (mHdmiTvClient) {
                        if (mHdmiSystemAudioSupported) {
                            mHdmiTvClient.setSystemAudioMute(state);
                        }
                    }
                }
            }
        }
        mStreamStates[streamType].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (streamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        streamType = getActiveStreamType(streamType);
    }
    int streamAlias = mStreamVolumeAlias[streamType];
    if (isStreamAffectedByMute(streamAlias)) {
        if (streamAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioMute(state);
        }
        for (int stream = 0; stream < mStreamStates.length; stream++) {
            if (streamAlias == mStreamVolumeAlias[stream]) {
                mStreamStates[stream].mute(cb, state);
                Intent intent = new Intent(AudioManager.STREAM_MUTE_CHANGED_ACTION);
                intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, stream);
                intent.putExtra(AudioManager.EXTRA_STREAM_VOLUME_MUTED, state);
                sendBroadcastToAll(intent);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.ResourceHelper.getDrawable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,
 * or an hexadecimal color
 * @param context the current context
 */

Body of Frist Method:
{
    if (value == null) {
        return null;
    }
    String stringValue = value.getValue();
    if (RenderResources.REFERENCE_NULL.equals(stringValue)) {
        return null;
    }
    String lowerCaseValue = stringValue.toLowerCase();
    Density density = Density.MEDIUM;
    if (value instanceof DensityBasedResourceValue) {
        density = ((DensityBasedResourceValue) value).getResourceDensity();
    }
    if (lowerCaseValue.endsWith(NinePatch.EXTENSION_9PATCH)) {
        File file = new File(stringValue);
        if (file.isFile()) {
            try {
                return getNinePatchDrawable(new FileInputStream(file), density, value.isFramework(), stringValue, context);
            } catch (IOException e) {
                // failed to read the file, we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + file.getAbsolutePath(), e, null);
            }
        }
        return null;
    } else if (lowerCaseValue.endsWith(".xml")) {
        // create a block parser for the file
        File f = new File(stringValue);
        if (f.isFile()) {
            try {
                // let the framework inflate the Drawable from the XML file.
                XmlPullParser parser = ParserFactory.create(f);
                BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, context, value.isFramework());
                try {
                    return Drawable.createFromXml(context.getResources(), blockParser);
                } finally {
                    blockParser.ensurePopped();
                }
            } catch (Exception e) {
                // this is an error and not warning since the file existence is checked before
                // attempting to parse it.
                Bridge.getLog().error(null, "Failed to parse file " + stringValue, e, null);
            }
        } else {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, String.format("File %s does not exist (or is not a file)", stringValue), null);
        }
        return null;
    } else {
        File bmpFile = new File(stringValue);
        if (bmpFile.isFile()) {
            try {
                Bitmap bitmap = Bridge.getCachedBitmap(stringValue, value.isFramework() ? null : context.getProjectKey());
                if (bitmap == null) {
                    bitmap = Bitmap_Delegate.createBitmap(bmpFile, false, /*isMutable*/
                    density);
                    Bridge.setCachedBitmap(stringValue, bitmap, value.isFramework() ? null : context.getProjectKey());
                }
                return new BitmapDrawable(context.getResources(), bitmap);
            } catch (IOException e) {
                // we'll return null below
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed lot load " + bmpFile.getAbsolutePath(), e, null);
            }
        } else {
            // attempt to get a color from the value
            try {
                int color = getColor(stringValue);
                return new ColorDrawable(color);
            } catch (NumberFormatException e) {
                // we'll return null below.
                Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, "Failed to convert " + stringValue + " into a drawable", e, null);
            }
        }
    }
    return null;
}
Body of Second Method:
{
    return getDrawable(value, context, null);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ClipDrawable.setLayoutDirection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mClipState.mDrawable.setLayoutDirection(layoutDirection);
    super.setLayoutDirection(layoutDirection);
}
Body of Second Method:
{
    mState.mDrawable.setLayoutDirection(layoutDirection);
    super.setLayoutDirection(layoutDirection);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDefaultFixedFontSize:COMMENT
<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.enableSmoothTransition:COMMENT
<android.webkit.WebSettings: boolean enableSmoothTransition()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether the WebView enables smooth transition while panning or
 * zooming.
 *
 * @see #setEnableSmoothTransition
 *
 * @deprecated This method is now obsolete, and will become a no-op in future.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.display.LogicalDisplay.getDisplayInfoLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Gets information about the logical display.
 *
 * @return The device info, which should be treated as immutable by the caller.
 * The logical display should allocate a new display info object whenever
 * the data changes.
 */

Body of Frist Method:
{
    if (mInfo == null) {
        mInfo = new DisplayInfo();
        if (mOverrideDisplayInfo != null) {
            mInfo.copyFrom(mOverrideDisplayInfo);
            mInfo.layerStack = mBaseDisplayInfo.layerStack;
            mInfo.name = mBaseDisplayInfo.name;
            mInfo.state = mBaseDisplayInfo.state;
        } else {
            mInfo.copyFrom(mBaseDisplayInfo);
        }
    }
    return mInfo;
}
Body of Second Method:
{
    if (mInfo == null) {
        mInfo = new DisplayInfo();
        if (mOverrideDisplayInfo != null) {
            mInfo.copyFrom(mOverrideDisplayInfo);
            mInfo.layerStack = mBaseDisplayInfo.layerStack;
            mInfo.name = mBaseDisplayInfo.name;
            mInfo.uniqueId = mBaseDisplayInfo.uniqueId;
            mInfo.state = mBaseDisplayInfo.state;
        } else {
            mInfo.copyFrom(mBaseDisplayInfo);
        }
    }
    return mInfo;
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.setPlaybackHeadPosition:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the playback head position.
 * The track must be stopped or paused for the position to be changed,
 * and must use the {@link #MODE_STATIC} mode.
 * @param positionInFrames playback head position expressed in frames
 * Zero corresponds to start of buffer.
 * The position must not be greater than the buffer size in frames, or negative.
 * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
 * {@link #ERROR_INVALID_OPERATION}
 */

Body of Frist Method:
{
    if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (!(0 <= positionInFrames && positionInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_position(positionInFrames);
}
Body of Second Method:
{
    if (mDataLoadMode == MODE_STREAM || mState == STATE_UNINITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (!(0 <= positionInFrames && positionInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_position(positionInFrames);
}
------------------------
Find a functionally equivalent code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     
Comment:/**
 * Check if mobile network with matching IMSI.
 */

Body of Frist Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equals(mSubscriberId, ident.mSubscriberId));
    }
}
Body of Second Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        final boolean matchesType = (sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType));
        return matchesType && ArrayUtils.contains(mMatchSubscriberIds, ident.mSubscriberId);
    }
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.shouldShowSelector:COMMENT
Method Modifier: 
Comment:/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */

Body of Frist Method:
{
    return (!isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}
Body of Second Method:
{
    return (isFocused() && !isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.removeAllViewsInLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may "have" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */

Body of Frist Method:
{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        if (getWindow().performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}
Body of Second Method:
{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        Window w = getWindow();
        if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) && w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.screenshot.ScreenshotTest.testScreenshot:COMMENT
Method Modifier: public      
Comment:/**
 * A simple test for screenshots that launches an Activity, injects the key event combo
 * to trigger the screenshot, and verifies the screenshot was taken successfully.
 */

Body of Frist Method:
{
    Log.d(LOG_TAG, "starting testScreenshot");
    // launch the activity.
    ScreenshotStubActivity activity = getActivity();
    assertNotNull(activity);
    File screenshotDir = getScreenshotDir();
    NewScreenshotObserver observer = new NewScreenshotObserver(screenshotDir.getAbsolutePath());
    observer.startWatching();
    takeScreenshot();
    // unlikely, but check if a new screenshot file was already created
    if (observer.getCreatedPath() == null) {
        // wait for screenshot to be created
        synchronized (observer) {
            observer.wait(SCREEN_WAIT_TIME_SEC * 1000);
        }
    }
    assertNotNull(String.format("Could not find screenshot after %d seconds", SCREEN_WAIT_TIME_SEC), observer.getCreatedPath());
    File screenshotFile = new File(screenshotDir, observer.getCreatedPath());
    try {
        assertTrue(String.format("Detected new screenshot %s but its not a file", screenshotFile.getName()), screenshotFile.isFile());
        assertTrue(String.format("Detected new screenshot %s but its not an image", screenshotFile.getName()), isValidImage(screenshotFile));
    } finally {
        // delete the file to prevent external storage from filing up
        screenshotFile.delete();
    }
}
Body of Second Method:
{
    if (true) {
        // Disable until this works again.
        return;
    }
    Log.d(LOG_TAG, "starting testScreenshot");
    // launch the activity.
    ScreenshotStubActivity activity = getActivity();
    assertNotNull(activity);
    File screenshotDir = getScreenshotDir();
    NewScreenshotObserver observer = new NewScreenshotObserver(screenshotDir.getAbsolutePath());
    observer.startWatching();
    takeScreenshot();
    // unlikely, but check if a new screenshot file was already created
    if (observer.getCreatedPath() == null) {
        // wait for screenshot to be created
        synchronized (observer) {
            observer.wait(SCREEN_WAIT_TIME_SEC * 1000);
        }
    }
    assertNotNull(String.format("Could not find screenshot after %d seconds", SCREEN_WAIT_TIME_SEC), observer.getCreatedPath());
    File screenshotFile = new File(screenshotDir, observer.getCreatedPath());
    try {
        assertTrue(String.format("Detected new screenshot %s but its not a file", screenshotFile.getName()), screenshotFile.isFile());
        assertTrue(String.format("Detected new screenshot %s but its not an image", screenshotFile.getName()), isValidImage(screenshotFile));
    } finally {
        // delete the file to prevent external storage from filing up
        screenshotFile.delete();
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

Body of Frist Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
Body of Second Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.FM_TUNER) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.ScaleDrawable.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the drawable scaled by this ScaleDrawable.
 */

Body of Frist Method:
{
    return mScaleState.mDrawable;
}
Body of Second Method:
{
    return mState.mDrawable;
}
------------------------
Find a functionally equivalent code:android.webkit.WebBackForwardList.getItemAtIndex:COMMENT
<android.webkit.WebBackForwardList: WebHistoryItem getItemAtIndex(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the history item at the given index. The index range is from 0...n
 * where 0 is the first item and n is the last item.
 * @param index The index to retrieve.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.BackStackRecord.addTransitionTargets:COMMENT
Method Modifier: private     
Comment:/**
 * Prepares the enter transition by adding a non-existent view to the transition's target list
 * and setting it epicenter callback. By adding a non-existent view to the target list,
 * we can prevent any view from being targeted at the beginning of the transition.
 * We will add to the views before the end state of the transition is captured so that the
 * views will appear. At the start of the transition, we clear the list of targets so that
 * we can restore the state of the transition and use it again.
 *
 * <p>The shared element transition maps its shared elements immediately prior to
 * capturing the final state of the Transition.</p>
 */

Body of Frist Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                sharedElementTargets.clear();
                if (namedViews.isEmpty()) {
                    sharedElementTargets.add(state.nonExistentView);
                } else {
                    sharedElementTargets.addAll(namedViews.values());
                }
                addTargets(sharedElementTransition, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
Body of Second Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                sharedElementTargets.clear();
                sharedElementTargets.add(state.nonExistentView);
                sharedElementTargets.addAll(namedViews.values());
                addTargets(sharedElementTransition, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    enteringViews.add(state.nonExistentView);
                    // We added this earlier to prevent any views being targeted.
                    enterTransition.removeTarget(state.nonExistentView);
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.supportZoom:COMMENT
<android.webkit.WebSettings: boolean supportZoom()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports zoom.
 *
 * @return true if the WebView supports zoom
 * @see #setSupportZoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockPatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether the lock pattern is enabled, or if it is set as a backup for biometric weak
 */

Body of Frist Method:
{
    final boolean backupEnabled = getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
    return getBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, false) && (getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING || (usingBiometricWeak() && backupEnabled));
}
Body of Second Method:
{
    return isLockPatternEnabled(getCurrentOrCallingUserId());
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.intensive.Main.testRendering:COMMENT
Method Modifier: public      
Comment:/**
 * Create a new rendering session and test that rendering /layout/activity.xml on nexus 5
 * doesn't throw any exceptions.
 */

Body of Frist Method:
{
    // Create the layout pull parser.
    LayoutPullParser parser = new LayoutPullParser(APP_TEST_RES + "/layout/activity.xml");
    // Create LayoutLibCallback.
    LayoutLibTestCallback layoutLibCallback = new LayoutLibTestCallback(getLogger());
    layoutLibCallback.initResources();
    // TODO: Set up action bar handler properly to test menu rendering.
    // Create session params.
    SessionParams params = getSessionParams(parser, ConfigGenerator.NEXUS_5, layoutLibCallback);
    RenderSession session = mBridge.createSession(params);
    if (!session.getResult().isSuccess()) {
        getLogger().error(session.getResult().getException(), session.getResult().getErrorMessage());
    }
    // Render the session with a timeout of 50s.
    Result renderResult = session.render(50000);
    if (!renderResult.isSuccess()) {
        getLogger().error(session.getResult().getException(), session.getResult().getErrorMessage());
    }
}
Body of Second Method:
{
    // Create the layout pull parser.
    LayoutPullParser parser = new LayoutPullParser(APP_TEST_RES + "/layout/activity.xml");
    // Create LayoutLibCallback.
    LayoutLibTestCallback layoutLibCallback = new LayoutLibTestCallback(getLogger());
    layoutLibCallback.initResources();
    // TODO: Set up action bar handler properly to test menu rendering.
    // Create session params.
    SessionParams params = getSessionParams(parser, ConfigGenerator.NEXUS_5, layoutLibCallback);
    RenderSession session = mBridge.createSession(params);
    if (!session.getResult().isSuccess()) {
        getLogger().error(session.getResult().getException(), session.getResult().getErrorMessage());
    }
    // Render the session with a timeout of 50s.
    Result renderResult = session.render(50000);
    if (!renderResult.isSuccess()) {
        getLogger().error(session.getResult().getException(), session.getResult().getErrorMessage());
    }
    try {
        String goldenImagePath = APP_TEST_DIR + "/golden/activity.png";
        ImageUtils.requireSimilar(goldenImagePath, session.getImage());
    } catch (IOException e) {
        getLogger().error(e, e.getMessage());
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.forceVolumeControlStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * forces the stream controlled by hard volume keys
 * specifying streamType == -1 releases control to the
 * logic.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
Body of Second Method:
{
    if (mUseMasterVolume) {
        return;
    }
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.getId:COMMENT
<android.webkit.WebHistoryItem: int getId()>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Return an identifier for this history item. If an item is a copy of
 * another item, the identifiers will be the same even if they are not the
 * same object.
 * @return The id for this item.
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.AudioService.adjustMasterVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#adjustMasterVolume(int, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    ensureValidSteps(steps);
    int volume = Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
    int delta = 0;
    int numSteps = Math.abs(steps);
    int direction = steps > 0 ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
    for (int i = 0; i < numSteps; ++i) {
        delta = findVolumeDelta(direction, volume);
        volume += delta;
    }
    // Log.d(TAG, "adjustMasterVolume volume: " + volume + " steps: " + steps);
    setMasterVolume(volume, flags, callingPackage);
}
Body of Second Method:
{
    adjustMasterVolume(steps, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowManagerService.performLayoutAndPlaceSurfacesLockedInner:COMMENT
Method Modifier: private     final       
Comment:// "Something has changed!  Let's make it correct now."

Body of Frist Method:
{
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by " + Debug.getCallers(3));
    }
    final long currentTime = SystemClock.uptimeMillis();
    int i;
    boolean updateInputWindowsNeeded = false;
    if (mFocusMayChange) {
        mFocusMayChange = false;
        updateInputWindowsNeeded = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false);
    }
    // Initialize state of exiting tokens.
    final int numDisplays = mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        for (i = displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
            displayContent.mExitingTokens.get(i).hasVisible = false;
        }
    }
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (int tokenNdx = exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
            exitingAppTokens.get(tokenNdx).hasVisible = false;
        }
    }
    mInnerFields.mHoldScreen = null;
    mInnerFields.mScreenBrightness = -1;
    mInnerFields.mButtonBrightness = -1;
    mInnerFields.mUserActivityTimeout = -1;
    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = false;
    mTransactionSequence++;
    final DisplayContent defaultDisplay = getDefaultDisplayContentLocked();
    final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();
    final int defaultDw = defaultInfo.logicalWidth;
    final int defaultDh = defaultInfo.logicalHeight;
    if (SHOW_LIGHT_TRANSACTIONS)
        Slog.i(TAG, ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
    SurfaceControl.openTransaction();
    try {
        if (mWatermark != null) {
            mWatermark.positionSurface(defaultDw, defaultDh);
        }
        if (mStrictModeFlash != null) {
            mStrictModeFlash.positionSurface(defaultDw, defaultDh);
        }
        if (mCircularDisplayMask != null) {
            mCircularDisplayMask.positionSurface(defaultDw, defaultDh, mRotation);
        }
        if (mEmulatorDisplayOverlay != null) {
            mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mRotation);
        }
        boolean focusDisplayed = false;
        for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
            final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
            boolean updateAllDrawn = false;
            WindowList windows = displayContent.getWindowList();
            DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final int displayId = displayContent.getDisplayId();
            final int dw = displayInfo.logicalWidth;
            final int dh = displayInfo.logicalHeight;
            final int innerDw = displayInfo.appWidth;
            final int innerDh = displayInfo.appHeight;
            final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
            // Reset for each display.
            mInnerFields.mDisplayHasContent = false;
            mInnerFields.mPreferredRefreshRate = 0;
            int repeats = 0;
            do {
                repeats++;
                if (repeats > 6) {
                    Slog.w(TAG, "Animation repeat aborted after too many iterations");
                    displayContent.layoutNeeded = false;
                    break;
                }
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("On entry to LockedInner", displayContent.pendingLayoutChanges);
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && (adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
                    assignLayersLocked(windows);
                    displayContent.layoutNeeded = true;
                }
                if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Computing new config from layout");
                    if (updateOrientationFromAppTokensLocked(true)) {
                        displayContent.layoutNeeded = true;
                        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
                    }
                }
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
                    displayContent.layoutNeeded = true;
                }
                // FIRST LOOP: Perform a layout, if needed.
                if (repeats < 4) {
                    performLayoutLockedInner(displayContent, repeats == 1, false);
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                }
                // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think
                // it is animating.
                displayContent.pendingLayoutChanges = 0;
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("loop number " + mLayoutRepeatCount, displayContent.pendingLayoutChanges);
                if (isDefaultDisplay) {
                    mPolicy.beginPostLayoutPolicyLw(dw, dh);
                    for (i = windows.size() - 1; i >= 0; i--) {
                        WindowState w = windows.get(i);
                        if (w.mHasSurface) {
                            mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs);
                        }
                    }
                    displayContent.pendingLayoutChanges |= mPolicy.finishPostLayoutPolicyLw();
                    if (DEBUG_LAYOUT_REPEATS)
                        debugLayoutRepeats("after finishPostLayoutPolicyLw", displayContent.pendingLayoutChanges);
                }
            } while (displayContent.pendingLayoutChanges != 0);
            mInnerFields.mObscured = false;
            mInnerFields.mSyswin = false;
            displayContent.resetDimming();
            // Only used if default window
            final boolean someoneLosingFocus = !mLosingFocus.isEmpty();
            final int N = windows.size();
            for (i = N - 1; i >= 0; i--) {
                WindowState w = windows.get(i);
                final TaskStack stack = w.getStack();
                if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
                    continue;
                }
                final boolean obscuredChanged = w.mObscured != mInnerFields.mObscured;
                // Update effect.
                w.mObscured = mInnerFields.mObscured;
                if (!mInnerFields.mObscured) {
                    handleNotObscuredLocked(w, currentTime, innerDw, innerDh);
                }
                if (stack != null && !stack.testDimmingTag()) {
                    handleFlagDimBehind(w);
                }
                if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w) && w.isVisibleLw()) {
                    // This is the wallpaper target and its obscured state
                    // changed... make sure the current wallaper's visibility
                    // has been updated accordingly.
                    updateWallpaperVisibilityLocked();
                }
                final WindowStateAnimator winAnimator = w.mWinAnimator;
                // it.
                if (w.mHasSurface && w.shouldAnimateMove()) {
                    // Frame has moved, containing content frame
                    // has also moved, and we're not currently animating...
                    // let's do something.
                    Animation a = AnimationUtils.loadAnimation(mContext, com.android.internal.R.anim.window_move_from_decor);
                    winAnimator.setAnimation(a);
                    winAnimator.mAnimDw = w.mLastFrame.left - w.mFrame.left;
                    winAnimator.mAnimDh = w.mLastFrame.top - w.mFrame.top;
                    // TODO (multidisplay): Accessibility supported only for the default display.
                    if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
                        mAccessibilityController.onSomeWindowResizedOrMovedLocked();
                    }
                    try {
                        w.mClient.moved(w.mFrame.left, w.mFrame.top);
                    } catch (RemoteException e) {
                    }
                }
                // Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
                w.mContentChanged = false;
                // Moved from updateWindowsAndWallpaperLocked().
                if (w.mHasSurface) {
                    // Take care of the window being ready to display.
                    final boolean committed = winAnimator.commitFinishDrawingLocked(currentTime);
                    if (isDefaultDisplay && committed) {
                        if (w.mAttrs.type == TYPE_DREAM) {
                            // HACK: When a dream is shown, it may at that
                            // point hide the lock screen.  So we need to
                            // redo the layout to let the phone window manager
                            // make this happen.
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("dream and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                        if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                            if (DEBUG_WALLPAPER_LIGHT)
                                Slog.v(TAG, "First draw done in potential wallpaper target " + w);
                            mInnerFields.mWallpaperMayChange = true;
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                    }
                    winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
                    final AppWindowToken atoken = w.mAppToken;
                    if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
                        Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen=" + w.isOnScreen() + " allDrawn=" + atoken.allDrawn + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
                    }
                    if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
                        if (atoken.lastTransactionSequence != mTransactionSequence) {
                            atoken.lastTransactionSequence = mTransactionSequence;
                            atoken.numInterestingWindows = atoken.numDrawnWindows = 0;
                            atoken.startingDisplayed = false;
                        }
                        if ((w.isOnScreen() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                                Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw() + ", isAnimating=" + winAnimator.isAnimating());
                                if (!w.isDrawnLw()) {
                                    Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl + " pv=" + w.mPolicyVisibility + " mDrawState=" + winAnimator.mDrawState + " ah=" + w.mAttachedHidden + " th=" + atoken.hiddenRequested + " a=" + winAnimator.mAnimating);
                                }
                            }
                            if (w != atoken.startingWindow) {
                                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                                    atoken.numInterestingWindows++;
                                    if (w.isDrawnLw()) {
                                        atoken.numDrawnWindows++;
                                        if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)
                                            Slog.v(TAG, "tokenMayBeDrawn: " + atoken + " freezingScreen=" + atoken.mAppAnimator.freezingScreen + " mAppFreezing=" + w.mAppFreezing);
                                        updateAllDrawn = true;
                                    }
                                }
                            } else if (w.isDrawnLw()) {
                                atoken.startingDisplayed = true;
                            }
                        }
                    }
                }
                if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus) && w.isDisplayedLw()) {
                    focusDisplayed = true;
                }
                updateResizingWindows(w);
            }
            mDisplayManagerInternal.setDisplayProperties(displayId, mInnerFields.mDisplayHasContent, mInnerFields.mPreferredRefreshRate, true);
            getDisplayContentLocked(displayId).stopDimmingIfNeeded();
            if (updateAllDrawn) {
                updateAllDrawnLocked(displayContent);
            }
        }
        if (focusDisplayed) {
            mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
        }
        // Give the display manager a chance to adjust properties
        // like display rotation if it needs to.
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } catch (RuntimeException e) {
        Slog.wtf(TAG, "Unhandled exception in Window Manager", e);
    } finally {
        SurfaceControl.closeTransaction();
        if (SHOW_LIGHT_TRANSACTIONS)
            Slog.i(TAG, "<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
    }
    final WindowList defaultWindows = defaultDisplay.getWindowList();
    // to go.
    if (mAppTransition.isReady()) {
        defaultDisplay.pendingLayoutChanges |= handleAppTransitionReadyLocked(defaultWindows);
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAppTransitionReadyLocked", defaultDisplay.pendingLayoutChanges);
    }
    if (!mAnimator.mAnimating && mAppTransition.isRunning()) {
        // We have finished the animation of an app transition.  To do
        // this, we have delayed a lot of operations like showing and
        // hiding apps, moving apps in Z-order, etc.  The app token list
        // reflects the correct Z-order, but the window list may now
        // be out of sync with it.  So here we will just rebuild the
        // entire app window list.  Fun!
        defaultDisplay.pendingLayoutChanges |= handleAnimatingStoppedAndTransitionLocked();
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAnimStopAndXitionLock", defaultDisplay.pendingLayoutChanges);
    }
    if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
        // At this point, there was a window with a wallpaper that
        // was force hiding other windows behind it, but now it
        // is going away.  This may be simple -- just animate
        // away the wallpaper and its window -- or it may be
        // hard -- the wallpaper now needs to be shown behind
        // something that was hidden.
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after animateAwayWallpaperLocked", defaultDisplay.pendingLayoutChanges);
    }
    mInnerFields.mWallpaperForceHidingChanged = false;
    if (mInnerFields.mWallpaperMayChange) {
        if (DEBUG_WALLPAPER_LIGHT)
            Slog.v(TAG, "Wallpaper may change!  Adjusting");
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("WallpaperMayChange", defaultDisplay.pendingLayoutChanges);
    }
    if (mFocusMayChange) {
        mFocusMayChange = false;
        if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false)) {
            updateInputWindowsNeeded = true;
            defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
        }
    }
    if (needsLayout()) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("mLayoutNeeded", defaultDisplay.pendingLayoutChanges);
    }
    for (i = mResizingWindows.size() - 1; i >= 0; i--) {
        WindowState win = mResizingWindows.get(i);
        if (win.mAppFreezing) {
            // Don't remove this window until rotation has completed.
            continue;
        }
        win.reportResized();
        mResizingWindows.remove(i);
    }
    if (DEBUG_ORIENTATION && mDisplayFrozen)
        Slog.v(TAG, "With display frozen, orientationChangeComplete=" + mInnerFields.mOrientationChangeComplete);
    if (mInnerFields.mOrientationChangeComplete) {
        if (mWindowsFreezingScreen) {
            mWindowsFreezingScreen = false;
            mLastFinishedFreezeSource = mInnerFields.mLastWindowFreezeSource;
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        }
        stopFreezingDisplayLocked();
    }
    // Destroy the surface of any windows that are no longer visible.
    boolean wallpaperDestroyed = false;
    i = mDestroySurface.size();
    if (i > 0) {
        do {
            i--;
            WindowState win = mDestroySurface.get(i);
            win.mDestroying = false;
            if (mInputMethodWindow == win) {
                mInputMethodWindow = null;
            }
            if (win == mWallpaperTarget) {
                wallpaperDestroyed = true;
            }
            win.mWinAnimator.destroySurfaceLocked();
        } while (i > 0);
        mDestroySurface.clear();
    }
    // Time to remove any exiting tokens?
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        ArrayList<WindowToken> exitingTokens = displayContent.mExitingTokens;
        for (i = exitingTokens.size() - 1; i >= 0; i--) {
            WindowToken token = exitingTokens.get(i);
            if (!token.hasVisible) {
                exitingTokens.remove(i);
                if (token.windowType == TYPE_WALLPAPER) {
                    mWallpaperTokens.remove(token);
                }
            }
        }
    }
    // Time to remove any exiting applications?
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (i = exitingAppTokens.size() - 1; i >= 0; i--) {
            AppWindowToken token = exitingAppTokens.get(i);
            if (!token.hasVisible && !mClosingApps.contains(token) && !token.mDeferRemoval) {
                // Make sure there is no animation running on this token,
                // so any windows associated with it will be removed as
                // soon as their animations are complete
                token.mAppAnimator.clearAnimation();
                token.mAppAnimator.animating = false;
                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)
                    Slog.v(TAG, "performLayout: App token exiting now removed" + token);
                removeAppFromTaskLocked(token);
                exitingAppTokens.remove(i);
            }
        }
    }
    if (!mAnimator.mAnimating && mRelayoutWhileAnimating.size() > 0) {
        for (int j = mRelayoutWhileAnimating.size() - 1; j >= 0; j--) {
            try {
                mRelayoutWhileAnimating.get(j).mClient.doneAnimating();
            } catch (RemoteException e) {
            }
        }
        mRelayoutWhileAnimating.clear();
    }
    if (wallpaperDestroyed) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        defaultDisplay.layoutNeeded = true;
    }
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        if (displayContent.pendingLayoutChanges != 0) {
            displayContent.layoutNeeded = true;
        }
    }
    // Finally update all input windows now that the window changes have stabilized.
    mInputMonitor.updateInputWindowsLw(true);
    setHoldScreenLocked(mInnerFields.mHoldScreen);
    if (!mDisplayFrozen) {
        if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
        }
        if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
        }
        mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
    }
    if (mTurnOnScreen) {
        if (DEBUG_VISIBILITY)
            Slog.v(TAG, "Turning screen on after layout!");
        mPowerManager.wakeUp(SystemClock.uptimeMillis());
        mTurnOnScreen = false;
    }
    if (mInnerFields.mUpdateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        if (updateRotationUncheckedLocked(false)) {
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
        } else {
            mInnerFields.mUpdateRotation = false;
        }
    }
    if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
        checkDrawnWindowsLocked();
    }
    final int N = mPendingRemove.size();
    if (N > 0) {
        if (mPendingRemoveTmp.length < N) {
            mPendingRemoveTmp = new WindowState[N + 10];
        }
        mPendingRemove.toArray(mPendingRemoveTmp);
        mPendingRemove.clear();
        DisplayContentList displayList = new DisplayContentList();
        for (i = 0; i < N; i++) {
            WindowState w = mPendingRemoveTmp[i];
            removeWindowInnerLocked(w.mSession, w);
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && !displayList.contains(displayContent)) {
                displayList.add(displayContent);
            }
        }
        for (DisplayContent displayContent : displayList) {
            assignLayersLocked(displayContent.getWindowList());
            displayContent.layoutNeeded = true;
        }
    }
    // Remove all deferred displays stacks, tasks, and activities.
    for (int displayNdx = mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
        mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
    }
    if (updateInputWindowsNeeded) {
        mInputMonitor.updateInputWindowsLw(false);
    }
    setFocusedStackFrame();
    // Check to see if we are now in a state where the screen should
    // be enabled, because the window obscured flags have changed.
    enableScreenIfNeededLocked();
    scheduleAnimationLocked();
    if (DEBUG_WINDOW_TRACE) {
        Slog.e(TAG, "performLayoutAndPlaceSurfacesLockedInner exit: animating=" + mAnimator.mAnimating);
    }
}
Body of Second Method:
{
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by " + Debug.getCallers(3));
    }
    final long currentTime = SystemClock.uptimeMillis();
    int i;
    boolean updateInputWindowsNeeded = false;
    if (mFocusMayChange) {
        mFocusMayChange = false;
        updateInputWindowsNeeded = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false);
    }
    // Initialize state of exiting tokens.
    final int numDisplays = mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        for (i = displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
            displayContent.mExitingTokens.get(i).hasVisible = false;
        }
    }
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (int tokenNdx = exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
            exitingAppTokens.get(tokenNdx).hasVisible = false;
        }
    }
    mInnerFields.mHoldScreen = null;
    mInnerFields.mScreenBrightness = -1;
    mInnerFields.mButtonBrightness = -1;
    mInnerFields.mUserActivityTimeout = -1;
    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = false;
    mTransactionSequence++;
    final DisplayContent defaultDisplay = getDefaultDisplayContentLocked();
    final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();
    final int defaultDw = defaultInfo.logicalWidth;
    final int defaultDh = defaultInfo.logicalHeight;
    if (SHOW_LIGHT_TRANSACTIONS)
        Slog.i(TAG, ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
    SurfaceControl.openTransaction();
    try {
        if (mWatermark != null) {
            mWatermark.positionSurface(defaultDw, defaultDh);
        }
        if (mStrictModeFlash != null) {
            mStrictModeFlash.positionSurface(defaultDw, defaultDh);
        }
        if (mCircularDisplayMask != null) {
            mCircularDisplayMask.positionSurface(defaultDw, defaultDh, mRotation);
        }
        if (mEmulatorDisplayOverlay != null) {
            mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mRotation);
        }
        boolean focusDisplayed = false;
        for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
            final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
            boolean updateAllDrawn = false;
            WindowList windows = displayContent.getWindowList();
            DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final int displayId = displayContent.getDisplayId();
            final int dw = displayInfo.logicalWidth;
            final int dh = displayInfo.logicalHeight;
            final int innerDw = displayInfo.appWidth;
            final int innerDh = displayInfo.appHeight;
            final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
            // Reset for each display.
            mInnerFields.mDisplayHasContent = false;
            mInnerFields.mPreferredRefreshRate = 0;
            int repeats = 0;
            do {
                repeats++;
                if (repeats > 6) {
                    Slog.w(TAG, "Animation repeat aborted after too many iterations");
                    displayContent.layoutNeeded = false;
                    break;
                }
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("On entry to LockedInner", displayContent.pendingLayoutChanges);
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && (adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
                    assignLayersLocked(windows);
                    displayContent.layoutNeeded = true;
                }
                if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Computing new config from layout");
                    if (updateOrientationFromAppTokensLocked(true)) {
                        displayContent.layoutNeeded = true;
                        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
                    }
                }
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
                    displayContent.layoutNeeded = true;
                }
                // FIRST LOOP: Perform a layout, if needed.
                if (repeats < 4) {
                    performLayoutLockedInner(displayContent, repeats == 1, false);
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                }
                // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think
                // it is animating.
                displayContent.pendingLayoutChanges = 0;
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("loop number " + mLayoutRepeatCount, displayContent.pendingLayoutChanges);
                if (isDefaultDisplay) {
                    mPolicy.beginPostLayoutPolicyLw(dw, dh);
                    for (i = windows.size() - 1; i >= 0; i--) {
                        WindowState w = windows.get(i);
                        if (w.mHasSurface) {
                            mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow);
                        }
                    }
                    displayContent.pendingLayoutChanges |= mPolicy.finishPostLayoutPolicyLw();
                    if (DEBUG_LAYOUT_REPEATS)
                        debugLayoutRepeats("after finishPostLayoutPolicyLw", displayContent.pendingLayoutChanges);
                }
            } while (displayContent.pendingLayoutChanges != 0);
            mInnerFields.mObscured = false;
            mInnerFields.mSyswin = false;
            displayContent.resetDimming();
            // Only used if default window
            final boolean someoneLosingFocus = !mLosingFocus.isEmpty();
            final int N = windows.size();
            for (i = N - 1; i >= 0; i--) {
                WindowState w = windows.get(i);
                final TaskStack stack = w.getStack();
                if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
                    continue;
                }
                final boolean obscuredChanged = w.mObscured != mInnerFields.mObscured;
                // Update effect.
                w.mObscured = mInnerFields.mObscured;
                if (!mInnerFields.mObscured) {
                    handleNotObscuredLocked(w, currentTime, innerDw, innerDh);
                }
                if (stack != null && !stack.testDimmingTag()) {
                    handleFlagDimBehind(w);
                }
                if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w) && w.isVisibleLw()) {
                    // This is the wallpaper target and its obscured state
                    // changed... make sure the current wallaper's visibility
                    // has been updated accordingly.
                    updateWallpaperVisibilityLocked();
                }
                final WindowStateAnimator winAnimator = w.mWinAnimator;
                // it.
                if (w.mHasSurface && w.shouldAnimateMove()) {
                    // Frame has moved, containing content frame
                    // has also moved, and we're not currently animating...
                    // let's do something.
                    Animation a = AnimationUtils.loadAnimation(mContext, com.android.internal.R.anim.window_move_from_decor);
                    winAnimator.setAnimation(a);
                    winAnimator.mAnimDw = w.mLastFrame.left - w.mFrame.left;
                    winAnimator.mAnimDh = w.mLastFrame.top - w.mFrame.top;
                    // TODO (multidisplay): Accessibility supported only for the default display.
                    if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
                        mAccessibilityController.onSomeWindowResizedOrMovedLocked();
                    }
                    try {
                        w.mClient.moved(w.mFrame.left, w.mFrame.top);
                    } catch (RemoteException e) {
                    }
                }
                // Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
                w.mContentChanged = false;
                // Moved from updateWindowsAndWallpaperLocked().
                if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
                    // Take care of the window being ready to display.
                    final boolean committed = winAnimator.commitFinishDrawingLocked(currentTime);
                    if (isDefaultDisplay && committed) {
                        if (w.mAttrs.type == TYPE_DREAM) {
                            // HACK: When a dream is shown, it may at that
                            // point hide the lock screen.  So we need to
                            // redo the layout to let the phone window manager
                            // make this happen.
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("dream and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                        if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                            if (DEBUG_WALLPAPER_LIGHT)
                                Slog.v(TAG, "First draw done in potential wallpaper target " + w);
                            mInnerFields.mWallpaperMayChange = true;
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                    }
                    winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
                    final AppWindowToken atoken = w.mAppToken;
                    if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
                        Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen=" + w.isOnScreen() + " allDrawn=" + atoken.allDrawn + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
                    }
                    if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
                        if (atoken.lastTransactionSequence != mTransactionSequence) {
                            atoken.lastTransactionSequence = mTransactionSequence;
                            atoken.numInterestingWindows = atoken.numDrawnWindows = 0;
                            atoken.startingDisplayed = false;
                        }
                        if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                                Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw() + ", isAnimating=" + winAnimator.isAnimating());
                                if (!w.isDrawnLw()) {
                                    Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl + " pv=" + w.mPolicyVisibility + " mDrawState=" + winAnimator.drawStateToString() + " ah=" + w.mAttachedHidden + " th=" + atoken.hiddenRequested + " a=" + winAnimator.mAnimating);
                                }
                            }
                            if (w != atoken.startingWindow) {
                                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                                    atoken.numInterestingWindows++;
                                    if (w.isDrawnLw()) {
                                        atoken.numDrawnWindows++;
                                        if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)
                                            Slog.v(TAG, "tokenMayBeDrawn: " + atoken + " freezingScreen=" + atoken.mAppAnimator.freezingScreen + " mAppFreezing=" + w.mAppFreezing);
                                        updateAllDrawn = true;
                                    }
                                }
                            } else if (w.isDrawnLw()) {
                                atoken.startingDisplayed = true;
                            }
                        }
                    }
                }
                if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus) && w.isDisplayedLw()) {
                    focusDisplayed = true;
                }
                updateResizingWindows(w);
            }
            mDisplayManagerInternal.setDisplayProperties(displayId, mInnerFields.mDisplayHasContent, mInnerFields.mPreferredRefreshRate, true);
            getDisplayContentLocked(displayId).stopDimmingIfNeeded();
            if (updateAllDrawn) {
                updateAllDrawnLocked(displayContent);
            }
        }
        if (focusDisplayed) {
            mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
        }
        // Give the display manager a chance to adjust properties
        // like display rotation if it needs to.
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } catch (RuntimeException e) {
        Slog.wtf(TAG, "Unhandled exception in Window Manager", e);
    } finally {
        SurfaceControl.closeTransaction();
        if (SHOW_LIGHT_TRANSACTIONS)
            Slog.i(TAG, "<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
    }
    final WindowList defaultWindows = defaultDisplay.getWindowList();
    // to go.
    if (mAppTransition.isReady()) {
        defaultDisplay.pendingLayoutChanges |= handleAppTransitionReadyLocked(defaultWindows);
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAppTransitionReadyLocked", defaultDisplay.pendingLayoutChanges);
    }
    if (!mAnimator.mAnimating && mAppTransition.isRunning()) {
        // We have finished the animation of an app transition.  To do
        // this, we have delayed a lot of operations like showing and
        // hiding apps, moving apps in Z-order, etc.  The app token list
        // reflects the correct Z-order, but the window list may now
        // be out of sync with it.  So here we will just rebuild the
        // entire app window list.  Fun!
        defaultDisplay.pendingLayoutChanges |= handleAnimatingStoppedAndTransitionLocked();
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAnimStopAndXitionLock", defaultDisplay.pendingLayoutChanges);
    }
    if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
        // At this point, there was a window with a wallpaper that
        // was force hiding other windows behind it, but now it
        // is going away.  This may be simple -- just animate
        // away the wallpaper and its window -- or it may be
        // hard -- the wallpaper now needs to be shown behind
        // something that was hidden.
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after animateAwayWallpaperLocked", defaultDisplay.pendingLayoutChanges);
    }
    mInnerFields.mWallpaperForceHidingChanged = false;
    if (mInnerFields.mWallpaperMayChange) {
        if (DEBUG_WALLPAPER_LIGHT)
            Slog.v(TAG, "Wallpaper may change!  Adjusting");
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("WallpaperMayChange", defaultDisplay.pendingLayoutChanges);
    }
    if (mFocusMayChange) {
        mFocusMayChange = false;
        if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false)) {
            updateInputWindowsNeeded = true;
            defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
        }
    }
    if (needsLayout()) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("mLayoutNeeded", defaultDisplay.pendingLayoutChanges);
    }
    for (i = mResizingWindows.size() - 1; i >= 0; i--) {
        WindowState win = mResizingWindows.get(i);
        if (win.mAppFreezing) {
            // Don't remove this window until rotation has completed.
            continue;
        }
        win.reportResized();
        mResizingWindows.remove(i);
    }
    if (DEBUG_ORIENTATION && mDisplayFrozen)
        Slog.v(TAG, "With display frozen, orientationChangeComplete=" + mInnerFields.mOrientationChangeComplete);
    if (mInnerFields.mOrientationChangeComplete) {
        if (mWindowsFreezingScreen) {
            mWindowsFreezingScreen = false;
            mLastFinishedFreezeSource = mInnerFields.mLastWindowFreezeSource;
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        }
        stopFreezingDisplayLocked();
    }
    // Destroy the surface of any windows that are no longer visible.
    boolean wallpaperDestroyed = false;
    i = mDestroySurface.size();
    if (i > 0) {
        do {
            i--;
            WindowState win = mDestroySurface.get(i);
            win.mDestroying = false;
            if (mInputMethodWindow == win) {
                mInputMethodWindow = null;
            }
            if (win == mWallpaperTarget) {
                wallpaperDestroyed = true;
            }
            win.mWinAnimator.destroySurfaceLocked();
        } while (i > 0);
        mDestroySurface.clear();
    }
    // Time to remove any exiting tokens?
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        ArrayList<WindowToken> exitingTokens = displayContent.mExitingTokens;
        for (i = exitingTokens.size() - 1; i >= 0; i--) {
            WindowToken token = exitingTokens.get(i);
            if (!token.hasVisible) {
                exitingTokens.remove(i);
                if (token.windowType == TYPE_WALLPAPER) {
                    mWallpaperTokens.remove(token);
                }
            }
        }
    }
    // Time to remove any exiting applications?
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (i = exitingAppTokens.size() - 1; i >= 0; i--) {
            AppWindowToken token = exitingAppTokens.get(i);
            if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mDeferRemoval || token.allAppWindows.isEmpty())) {
                // Make sure there is no animation running on this token,
                // so any windows associated with it will be removed as
                // soon as their animations are complete
                token.mAppAnimator.clearAnimation();
                token.mAppAnimator.animating = false;
                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)
                    Slog.v(TAG, "performLayout: App token exiting now removed" + token);
                removeAppFromTaskLocked(token);
                exitingAppTokens.remove(i);
                final Task task = mTaskIdToTask.get(token.groupId);
                if (task != null && task.mDeferRemoval && task.mAppTokens.isEmpty()) {
                    removeTaskLocked(task);
                }
            }
        }
    }
    if (!mAnimator.mAnimating && mRelayoutWhileAnimating.size() > 0) {
        for (int j = mRelayoutWhileAnimating.size() - 1; j >= 0; j--) {
            try {
                mRelayoutWhileAnimating.get(j).mClient.doneAnimating();
            } catch (RemoteException e) {
            }
        }
        mRelayoutWhileAnimating.clear();
    }
    if (wallpaperDestroyed) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        defaultDisplay.layoutNeeded = true;
    }
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        if (displayContent.pendingLayoutChanges != 0) {
            displayContent.layoutNeeded = true;
        }
    }
    // Finally update all input windows now that the window changes have stabilized.
    mInputMonitor.updateInputWindowsLw(true);
    setHoldScreenLocked(mInnerFields.mHoldScreen);
    if (!mDisplayFrozen) {
        if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
        }
        if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
        }
        mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
    }
    if (mTurnOnScreen) {
        if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 0) {
            if (DEBUG_VISIBILITY)
                Slog.v(TAG, "Turning screen on after layout!");
            mPowerManager.wakeUp(SystemClock.uptimeMillis());
        }
        mTurnOnScreen = false;
    }
    if (mInnerFields.mUpdateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        if (updateRotationUncheckedLocked(false)) {
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
        } else {
            mInnerFields.mUpdateRotation = false;
        }
    }
    if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
        checkDrawnWindowsLocked();
    }
    final int N = mPendingRemove.size();
    if (N > 0) {
        if (mPendingRemoveTmp.length < N) {
            mPendingRemoveTmp = new WindowState[N + 10];
        }
        mPendingRemove.toArray(mPendingRemoveTmp);
        mPendingRemove.clear();
        DisplayContentList displayList = new DisplayContentList();
        for (i = 0; i < N; i++) {
            WindowState w = mPendingRemoveTmp[i];
            removeWindowInnerLocked(w.mSession, w);
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && !displayList.contains(displayContent)) {
                displayList.add(displayContent);
            }
        }
        for (DisplayContent displayContent : displayList) {
            assignLayersLocked(displayContent.getWindowList());
            displayContent.layoutNeeded = true;
        }
    }
    // Remove all deferred displays stacks, tasks, and activities.
    for (int displayNdx = mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
        mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
    }
    if (updateInputWindowsNeeded) {
        mInputMonitor.updateInputWindowsLw(false);
    }
    setFocusedStackFrame();
    // Check to see if we are now in a state where the screen should
    // be enabled, because the window obscured flags have changed.
    enableScreenIfNeededLocked();
    scheduleAnimationLocked();
    if (DEBUG_WINDOW_TRACE) {
        Slog.e(TAG, "performLayoutAndPlaceSurfacesLockedInner exit: animating=" + mAnimator.mAnimating);
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.startAppWidgetConfigureActivityForResult:COMMENT
Method Modifier: public      final       
Comment:/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */

Body of Frist Method:
{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContext.getOpPackageName(), appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContextOpPackageName, appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.server.media.MediaSessionRecord.adjustVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Send a volume adjustment to the session owner. Direction must be one of
 * {@link AudioManager#ADJUST_LOWER}, {@link AudioManager#ADJUST_RAISE},
 * {@link AudioManager#ADJUST_SAME}.
 *
 * @param direction The direction to adjust volume in.
 * @param flags Any of the flags from {@link AudioManager}.
 * @param packageName The package that made the original volume request.
 * @param uid The uid that made the original volume request.
 * @param useSuggested True to use adjustSuggestedStreamVolume instead of
 * adjustStreamVolume.
 */

Body of Frist Method:
{
    int previousFlagPlaySound = flags & AudioManager.FLAG_PLAY_SOUND;
    if (isPlaybackActive(false) || hasFlag(MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY)) {
        flags &= ~AudioManager.FLAG_PLAY_SOUND;
    }
    if (direction > 1) {
        direction = 1;
    } else if (direction < -1) {
        direction = -1;
    }
    if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {
        int stream = AudioAttributes.toLegacyStreamType(mAudioAttrs);
        if (useSuggested) {
            if (AudioSystem.isStreamActive(stream, 0)) {
                mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(stream, direction, flags, packageName, uid);
            } else {
                flags |= previousFlagPlaySound;
                mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(AudioManager.USE_DEFAULT_STREAM_TYPE, direction, flags, packageName, uid);
            }
        } else {
            mAudioManagerInternal.adjustStreamVolumeForUid(stream, direction, flags, packageName, uid);
        }
    } else {
        if (mVolumeControlType == VolumeProvider.VOLUME_CONTROL_FIXED) {
            // Nothing to do, the volume cannot be changed
            return;
        }
        mSessionCb.adjustVolume(direction);
        int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);
        mOptimisticVolume = volumeBefore + direction;
        mOptimisticVolume = Math.max(0, Math.min(mOptimisticVolume, mMaxVolume));
        mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);
        mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);
        if (volumeBefore != mOptimisticVolume) {
            pushVolumeUpdate();
        }
        if (DEBUG) {
            Log.d(TAG, "Adjusted optimistic volume to " + mOptimisticVolume + " max is " + mMaxVolume);
        }
    }
}
Body of Second Method:
{
    int previousFlagPlaySound = flags & AudioManager.FLAG_PLAY_SOUND;
    if (isPlaybackActive(false) || hasFlag(MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY)) {
        flags &= ~AudioManager.FLAG_PLAY_SOUND;
    }
    boolean isMute = direction == MediaSessionManager.DIRECTION_MUTE;
    if (direction > 1) {
        direction = 1;
    } else if (direction < -1) {
        direction = -1;
    }
    if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {
        if (mUseMasterVolume) {
            // If this device only uses master volume and playback is local
            // just adjust the master volume and return.
            boolean isMasterMute = mAudioManager.isMasterMute();
            if (isMute) {
                mAudioManagerInternal.setMasterMuteForUid(!isMasterMute, flags, packageName, mService.mICallback, uid);
            } else {
                mAudioManagerInternal.adjustMasterVolumeForUid(direction, flags, packageName, uid);
                if (isMasterMute) {
                    mAudioManagerInternal.setMasterMuteForUid(false, flags, packageName, mService.mICallback, uid);
                }
            }
            return;
        }
        int stream = AudioAttributes.toLegacyStreamType(mAudioAttrs);
        boolean isStreamMute = mAudioManager.isStreamMute(stream);
        if (useSuggested) {
            if (AudioSystem.isStreamActive(stream, 0)) {
                if (isMute) {
                    mAudioManager.setStreamMute(stream, !isStreamMute);
                } else {
                    mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(stream, direction, flags, packageName, uid);
                    if (isStreamMute && direction != 0) {
                        mAudioManager.setStreamMute(stream, false);
                    }
                }
            } else {
                flags |= previousFlagPlaySound;
                isStreamMute = mAudioManager.isStreamMute(AudioManager.USE_DEFAULT_STREAM_TYPE);
                if (isMute) {
                    mAudioManager.setStreamMute(AudioManager.USE_DEFAULT_STREAM_TYPE, !isStreamMute);
                } else {
                    mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(AudioManager.USE_DEFAULT_STREAM_TYPE, direction, flags, packageName, uid);
                    if (isStreamMute && direction != 0) {
                        mAudioManager.setStreamMute(AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                    }
                }
            }
        } else {
            if (isMute) {
                mAudioManager.setStreamMute(stream, !isStreamMute);
            } else {
                mAudioManagerInternal.adjustStreamVolumeForUid(stream, direction, flags, packageName, uid);
                if (isStreamMute && direction != 0) {
                    mAudioManager.setStreamMute(stream, false);
                }
            }
        }
    } else {
        if (mVolumeControlType == VolumeProvider.VOLUME_CONTROL_FIXED) {
            // Nothing to do, the volume cannot be changed
            return;
        }
        if (isMute) {
            Log.w(TAG, "Muting remote playback is not supported");
            return;
        }
        mSessionCb.adjustVolume(direction);
        int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);
        mOptimisticVolume = volumeBefore + direction;
        mOptimisticVolume = Math.max(0, Math.min(mOptimisticVolume, mMaxVolume));
        mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);
        mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);
        if (volumeBefore != mOptimisticVolume) {
            pushVolumeUpdate();
        }
        mService.notifyRemoteVolumeChanged(flags, this);
        if (DEBUG) {
            Log.d(TAG, "Adjusted optimistic volume to " + mOptimisticVolume + " max is " + mMaxVolume);
        }
    }
}
------------------------
Find a functionally equivalent code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
------------------------
Find a functionally equivalent code:android.net.Network.openConnection:COMMENT
Method Modifier: public      
Comment:/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */

Body of Frist Method:
{
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkHttpClient client;
    // TODO: Should the network's proxy be specified?
    if (protocol.equals("http")) {
        client = HttpHandler.createHttpOkHttpClient(null);
    } else if (protocol.equals("https")) {
        client = HttpsHandler.createHttpsOkHttpClient(null);
    } else {
        // passed another protocol.
        throw new MalformedURLException("Invalid URL or unrecognized protocol " + protocol);
    }
    return client.setSocketFactory(getSocketFactory()).setHostResolver(mHostResolver).setConnectionPool(mConnectionPool).open(url);
}
Body of Second Method:
{
    final ConnectivityManager cm = ConnectivityManager.getInstance();
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    ProxyInfo proxyInfo = cm.getGlobalProxy();
    if (proxyInfo == null) {
        // TODO: Should this be optimized to avoid fetching LinkProperties for every request?
        final LinkProperties lp = cm.getLinkProperties(this);
        if (lp != null)
            proxyInfo = lp.getHttpProxy();
    }
    java.net.Proxy proxy = null;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.findAll:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String "find" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findAll");
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAll");
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Ripple.cancelHardwareAnimations:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels any running hardware animations.
 */

Body of Frist Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        runningAnimations.get(i).cancel();
    }
    runningAnimations.clear();
    if (cancelPending && !mPendingAnimations.isEmpty()) {
        mPendingAnimations.clear();
    }
    mHardwareAnimating = false;
}
Body of Second Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        if (jumpToEnd) {
            runningAnimations.get(i).end();
        } else {
            runningAnimations.get(i).cancel();
        }
    }
    runningAnimations.clear();
    if (mHasPendingHardwareExit) {
        // If we had a pending hardware exit, jump to the end state.
        mHasPendingHardwareExit = false;
        if (jumpToEnd) {
            mOpacity = 0;
            mTweenX = 1;
            mTweenY = 1;
            mTweenRadius = 1;
        }
    }
    mHardwareAnimating = false;
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.ExpandableNotificationRow.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets this view so it can be re-used for an updated notification.
 */

Body of Frist Method:
{
    super.reset();
    mRowMinHeight = 0;
    final boolean wasExpanded = isExpanded();
    mRowMaxHeight = 0;
    mExpandable = false;
    mHasUserChangedExpansion = false;
    mUserLocked = false;
    mShowingPublic = false;
    mSensitive = false;
    mShowingPublicInitialized = false;
    mIsSystemExpanded = false;
    mExpansionDisabled = false;
    mPublicLayout.reset();
    mPrivateLayout.reset();
    resetHeight();
    logExpansionEvent(false, wasExpanded);
}
Body of Second Method:
{
    super.reset();
    mRowMinHeight = 0;
    final boolean wasExpanded = isExpanded();
    mRowMaxHeight = 0;
    mExpandable = false;
    mHasUserChangedExpansion = false;
    mUserLocked = false;
    mShowingPublic = false;
    mSensitive = false;
    mShowingPublicInitialized = false;
    mIsSystemExpanded = false;
    mExpansionDisabled = false;
    mPublicLayout.reset(mIsHeadsUp);
    mPrivateLayout.reset(mIsHeadsUp);
    resetHeight();
    logExpansionEvent(false, wasExpanded);
}
------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.getFavicon:COMMENT
<android.webkit.WebHistoryItem: Bitmap getFavicon()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the favicon of this history item or null if no favicon was found.
 * @return A Bitmap containing the favicon for this history item or null.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.CookieManager.setAcceptCookie:COMMENT
<android.webkit.CookieManager: void setAcceptCookie(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the application's {@link WebView} instances should send and
 * accept cookies.
 * By default this is set to true and the WebView accepts cookies.
 * <p>
 * When this is true
 * {@link CookieManager#setAcceptThirdPartyCookies setAcceptThirdPartyCookies} and
 * {@link CookieManager#setAcceptFileSchemeCookies setAcceptFileSchemeCookies}
 * can be used to control the policy for those specific types of cookie.
 *
 * @param accept whether {@link WebView} instances should send and accept
 * cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.DayPickerView.performAccessibilityAction:COMMENT
Method Modifier: public      
Comment:/**
 * When scroll forward/backward events are received, announce the newly scrolled-to month.
 */

Body of Frist Method:
{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    int firstVisiblePosition = getFirstVisiblePosition();
    int month = firstVisiblePosition % 12;
    int year = firstVisiblePosition / 12 + mController.getMinYear();
    Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day, true, false, true);
    mPerformingScroll = true;
    return true;
}
Body of Second Method:
{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    final int firstVisiblePosition = getFirstVisiblePosition();
    final int month = firstVisiblePosition % 12;
    final int year = firstVisiblePosition / 12 + mMinDate.get(Calendar.YEAR);
    final Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day.getTimeInMillis(), true, false, true);
    mPerformingScroll = true;
    return true;
}
------------------------
Find a functionally equivalent code:com.android.server.pm.Settings.transferPermissionsLPw:COMMENT
Method Modifier: 
Comment:// Transfer ownership of permissions from one package to another.

Body of Frist Method:
{
    // Transfer ownership of permissions to the new package.
    for (int i = 0; i < 2; i++) {
        HashMap<String, BasePermission> permissions = i == 0 ? mPermissionTrees : mPermissions;
        for (BasePermission bp : permissions.values()) {
            if (origPkg.equals(bp.sourcePackage)) {
                if (PackageManagerService.DEBUG_UPGRADE)
                    Log.v(PackageManagerService.TAG, "Moving permission " + bp.name + " from pkg " + bp.sourcePackage + " to " + newPkg);
                bp.sourcePackage = newPkg;
                bp.packageSetting = null;
                bp.perm = null;
                if (bp.pendingInfo != null) {
                    bp.pendingInfo.packageName = newPkg;
                }
                bp.uid = 0;
                bp.gids = null;
            }
        }
    }
}
Body of Second Method:
{
    // Transfer ownership of permissions to the new package.
    for (int i = 0; i < 2; i++) {
        ArrayMap<String, BasePermission> permissions = i == 0 ? mPermissionTrees : mPermissions;
        for (BasePermission bp : permissions.values()) {
            if (origPkg.equals(bp.sourcePackage)) {
                if (PackageManagerService.DEBUG_UPGRADE)
                    Log.v(PackageManagerService.TAG, "Moving permission " + bp.name + " from pkg " + bp.sourcePackage + " to " + newPkg);
                bp.sourcePackage = newPkg;
                bp.packageSetting = null;
                bp.perm = null;
                if (bp.pendingInfo != null) {
                    bp.pendingInfo.packageName = newPkg;
                }
                bp.uid = 0;
                bp.gids = null;
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupStartValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the start values for an animation.
 * The start values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
Body of Second Method:
{
    List<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
------------------------
Find a functionally equivalent code:android.widget.ProgressBar.applyProgressBackgroundTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressBackgroundTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressBackgroundTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.connectivity.NetworkMonitor.isCaptivePortal:COMMENT
Method Modifier: private     
Comment:/**
 * Do a URL fetch on a known server to see if we get the data we expect.
 * Returns HTTP response code.
 */

Body of Frist Method:
{
    if (!mIsCaptivePortalCheckEnabled)
        return 204;
    HttpURLConnection urlConnection = null;
    int httpResponseCode = 599;
    try {
        URL url = new URL("http", mServer, "/generate_204");
        if (DBG) {
            log("Checking " + url.toString() + " on " + mNetworkAgentInfo.networkInfo.getExtraInfo());
        }
        urlConnection = (HttpURLConnection) mNetworkAgentInfo.network.openConnection(url);
        urlConnection.setInstanceFollowRedirects(false);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        urlConnection.getInputStream();
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        if (DBG) {
            log("isCaptivePortal: ret=" + httpResponseCode + " headers=" + urlConnection.getHeaderFields());
        }
        // See http://b/9972012.
        if (httpResponseCode == 200 && urlConnection.getContentLength() == 0) {
            if (DBG)
                log("Empty 200 response interpreted as 204 response.");
            httpResponseCode = 204;
        }
        sendNetworkConditionsBroadcast(true, /* response received */
        httpResponseCode == 204, requestTimestamp, responseTimestamp);
    } catch (IOException e) {
        if (DBG)
            log("Probably not a portal: exception " + e);
        if (httpResponseCode == 599) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
    }
    return httpResponseCode;
}
Body of Second Method:
{
    if (!mIsCaptivePortalCheckEnabled)
        return 204;
    HttpURLConnection urlConnection = null;
    int httpResponseCode = 599;
    try {
        URL url = new URL("http", mServer, "/generate_204");
        // On networks with a PAC instead of fetching a URL that should result in a 204
        // reponse, we instead simply fetch the PAC script.  This is done for a few reasons:
        // 1. At present our PAC code does not yet handle multiple PACs on multiple networks
        // until something like https://android-review.googlesource.com/#/c/115180/ lands.
        // Network.openConnection() will ignore network-specific PACs and instead fetch
        // using NO_PROXY.  If a PAC is in place, the only fetch we know will succeed with
        // NO_PROXY is the fetch of the PAC itself.
        // 2. To proxy the generate_204 fetch through a PAC would require a number of things
        // happen before the fetch can commence, namely:
        // a) the PAC script be fetched
        // b) a PAC script resolver service be fired up and resolve mServer
        // Network validation could be delayed until these prerequisities are satisifed or
        // could simply be left to race them.  Neither is an optimal solution.
        // 3. PAC scripts are sometimes used to block or restrict Internet access and may in
        // fact block fetching of the generate_204 URL which would lead to false negative
        // results for network validation.
        boolean fetchPac = false;
        {
            final ProxyInfo proxyInfo = mNetworkAgentInfo.linkProperties.getHttpProxy();
            if (proxyInfo != null && !Uri.EMPTY.equals(proxyInfo.getPacFileUrl())) {
                url = new URL(proxyInfo.getPacFileUrl().toString());
                fetchPac = true;
            }
        }
        if (DBG) {
            log("Checking " + url.toString() + " on " + mNetworkAgentInfo.networkInfo.getExtraInfo());
        }
        urlConnection = (HttpURLConnection) mNetworkAgentInfo.network.openConnection(url);
        urlConnection.setInstanceFollowRedirects(fetchPac);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        urlConnection.getInputStream();
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        if (DBG) {
            log("isCaptivePortal: ret=" + httpResponseCode + " headers=" + urlConnection.getHeaderFields());
        }
        // See http://b/9972012.
        if (httpResponseCode == 200 && urlConnection.getContentLength() == 0) {
            if (DBG)
                log("Empty 200 response interpreted as 204 response.");
            httpResponseCode = 204;
        }
        if (httpResponseCode == 200 && fetchPac) {
            if (DBG)
                log("PAC fetch 200 response interpreted as 204 response.");
            httpResponseCode = 204;
        }
        sendNetworkConditionsBroadcast(true, /* response received */
        httpResponseCode != 204, /* isCaptivePortal */
        requestTimestamp, responseTimestamp);
    } catch (IOException e) {
        if (DBG)
            log("Probably not a portal: exception " + e);
        if (httpResponseCode == 599) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
    }
    return httpResponseCode;
}
------------------------
Find a functionally equivalent code:android.view.HardwareRenderer.pauseSurface:COMMENT
Method Modifier: default     abstract    
Comment:/**
 * Stops any rendering into the surface. Use this if it is unclear whether
 * or not the surface used by the HardwareRenderer will be changing. It
 * Suspends any rendering into the surface, but will not do any destruction
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewHeader.startLaunchTaskDismissAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Animates this task bar dismiss button when launching a task.
 */

Body of Frist Method:
{
    if (mDismissButton.getVisibility() == View.VISIBLE) {
        mDismissButton.animate().cancel();
        mDismissButton.animate().alpha(0f).setStartDelay(0).setInterpolator(mConfig.fastOutSlowInInterpolator).setDuration(mConfig.taskBarExitAnimDuration).withLayer().start();
    }
}
Body of Second Method:
{
    if (mDismissButton.getVisibility() == View.VISIBLE) {
        mDismissButton.animate().cancel();
        mDismissButton.animate().alpha(0f).setStartDelay(0).setInterpolator(mConfig.fastOutSlowInInterpolator).setDuration(mConfig.taskViewExitToAppDuration).withLayer().start();
    }
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.getInputType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the input type set on the query text field.
 * @return the input type
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */

Body of Frist Method:
{
    return mQueryTextView.getInputType();
}
Body of Second Method:
{
    return mSearchSrcTextView.getInputType();
}
------------------------
Find a functionally equivalent code:android.media.AudioService.sendMasterVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumeController.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
Body of Second Method:
{
    mVolumeController.postMasterVolumeChanged(updateFlagsForSystemAudio(flags));
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.markAsVoiceMail:COMMENT
Method Modifier: internal    
Comment:/* package */

Body of Frist Method:
{
    mIsVoiceMail = true;
    try {
        String voiceMailLabel = TelephonyManager.getDefault().getVoiceMailAlphaTag(subId);
        phoneNumber = voiceMailLabel;
    } catch (SecurityException se) {
        // Should never happen: if this process does not have
        // permission to retrieve VM tag, it should not have
        // permission to retrieve VM number and would not call
        // this method.
        // Leave phoneNumber untouched.
        Rlog.e(TAG, "Cannot access VoiceMail.", se);
    }
    // photoResource = android.R.drawable.badge_voicemail;
    return this;
}
Body of Second Method:
{
    int subId = SubscriptionManager.getDefaultSubId();
    return markAsVoiceMail(subId);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptMotionBeforeQueueingNonInteractive:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if ((policyFlags & FLAG_WAKE) != 0) {
        mPowerManager.wakeUp(whenNanos / 1000000);
        return 0;
    }
    if (shouldDispatchInputWhenNonInteractive()) {
        return ACTION_PASS_TO_USER;
    }
    return 0;
}
Body of Second Method:
{
    if ((policyFlags & FLAG_WAKE) != 0) {
        if (wakeUp(whenNanos / 1000000, mAllowTheaterModeWakeFromMotion)) {
            return 0;
        }
    }
    if (shouldDispatchInputWhenNonInteractive()) {
        return ACTION_PASS_TO_USER;
    }
    // wake up in this case.
    if (isTheaterModeEnabled() && (policyFlags & FLAG_WAKE) != 0) {
        wakeUp(whenNanos / 1000000, mAllowTheaterModeWakeFromMotionWhenNotDreaming);
    }
    return 0;
}
------------------------
Find a functionally equivalent code:com.android.server.backup.PackageManagerBackupAgent.parseStateFile:COMMENT
Method Modifier: private     
Comment:// Util: parse out an existing state file into a usable structure

Body of Frist Method:
{
    mExisting.clear();
    mStateVersions.clear();
    mStoredSdkVersion = 0;
    mStoredIncrementalVersion = null;
    mStoredHomeComponent = null;
    mStoredHomeVersion = 0;
    mStoredHomeSigHashes = null;
    // The state file is just the list of app names we have stored signatures for
    // with the exception of the metadata block, to which is also appended the
    // version numbers corresponding with the last time we wrote this PM block.
    // If they mismatch the current system, we'll re-store the metadata key.
    FileInputStream instream = new FileInputStream(stateFile.getFileDescriptor());
    BufferedInputStream inbuffer = new BufferedInputStream(instream);
    DataInputStream in = new DataInputStream(inbuffer);
    try {
        boolean ignoreExisting = false;
        String pkg = in.readUTF();
        // Validate the state file version is sensical to us
        if (pkg.equals(STATE_FILE_HEADER)) {
            int stateVersion = in.readInt();
            if (stateVersion > STATE_FILE_VERSION) {
                Slog.w(TAG, "Unsupported state file version " + stateVersion + ", redoing from start");
                return;
            }
        } else {
            // This is an older version of the state file in which the lead element
            // is not a STATE_FILE_VERSION string.  If that's the case, we want to
            // make sure to write our full backup dataset when given an opportunity.
            // We trigger that by simply not marking the restored package metadata
            // as known-to-exist-in-archive.
            Slog.i(TAG, "Older version of saved state - rewriting");
            ignoreExisting = true;
        }
        // First comes the preferred home app data, if any, headed by the DEFAULT_HOME_KEY tag
        if (pkg.equals(DEFAULT_HOME_KEY)) {
            // flattened component name, version, signature of the home app
            mStoredHomeComponent = ComponentName.unflattenFromString(in.readUTF());
            mStoredHomeVersion = in.readLong();
            mStoredHomeSigHashes = readSignatureHashArray(in);
            // set up for the next block of state
            pkg = in.readUTF();
        } else {
        // else no preferred home app on the ancestral device - fall through to the rest
        }
        // After (possible) home app data comes the global metadata block
        if (pkg.equals(GLOBAL_METADATA_KEY)) {
            mStoredSdkVersion = in.readInt();
            mStoredIncrementalVersion = in.readUTF();
            if (!ignoreExisting) {
                mExisting.add(GLOBAL_METADATA_KEY);
            }
        } else {
            Slog.e(TAG, "No global metadata in state file!");
            return;
        }
        // The global metadata was last; now read all the apps
        while (true) {
            pkg = in.readUTF();
            int versionCode = in.readInt();
            if (!ignoreExisting) {
                mExisting.add(pkg);
            }
            mStateVersions.put(pkg, new Metadata(versionCode, null));
        }
    } catch (EOFException eof) {
    // safe; we're done
    } catch (IOException e) {
        // whoops, bad state file.  abort.
        Slog.e(TAG, "Unable to read Package Manager state file: " + e);
    }
}
Body of Second Method:
{
    mExisting.clear();
    mStateVersions.clear();
    mStoredSdkVersion = 0;
    mStoredIncrementalVersion = null;
    mStoredHomeComponent = null;
    mStoredHomeVersion = 0;
    mStoredHomeSigHashes = null;
    // The state file is just the list of app names we have stored signatures for
    // with the exception of the metadata block, to which is also appended the
    // version numbers corresponding with the last time we wrote this PM block.
    // If they mismatch the current system, we'll re-store the metadata key.
    FileInputStream instream = new FileInputStream(stateFile.getFileDescriptor());
    BufferedInputStream inbuffer = new BufferedInputStream(instream);
    DataInputStream in = new DataInputStream(inbuffer);
    try {
        boolean ignoreExisting = false;
        String pkg = in.readUTF();
        // Validate the state file version is sensical to us
        if (pkg.equals(STATE_FILE_HEADER)) {
            int stateVersion = in.readInt();
            if (stateVersion > STATE_FILE_VERSION) {
                Slog.w(TAG, "Unsupported state file version " + stateVersion + ", redoing from start");
                return;
            }
            pkg = in.readUTF();
        } else {
            // This is an older version of the state file in which the lead element
            // is not a STATE_FILE_VERSION string.  If that's the case, we want to
            // make sure to write our full backup dataset when given an opportunity.
            // We trigger that by simply not marking the restored package metadata
            // as known-to-exist-in-archive.
            Slog.i(TAG, "Older version of saved state - rewriting");
            ignoreExisting = true;
        }
        // First comes the preferred home app data, if any, headed by the DEFAULT_HOME_KEY tag
        if (pkg.equals(DEFAULT_HOME_KEY)) {
            // flattened component name, version, signature of the home app
            mStoredHomeComponent = ComponentName.unflattenFromString(in.readUTF());
            mStoredHomeVersion = in.readLong();
            mStoredHomeSigHashes = readSignatureHashArray(in);
            // set up for the next block of state
            pkg = in.readUTF();
        } else {
        // else no preferred home app on the ancestral device - fall through to the rest
        }
        // After (possible) home app data comes the global metadata block
        if (pkg.equals(GLOBAL_METADATA_KEY)) {
            mStoredSdkVersion = in.readInt();
            mStoredIncrementalVersion = in.readUTF();
            if (!ignoreExisting) {
                mExisting.add(GLOBAL_METADATA_KEY);
            }
        } else {
            Slog.e(TAG, "No global metadata in state file!");
            return;
        }
        // The global metadata was last; now read all the apps
        while (true) {
            pkg = in.readUTF();
            int versionCode = in.readInt();
            if (!ignoreExisting) {
                mExisting.add(pkg);
            }
            mStateVersions.put(pkg, new Metadata(versionCode, null));
        }
    } catch (EOFException eof) {
    // safe; we're done
    } catch (IOException e) {
        // whoops, bad state file.  abort.
        Slog.e(TAG, "Unable to read Package Manager state file: " + e);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.getUrl:COMMENT
<android.webkit.WebHistoryItem: String getUrl()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the url of this history item. The url is the base url of this
 * history item. See getTargetUrl() for the url that is the actual target of
 * this history item.
 * @return The base url of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.saveState:COMMENT
Method Modifier: public      
Comment:/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "saveState");
    return mProvider.saveState(outState);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "saveState");
    return mProvider.saveState(outState);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setJavaScriptEnabled:COMMENT
<android.webkit.WebSettings: void setJavaScriptEnabled(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells the WebView to enable JavaScript execution.
 * <b>The default is false.</b>
 *
 * @param flag true if the WebView should execute JavaScript
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.windowTypeToLayerLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
        return 2;
    }
    switch(type) {
        case TYPE_UNIVERSE_BACKGROUND:
            return 1;
        case TYPE_PRIVATE_PRESENTATION:
            return 2;
        case TYPE_WALLPAPER:
            // wallpaper is at the bottom, though the window manager may move it.
            return 2;
        case TYPE_PHONE:
            return 3;
        case TYPE_SEARCH_BAR:
            return 4;
        case TYPE_VOICE_INTERACTION:
            // voice interaction layer is almost immediately above apps.
            return 5;
        case TYPE_RECENTS_OVERLAY:
        case TYPE_SYSTEM_DIALOG:
            return 6;
        case TYPE_TOAST:
            // toasts and the plugged-in battery thing
            return 7;
        case TYPE_PRIORITY_PHONE:
            // SIM errors and unlock.  Not sure if this really should be in a high layer.
            return 8;
        case TYPE_DREAM:
            // used for Dreams (screensavers with TYPE_DREAM windows)
            return 9;
        case TYPE_SYSTEM_ALERT:
            // like the ANR / app crashed dialogs
            return 10;
        case TYPE_INPUT_METHOD:
            // on-screen keyboards and other such input method user interfaces go here.
            return 11;
        case TYPE_INPUT_METHOD_DIALOG:
            // on-screen keyboards and other such input method user interfaces go here.
            return 12;
        case TYPE_KEYGUARD_SCRIM:
            // the safety window that shows behind keyguard while keyguard is starting
            return 13;
        case TYPE_STATUS_BAR_SUB_PANEL:
            return 14;
        case TYPE_STATUS_BAR:
            return 15;
        case TYPE_STATUS_BAR_PANEL:
            return 16;
        case TYPE_KEYGUARD_DIALOG:
            return 17;
        case TYPE_VOLUME_OVERLAY:
            // changes the device volume
            return 18;
        case TYPE_SYSTEM_OVERLAY:
            // changes the device volume
            return 19;
        case TYPE_NAVIGATION_BAR:
            // the navigation bar, if available, shows atop most things
            return 20;
        case TYPE_NAVIGATION_BAR_PANEL:
            // some panels (e.g. search) need to show on top of the navigation bar
            return 21;
        case TYPE_SYSTEM_ERROR:
            // system-level error dialogs
            return 22;
        case TYPE_MAGNIFICATION_OVERLAY:
            // used to highlight the magnified portion of a display
            return 23;
        case TYPE_DISPLAY_OVERLAY:
            // used to simulate secondary display devices
            return 24;
        case TYPE_DRAG:
            // which sits above all other focusable windows
            return 25;
        case TYPE_SECURE_SYSTEM_OVERLAY:
            return 26;
        case TYPE_BOOT_PROGRESS:
            return 27;
        case TYPE_POINTER:
            // the (mouse) pointer layer
            return 28;
        case TYPE_HIDDEN_NAV_CONSUMER:
            return 29;
    }
    Log.e(TAG, "Unknown window type: " + type);
    return 2;
}
Body of Second Method:
{
    if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
        return 2;
    }
    switch(type) {
        case TYPE_UNIVERSE_BACKGROUND:
            return 1;
        case TYPE_PRIVATE_PRESENTATION:
            return 2;
        case TYPE_WALLPAPER:
            // wallpaper is at the bottom, though the window manager may move it.
            return 2;
        case TYPE_PHONE:
            return 3;
        case TYPE_SEARCH_BAR:
            return 4;
        case TYPE_VOICE_INTERACTION:
            // voice interaction layer is almost immediately above apps.
            return 5;
        case TYPE_SYSTEM_DIALOG:
            return 6;
        case TYPE_TOAST:
            // toasts and the plugged-in battery thing
            return 7;
        case TYPE_PRIORITY_PHONE:
            // SIM errors and unlock.  Not sure if this really should be in a high layer.
            return 8;
        case TYPE_DREAM:
            // used for Dreams (screensavers with TYPE_DREAM windows)
            return 9;
        case TYPE_SYSTEM_ALERT:
            // like the ANR / app crashed dialogs
            return 10;
        case TYPE_INPUT_METHOD:
            // on-screen keyboards and other such input method user interfaces go here.
            return 11;
        case TYPE_INPUT_METHOD_DIALOG:
            // on-screen keyboards and other such input method user interfaces go here.
            return 12;
        case TYPE_KEYGUARD_SCRIM:
            // the safety window that shows behind keyguard while keyguard is starting
            return 13;
        case TYPE_STATUS_BAR_SUB_PANEL:
            return 14;
        case TYPE_STATUS_BAR:
            return 15;
        case TYPE_STATUS_BAR_PANEL:
            return 16;
        case TYPE_KEYGUARD_DIALOG:
            return 17;
        case TYPE_VOLUME_OVERLAY:
            // changes the device volume
            return 18;
        case TYPE_SYSTEM_OVERLAY:
            // changes the device volume
            return 19;
        case TYPE_NAVIGATION_BAR:
            // the navigation bar, if available, shows atop most things
            return 20;
        case TYPE_NAVIGATION_BAR_PANEL:
            // some panels (e.g. search) need to show on top of the navigation bar
            return 21;
        case TYPE_SYSTEM_ERROR:
            // system-level error dialogs
            return 22;
        case TYPE_MAGNIFICATION_OVERLAY:
            // used to highlight the magnified portion of a display
            return 23;
        case TYPE_DISPLAY_OVERLAY:
            // used to simulate secondary display devices
            return 24;
        case TYPE_DRAG:
            // which sits above all other focusable windows
            return 25;
        case TYPE_ACCESSIBILITY_OVERLAY:
            // overlay put by accessibility services to intercept user interaction
            return 26;
        case TYPE_SECURE_SYSTEM_OVERLAY:
            return 27;
        case TYPE_BOOT_PROGRESS:
            return 28;
        case TYPE_POINTER:
            // the (mouse) pointer layer
            return 29;
        case TYPE_HIDDEN_NAV_CONSUMER:
            return 30;
    }
    Log.e(TAG, "Unknown window type: " + type);
    return 2;
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchMoreCertsReplaceSomeCerts:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with a certificate can be upgraded by app
     * signed with a superset of certificates. Then verify that the an app
     * signed with the original set of certs cannot upgrade the new one.
     */

Body of Frist Method:
{
    InstallParams ip = replaceCerts(APP1_CERT1, APP1_CERT1_CERT2, false, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
    try {
        int rFlags = PackageManager.INSTALL_REPLACE_EXISTING;
        installFromRawResource("install.apk", APP1_CERT1, rFlags, false, false, -1, PackageInfo.INSTALL_LOCATION_UNSPECIFIED);
    } catch (Exception e) {
        failStr(e.getMessage());
    } finally {
        if (ip != null) {
            cleanUpInstall(ip);
        }
    }
}
Body of Second Method:
{
    InstallParams ip = replaceCerts(APP1_CERT1, APP1_CERT1_CERT2, false, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
    try {
        int rFlags = PackageManager.INSTALL_REPLACE_EXISTING;
        installFromRawResource("install.apk", APP1_CERT1, rFlags, false, false, -1, PackageInfo.INSTALL_LOCATION_UNSPECIFIED);
    } catch (Exception e) {
        failStr(e.getMessage());
    } finally {
        if (ip != null) {
            cleanUpInstall(ip);
        }
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.handleKeyUp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                if (mUseMasterVolume) {
                    adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
                } else {
                    int flags = FLAG_PLAY_SOUND;
                    adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
                }
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                if (mUseMasterVolume) {
                    adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
                } else {
                    int flags = FLAG_PLAY_SOUND;
                    adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
                }
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            break;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getNavDump:COMMENT
<android.webkit.WebSettings: boolean getNavDump()>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether dumping the navigation cache is enabled.
 *
 * @return whether dumping the navigation cache is enabled
 * @see #setNavDump
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.SharedElementCallback.onCaptureSharedElementSnapshot:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */

Body of Frist Method:
{
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}
Body of Second Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.init:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
}
Body of Second Method:
{
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setNeedInitialFocus:COMMENT
<android.webkit.WebSettings: void setNeedInitialFocus(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells the WebView whether it needs to set a node to have focus when
 * {@link WebView#requestFocus(int, android.graphics.Rect)} is called. The
 * default value is true.
 *
 * @param flag whether the WebView needs to set a node
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.AudioService.sendVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    // only when TV receives volume notification from Audio Receiver.
    if (mHdmiTvClient != null && streamType == AudioSystem.STREAM_MUSIC) {
        synchronized (mHdmiTvClient) {
            if (mHdmiSystemAudioSupported && ((flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) == 0)) {
                flags &= ~AudioManager.FLAG_SHOW_UI;
            }
        }
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
Body of Second Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    if (streamType == AudioSystem.STREAM_MUSIC) {
        flags = updateFlagsForSystemAudio(flags);
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioTrack.setLoopPoints:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the loop points and the loop count. The loop can be infinite.
 * Similarly to setPlaybackHeadPosition,
 * the track must be stopped or paused for the loop points to be changed,
 * and must use the {@link #MODE_STATIC} mode.
 * @param startInFrames loop start marker expressed in frames
 * Zero corresponds to start of buffer.
 * The start marker must not be greater than or equal to the buffer size in frames, or negative.
 * @param endInFrames loop end marker expressed in frames
 * The total buffer size in frames corresponds to end of buffer.
 * The end marker must not be greater than the buffer size in frames.
 * For looping, the end marker must not be less than or equal to the start marker,
 * but to disable looping
 * it is permitted for start marker, end marker, and loop count to all be 0.
 * @param loopCount the number of times the loop is looped.
 * A value of -1 means infinite looping, and 0 disables looping.
 * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
 * {@link #ERROR_INVALID_OPERATION}
 */

Body of Frist Method:
{
    if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (loopCount == 0) {
        // explicitly allowed as an exception to the loop region range check
        ;
    } else if (!(0 <= startInFrames && startInFrames < mNativeBufferSizeInFrames && startInFrames < endInFrames && endInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_loop(startInFrames, endInFrames, loopCount);
}
Body of Second Method:
{
    if (mDataLoadMode == MODE_STREAM || mState == STATE_UNINITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (loopCount == 0) {
        // explicitly allowed as an exception to the loop region range check
        ;
    } else if (!(0 <= startInFrames && startInFrames < mNativeBufferSizeInFrames && startInFrames < endInFrames && endInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_loop(startInFrames, endInFrames, loopCount);
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.notifyLidSwitchChanged:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // lid changed state
    final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
    if (newLidState == mLidState) {
        return;
    }
    mLidState = newLidState;
    applyLidSwitchState();
    updateRotation(true);
    if (lidOpen) {
        mPowerManager.wakeUp(SystemClock.uptimeMillis());
    } else if (!mLidControlsSleep) {
        mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
    }
}
Body of Second Method:
{
    // lid changed state
    final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
    if (newLidState == mLidState) {
        return;
    }
    mLidState = newLidState;
    applyLidSwitchState();
    updateRotation(true);
    if (lidOpen) {
        wakeUp(SystemClock.uptimeMillis(), mAllowTheaterModeWakeFromLidSwitch);
    } else if (!mLidControlsSleep) {
        mPowerManager.userActivity(SystemClock.uptimeMillis(), false);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.hasFormData:COMMENT
<android.webkit.WebViewDatabase: boolean hasFormData()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether there is any saved data for web forms.
 *
 * @return whether there is any saved data for web forms
 * @see #clearFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.model.RecentsTaskLoader.onTrimMemory:COMMENT
Method Modifier: public      
Comment:/**
 * Handles signals from the system, trimming memory when requested to prevent us from running
 * out of memory.
 */

Body of Frist Method:
{
    switch(level) {
        case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:
            // Stop the loader immediately when the UI is no longer visible
            stopLoader();
            mThumbnailCache.trimToSize(Math.max(Constants.Values.RecentsTaskLoader.PreloadFirstTasksCount, mMaxThumbnailCacheSize / 2));
            mApplicationIconCache.trimToSize(Math.max(Constants.Values.RecentsTaskLoader.PreloadFirstTasksCount, mMaxIconCacheSize / 2));
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:
        case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:
            // We are leaving recents, so trim the data a bit
            mThumbnailCache.trimToSize(mMaxThumbnailCacheSize / 2);
            mApplicationIconCache.trimToSize(mMaxIconCacheSize / 2);
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:
        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
            // We are going to be low on memory
            mThumbnailCache.trimToSize(mMaxThumbnailCacheSize / 4);
            mApplicationIconCache.trimToSize(mMaxIconCacheSize / 4);
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:
        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            // We are low on memory, so release everything
            mThumbnailCache.evictAll();
            mApplicationIconCache.evictAll();
            // The cache is small, only clear the label cache when we are critical
            mActivityLabelCache.evictAll();
            break;
        default:
            break;
    }
}
Body of Second Method:
{
    RecentsConfiguration config = RecentsConfiguration.getInstance();
    switch(level) {
        case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:
            // Stop the loader immediately when the UI is no longer visible
            stopLoader();
            if (config.svelteLevel == RecentsConfiguration.SVELTE_NONE) {
                mThumbnailCache.trimToSize(Math.max(mNumVisibleTasksLoaded, mMaxThumbnailCacheSize / 2));
            } else if (config.svelteLevel == RecentsConfiguration.SVELTE_LIMIT_CACHE) {
                mThumbnailCache.trimToSize(mNumVisibleThumbnailsLoaded);
            } else if (config.svelteLevel >= RecentsConfiguration.SVELTE_DISABLE_CACHE) {
                mThumbnailCache.evictAll();
            }
            mApplicationIconCache.trimToSize(Math.max(mNumVisibleTasksLoaded, mMaxIconCacheSize / 2));
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:
        case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:
            // We are leaving recents, so trim the data a bit
            mThumbnailCache.trimToSize(Math.max(1, mMaxThumbnailCacheSize / 2));
            mApplicationIconCache.trimToSize(Math.max(1, mMaxIconCacheSize / 2));
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:
        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
            // We are going to be low on memory
            mThumbnailCache.trimToSize(Math.max(1, mMaxThumbnailCacheSize / 4));
            mApplicationIconCache.trimToSize(Math.max(1, mMaxIconCacheSize / 4));
            break;
        case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:
        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            // We are low on memory, so release everything
            mThumbnailCache.evictAll();
            mApplicationIconCache.evictAll();
            // The cache is small, only clear the label cache when we are critical
            mActivityLabelCache.evictAll();
            break;
        default:
            break;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setFantasyFontFamily:COMMENT
<android.webkit.WebSettings: void setFantasyFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the fantasy font family name. The default is "fantasy".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.launchHomeFromHotKey:COMMENT
Method Modifier: internal    
Comment:/**
 * A home key -> launch home action was detected.  Take the appropriate action
 * given the situation with the keyguard.
 */

Body of Frist Method:
{
    if (mKeyguardDelegate != null && mKeyguardDelegate.isShowingAndNotOccluded()) {
    // don't launch home if keyguard showing
    } else if (!mHideLockScreen && mKeyguardDelegate.isInputRestricted()) {
        // when in keyguard restricted mode, must first verify unlock
        // before launching home
        mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

            @Override
            public void onKeyguardExitResult(boolean success) {
                if (success) {
                    try {
                        ActivityManagerNative.getDefault().stopAppSwitches();
                    } catch (RemoteException e) {
                    }
                    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
                    startDockOrHome();
                }
            }
        });
    } else {
        // no keyguard stuff to worry about, just launch home!
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        if (mRecentsVisible) {
            // Hide Recents and notify it to launch Home
            awakenDreams();
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            hideRecentApps(false, true);
        } else {
            // Otherwise, just launch Home
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            startDockOrHome();
        }
    }
}
Body of Second Method:
{
    if (isKeyguardShowingAndNotOccluded()) {
    // don't launch home if keyguard showing
    } else if (!mHideLockScreen && mKeyguardDelegate.isInputRestricted()) {
        // when in keyguard restricted mode, must first verify unlock
        // before launching home
        mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

            @Override
            public void onKeyguardExitResult(boolean success) {
                if (success) {
                    try {
                        ActivityManagerNative.getDefault().stopAppSwitches();
                    } catch (RemoteException e) {
                    }
                    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
                    startDockOrHome();
                }
            }
        });
    } else {
        // no keyguard stuff to worry about, just launch home!
        try {
            ActivityManagerNative.getDefault().stopAppSwitches();
        } catch (RemoteException e) {
        }
        if (mRecentsVisible) {
            // Hide Recents and notify it to launch Home
            awakenDreams();
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            hideRecentApps(false, true);
        } else {
            // Otherwise, just launch Home
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
            startDockOrHome();
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.usb.UsbHostManager.endUsbDeviceAdded:COMMENT
Method Modifier: private     
Comment:/* Called from JNI in monitorUsbHostBus() to finish adding a new device */

Body of Frist Method:
{
    if (DEBUG_AUDIO) {
        Slog.d(TAG, "usb:UsbHostManager.endUsbDeviceAdded()");
    }
    if (mNewInterface != null) {
        mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
    }
    if (mNewConfiguration != null) {
        mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
    }
    // Is there an audio interface in there?
    final int kUsbClassId_Audio = 0x01;
    boolean isAudioDevice = false;
    for (int ntrfaceIndex = 0; !isAudioDevice && ntrfaceIndex < mNewInterfaces.size(); ntrfaceIndex++) {
        UsbInterface ntrface = mNewInterfaces.get(ntrfaceIndex);
        if (ntrface.getInterfaceClass() == kUsbClassId_Audio) {
            isAudioDevice = true;
        }
    }
    synchronized (mLock) {
        if (mNewDevice != null) {
            mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
            mDevices.put(mNewDevice.getDeviceName(), mNewDevice);
            Slog.d(TAG, "Added device " + mNewDevice);
            getCurrentSettings().deviceAttached(mNewDevice);
        } else {
            Slog.e(TAG, "mNewDevice is null in endUsbDeviceAdded");
        }
        mNewDevice = null;
        mNewConfigurations = null;
        mNewInterfaces = null;
        mNewEndpoints = null;
    }
    if (!isAudioDevice) {
        // bail
        return;
    }
    // TODO(pmclean) The "Parser" objects inspect files in "/proc/asound" which we presume is
    // present, unlike the waitForAlsaFile() which waits on a file in /dev/snd. It is not
    // clear why this works, or that it can be relied on going forward.  Needs further
    // research.
    AlsaCardsParser cardsParser = new AlsaCardsParser();
    cardsParser.scan();
    // cardsParser.Log();
    // But we need to parse the device to determine its capabilities.
    AlsaDevicesParser devicesParser = new AlsaDevicesParser();
    devicesParser.scan();
    // devicesParser.Log();
    // The protocol for now will be to select the last-connected (highest-numbered)
    // Alsa Card.
    mConnectedUsbCard = cardsParser.getNumCardRecords() - 1;
    mConnectedUsbDeviceNum = 0;
    mConnectedHasPlayback = devicesParser.hasPlaybackDevices(mConnectedUsbCard);
    mConnectedHasCapture = devicesParser.hasCaptureDevices(mConnectedUsbCard);
    mConnectedHasMIDI = devicesParser.hasMIDIDevices(mConnectedUsbCard);
    // Playback device file needed/present?
    if (mConnectedHasPlayback && !waitForAlsaFile(mConnectedUsbCard, mConnectedUsbDeviceNum, false)) {
        return;
    }
    // Capture device file needed/present?
    if (mConnectedHasCapture && !waitForAlsaFile(mConnectedUsbCard, mConnectedUsbDeviceNum, true)) {
        return;
    }
    if (DEBUG_AUDIO) {
        Slog.d(TAG, "usb: hasPlayback:" + mConnectedHasPlayback + " hasCapture:" + mConnectedHasCapture);
    }
    sendDeviceNotification(mConnectedUsbCard, mConnectedUsbDeviceNum, true, mConnectedHasPlayback, mConnectedHasCapture, mConnectedHasMIDI);
}
Body of Second Method:
{
    if (DEBUG) {
        Slog.d(TAG, "usb:UsbHostManager.endUsbDeviceAdded()");
    }
    if (mNewInterface != null) {
        mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
    }
    if (mNewConfiguration != null) {
        mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
    }
    synchronized (mLock) {
        if (mNewDevice != null) {
            mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
            mDevices.put(mNewDevice.getDeviceName(), mNewDevice);
            Slog.d(TAG, "Added device " + mNewDevice);
            getCurrentSettings().deviceAttached(mNewDevice);
            mUsbAudioManager.deviceAdded(mNewDevice);
        } else {
            Slog.e(TAG, "mNewDevice is null in endUsbDeviceAdded");
        }
        mNewDevice = null;
        mNewConfigurations = null;
        mNewInterfaces = null;
        mNewEndpoints = null;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromXmlInner:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from inside an XML document using an optional
 * {@link Theme}. Called on a parser positioned at a tag in an XML
 * document, tries to create a Drawable from that tag. Returns {@code null}
 * if the tag is not a valid drawable.
 */

Body of Frist Method:
{
    final Drawable drawable;
    final String name = parser.getName();
    if (name.equals("selector")) {
        drawable = new StateListDrawable();
    } else if (name.equals("animated-selector")) {
        drawable = new AnimatedStateListDrawable();
    } else if (name.equals("level-list")) {
        drawable = new LevelListDrawable();
    } else if (name.equals("layer-list")) {
        drawable = new LayerDrawable();
    } else if (name.equals("transition")) {
        drawable = new TransitionDrawable();
    } else if (name.equals("ripple")) {
        drawable = new RippleDrawable();
    } else if (name.equals("color")) {
        drawable = new ColorDrawable();
    } else if (name.equals("shape")) {
        drawable = new GradientDrawable();
    } else if (name.equals("vector")) {
        drawable = new VectorDrawable();
    } else if (name.equals("animated-vector")) {
        drawable = new AnimatedVectorDrawable();
    } else if (name.equals("scale")) {
        drawable = new ScaleDrawable();
    } else if (name.equals("clip")) {
        drawable = new ClipDrawable();
    } else if (name.equals("rotate")) {
        drawable = new RotateDrawable();
    } else if (name.equals("animated-rotate")) {
        drawable = new AnimatedRotateDrawable();
    } else if (name.equals("animation-list")) {
        drawable = new AnimationDrawable();
    } else if (name.equals("inset")) {
        drawable = new InsetDrawable();
    } else if (name.equals("bitmap")) {
        // noinspection deprecation
        drawable = new BitmapDrawable(r);
        if (r != null) {
            ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
        }
    } else if (name.equals("nine-patch")) {
        drawable = new NinePatchDrawable();
        if (r != null) {
            ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
        }
    } else {
        throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
    }
    drawable.inflate(r, parser, attrs, theme);
    return drawable;
}
Body of Second Method:
{
    final Drawable drawable;
    final String name = parser.getName();
    switch(name) {
        case "selector":
            drawable = new StateListDrawable();
            break;
        case "animated-selector":
            drawable = new AnimatedStateListDrawable();
            break;
        case "level-list":
            drawable = new LevelListDrawable();
            break;
        case "layer-list":
            drawable = new LayerDrawable();
            break;
        case "transition":
            drawable = new TransitionDrawable();
            break;
        case "ripple":
            drawable = new RippleDrawable();
            break;
        case "color":
            drawable = new ColorDrawable();
            break;
        case "shape":
            drawable = new GradientDrawable();
            break;
        case "vector":
            drawable = new VectorDrawable();
            break;
        case "animated-vector":
            drawable = new AnimatedVectorDrawable();
            break;
        case "scale":
            drawable = new ScaleDrawable();
            break;
        case "clip":
            drawable = new ClipDrawable();
            break;
        case "rotate":
            drawable = new RotateDrawable();
            break;
        case "animated-rotate":
            drawable = new AnimatedRotateDrawable();
            break;
        case "animation-list":
            drawable = new AnimationDrawable();
            break;
        case "inset":
            drawable = new InsetDrawable();
            break;
        case "bitmap":
            drawable = new BitmapDrawable(r);
            if (r != null) {
                ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
            }
            break;
        case "nine-patch":
            drawable = new NinePatchDrawable();
            if (r != null) {
                ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
            }
            break;
        default:
            throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
    }
    drawable.inflate(r, parser, attrs, theme);
    return drawable;
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.removeSessionCookies:COMMENT
<android.webkit.CookieManager: void removeSessionCookies(ValueCallback<Boolean>)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Removes all session cookies, which are cookies without an expiration
 * date.
 * <p>
 * This method is asynchronous.
 * If a {@link ValueCallback} is provided,
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()} will be called on the current
 * thread's {@link android.os.Looper} once the operation is complete.
 * The value provided to the callback indicates whether any cookies were removed.
 * You can pass {@code null} as the callback if you don't need to know when the operation
 * completes or whether any cookie were removed, and in this case it is safe to call the
 * method from a thread without a Looper.
 * @param callback a callback which is executed when the session cookies have been removed
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getPhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSubId(subId)) {
        logd("[getPhoneId]- fail");
        return INVALID_PHONE_ID;
    }
    int result = INVALID_PHONE_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(subId)) {
        logd("[getPhoneId]- fail");
        return INVALID_PHONE_INDEX;
    }
    int result = INVALID_PHONE_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
------------------------
Find a functionally equivalent code:android.widget.DayPickerView.onInitializeAccessibilityNodeInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Necessary for accessibility, to ensure we support "scrolling" forward and backward
 * in the month list.
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfo(info);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfo(info);
    info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCodeForSms:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Process phone number for CDMA, converting plus code using the home network number format.
 * This is used for outgoing SMS messages.
 *
 * @param dialStr the original dial string
 * @return the converted dial string
 * @hide for internal use
 */

Body of Frist Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String defaultIso = SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, "");
            if (!TextUtils.isEmpty(defaultIso)) {
                int format = getFormatTypeFromCountryCode(defaultIso);
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, format, format);
            }
        }
    }
    return dialStr;
}
Body of Second Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String defaultIso = TelephonyManager.getDefault().getSimCountryIso();
            if (!TextUtils.isEmpty(defaultIso)) {
                int format = getFormatTypeFromCountryCode(defaultIso);
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, format, format);
            }
        }
    }
    return dialStr;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getBlockNetworkLoads:COMMENT
<android.webkit.WebSettings: boolean getBlockNetworkLoads()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView does not load any resources from the network.
 *
 * @return true if the WebView does not load any resources from the network
 * @see #setBlockNetworkLoads
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.AudioManager.abandonAudioFocus:COMMENT
Method Modifier: public      
Comment:/**
 * Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
 * @param l the listener with which focus was requested.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */

Body of Frist Method:
{
    int status = AUDIOFOCUS_REQUEST_FAILED;
    unregisterAudioFocusListener(l);
    IAudioService service = getService();
    try {
        status = service.abandonAudioFocus(mAudioFocusDispatcher, getIdForAudioFocusListener(l));
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocus() on AudioService due to " + e);
    }
    return status;
}
Body of Second Method:
{
    return abandonAudioFocus(l, null);
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.updateUserActivitySummaryLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the value of mUserActivitySummary to summarize the user requested
 * state of the system such as whether the screen should be bright or dim.
 * Note that user activity is ignored when the system is asleep.
 *
 * This function must have no other side-effects.
 */

Body of Frist Method:
{
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
Body of Second Method:
{
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.onSuggestionsKey:COMMENT
Method Modifier: private     
Comment:/**
 * React to the user typing while in the suggestions list. First, check for
 * action keys. If not handled, try refocusing regular characters into the
 * EditText.
 */

Body of Frist Method:
{
    // guard against possible race conditions (late arrival after dismiss)
    if (mSearchable == null) {
        return false;
    }
    if (mSuggestionsAdapter == null) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.hasNoModifiers()) {
        // "click")
        if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_TAB) {
            int position = mQueryTextView.getListSelection();
            return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
        }
        // user to the edit view
        if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // give "focus" to text editor, with cursor at the beginning if
            // left key, at end if right key
            // TODO: Reverse left/right for right-to-left languages, e.g.
            // Arabic
            int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mQueryTextView.length();
            mQueryTextView.setSelection(selPoint);
            mQueryTextView.setListSelection(0);
            mQueryTextView.clearListSelection();
            mQueryTextView.ensureImeVisible(true);
            return true;
        }
        // Next, check for an "up and out" move
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && 0 == mQueryTextView.getListSelection()) {
            // let ACTV complete the move
            return false;
        }
        // Next, check for an "action key"
        SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
        if ((actionKey != null) && ((actionKey.getSuggestActionMsg() != null) || (actionKey.getSuggestActionMsgColumn() != null))) {
            // launch suggestion using action key column
            int position = mQueryTextView.getListSelection();
            if (position != ListView.INVALID_POSITION) {
                Cursor c = mSuggestionsAdapter.getCursor();
                if (c.moveToPosition(position)) {
                    final String actionMsg = getActionKeyMessage(c, actionKey);
                    if (actionMsg != null && (actionMsg.length() > 0)) {
                        return onItemClicked(position, keyCode, actionMsg);
                    }
                }
            }
        }
    }
    return false;
}
Body of Second Method:
{
    // guard against possible race conditions (late arrival after dismiss)
    if (mSearchable == null) {
        return false;
    }
    if (mSuggestionsAdapter == null) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.hasNoModifiers()) {
        // "click")
        if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_TAB) {
            int position = mSearchSrcTextView.getListSelection();
            return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
        }
        // user to the edit view
        if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // give "focus" to text editor, with cursor at the beginning if
            // left key, at end if right key
            // TODO: Reverse left/right for right-to-left languages, e.g.
            // Arabic
            int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mSearchSrcTextView.length();
            mSearchSrcTextView.setSelection(selPoint);
            mSearchSrcTextView.setListSelection(0);
            mSearchSrcTextView.clearListSelection();
            mSearchSrcTextView.ensureImeVisible(true);
            return true;
        }
        // Next, check for an "up and out" move
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && 0 == mSearchSrcTextView.getListSelection()) {
            // let ACTV complete the move
            return false;
        }
        // Next, check for an "action key"
        SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
        if ((actionKey != null) && ((actionKey.getSuggestActionMsg() != null) || (actionKey.getSuggestActionMsgColumn() != null))) {
            // launch suggestion using action key column
            int position = mSearchSrcTextView.getListSelection();
            if (position != ListView.INVALID_POSITION) {
                Cursor c = mSuggestionsAdapter.getCursor();
                if (c.moveToPosition(position)) {
                    final String actionMsg = getActionKeyMessage(c, actionKey);
                    if (actionMsg != null && (actionMsg.length() > 0)) {
                        return onItemClicked(position, keyCode, actionMsg);
                    }
                }
            }
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.setCurrentPlayTime:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified point in time. This time should
 * be between 0 and the total duration of the animation, including any repetition. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this time; it will simply set the time to this value and perform any appropriate
 * actions based on that time. If the animation is already running, then setCurrentPlayTime()
 * will set the current playing time to this value and continue playing from that point.
 *
 * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 */

Body of Frist Method:
{
    initAnimation();
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    if (mPlayingState != RUNNING) {
        mSeekTime = playTime;
        mPlayingState = SEEKED;
    }
    mStartTime = currentTime - playTime;
    doAnimationFrame(currentTime);
}
Body of Second Method:
{
    float fraction = mUnscaledDuration > 0 ? (float) playTime / mUnscaledDuration : 1;
    setCurrentFraction(fraction);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.DragDownHelper.DragDownCallback.onDraggedDown:COMMENT
Method Modifier: 
Comment:/**
 * @return true if the interaction is accepted, false if it should be cancelled
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.content.res.Resources.getDrawableForDensity:COMMENT
Method Modifier: public      
Comment:/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI and styled for the specified theme.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density The desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @param theme The theme used to style the drawable attributes, may be {@code null}.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 */

Body of Frist Method:
{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
    }
    final Drawable res = loadDrawable(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}
Body of Second Method:
{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
    }
    final Drawable res = loadDrawable(value, id, theme);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.AlternateRecentsComponent.reloadHeaderBarLayout:COMMENT
Method Modifier: 
Comment:/**
 * Prepares the header bar layout.
 */

Body of Frist Method:
{
    Resources res = mContext.getResources();
    mWindowRect = mSystemServicesProxy.getWindowRect();
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    mNavBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    mNavBarWidth = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width);
    mConfig = RecentsConfiguration.reinitialize(mContext, mSystemServicesProxy);
    mConfig.updateOnConfigurationChange();
    mConfig.getTaskStackBounds(mWindowRect.width(), mWindowRect.height(), mStatusBarHeight, (mConfig.hasTransposedNavBar ? mNavBarWidth : 0), mTaskStackBounds);
    if (mConfig.isLandscape && mConfig.hasTransposedNavBar) {
        mSystemInsets.set(0, mStatusBarHeight, mNavBarWidth, 0);
    } else {
        mSystemInsets.set(0, mStatusBarHeight, 0, mNavBarHeight);
    }
    // Inflate the header bar layout so that we can rebind and draw it for the transition
    TaskStack stack = new TaskStack();
    mDummyStackView = new TaskStackView(mContext, stack);
    TaskStackViewLayoutAlgorithm algo = mDummyStackView.getStackAlgorithm();
    Rect taskStackBounds = new Rect(mTaskStackBounds);
    taskStackBounds.bottom -= mSystemInsets.bottom;
    algo.computeRects(mWindowRect.width(), mWindowRect.height(), taskStackBounds);
    Rect taskViewSize = algo.getUntransformedTaskViewSize();
    int taskBarHeight = res.getDimensionPixelSize(R.dimen.recents_task_bar_height);
    mHeaderBar = (TaskViewHeader) mInflater.inflate(R.layout.recents_task_view_header, null, false);
    mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewSize.width(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(taskBarHeight, View.MeasureSpec.EXACTLY));
    mHeaderBar.layout(0, 0, taskViewSize.width(), taskBarHeight);
}
Body of Second Method:
{
    Resources res = mContext.getResources();
    mWindowRect = mSystemServicesProxy.getWindowRect();
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    mNavBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    mNavBarWidth = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width);
    mConfig = RecentsConfiguration.reinitialize(mContext, mSystemServicesProxy);
    mConfig.updateOnConfigurationChange();
    if (reloadWidget) {
        // Reload the widget id before we get the task stack bounds
        reloadSearchBarAppWidget(mContext, mSystemServicesProxy);
    }
    mConfig.getTaskStackBounds(mWindowRect.width(), mWindowRect.height(), mStatusBarHeight, (mConfig.hasTransposedNavBar ? mNavBarWidth : 0), mTaskStackBounds);
    if (mConfig.isLandscape && mConfig.hasTransposedNavBar) {
        mSystemInsets.set(0, mStatusBarHeight, mNavBarWidth, 0);
    } else {
        mSystemInsets.set(0, mStatusBarHeight, 0, mNavBarHeight);
    }
    // Inflate the header bar layout so that we can rebind and draw it for the transition
    TaskStack stack = new TaskStack();
    mDummyStackView = new TaskStackView(mContext, stack);
    TaskStackViewLayoutAlgorithm algo = mDummyStackView.getStackAlgorithm();
    Rect taskStackBounds = new Rect(mTaskStackBounds);
    taskStackBounds.bottom -= mSystemInsets.bottom;
    algo.computeRects(mWindowRect.width(), mWindowRect.height(), taskStackBounds);
    Rect taskViewSize = algo.getUntransformedTaskViewSize();
    int taskBarHeight = res.getDimensionPixelSize(R.dimen.recents_task_bar_height);
    mHeaderBar = (TaskViewHeader) mInflater.inflate(R.layout.recents_task_view_header, null, false);
    mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewSize.width(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(taskBarHeight, View.MeasureSpec.EXACTLY));
    mHeaderBar.layout(0, 0, taskViewSize.width(), taskBarHeight);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSaveFormData:COMMENT
<android.webkit.WebSettings: void setSaveFormData(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should save form data. The default is true.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getAllowFileAccess:COMMENT
<android.webkit.WebSettings: boolean getAllowFileAccess()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView supports file access.
 *
 * @see #setAllowFileAccess
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.AbsListView.trackMotionScroll:COMMENT
Method Modifier: 
Comment:/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */

Body of Frist Method:
{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // "effective padding" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}
Body of Second Method:
{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // "effective padding" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setRenderPriority:COMMENT
<android.webkit.WebSettings: void setRenderPriority(RenderPriority)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the priority of the Render thread. Unlike the other settings, this
 * one only needs to be called once per process. The default value is
 * {@link RenderPriority#NORMAL}.
 *
 * @param priority the priority
 * @deprecated It is not recommended to adjust thread priorities, and this will
 * not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getAcceptThirdPartyCookies:COMMENT
<android.webkit.WebSettings: boolean getAcceptThirdPartyCookies()>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets policy for third party cookies.
 * Developers should access this via {@link CookieManager#getShouldAcceptThirdPartyCookies}.
 * @hide Internal API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.util.PathParser.createPathFromPathData:COMMENT
Method Modifier: public      static      
Comment:/**
 * @param pathData The string representing a path, the same as "d" string in svg file.
 * @return the generated Path object.
 */

Body of Frist Method:
{
    Path path = new Path();
    PathDataNode[] nodes = createNodesFromPathData(pathData);
    if (nodes != null) {
        PathDataNode.nodesToPath(nodes, path);
        return path;
    }
    return null;
}
Body of Second Method:
{
    Path path = new Path();
    PathDataNode[] nodes = createNodesFromPathData(pathData);
    if (nodes != null) {
        try {
            PathDataNode.nodesToPath(nodes, path);
        } catch (RuntimeException e) {
            throw new RuntimeException("Error in parsing " + pathData, e);
        }
        return path;
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.widget.AbsListView.positionSelectorLikeFocus:COMMENT
Method Modifier: 
Comment:/**
 * Positions the selector in a way that mimics keyboard focus.
 */

Body of Frist Method:
{
    // If we're changing position, update the visibility since the selector
    // is technically being detached from the previous selection.
    final Drawable selector = mSelector;
    final boolean manageState = selector != null && mSelectorPosition != position && position != INVALID_POSITION;
    if (manageState) {
        selector.setVisible(false, false);
    }
    positionSelector(position, sel);
    if (manageState) {
        final Rect bounds = mSelectorRect;
        final float x = bounds.exactCenterX();
        final float y = bounds.exactCenterY();
        selector.setVisible(getVisibility() == VISIBLE, false);
        selector.setHotspot(x, y);
    }
}
Body of Second Method:
{
    if (mSelector != null && mSelectorPosition != position && position != INVALID_POSITION) {
        final Rect bounds = mSelectorRect;
        final float x = bounds.exactCenterX();
        final float y = bounds.exactCenterY();
        positionSelector(position, sel, true, x, y);
    } else {
        positionSelector(position, sel);
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.media.projection.MediaProjection.registerCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Register a listener to receive notifications about when the {@link
 * MediaProjection} changes state.
 *
 * @param callback The callback to call.
 * @param handler The handler on which the callback should be invoked, or
 * null if the callback should be invoked on the calling thread's looper.
 *
 * @see #unregisterCallback
 */

Body of Frist Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("callback should not be null");
    }
    mCallbacks.put(callback, new CallbackRecord(callback, handler));
}
Body of Second Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("callback should not be null");
    }
    if (handler == null) {
        handler = new Handler();
    }
    mCallbacks.put(callback, new CallbackRecord(callback, handler));
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.setAcceptFileSchemeCookiesImpl:COMMENT
<android.webkit.CookieManager: void setAcceptFileSchemeCookiesImpl(boolean)>
Method Modifier: protected   abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implements {@link #setAcceptFileSchemeCookies(boolean)}.
 *
 * @hide Only for use by WebViewProvider implementations
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewLayoutAlgorithm.getStackScrollForTask:COMMENT
Method Modifier: 
Comment:/**
 * Returns the scroll to such task top = 1f;
 */

Body of Frist Method:
{
    return mTaskProgressMap.get(t.key);
}
Body of Second Method:
{
    if (!mTaskProgressMap.containsKey(t.key))
        return 0f;
    return mTaskProgressMap.get(t.key);
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.removeAllIcons:COMMENT
<android.webkit.WebIconDatabase: void removeAllIcons()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Removes all the icons in the database.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.SearchView.updateSearchAutoComplete:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the auto-complete text view.
 */

Body of Frist Method:
{
    // no animation
    mQueryTextView.setDropDownAnimationStyle(0);
    mQueryTextView.setThreshold(mSearchable.getSuggestThreshold());
    mQueryTextView.setImeOptions(mSearchable.getImeOptions());
    int inputType = mSearchable.getInputType();
    // should be, in the case of search!)
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
        // The existence of a suggestions authority is the proxy for "suggestions
        // are available here"
        inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        if (mSearchable.getSuggestAuthority() != null) {
            inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
            // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
            // auto-completion based on its own semantics, which it will present to the user
            // as they type. This generally means that the input method should not show its
            // own candidates, and the spell checker should not be in action. The text editor
            // supplies its candidates by calling InputMethodManager.displayCompletions(),
            // which in turn will call InputMethodSession.displayCompletions().
            inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }
    }
    mQueryTextView.setInputType(inputType);
    if (mSuggestionsAdapter != null) {
        mSuggestionsAdapter.changeCursor(null);
    }
    // The existence of a suggestions authority is the proxy for "suggestions available here"
    if (mSearchable.getSuggestAuthority() != null) {
        mSuggestionsAdapter = new SuggestionsAdapter(getContext(), this, mSearchable, mOutsideDrawablesCache);
        mQueryTextView.setAdapter(mSuggestionsAdapter);
        ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(mQueryRefinement ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
    }
}
Body of Second Method:
{
    // no animation
    mSearchSrcTextView.setDropDownAnimationStyle(0);
    mSearchSrcTextView.setThreshold(mSearchable.getSuggestThreshold());
    mSearchSrcTextView.setImeOptions(mSearchable.getImeOptions());
    int inputType = mSearchable.getInputType();
    // should be, in the case of search!)
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
        // The existence of a suggestions authority is the proxy for "suggestions
        // are available here"
        inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        if (mSearchable.getSuggestAuthority() != null) {
            inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
            // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
            // auto-completion based on its own semantics, which it will present to the user
            // as they type. This generally means that the input method should not show its
            // own candidates, and the spell checker should not be in action. The text editor
            // supplies its candidates by calling InputMethodManager.displayCompletions(),
            // which in turn will call InputMethodSession.displayCompletions().
            inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }
    }
    mSearchSrcTextView.setInputType(inputType);
    if (mSuggestionsAdapter != null) {
        mSuggestionsAdapter.changeCursor(null);
    }
    // The existence of a suggestions authority is the proxy for "suggestions available here"
    if (mSearchable.getSuggestAuthority() != null) {
        mSuggestionsAdapter = new SuggestionsAdapter(getContext(), this, mSearchable, mOutsideDrawablesCache);
        mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
        ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(mQueryRefinement ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleDrawable.clearHotspots:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels and removes the active ripple, all exiting ripples, and the
 * background. Nothing will be drawn after this method is called.
 */

Body of Frist Method:
{
    boolean needsDraw = false;
    if (mRipple != null) {
        needsDraw |= mRipple.isHardwareAnimating();
        mRipple.cancel();
        mRipple = null;
    }
    if (mBackground != null) {
        needsDraw |= mBackground.isHardwareAnimating();
        mBackground.cancel();
        mBackground = null;
    }
    needsDraw |= cancelExitingRipples();
    mNeedsDraw = needsDraw;
    invalidateSelf();
}
Body of Second Method:
{
    if (mRipple != null) {
        mRipple.cancel();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.cancel();
        mBackground = null;
        mBackgroundActive = false;
    }
    cancelExitingRipples();
    invalidateSelf();
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.requestFocus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Don't accept focus if in the middle of clearing focus
    if (mClearingFocus)
        return false;
    // Check if SearchView is focusable.
    if (!isFocusable())
        return false;
    // If it is not iconified, then give the focus to the text field
    if (!isIconified()) {
        boolean result = mQueryTextView.requestFocus(direction, previouslyFocusedRect);
        if (result) {
            updateViewsVisibility(false);
        }
        return result;
    } else {
        return super.requestFocus(direction, previouslyFocusedRect);
    }
}
Body of Second Method:
{
    // Don't accept focus if in the middle of clearing focus
    if (mClearingFocus)
        return false;
    // Check if SearchView is focusable.
    if (!isFocusable())
        return false;
    // If it is not iconified, then give the focus to the text field
    if (!isIconified()) {
        boolean result = mSearchSrcTextView.requestFocus(direction, previouslyFocusedRect);
        if (result) {
            updateViewsVisibility(false);
        }
        return result;
    } else {
        return super.requestFocus(direction, previouslyFocusedRect);
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchNoCerts1:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with two certificates cannot be upgraded
     * by an app signed with a different certificate.
     */

Body of Frist Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT3, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT3, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.onMeasure:COMMENT
Method Modifier: protected   
Comment:/**
 * This is called with the full window width and height to allow stack view children to
 * perform the full screen transition down.
 */

Body of Frist Method:
{
    int width = MeasureSpec.getSize(widthMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);
    // Compute our stack/task rects
    Rect taskStackBounds = new Rect(mTaskStackBounds);
    taskStackBounds.bottom -= mConfig.systemInsets.bottom;
    computeRects(width, height, taskStackBounds, mConfig.launchedWithAltTab, mConfig.launchedFromHome);
    // stack views immediately to load all the views
    if (mAwaitingFirstLayout) {
        mStackScroller.setStackScrollToInitialState();
        requestSynchronizeStackViewsWithModel();
        synchronizeStackViewsWithModel();
    }
    // Measure each of the TaskViews
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        if (tv.isFullScreenView()) {
            tv.measure(widthMeasureSpec, heightMeasureSpec);
        } else {
            if (tv.getBackground() != null) {
                tv.getBackground().getPadding(mTmpRect);
            } else {
                mTmpRect.setEmpty();
            }
            tv.measure(MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.width() + mTmpRect.left + mTmpRect.right, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.height() + mTmpRect.top + mTmpRect.bottom + tv.getMaxFooterHeight(), MeasureSpec.EXACTLY));
        }
    }
    setMeasuredDimension(width, height);
}
Body of Second Method:
{
    int width = MeasureSpec.getSize(widthMeasureSpec);
    int height = MeasureSpec.getSize(heightMeasureSpec);
    // Compute our stack/task rects
    Rect taskStackBounds = new Rect(mTaskStackBounds);
    taskStackBounds.bottom -= mConfig.systemInsets.bottom;
    computeRects(width, height, taskStackBounds, mConfig.launchedWithAltTab, mConfig.launchedFromHome);
    // stack views immediately to load all the views
    if (mAwaitingFirstLayout) {
        mStackScroller.setStackScrollToInitialState();
        requestSynchronizeStackViewsWithModel();
        synchronizeStackViewsWithModel();
    }
    // Measure each of the TaskViews
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        if (tv.getBackground() != null) {
            tv.getBackground().getPadding(mTmpRect);
        } else {
            mTmpRect.setEmpty();
        }
        tv.measure(MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.width() + mTmpRect.left + mTmpRect.right, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.height() + mTmpRect.top + mTmpRect.bottom, MeasureSpec.EXACTLY));
    }
    setMeasuredDimension(width, height);
}
------------------------
Find a functionally equivalent code:com.android.server.TextServicesManagerService.getCurrentSpellChecker:COMMENT
Method Modifier: public      
Comment:// checker is saved.

Body of Frist Method:
{
    // TODO: Make this work even for non-current users?
    if (!calledFromValidUser()) {
        return null;
    }
    synchronized (mSpellCheckerMap) {
        final String curSpellCheckerId = mSettings.getSelectedSpellChecker();
        if (DBG) {
            Slog.w(TAG, "getCurrentSpellChecker: " + curSpellCheckerId);
        }
        if (TextUtils.isEmpty(curSpellCheckerId)) {
            return null;
        }
        return mSpellCheckerMap.get(curSpellCheckerId);
    }
}
Body of Second Method:
{
    // TODO: Make this work even for non-current users?
    if (!calledFromValidUser()) {
        return null;
    }
    return getCurrentSpellCheckerWithoutVerification();
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchNoCerts2:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with two certificates cannot be upgraded
     * by an app signed with a different certificate.
     */

Body of Frist Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT3_CERT4, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(APP1_CERT1_CERT2, APP1_CERT3_CERT4, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.showFindDialog:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "showFindDialog");
    return mProvider.showFindDialog(text, showIme);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "showFindDialog");
    return mProvider.showFindDialog(text, showIme);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setBlockNetworkImage:COMMENT
<android.webkit.WebSettings: void setBlockNetworkImage(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should not load image resources from the
 * network (resources accessed via http and https URI schemes).  Note
 * that this method has no effect unless
 * {@link #getLoadsImagesAutomatically} returns true. Also note that
 * disabling all network loads using {@link #setBlockNetworkLoads}
 * will also prevent network images from loading, even if this flag is set
 * to false. When the value of this setting is changed from true to false,
 * network images resources referenced by content currently displayed by
 * the WebView are fetched automatically. The default is false.
 *
 * @param flag whether the WebView should not load image resources from the
 * network
 * @see #setBlockNetworkLoads
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getSavePassword:COMMENT
<android.webkit.WebSettings: boolean getSavePassword()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether the WebView saves passwords.
 *
 * @return whether the WebView saves passwords
 * @see #setSavePassword
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setStandardFontFamily:COMMENT
<android.webkit.WebSettings: void setStandardFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the standard font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.normalizeNumber:COMMENT
Method Modifier: public      static      
Comment:/**
 * Normalize a phone number by removing the characters other than digits. If
 * the given number has keypad letters, the letters will be converted to
 * digits first.
 *
 * @param phoneNumber the number to be normalized.
 * @return the normalized number.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(phoneNumber)) {
        return "";
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (i == 0 && c == '+') {
            sb.append(c);
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
    return sb.toString();
}
Body of Second Method:
{
    if (TextUtils.isEmpty(phoneNumber)) {
        return "";
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (sb.length() == 0 && c == '+') {
            sb.append(c);
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
    return sb.toString();
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getUseDoubleTree:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Controlled a rendering optimization that is no longer present. Setting
 * it now has no effect.
 *
 * @deprecated This setting now has no effect.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    // Returns false unconditionally, so no need for derived classes to override.
    return false;
}
Body of Second Method:
{
    // Returns false unconditionally, so no need for derived classes to override.
    return false;
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.setAcceptThirdPartyCookies:COMMENT
<android.webkit.CookieManager: void setAcceptThirdPartyCookies(WebView,boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the {@link WebView} should allow third party cookies to be set.
 * Allowing third party cookies is a per WebView policy and can be set
 * differently on different WebView instances.
 * <p>
 * Apps that target {@link android.os.Build.VERSION_CODES#KITKAT} or below
 * default to allowing third party cookies. Apps targeting
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP} or later default to disallowing
 * third party cookies.
 *
 * @param webview the {@link WebView} instance to set the cookie policy on
 * @param accept whether the {@link WebView} instance should accept
 * third party cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setMediaPlaybackRequiresUserGesture:COMMENT
<android.webkit.WebSettings: void setMediaPlaybackRequiresUserGesture(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView requires a user gesture to play media.
 * The default is true.
 *
 * @param require whether the WebView requires a user gesture to play media
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.renderscript.Allocation.copyTo:COMMENT
Method Modifier: public      
Comment:/**
 * Copy from the Allocation into an array.  The array must be at
 * least as large as the Allocation.  The
 * {@link android.renderscript.Element} must match the component
 * type of the array passed in.
 *
 * @param array The array to be set from the Allocation.
 */

Body of Frist Method:
{
    copyTo(array, validateObjectIsPrimitiveArray(array, true), java.lang.reflect.Array.getLength(array));
}
Body of Second Method:
{
    copyTo(array, validateObjectIsPrimitiveArray(array, true), java.lang.reflect.Array.getLength(array));
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDefaultZoom:COMMENT
<android.webkit.WebSettings: void setDefaultZoom(ZoomDensity)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the default zoom density of the page. This must be called from the UI
 * thread. The default is {@link ZoomDensity#MEDIUM}.
 *
 * This setting is not recommended for use in new applications.  If the WebView
 * is utilized to display mobile-oriented pages, the desired effect can be achieved by
 * adjusting 'width' and 'initial-scale' attributes of page's 'meta viewport'
 * tag. For pages lacking the tag, {@link android.webkit.WebView#setInitialScale}
 * and {@link #setUseWideViewPort} can be used.
 *
 * @param zoom the zoom density
 * @deprecated This method is no longer supported, see the function documentation for
 * recommended alternatives.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.view.ViewGroup.isTransformedTouchPointInView:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Returns true if a child view contains the specified point when transformed
 * into its coordinate space.
 * Child must not be null.
 * @hide
 */

Body of Frist Method:
{
    float localX = x + mScrollX - child.mLeft;
    float localY = y + mScrollY - child.mTop;
    if (!child.hasIdentityMatrix() && mAttachInfo != null) {
        final float[] localXY = mAttachInfo.mTmpTransformLocation;
        localXY[0] = localX;
        localXY[1] = localY;
        child.getInverseMatrix().mapPoints(localXY);
        localX = localXY[0];
        localY = localXY[1];
    }
    final boolean isInView = child.pointInView(localX, localY);
    if (isInView && outLocalPoint != null) {
        outLocalPoint.set(localX, localY);
    }
    return isInView;
}
Body of Second Method:
{
    final float[] point = getTempPoint();
    point[0] = x;
    point[1] = y;
    transformPointToViewLocal(point, child);
    final boolean isInView = child.pointInView(point[0], point[1]);
    if (isInView && outLocalPoint != null) {
        outLocalPoint.set(point[0], point[1]);
    }
    return isInView;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.checkForRingerModeChange:COMMENT
Method Modifier: private     
Comment:/**
 * Checks if the adjustment should change ringer mode instead of just
 * adjusting volume. If so, this will set the proper ringer mode and volume
 * indices on the stream states.
 */

Body of Frist Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, false);
    mPrevVolDirection = direction;
    return result;
}
Body of Second Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerModeInternal();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    if (VOLUME_SETS_RINGER_MODE_SILENT) {
                        ringerMode = RINGER_MODE_SILENT;
                    } else {
                        result |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
                    }
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, TAG + ".checkForRingerModeChange", false);
    mPrevVolDirection = direction;
    return result;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothHeadset.close:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    mServiceListener = null;
    doUnbind();
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getDefaultSmsPhoneId:COMMENT
<android.telephony.SubscriptionManager: int getDefaultSmsPhoneId()>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getPhoneId(getDefaultSmsSubId());
}
Body of Second Method:
{
    return getPhoneId(getDefaultSmsSubId());
}
------------------------
Find a functionally equivalent code:android.content.ContentProvider.enforceWritePermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.getBluetoothService:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    synchronized (mManagerCallback) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
Body of Second Method:
{
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.resolveDrawables:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resolveDrawables();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited()) {
            child.resolveDrawables();
        }
    }
}
Body of Second Method:
{
    super.resolveDrawables();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited() && !child.areDrawablesResolved()) {
            child.resolveDrawables();
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setMinimumLogicalFontSize:COMMENT
<android.webkit.WebSettings: void setMinimumLogicalFontSize(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the minimum logical font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.ServiceState.getOperatorAlphaShort:COMMENT
Method Modifier: public      
Comment:/**
 * Get current registered operator name in short alphanumeric format.
 *
 * In GSM/UMTS, short format can be up to 8 characters long.
 *
 * @return short name of operator, null if unregistered or unknown
 */

Body of Frist Method:
{
    return mOperatorAlphaShort;
}
Body of Second Method:
{
    return mVoiceOperatorAlphaShort;
}
------------------------
Find a functionally equivalent code:android.media.audiopolicy.AudioMixingRule.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the matching and exclusion rules that have been set and return a new
 * {@link AudioMixingRule} object.
 * @return a new {@link AudioMixingRule} object
 */

Body of Frist Method:
{
    return new AudioMixingRule(mCriteria);
}
Body of Second Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria);
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.isLocalEmergencyNumber:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given number is an emergency number for the country that the user is in.
 *
 * @param subId the subscription id of the SIM.
 * @param number the number to look up.
 * @param context the specific context which the number should be checked against
 * @return true if the specified number is an emergency number for the country the user
 * is currently in.
 * @hide
 */

Body of Frist Method:
{
    return isLocalEmergencyNumberInternal(subId, number, context, true);
}
Body of Second Method:
{
    return isLocalEmergencyNumberInternal(subId, number, context, true);
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.allocateAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */

Body of Frist Method:
{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleBackground.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancel all animations. The caller is responsible for removing
 * the ripple from the list of animating ripples.
 */

Body of Frist Method:
{
    cancelSoftwareAnimations();
    cancelHardwareAnimations(true);
}
Body of Second Method:
{
    cancelSoftwareAnimations();
    cancelHardwareAnimations(false);
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormats:COMMENT
Method Modifier: private     
Comment:/**
 * Get the list of publically visible output formats; does not include IMPL_DEFINED
 */

Body of Frist Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    for (int format : getFormatsMap(output).keySet()) {
        if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
            formats[i++] = format;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return imageFormatToPublic(formats);
}
Body of Second Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    for (int format : getFormatsMap(output).keySet()) {
        if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED && format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
            formats[i++] = format;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return imageFormatToPublic(formats);
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.allowFileSchemeCookiesImpl:COMMENT
<android.webkit.CookieManager: boolean allowFileSchemeCookiesImpl()>
Method Modifier: protected   abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implements {@link #allowFileSchemeCookies()}.
 *
 * @hide Only for use by WebViewProvider implementations
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.goToSleepNoUpdateLocked:COMMENT
Method Modifier: private     
Comment:// dozing before really going to sleep.

Body of Frist Method:
{
    if (DEBUG_SPEW) {
        Slog.d(TAG, "goToSleepNoUpdateLocked: eventTime=" + eventTime + ", reason=" + reason + ", flags=" + flags + ", uid=" + uid);
    }
    if (eventTime < mLastWakeTime || mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "goToSleep");
    try {
        switch(reason) {
            case PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN:
                Slog.i(TAG, "Going to sleep due to device administration policy " + "(uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_TIMEOUT:
                Slog.i(TAG, "Going to sleep due to screen timeout (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH:
                Slog.i(TAG, "Going to sleep due to lid switch (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON:
                Slog.i(TAG, "Going to sleep due to power button (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_HDMI:
                Slog.i(TAG, "Going to sleep due to HDMI standby (uid " + uid + ")...");
                break;
            default:
                Slog.i(TAG, "Going to sleep by application request (uid " + uid + ")...");
                reason = PowerManager.GO_TO_SLEEP_REASON_APPLICATION;
                break;
        }
        mLastSleepTime = eventTime;
        mDirty |= DIRTY_WAKEFULNESS;
        mWakefulness = WAKEFULNESS_DOZING;
        mSandmanSummoned = true;
        setInteractiveStateLocked(false, reason);
        // Report the number of wake locks that will be cleared by going to sleep.
        int numWakeLocksCleared = 0;
        final int numWakeLocks = mWakeLocks.size();
        for (int i = 0; i < numWakeLocks; i++) {
            final WakeLock wakeLock = mWakeLocks.get(i);
            switch(wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) {
                case PowerManager.FULL_WAKE_LOCK:
                case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
                case PowerManager.SCREEN_DIM_WAKE_LOCK:
                    numWakeLocksCleared += 1;
                    break;
            }
        }
        EventLog.writeEvent(EventLogTags.POWER_SLEEP_REQUESTED, numWakeLocksCleared);
        // Skip dozing if requested.
        if ((flags & PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE) != 0) {
            reallyGoToSleepNoUpdateLocked(eventTime, uid);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG_SPEW) {
        Slog.d(TAG, "goToSleepNoUpdateLocked: eventTime=" + eventTime + ", reason=" + reason + ", flags=" + flags + ", uid=" + uid);
    }
    if (eventTime < mLastWakeTime || mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "goToSleep");
    try {
        switch(reason) {
            case PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN:
                Slog.i(TAG, "Going to sleep due to device administration policy " + "(uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_TIMEOUT:
                Slog.i(TAG, "Going to sleep due to screen timeout (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH:
                Slog.i(TAG, "Going to sleep due to lid switch (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON:
                Slog.i(TAG, "Going to sleep due to power button (uid " + uid + ")...");
                break;
            case PowerManager.GO_TO_SLEEP_REASON_HDMI:
                Slog.i(TAG, "Going to sleep due to HDMI standby (uid " + uid + ")...");
                break;
            default:
                Slog.i(TAG, "Going to sleep by application request (uid " + uid + ")...");
                reason = PowerManager.GO_TO_SLEEP_REASON_APPLICATION;
                break;
        }
        mLastSleepTime = eventTime;
        mSandmanSummoned = true;
        setWakefulnessLocked(WAKEFULNESS_DOZING, reason);
        // Report the number of wake locks that will be cleared by going to sleep.
        int numWakeLocksCleared = 0;
        final int numWakeLocks = mWakeLocks.size();
        for (int i = 0; i < numWakeLocks; i++) {
            final WakeLock wakeLock = mWakeLocks.get(i);
            switch(wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) {
                case PowerManager.FULL_WAKE_LOCK:
                case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
                case PowerManager.SCREEN_DIM_WAKE_LOCK:
                    numWakeLocksCleared += 1;
                    break;
            }
        }
        EventLog.writeEvent(EventLogTags.POWER_SLEEP_REQUESTED, numWakeLocksCleared);
        // Skip dozing if requested.
        if ((flags & PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE) != 0) {
            reallyGoToSleepNoUpdateLocked(eventTime, uid);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.StatusBarKeyguardViewManager.hide:COMMENT
Method Modifier: public      
Comment:/**
 * Hides the keyguard view
 */

Body of Frist Method:
{
    mShowing = false;
    long uptimeMillis = SystemClock.uptimeMillis();
    long delay = Math.max(0, startTime + HIDE_TIMING_CORRECTION_MS - uptimeMillis);
    if (mPhoneStatusBar.isInLaunchTransition()) {
        mPhoneStatusBar.fadeKeyguardAfterLaunchTransition(new Runnable() {

            @Override
            public void run() {
                mStatusBarWindowManager.setKeyguardShowing(false);
                mStatusBarWindowManager.setKeyguardFadingAway(true);
                mBouncer.hide(true);
                updateStates();
                mScrimController.animateKeyguardFadingOut(PhoneStatusBar.FADE_KEYGUARD_START_DELAY, PhoneStatusBar.FADE_KEYGUARD_DURATION, null);
            }
        }, new Runnable() {

            @Override
            public void run() {
                mPhoneStatusBar.hideKeyguard();
                mStatusBarWindowManager.setKeyguardFadingAway(false);
                mViewMediatorCallback.keyguardGone();
                executeAfterKeyguardGoneAction();
            }
        });
    } else {
        mPhoneStatusBar.setKeyguardFadingAway(delay, fadeoutDuration);
        boolean staying = mPhoneStatusBar.hideKeyguard();
        if (!staying) {
            mStatusBarWindowManager.setKeyguardFadingAway(true);
            mScrimController.animateKeyguardFadingOut(delay, fadeoutDuration, new Runnable() {

                @Override
                public void run() {
                    mStatusBarWindowManager.setKeyguardFadingAway(false);
                    mPhoneStatusBar.finishKeyguardFadingAway();
                }
            });
        } else {
            mScrimController.animateGoingToFullShade(delay, fadeoutDuration);
            mPhoneStatusBar.finishKeyguardFadingAway();
        }
        mStatusBarWindowManager.setKeyguardShowing(false);
        mBouncer.hide(true);
        mViewMediatorCallback.keyguardGone();
        executeAfterKeyguardGoneAction();
        updateStates();
    }
}
Body of Second Method:
{
    mShowing = false;
    long uptimeMillis = SystemClock.uptimeMillis();
    long delay = Math.max(0, startTime + HIDE_TIMING_CORRECTION_MS - uptimeMillis);
    if (mPhoneStatusBar.isInLaunchTransition()) {
        mPhoneStatusBar.fadeKeyguardAfterLaunchTransition(new Runnable() {

            @Override
            public void run() {
                mStatusBarWindowManager.setKeyguardShowing(false);
                mStatusBarWindowManager.setKeyguardFadingAway(true);
                mBouncer.hide(true);
                updateStates();
                mScrimController.animateKeyguardFadingOut(PhoneStatusBar.FADE_KEYGUARD_START_DELAY, PhoneStatusBar.FADE_KEYGUARD_DURATION, null);
            }
        }, new Runnable() {

            @Override
            public void run() {
                mPhoneStatusBar.hideKeyguard();
                mStatusBarWindowManager.setKeyguardFadingAway(false);
                mViewMediatorCallback.keyguardGone();
                executeAfterKeyguardGoneAction();
            }
        });
    } else {
        mPhoneStatusBar.setKeyguardFadingAway(delay, fadeoutDuration);
        boolean staying = mPhoneStatusBar.hideKeyguard();
        if (!staying) {
            mStatusBarWindowManager.setKeyguardFadingAway(true);
            mScrimController.animateKeyguardFadingOut(delay, fadeoutDuration, new Runnable() {

                @Override
                public void run() {
                    mStatusBarWindowManager.setKeyguardFadingAway(false);
                    mPhoneStatusBar.finishKeyguardFadingAway();
                    WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                }
            });
        } else {
            mScrimController.animateGoingToFullShade(delay, fadeoutDuration);
            mPhoneStatusBar.finishKeyguardFadingAway();
        }
        mStatusBarWindowManager.setKeyguardShowing(false);
        mBouncer.hide(true);
        mViewMediatorCallback.keyguardGone();
        executeAfterKeyguardGoneAction();
        updateStates();
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getSerifFontFamily:COMMENT
<android.webkit.WebSettings: String getSerifFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the serif font family name. The default is "serif".
 *
 * @return the serif font family name as a string
 * @see #setSerifFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.restoreState:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "restoreState");
    return mProvider.restoreState(inState);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restoreState");
    return mProvider.restoreState(inState);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.PanelView.onEmptySpaceClick:COMMENT
<com.android.systemui.statusbar.phone.PanelView: boolean onEmptySpaceClick(float)>
Method Modifier: protected   private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Gets called when the user performs a click anywhere in the empty area of the panel.
 *
 * @return whether the panel will be expanded after the action performed by this method
 */

Body of Frist Method:
{
    if (mHintAnimationRunning) {
        return true;
    }
    if (x < mEdgeTapAreaWidth && mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
        onEdgeClicked(false);
        return true;
    } else if (x > getWidth() - mEdgeTapAreaWidth && mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
        onEdgeClicked(true);
        return true;
    } else {
        return onMiddleClicked();
    }
}
Body of Second Method:
{
    if (mHintAnimationRunning) {
        return true;
    }
    if (x < mEdgeTapAreaWidth && mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
        onEdgeClicked(false);
        return true;
    } else if (x > getWidth() - mEdgeTapAreaWidth && mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
        onEdgeClicked(true);
        return true;
    } else {
        return onMiddleClicked();
    }
}
------------------------
Find a functionally equivalent code:android.net.StaticIpConfiguration.toLinkProperties:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a LinkProperties object expressing the data in this object. Note that the information
 * contained in the LinkProperties will not be a complete picture of the link's configuration,
 * because any configuration information that is obtained dynamically by the network (e.g.,
 * IPv6 configuration) will not be included.
 */

Body of Frist Method:
{
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(iface);
    if (ipAddress != null) {
        lp.addLinkAddress(ipAddress);
    }
    for (RouteInfo route : getRoutes(iface)) {
        lp.addRoute(route);
    }
    for (InetAddress dns : dnsServers) {
        lp.addDnsServer(dns);
    }
    return lp;
}
Body of Second Method:
{
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(iface);
    if (ipAddress != null) {
        lp.addLinkAddress(ipAddress);
    }
    for (RouteInfo route : getRoutes(iface)) {
        lp.addRoute(route);
    }
    for (InetAddress dns : dnsServers) {
        lp.addDnsServer(dns);
    }
    lp.setDomains(domains);
    return lp;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.inflate:COMMENT
Method Modifier: public      
Comment:/**
 * Inflates the layout.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #init(long)} was not called.
 */

Body of Frist Method:
{
    checkLock();
    try {
        SessionParams params = getParams();
        HardwareConfig hardwareConfig = params.getHardwareConfig();
        BridgeContext context = getContext();
        boolean isRtl = Bridge.isLocaleRtl(params.getLocale());
        int layoutDirection = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
        // the view group that receives the window background.
        ViewGroup backgroundView;
        if (mWindowIsFloating || params.isForceNoDecor()) {
            backgroundView = mViewRoot = mContentRoot = new FrameLayout(context);
            mViewRoot.setLayoutDirection(layoutDirection);
        } else {
            int simulatedPlatformVersion = params.getSimulatedPlatformVersion();
            if (hasSoftwareButtons() && mNavigationBarOrientation == LinearLayout.VERTICAL) {
                /*
                     * This is a special case where the navigation bar is on the right.
                       +-------------------------------------------------+---+
                       | Status bar (always)                             |   |
                       +-------------------------------------------------+   |
                       | (Layout with background drawable)               |   |
                       | +---------------------------------------------+ |   |
                       | | Title/Action bar (optional)                 | |   |
                       | +---------------------------------------------+ |   |
                       | | Content, vertical extending                 | |   |
                       | |                                             | |   |
                       | +---------------------------------------------+ |   |
                       +-------------------------------------------------+---+

                       So we create a horizontal layout, with the nav bar on the right,
                       and the left part is the normal layout below without the nav bar at
                       the bottom
                     */
                LinearLayout topLayout = new LinearLayout(context);
                topLayout.setLayoutDirection(layoutDirection);
                mViewRoot = topLayout;
                topLayout.setOrientation(LinearLayout.HORIZONTAL);
                if (Config.showOnScreenNavBar(simulatedPlatformVersion)) {
                    try {
                        NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                        topLayout.addView(navigationBar);
                    } catch (XmlPullParserException ignored) {
                    }
                }
            }
            /*
                 * we're creating the following layout
                 *
                   +-------------------------------------------------+
                   | Status bar (always)                             |
                   +-------------------------------------------------+
                   | (Layout with background drawable)               |
                   | +---------------------------------------------+ |
                   | | Title/Action bar (optional)                 | |
                   | +---------------------------------------------+ |
                   | | Content, vertical extending                 | |
                   | |                                             | |
                   | +---------------------------------------------+ |
                   +-------------------------------------------------+
                   | Navigation bar for soft buttons, maybe see above|
                   +-------------------------------------------------+

                 */
            LinearLayout topLayout = new LinearLayout(context);
            topLayout.setOrientation(LinearLayout.VERTICAL);
            topLayout.setLayoutDirection(layoutDirection);
            // if we don't already have a view root this is it
            if (mViewRoot == null) {
                mViewRoot = topLayout;
            } else {
                int topLayoutWidth = params.getHardwareConfig().getScreenWidth() - mNavigationBarSize;
                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(topLayoutWidth, LayoutParams.MATCH_PARENT);
                topLayout.setLayoutParams(layoutParams);
                // this top layout is the first layout in the horizontal layout. see above)
                if (isRtl && params.isRtlSupported()) {
                    // If RTL is enabled, layoutlib will mirror the layouts. So, add the
                    // topLayout to the right of Navigation Bar and layoutlib will draw it
                    // to the left.
                    mViewRoot.addView(topLayout);
                } else {
                    // Add the top layout to the left of the Navigation Bar.
                    mViewRoot.addView(topLayout, 0);
                }
            }
            if (mStatusBarSize > 0) {
                // system bar
                try {
                    StatusBar statusBar = createStatusBar(context, hardwareConfig.getDensity(), layoutDirection, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(statusBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            LinearLayout backgroundLayout = new LinearLayout(context);
            backgroundView = backgroundLayout;
            backgroundLayout.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
            layoutParams.weight = 1;
            backgroundLayout.setLayoutParams(layoutParams);
            topLayout.addView(backgroundLayout);
            // if the theme says no title/action bar, then the size will be 0
            if (mActionBarSize > 0) {
                ActionBarLayout actionBar = createActionBar(context, params);
                backgroundLayout.addView(actionBar);
                actionBar.createMenuPopup();
                mContentRoot = actionBar.getContentRoot();
            } else if (mTitleBarSize > 0) {
                try {
                    TitleBar titleBar = createTitleBar(context, params.getAppLabel(), simulatedPlatformVersion);
                    backgroundLayout.addView(titleBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            // content frame
            if (mContentRoot == null) {
                mContentRoot = new FrameLayout(context);
                layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
                layoutParams.weight = 1;
                mContentRoot.setLayoutParams(layoutParams);
                backgroundLayout.addView(mContentRoot);
            }
            if (Config.showOnScreenNavBar(simulatedPlatformVersion) && mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
                // system bar
                try {
                    NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(navigationBar);
                } catch (XmlPullParserException ignored) {
                }
            }
        }
        // Sets the project callback (custom view loader) to the fragment delegate so that
        // it can instantiate the custom Fragment.
        Fragment_Delegate.setProjectCallback(params.getProjectCallback());
        View view = mInflater.inflate(mBlockParser, mContentRoot);
        // done with the parser, pop it.
        context.popParser();
        Fragment_Delegate.setProjectCallback(null);
        // set the AttachInfo on the root view.
        AttachInfo_Accessor.setAttachInfo(mViewRoot);
        // post-inflate process. For now this supports TabHost/TabWidget
        postInflateProcess(view, params.getProjectCallback());
        // get the background drawable
        if (mWindowBackground != null) {
            Drawable d = ResourceHelper.getDrawable(mWindowBackground, context);
            backgroundView.setBackground(d);
        }
        return SUCCESS.createResult();
    } catch (PostInflateException e) {
        return ERROR_INFLATION.createResult(e.getMessage(), e);
    } catch (Throwable e) {
        // get the real cause of the exception.
        Throwable t = e;
        while (t.getCause() != null) {
            t = t.getCause();
        }
        return ERROR_INFLATION.createResult(t.getMessage(), t);
    }
}
Body of Second Method:
{
    checkLock();
    try {
        SessionParams params = getParams();
        HardwareConfig hardwareConfig = params.getHardwareConfig();
        BridgeContext context = getContext();
        boolean isRtl = Bridge.isLocaleRtl(params.getLocale());
        int layoutDirection = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
        // the view group that receives the window background.
        ViewGroup backgroundView;
        if (mWindowIsFloating || params.isForceNoDecor()) {
            backgroundView = mViewRoot = mContentRoot = new FrameLayout(context);
            mViewRoot.setLayoutDirection(layoutDirection);
        } else {
            int simulatedPlatformVersion = params.getSimulatedPlatformVersion();
            if (hasSoftwareButtons() && mNavigationBarOrientation == LinearLayout.VERTICAL) {
                /*
                     * This is a special case where the navigation bar is on the right.
                       +-------------------------------------------------+---+
                       | Status bar (always)                             |   |
                       +-------------------------------------------------+   |
                       | (Layout with background drawable)               |   |
                       | +---------------------------------------------+ |   |
                       | | Title/Action bar (optional)                 | |   |
                       | +---------------------------------------------+ |   |
                       | | Content, vertical extending                 | |   |
                       | |                                             | |   |
                       | +---------------------------------------------+ |   |
                       +-------------------------------------------------+---+

                       So we create a horizontal layout, with the nav bar on the right,
                       and the left part is the normal layout below without the nav bar at
                       the bottom
                     */
                LinearLayout topLayout = new LinearLayout(context);
                topLayout.setLayoutDirection(layoutDirection);
                mViewRoot = topLayout;
                topLayout.setOrientation(LinearLayout.HORIZONTAL);
                if (Config.showOnScreenNavBar(simulatedPlatformVersion)) {
                    try {
                        NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                        topLayout.addView(navigationBar);
                    } catch (XmlPullParserException ignored) {
                    }
                }
            }
            /*
                 * we're creating the following layout
                 *
                   +-------------------------------------------------+
                   | Status bar (always)                             |
                   +-------------------------------------------------+
                   | (Layout with background drawable)               |
                   | +---------------------------------------------+ |
                   | | Title/Action bar (optional)                 | |
                   | +---------------------------------------------+ |
                   | | Content, vertical extending                 | |
                   | |                                             | |
                   | +---------------------------------------------+ |
                   +-------------------------------------------------+
                   | Navigation bar for soft buttons, maybe see above|
                   +-------------------------------------------------+

                 */
            LinearLayout topLayout = new LinearLayout(context);
            topLayout.setOrientation(LinearLayout.VERTICAL);
            topLayout.setLayoutDirection(layoutDirection);
            // if we don't already have a view root this is it
            if (mViewRoot == null) {
                mViewRoot = topLayout;
            } else {
                int topLayoutWidth = params.getHardwareConfig().getScreenWidth() - mNavigationBarSize;
                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(topLayoutWidth, LayoutParams.MATCH_PARENT);
                topLayout.setLayoutParams(layoutParams);
                // this top layout is the first layout in the horizontal layout. see above)
                if (isRtl && params.isRtlSupported()) {
                    // If RTL is enabled, layoutlib will mirror the layouts. So, add the
                    // topLayout to the right of Navigation Bar and layoutlib will draw it
                    // to the left.
                    mViewRoot.addView(topLayout);
                } else {
                    // Add the top layout to the left of the Navigation Bar.
                    mViewRoot.addView(topLayout, 0);
                }
            }
            if (mStatusBarSize > 0) {
                // system bar
                try {
                    StatusBar statusBar = createStatusBar(context, hardwareConfig.getDensity(), layoutDirection, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(statusBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            LinearLayout backgroundLayout = new LinearLayout(context);
            backgroundView = backgroundLayout;
            backgroundLayout.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
            layoutParams.weight = 1;
            backgroundLayout.setLayoutParams(layoutParams);
            topLayout.addView(backgroundLayout);
            // if the theme says no title/action bar, then the size will be 0
            if (mActionBarSize > 0) {
                BridgeActionBar actionBar = createActionBar(context, params, backgroundLayout);
                actionBar.createMenuPopup();
                mContentRoot = actionBar.getContentRoot();
            } else if (mTitleBarSize > 0) {
                try {
                    TitleBar titleBar = createTitleBar(context, params.getAppLabel(), simulatedPlatformVersion);
                    backgroundLayout.addView(titleBar);
                } catch (XmlPullParserException ignored) {
                }
            }
            // content frame
            if (mContentRoot == null) {
                mContentRoot = new FrameLayout(context);
                layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
                layoutParams.weight = 1;
                mContentRoot.setLayoutParams(layoutParams);
                backgroundLayout.addView(mContentRoot);
            }
            if (Config.showOnScreenNavBar(simulatedPlatformVersion) && mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
                // system bar
                try {
                    NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                    topLayout.addView(navigationBar);
                } catch (XmlPullParserException ignored) {
                }
            }
        }
        // Sets the project callback (custom view loader) to the fragment delegate so that
        // it can instantiate the custom Fragment.
        Fragment_Delegate.setProjectCallback(params.getProjectCallback());
        String rootTag = params.getFlag(SessionParamsFlags.FLAG_KEY_ROOT_TAG);
        boolean isPreference = "PreferenceScreen".equals(rootTag);
        View view;
        if (isPreference) {
            view = Preference_Delegate.inflatePreference(getContext(), mBlockParser, mContentRoot);
        } else {
            view = mInflater.inflate(mBlockParser, mContentRoot);
        }
        // done with the parser, pop it.
        context.popParser();
        Fragment_Delegate.setProjectCallback(null);
        // set the AttachInfo on the root view.
        AttachInfo_Accessor.setAttachInfo(mViewRoot);
        // post-inflate process. For now this supports TabHost/TabWidget
        postInflateProcess(view, params.getProjectCallback(), isPreference ? view : null);
        // get the background drawable
        if (mWindowBackground != null) {
            Drawable d = ResourceHelper.getDrawable(mWindowBackground, context);
            backgroundView.setBackground(d);
        }
        return SUCCESS.createResult();
    } catch (PostInflateException e) {
        return ERROR_INFLATION.createResult(e.getMessage(), e);
    } catch (Throwable e) {
        // get the real cause of the exception.
        Throwable t = e;
        while (t.getCause() != null) {
            t = t.getCause();
        }
        return ERROR_INFLATION.createResult(t.getMessage(), t);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getMinimumFontSize:COMMENT
<android.webkit.WebSettings: int getMinimumFontSize()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the minimum font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.Activity.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically opens the options menu. If the options menu is already
 * open, this method does nothing.
 */

Body of Frist Method:
{
    if (mActionBar == null || !mActionBar.openOptionsMenu()) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) && (mActionBar == null || !mActionBar.openOptionsMenu())) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function checks if there is a plus sign (+) in the passed-in dialing number.
 * If there is, it processes the plus sign based on the default telephone
 * numbering plan of the system when the phone is activated and the current
 * telephone numbering plan of the system that the phone is camped on.
 * Currently, we only support the case that the default and current telephone
 * numbering plans are North American Numbering Plan(NANP).
 *
 * The passed-in dialStr should only contain the valid format as described below,
 * 1) the 1st character in the dialStr should be one of the really dialable
 * characters listed below
 * ISO-LATIN characters 0-9, *, # , +
 * 2) the dialStr should already strip out the separator characters,
 * every character in the dialStr should be one of the non separator characters
 * listed below
 * ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE
 *
 * Otherwise, this function returns the dial string passed in
 *
 * @param dialStr the original dial string
 * @return the converted dial string if the current/default countries belong to NANP,
 * and if there is the "+" in the original dial string. Otherwise, the original dial
 * string returns.
 *
 * This API is for CDMA only
 *
 * @hide TODO: pending API Council approval
 */

Body of Frist Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String currIso = SystemProperties.get(PROPERTY_OPERATOR_ISO_COUNTRY, "");
            String defaultIso = SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, "");
            if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, getFormatTypeFromCountryCode(currIso), getFormatTypeFromCountryCode(defaultIso));
            }
        }
    }
    return dialStr;
}
Body of Second Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String currIso = TelephonyManager.getDefault().getNetworkCountryIso();
            String defaultIso = TelephonyManager.getDefault().getSimCountryIso();
            if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, getFormatTypeFromCountryCode(currIso), getFormatTypeFromCountryCode(defaultIso));
            }
        }
    }
    return dialStr;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.RecentsView.focusNextTask:COMMENT
Method Modifier: public      
Comment:/**
 * Focuses the next task in the first stack view
 */

Body of Frist Method:
{
    // Get the first stack view
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.focusNextTask(forward);
            break;
        }
    }
}
Body of Second Method:
{
    // Get the first stack view
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        if (child != mSearchBar) {
            TaskStackView stackView = (TaskStackView) child;
            stackView.focusNextTask(forward, true);
            break;
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.display.OverlayDisplayAdapter.OverlayDisplayHandle.onWindowCreated:COMMENT
Method Modifier: public      
Comment:// Called on the UI thread.

Body of Frist Method:
{
    synchronized (getSyncRoot()) {
        IBinder displayToken = SurfaceControl.createDisplay(mName, mSecure);
        mDevice = new OverlayDisplayDevice(displayToken, mName, mWidth, mHeight, refreshRate, presentationDeadlineNanos, mDensityDpi, mSecure, state, surfaceTexture);
        sendDisplayDeviceEventLocked(mDevice, DISPLAY_DEVICE_EVENT_ADDED);
    }
}
Body of Second Method:
{
    synchronized (getSyncRoot()) {
        IBinder displayToken = SurfaceControl.createDisplay(mName, mSecure);
        mDevice = new OverlayDisplayDevice(displayToken, mName, mWidth, mHeight, refreshRate, presentationDeadlineNanos, mDensityDpi, mSecure, state, surfaceTexture, mNumber);
        sendDisplayDeviceEventLocked(mDevice, DISPLAY_DEVICE_EVENT_ADDED);
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.Builder.processSmallIconAsLarge:COMMENT
Method Modifier: private     
Comment:/**
 * Apply any necessary background to smallIcons being used in the largeIcon spot.
 */

Body of Frist Method:
{
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, largeIconId)) {
        applyLargeIconBackground(contentView);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, largeIconId)) {
        applyLargeIconBackground(contentView);
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.util.DynamicIdMap.getId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a dynamic integer for the given resource type/name, creating it if it doesn't
 * already exist.
 *
 * @param resource the type/name of the resource
 * @return an integer.
 */

Body of Frist Method:
{
    Integer value = mDynamicIds.get(resource);
    if (value == null) {
        value = Integer.valueOf(++mDynamicSeed);
        mDynamicIds.put(resource, value);
        mRevDynamicIds.put(value, resource);
    }
    return value;
}
Body of Second Method:
{
    Integer value = mDynamicIds.get(resource);
    if (value == null) {
        value = ++mDynamicSeed;
        mDynamicIds.put(resource, value);
        mRevDynamicIds.put(value, resource);
    }
    return value;
}
------------------------
Find a functionally equivalent code:android.app.Activity.closeContextMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically closes the most recently opened context menu, if showing.
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_CONTEXT_MENU)) {
        mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
    }
}
------------------------
Find a functionally equivalent code:android.renderscript.ScriptIntrinsicHistogram.forEach_Dot:COMMENT
Method Modifier: public      
Comment:/**
 * Process an input buffer and place the histogram into the
 * output allocation. The dot product of the input channel and
 * the coefficients from 'setDotCoefficients' are used to
 * calculate the output values.
 *
 * 1D and 2D input allocations are supported.
 *
 * @param ain The input image
 * @param opt LaunchOptions for clipping
 */

Body of Frist Method:
{
    if (mOut.getType().getElement().getVectorSize() != 1) {
        throw new RSIllegalArgumentException("Output vector size must be one.");
    }
    if (ain.getType().getElement().isCompatible(Element.U8(mRS)) && ain.getType().getElement().isCompatible(Element.U8_4(mRS))) {
        throw new RSIllegalArgumentException("Output type must be U32 or I32.");
    }
    forEach(1, ain, null, null, opt);
}
Body of Second Method:
{
    if (mOut.getType().getElement().getVectorSize() != 1) {
        throw new RSIllegalArgumentException("Output vector size must be one.");
    }
    if (!ain.getType().getElement().isCompatible(Element.U8(mRS)) && !ain.getType().getElement().isCompatible(Element.U8_2(mRS)) && !ain.getType().getElement().isCompatible(Element.U8_3(mRS)) && !ain.getType().getElement().isCompatible(Element.U8_4(mRS))) {
        throw new RSIllegalArgumentException("Input type must be U8, U8_1, U8_2 or U8_4.");
    }
    forEach(1, ain, null, null, opt);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getLayoutAlgorithm:COMMENT
<android.webkit.WebSettings: LayoutAlgorithm getLayoutAlgorithm()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the current layout algorithm.
 *
 * @return the layout algorithm in use, as a {@link LayoutAlgorithm} value
 * @see #setLayoutAlgorithm
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.ConnectivityManager.startUsingNetworkFeature:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */

Body of Frist Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        if (LEGACY_DBG) {
            Log.d(TAG, "Looking for legacyRequest for netCap with hash: " + netCap + " (" + netCap.hashCode() + ")");
            Log.d(TAG, "sLegacyRequests has:");
            for (NetworkCapabilities nc : sLegacyRequests.keySet()) {
                Log.d(TAG, "  " + nc + " (" + nc.hashCode() + ")");
            }
        }
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, " request Failed");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}
Body of Second Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, " request Failed");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.Builder.processSmallRightIcon:COMMENT
Method Modifier: private     
Comment:/**
 * Recolor small icons when used in the R.id.right_icon slot.
 */

Body of Frist Method:
{
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, smallIconDrawableId)) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, smallIconDrawableId)) {
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setCacheMode:COMMENT
<android.webkit.WebSettings: void setCacheMode(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Overrides the way the cache is used. The way the cache is used is based
 * on the navigation type. For a normal page load, the cache is checked
 * and content is re-validated as needed. When navigating back, content is
 * not revalidated, instead the content is just retrieved from the cache.
 * This method allows the client to override this behavior by specifying
 * one of {@link #LOAD_DEFAULT},
 * {@link #LOAD_CACHE_ELSE_NETWORK}, {@link #LOAD_NO_CACHE} or
 * {@link #LOAD_CACHE_ONLY}. The default value is {@link #LOAD_DEFAULT}.
 *
 * @param mode the mode to use
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setLayoutAlgorithm:COMMENT
<android.webkit.WebSettings: void setLayoutAlgorithm(LayoutAlgorithm)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the underlying layout algorithm. This will cause a relayout of the
 * WebView. The default is {@link LayoutAlgorithm#NARROW_COLUMNS}.
 *
 * @param l the layout algorithm to use, as a {@link LayoutAlgorithm} value
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.ProgressBar.applySecondaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mSecondaryProgressTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mSecondaryProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.app.SharedElementCallback.onCreateSnapshotView:COMMENT
Method Modifier: public      
Comment:/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */

Body of Frist Method:
{
    View view = null;
    if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
Body of Second Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        Bitmap bitmap = (Bitmap) bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (bitmap == null) {
            return null;
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
------------------------
Find a functionally equivalent code:com.android.server.media.MediaSessionService.SessionManagerImpl.dispatchMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Handles the dispatching of the media button events to one of the
 * registered listeners, or if there was none, broadcast an
 * ACTION_MEDIA_BUTTON intent to the rest of the system.
 *
 * @param keyEvent a non-null KeyEvent whose key code is one of the
 * supported media buttons
 * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held
 * while this key event is dispatched.
 */

Body of Frist Method:
{
    if (keyEvent == null || !KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        Log.w(TAG, "Attempted to dispatch null or non-media key event.");
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            MediaSessionRecord session = mPriorityStack.getDefaultMediaButtonSession(mCurrentUserId);
            if (isVoiceKey(keyEvent.getKeyCode())) {
                handleVoiceKeyEventLocked(keyEvent, needWakeLock, session);
            } else {
                dispatchMediaKeyEventLocked(keyEvent, needWakeLock, session);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
Body of Second Method:
{
    if (keyEvent == null || !KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        Log.w(TAG, "Attempted to dispatch null or non-media key event.");
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            // If we don't have a media button receiver to fall back on
            // include non-playing sessions for dispatching
            boolean useNotPlayingSessions = mUserRecords.get(ActivityManager.getCurrentUser()).mLastMediaButtonReceiver == null;
            MediaSessionRecord session = mPriorityStack.getDefaultMediaButtonSession(mCurrentUserId, useNotPlayingSessions);
            if (isVoiceKey(keyEvent.getKeyCode())) {
                handleVoiceKeyEventLocked(keyEvent, needWakeLock, session);
            } else {
                dispatchMediaKeyEventLocked(keyEvent, needWakeLock, session);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getBuiltInZoomControls:COMMENT
<android.webkit.WebSettings: boolean getBuiltInZoomControls()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the zoom mechanisms built into WebView are being used.
 *
 * @return true if the zoom mechanisms built into WebView are being used
 * @see #setBuiltInZoomControls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.restorePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Restores the display data that was saved in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}. Note that this will not work if
 * this WebView is hardware accelerated.
 *
 * @param b a Bundle containing the saved display data
 * @param src the file where the picture data was stored
 * @return true if the picture was successfully restored
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "restorePicture=" + src.getName());
    return mProvider.restorePicture(b, src);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restorePicture=" + src.getName());
    return mProvider.restorePicture(b, src);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setTextZoom:COMMENT
<android.webkit.WebSettings: void setTextZoom(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the text zoom of the page in percent. The default is 100.
 *
 * @param textZoom the text zoom in percent
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.stack.StackScrollAlgorithm.updateZValuesForState:COMMENT
Method Modifier: private     
Comment:/**
 * Calculate the Z positions for all children based on the number of items in both stacks and
 * save it in the resultState
 *
 * @param resultState The result state to update the zTranslation values
 * @param algorithmState The state in which the current pass of the algorithm is currently in
 */

Body of Frist Method:
{
    int childCount = algorithmState.visibleChildren.size();
    for (int i = 0; i < childCount; i++) {
        View child = algorithmState.visibleChildren.get(i);
        StackScrollState.ViewState childViewState = resultState.getViewStateForView(child);
        if (i < algorithmState.itemsInTopStack) {
            float stackIndex = algorithmState.itemsInTopStack - i;
            stackIndex = Math.min(stackIndex, MAX_ITEMS_IN_TOP_STACK + 2);
            if (i == 0 && algorithmState.itemsInTopStack < 2.0f) {
                // We only have the top item and an additional item in the top stack,
                // Interpolate the index from 0 to 2 while the second item is
                // translating in.
                stackIndex -= 1.0f;
                if (algorithmState.scrollY > mCollapsedSize) {
                    // Since there is a shadow treshhold, we cant just interpolate from 0 to
                    // 2 but we interpolate from 0.1f to 2.0f when scrolled in. The jump in
                    // height will not be noticable since we have padding in between.
                    stackIndex = 0.1f + stackIndex * 1.9f;
                }
            }
            childViewState.zTranslation = mZBasicHeight + stackIndex * mZDistanceBetweenElements;
        } else if (i > (childCount - 1 - algorithmState.itemsInBottomStack)) {
            float numItemsAbove = i - (childCount - 1 - algorithmState.itemsInBottomStack);
            float translationZ = mZBasicHeight - numItemsAbove * mZDistanceBetweenElements;
            childViewState.zTranslation = translationZ;
        } else {
            childViewState.zTranslation = mZBasicHeight;
        }
    }
}
Body of Second Method:
{
    int childCount = algorithmState.visibleChildren.size();
    for (int i = 0; i < childCount; i++) {
        View child = algorithmState.visibleChildren.get(i);
        StackScrollState.ViewState childViewState = resultState.getViewStateForView(child);
        if (i < algorithmState.itemsInTopStack) {
            float stackIndex = algorithmState.itemsInTopStack - i;
            // Ensure that the topmost item is a little bit higher than the rest when fully
            // scrolled, to avoid drawing errors when swiping it out
            float max = MAX_ITEMS_IN_TOP_STACK + (i == 0 ? 2.5f : 2);
            stackIndex = Math.min(stackIndex, max);
            if (i == 0 && algorithmState.itemsInTopStack < 2.0f) {
                // We only have the top item and an additional item in the top stack,
                // Interpolate the index from 0 to 2 while the second item is
                // translating in.
                stackIndex -= 1.0f;
                if (algorithmState.scrollY > mCollapsedSize) {
                    // Since there is a shadow treshhold, we cant just interpolate from 0 to
                    // 2 but we interpolate from 0.1f to 2.0f when scrolled in. The jump in
                    // height will not be noticable since we have padding in between.
                    stackIndex = 0.1f + stackIndex * 1.9f;
                }
            }
            childViewState.zTranslation = mZBasicHeight + stackIndex * mZDistanceBetweenElements;
        } else if (i > (childCount - 1 - algorithmState.itemsInBottomStack)) {
            float numItemsAbove = i - (childCount - 1 - algorithmState.itemsInBottomStack);
            float translationZ = mZBasicHeight - numItemsAbove * mZDistanceBetweenElements;
            childViewState.zTranslation = translationZ;
        } else {
            childViewState.zTranslation = mZBasicHeight;
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setMinimumFontSize:COMMENT
<android.webkit.WebSettings: void setMinimumFontSize(int)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the minimum font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.usb.UsbHostManager.beginUsbDeviceAdded:COMMENT
Method Modifier: private     
Comment:/* Called from JNI in monitorUsbHostBus() to report new USB devices
       Returns true if successful, in which case the JNI code will continue adding configurations,
       interfaces and endpoints, and finally call endUsbDeviceAdded after all descriptors
       have been processed
     */

Body of Frist Method:
{
    if (DEBUG_AUDIO) {
        Slog.d(TAG, "usb:UsbHostManager.beginUsbDeviceAdded(" + deviceName + ")");
        // Audio Class Codes:
        // Audio: 0x01
        // Audio Subclass Codes:
        // undefined: 0x00
        // audio control: 0x01
        // audio streaming: 0x02
        // midi streaming: 0x03
        // some useful debugging info
        Slog.d(TAG, "usb: nm:" + deviceName + " vnd:" + vendorID + " prd:" + productID + " cls:" + deviceClass + " sub:" + deviceSubclass + " proto:" + deviceProtocol);
    }
    if (isBlackListed(deviceName) || isBlackListed(deviceClass, deviceSubclass, deviceProtocol)) {
        return false;
    }
    synchronized (mLock) {
        if (mDevices.get(deviceName) != null) {
            Slog.w(TAG, "device already on mDevices list: " + deviceName);
            return false;
        }
        if (mNewDevice != null) {
            Slog.e(TAG, "mNewDevice is not null in endUsbDeviceAdded");
            return false;
        }
        mNewDevice = new UsbDevice(deviceName, vendorID, productID, deviceClass, deviceSubclass, deviceProtocol, manufacturerName, productName, serialNumber);
        mNewConfigurations = new ArrayList<UsbConfiguration>();
        mNewInterfaces = new ArrayList<UsbInterface>();
        mNewEndpoints = new ArrayList<UsbEndpoint>();
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG) {
        Slog.d(TAG, "usb:UsbHostManager.beginUsbDeviceAdded(" + deviceName + ")");
        // Audio Class Codes:
        // Audio: 0x01
        // Audio Subclass Codes:
        // undefined: 0x00
        // audio control: 0x01
        // audio streaming: 0x02
        // midi streaming: 0x03
        // some useful debugging info
        Slog.d(TAG, "usb: nm:" + deviceName + " vnd:" + vendorID + " prd:" + productID + " cls:" + deviceClass + " sub:" + deviceSubclass + " proto:" + deviceProtocol);
    }
    if (isBlackListed(deviceName) || isBlackListed(deviceClass, deviceSubclass, deviceProtocol)) {
        return false;
    }
    synchronized (mLock) {
        if (mDevices.get(deviceName) != null) {
            Slog.w(TAG, "device already on mDevices list: " + deviceName);
            return false;
        }
        if (mNewDevice != null) {
            Slog.e(TAG, "mNewDevice is not null in endUsbDeviceAdded");
            return false;
        }
        mNewDevice = new UsbDevice(deviceName, vendorID, productID, deviceClass, deviceSubclass, deviceProtocol, manufacturerName, productName, serialNumber);
        mNewConfigurations = new ArrayList<UsbConfiguration>();
        mNewInterfaces = new ArrayList<UsbInterface>();
        mNewEndpoints = new ArrayList<UsbEndpoint>();
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.findNext:COMMENT
Method Modifier: public      
Comment:/**
 * Highlights and scrolls to the next match found by
 * {@link #findAllAsync}, wrapping around page boundaries as necessary.
 * Notifies any registered {@link FindListener}. If {@link #findAllAsync(String)}
 * has not been called yet, or if {@link #clearMatches} has been called since the
 * last find operation, this function does nothing.
 *
 * @param forward the direction to search
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findNext");
    mProvider.findNext(forward);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findNext");
    mProvider.findNext(forward);
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupEndValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the end values for an animation.
 * The end values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
Body of Second Method:
{
    List<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewThumbnail.rebindToTask:COMMENT
Method Modifier: 
Comment:/**
 * Binds the thumbnail view to the task
 */

Body of Frist Method:
{
    if (t.thumbnail != null) {
        setImageBitmap(t.thumbnail);
    } else {
        setImageBitmap(null);
    }
}
Body of Second Method:
{
    if (t.thumbnail != null) {
        setThumbnail(t.thumbnail);
    } else {
        setThumbnail(null);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getLightTouchEnabled:COMMENT
<android.webkit.WebSettings: boolean getLightTouchEnabled()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether light touches are enabled.
 * @see #setLightTouchEnabled
 * @deprecated This setting is obsolete.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.Parcel.unmarshall:COMMENT
Method Modifier: public      final       
Comment:/**
 * Set the bytes in data to be the raw bytes of this Parcel.
 */

Body of Frist Method:
{
    nativeUnmarshall(mNativePtr, data, offest, length);
}
Body of Second Method:
{
    nativeUnmarshall(mNativePtr, data, offset, length);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.savePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Saves the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b a Bundle to store the display data
 * @param dest the file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return true if the picture was successfully saved
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "savePicture=" + dest.getName());
    return mProvider.savePicture(b, dest);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "savePicture=" + dest.getName());
    return mProvider.savePicture(b, dest);
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewTouchHandler.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Handles touch events once we have intercepted them
 */

Body of Frist Method:
{
    // Short circuit if we have no children
    boolean hasChildren = (mSv.getChildCount() > 0);
    if (!hasChildren) {
        return false;
    }
    // Pass through to swipe helper if we are swiping
    if (mInterceptedBySwipeHelper && mSwipeHelper.onTouchEvent(ev)) {
        return true;
    }
    // Update the velocity tracker
    initVelocityTrackerIfNotExists();
    int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                // Save the touch down info
                mInitialMotionX = mLastMotionX = (int) ev.getX();
                mInitialMotionY = mLastMotionY = (int) ev.getY();
                mInitialP = mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mActivePointerId = ev.getPointerId(0);
                mActiveTaskView = findViewAtPoint(mLastMotionX, mLastMotionY);
                // Stop the current scroll if it is still flinging
                mScroller.stopScroller();
                mScroller.stopBoundScrollAnimation();
                // Initialize the velocity tracker
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                // Disallow parents from intercepting touch events
                final ViewParent parent = mSv.getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mActivePointerId = ev.getPointerId(index);
                mLastMotionX = (int) ev.getX(index);
                mLastMotionY = (int) ev.getY(index);
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mActivePointerId == INACTIVE_POINTER_ID)
                    break;
                int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                int x = (int) ev.getX(activePointerIndex);
                int y = (int) ev.getY(activePointerIndex);
                int yTotal = Math.abs(y - mInitialMotionY);
                float curP = mSv.mLayoutAlgorithm.screenYToCurveProgress(y);
                float deltaP = mLastP - curP;
                if (!mIsScrolling) {
                    if (yTotal > mScrollTouchSlop) {
                        mIsScrolling = true;
                        // Initialize the velocity tracker
                        initOrResetVelocityTracker();
                        mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                        // Disallow parents from intercepting touch events
                        final ViewParent parent = mSv.getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(true);
                        }
                    }
                }
                if (mIsScrolling) {
                    float curStackScroll = mScroller.getStackScroll();
                    float overScrollAmount = mScroller.getScrollAmountOutOfBounds(curStackScroll + deltaP);
                    if (Float.compare(overScrollAmount, 0f) != 0) {
                        // Bound the overscroll to a fixed amount, and inversely scale the y-movement
                        // relative to how close we are to the max overscroll
                        float maxOverScroll = mConfig.taskStackOverscrollPct;
                        deltaP *= (1f - (Math.min(maxOverScroll, overScrollAmount) / maxOverScroll));
                    }
                    mScroller.setStackScroll(curStackScroll + deltaP);
                    if (mScroller.isScrollOutOfBounds()) {
                        mVelocityTracker.clear();
                    } else {
                        mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                    }
                }
                mLastMotionX = x;
                mLastMotionY = y;
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mTotalPMotion += Math.abs(deltaP);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int velocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (mIsScrolling && (Math.abs(velocity) > mMinimumVelocity)) {
                    int overscrollRange = (int) (Math.min(1f, Math.abs((float) velocity / mMaximumVelocity)) * Constants.Values.TaskStackView.TaskStackOverscrollRange);
                    // Fling scroll
                    mScroller.mScroller.fling(0, mScroller.progressToScrollRange(mScroller.getStackScroll()), 0, velocity, 0, 0, mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMinScrollP), mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMaxScrollP), 0, overscrollRange);
                    // Invalidate to kick off computeScroll
                    mSv.invalidate();
                } else if (mScroller.isScrollOutOfBounds()) {
                    // Animate the scroll back into bounds
                    mScroller.animateBoundScroll();
                }
                mActivePointerId = INACTIVE_POINTER_ID;
                mIsScrolling = false;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                int pointerIndex = ev.getActionIndex();
                int pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == mActivePointerId) {
                    // Select a new active pointer id and reset the motion state
                    final int newPointerIndex = (pointerIndex == 0) ? 1 : 0;
                    mActivePointerId = ev.getPointerId(newPointerIndex);
                    mLastMotionX = (int) ev.getX(newPointerIndex);
                    mLastMotionY = (int) ev.getY(newPointerIndex);
                    mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                    mVelocityTracker.clear();
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mScroller.isScrollOutOfBounds()) {
                    // Animate the scroll back into bounds
                    mScroller.animateBoundScroll();
                }
                mActivePointerId = INACTIVE_POINTER_ID;
                mIsScrolling = false;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
    }
    return true;
}
Body of Second Method:
{
    // Short circuit if we have no children
    boolean hasChildren = (mSv.getChildCount() > 0);
    if (!hasChildren) {
        return false;
    }
    // Pass through to swipe helper if we are swiping
    if (mInterceptedBySwipeHelper && mSwipeHelper.onTouchEvent(ev)) {
        return true;
    }
    // Update the velocity tracker
    initVelocityTrackerIfNotExists();
    int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                // Save the touch down info
                mInitialMotionX = mLastMotionX = (int) ev.getX();
                mInitialMotionY = mLastMotionY = (int) ev.getY();
                mInitialP = mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mActivePointerId = ev.getPointerId(0);
                mActiveTaskView = findViewAtPoint(mLastMotionX, mLastMotionY);
                // Stop the current scroll if it is still flinging
                mScroller.stopScroller();
                mScroller.stopBoundScrollAnimation();
                // Initialize the velocity tracker
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                // Disallow parents from intercepting touch events
                final ViewParent parent = mSv.getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mActivePointerId = ev.getPointerId(index);
                mLastMotionX = (int) ev.getX(index);
                mLastMotionY = (int) ev.getY(index);
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mActivePointerId == INACTIVE_POINTER_ID)
                    break;
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                int x = (int) ev.getX(activePointerIndex);
                int y = (int) ev.getY(activePointerIndex);
                int yTotal = Math.abs(y - mInitialMotionY);
                float curP = mSv.mLayoutAlgorithm.screenYToCurveProgress(y);
                float deltaP = mLastP - curP;
                if (!mIsScrolling) {
                    if (yTotal > mScrollTouchSlop) {
                        mIsScrolling = true;
                        // Disallow parents from intercepting touch events
                        final ViewParent parent = mSv.getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(true);
                        }
                    }
                }
                if (mIsScrolling) {
                    float curStackScroll = mScroller.getStackScroll();
                    float overScrollAmount = mScroller.getScrollAmountOutOfBounds(curStackScroll + deltaP);
                    if (Float.compare(overScrollAmount, 0f) != 0) {
                        // Bound the overscroll to a fixed amount, and inversely scale the y-movement
                        // relative to how close we are to the max overscroll
                        float maxOverScroll = mConfig.taskStackOverscrollPct;
                        deltaP *= (1f - (Math.min(maxOverScroll, overScrollAmount) / maxOverScroll));
                    }
                    mScroller.setStackScroll(curStackScroll + deltaP);
                }
                mLastMotionX = x;
                mLastMotionY = y;
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mTotalPMotion += Math.abs(deltaP);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mVelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int velocity = (int) mVelocityTracker.getYVelocity(mActivePointerId);
                if (mIsScrolling && (Math.abs(velocity) > mMinimumVelocity)) {
                    float overscrollRangePct = Math.abs((float) velocity / mMaximumVelocity);
                    int overscrollRange = (int) (Math.min(1f, overscrollRangePct) * (Constants.Values.TaskStackView.TaskStackMaxOverscrollRange - Constants.Values.TaskStackView.TaskStackMinOverscrollRange));
                    mScroller.mScroller.fling(0, mScroller.progressToScrollRange(mScroller.getStackScroll()), 0, velocity, 0, 0, mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMinScrollP), mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMaxScrollP), 0, Constants.Values.TaskStackView.TaskStackMinOverscrollRange + overscrollRange);
                    // Invalidate to kick off computeScroll
                    mSv.invalidate();
                } else if (mScroller.isScrollOutOfBounds()) {
                    // Animate the scroll back into bounds
                    mScroller.animateBoundScroll();
                }
                mActivePointerId = INACTIVE_POINTER_ID;
                mIsScrolling = false;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                int pointerIndex = ev.getActionIndex();
                int pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == mActivePointerId) {
                    // Select a new active pointer id and reset the motion state
                    final int newPointerIndex = (pointerIndex == 0) ? 1 : 0;
                    mActivePointerId = ev.getPointerId(newPointerIndex);
                    mLastMotionX = (int) ev.getX(newPointerIndex);
                    mLastMotionY = (int) ev.getY(newPointerIndex);
                    mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                    mVelocityTracker.clear();
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mScroller.isScrollOutOfBounds()) {
                    // Animate the scroll back into bounds
                    mScroller.animateBoundScroll();
                }
                mActivePointerId = INACTIVE_POINTER_ID;
                mIsScrolling = false;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.graphics.Bitmap.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Free the native object associated with this bitmap, and clear the
 * reference to the pixel data. This will not free the pixel data synchronously;
 * it simply allows it to be garbage collected if there are no other references.
 * The bitmap is marked as "dead", meaning it will throw an exception if
 * getPixels() or setPixels() is called, and will draw nothing. This operation
 * cannot be reversed, so it should only be called if you are sure there are no
 * further uses for the bitmap. This is an advanced call, and normally need
 * not be called, since the normal GC process will free up this memory when
 * there are no more references to this bitmap.
 */

Body of Frist Method:
{
    if (!mRecycled) {
        if (nativeRecycle(mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
Body of Second Method:
{
    if (!mRecycled && mFinalizer.mNativeBitmap != 0) {
        if (nativeRecycle(mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getJavaScriptCanOpenWindowsAutomatically:COMMENT
<android.webkit.WebSettings: boolean getJavaScriptCanOpenWindowsAutomatically()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether JavaScript can open windows automatically.
 *
 * @return true if JavaScript can open windows automatically during
 * window.open()
 * @see #setJavaScriptCanOpenWindowsAutomatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.stopListening:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */

Body of Frist Method:
{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
Body of Second Method:
{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.updatePowerStateLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the global power state based on dirty bits recorded in mDirty.
 *
 * This is the main function that performs power state transitions.
 * We centralize them here so that we can recompute the power state completely
 * each time something important changes, and ensure that we do it the same
 * way each time.  The point is to gather all of the transition logic here.
 */

Body of Frist Method:
{
    if (!mSystemReady || mDirty == 0) {
        return;
    }
    if (!Thread.holdsLock(mLock)) {
        Slog.wtf(TAG, "Power manager lock was not held when calling updatePowerStateLocked");
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "updatePowerState");
    try {
        // Phase 0: Basic state updates.
        updateIsPoweredLocked(mDirty);
        updateStayOnLocked(mDirty);
        // Phase 1: Update wakefulness.
        // Loop because the wake lock and user activity computations are influenced
        // by changes in wakefulness.
        final long now = SystemClock.uptimeMillis();
        int dirtyPhase2 = 0;
        for (; ; ) {
            int dirtyPhase1 = mDirty;
            dirtyPhase2 |= dirtyPhase1;
            mDirty = 0;
            updateWakeLockSummaryLocked(dirtyPhase1);
            updateUserActivitySummaryLocked(now, dirtyPhase1);
            if (!updateWakefulnessLocked(dirtyPhase1)) {
                break;
            }
        }
        // Phase 2: Update display power state.
        boolean displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);
        // Phase 3: Update dream state (depends on display ready signal).
        updateDreamLocked(dirtyPhase2, displayBecameReady);
        // Phase 4: Send notifications, if needed.
        if (mDisplayReady) {
            finishInteractiveStateChangeLocked();
        }
        // Phase 5: Update suspend blocker.
        // Because we might release the last suspend blocker here, we need to make sure
        // we finished everything else first!
        updateSuspendBlockerLocked();
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
}
Body of Second Method:
{
    if (!mSystemReady || mDirty == 0) {
        return;
    }
    if (!Thread.holdsLock(mLock)) {
        Slog.wtf(TAG, "Power manager lock was not held when calling updatePowerStateLocked");
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "updatePowerState");
    try {
        // Phase 0: Basic state updates.
        updateIsPoweredLocked(mDirty);
        updateStayOnLocked(mDirty);
        updateScreenBrightnessBoostLocked(mDirty);
        // Phase 1: Update wakefulness.
        // Loop because the wake lock and user activity computations are influenced
        // by changes in wakefulness.
        final long now = SystemClock.uptimeMillis();
        int dirtyPhase2 = 0;
        for (; ; ) {
            int dirtyPhase1 = mDirty;
            dirtyPhase2 |= dirtyPhase1;
            mDirty = 0;
            updateWakeLockSummaryLocked(dirtyPhase1);
            updateUserActivitySummaryLocked(now, dirtyPhase1);
            if (!updateWakefulnessLocked(dirtyPhase1)) {
                break;
            }
        }
        // Phase 2: Update display power state.
        boolean displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);
        // Phase 3: Update dream state (depends on display ready signal).
        updateDreamLocked(dirtyPhase2, displayBecameReady);
        // Phase 4: Send notifications, if needed.
        if (mDisplayReady) {
            finishWakefulnessChangeLocked();
        }
        // Phase 5: Update suspend blocker.
        // Because we might release the last suspend blocker here, we need to make sure
        // we finished everything else first!
        updateSuspendBlockerLocked();
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.ExploreByTouchHelper.intersectVisibleToUser:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Computes whether the specified {@link Rect} intersects with the visible
 * portion of its parent {@link View}. Modifies {@code localRect} to contain
 * only the visible portion.
 *
 * @param localRect A rectangle in local (parent) coordinates.
 * @return Whether the specified {@link Rect} is visible on the screen.
 */

Body of Frist Method:
{
    // Missing or empty bounds mean this view is not visible.
    if ((localRect == null) || localRect.isEmpty()) {
        return false;
    }
    // Attached to invisible window means this view is not visible.
    if (mView.getWindowVisibility() != View.VISIBLE) {
        return false;
    }
    // An invisible predecessor means that this view is not visible.
    ViewParent viewParent = mView.getParent();
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        if ((view.getAlpha() <= 0) || (view.getVisibility() != View.VISIBLE)) {
            return false;
        }
        viewParent = view.getParent();
    }
    // A null parent implies the view is not visible.
    if (viewParent == null) {
        return false;
    }
    // If no portion of the parent is visible, this view is not visible.
    if (!mView.getLocalVisibleRect(mTempVisibleRect)) {
        return false;
    }
    // Check if the view intersects the visible portion of the parent.
    return localRect.intersect(mTempVisibleRect);
}
Body of Second Method:
{
    // Missing or empty bounds mean this view is not visible.
    if ((localRect == null) || localRect.isEmpty()) {
        return false;
    }
    // Attached to invisible window means this view is not visible.
    if (mView.getWindowVisibility() != View.VISIBLE) {
        return false;
    }
    // An invisible predecessor means that this view is not visible.
    ViewParent viewParent = mView.getParent();
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        if ((view.getAlpha() <= 0) || (view.getVisibility() != View.VISIBLE)) {
            return false;
        }
        viewParent = view.getParent();
    }
    // A null parent implies the view is not visible.
    if (viewParent == null) {
        return false;
    }
    // If no portion of the parent is visible, this view is not visible.
    if (mTempVisibleRect == null) {
        mTempVisibleRect = new Rect();
    }
    final Rect tempVisibleRect = mTempVisibleRect;
    if (!mView.getLocalVisibleRect(tempVisibleRect)) {
        return false;
    }
    // Check if the view intersects the visible portion of the parent.
    return localRect.intersect(tempVisibleRect);
}
------------------------
Find a functionally equivalent code:android.media.MediaFocusControl.dumpFocusStack:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the audio focus stack
 */

Body of Frist Method:
{
    pw.println("\nAudio Focus stack entries (last is top of stack):");
    synchronized (mAudioFocusLock) {
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw);
        }
    }
}
Body of Second Method:
{
    pw.println("\nAudio Focus stack entries (last is top of stack):");
    synchronized (mAudioFocusLock) {
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw);
        }
    }
    pw.println("\n Notify on duck: " + mNotifyFocusOwnerOnDuck + "\n");
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.removeServiceStateCallback:COMMENT
Method Modifier: 
Comment:/*package*/

Body of Frist Method:
{
    synchronized (mManagerCallback) {
        mProxyServiceStateCallbacks.remove(cb);
    }
}
Body of Second Method:
{
    synchronized (mProxyServiceStateCallbacks) {
        mProxyServiceStateCallbacks.remove(cb);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.onPause:COMMENT
Method Modifier: public      
Comment:/**
 * Pauses any extra processing associated with this WebView and its
 * associated DOM, plugins, JavaScript etc. For example, if this WebView is
 * taken offscreen, this could be called to reduce unnecessary CPU or
 * network traffic. When this WebView is again "active", call onResume().
 * Note that this differs from pauseTimers(), which affects all WebViews.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "onPause");
    mProvider.onPause();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onPause");
    mProvider.onPause();
}
------------------------
Find a functionally equivalent code:com.android.server.connectivity.Vpn.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Prepare for a VPN application. This method is designed to solve
 * race conditions. It first compares the current prepared package
 * with {@code oldPackage}. If they are the same, the prepared
 * package is revoked and replaced with {@code newPackage}. If
 * {@code oldPackage} is {@code null}, the comparison is omitted.
 * If {@code newPackage} is the same package or {@code null}, the
 * revocation is omitted. This method returns {@code true} if the
 * operation is succeeded.
 *
 * Legacy VPN is handled specially since it is not a real package.
 * It uses {@link VpnConfig#LEGACY_VPN} as its package name, and
 * it can be revoked by itself.
 *
 * @param oldPackage The package name of the old VPN application.
 * @param newPackage The package name of the new VPN application.
 * @return true if the operation is succeeded.
 */

Body of Frist Method:
{
    // Return false if the package does not match.
    if (oldPackage != null && !oldPackage.equals(mPackage)) {
        // to force user authorization. Otherwise, revoke the VPN anyway.
        if (!oldPackage.equals(VpnConfig.LEGACY_VPN) && isVpnUserPreConsented(oldPackage)) {
            long token = Binder.clearCallingIdentity();
            try {
                // This looks bizarre, but it is what ConfirmDialog in VpnDialogs is doing when
                // the user clicks through to allow the VPN to consent. So we are emulating the
                // action of the dialog without actually showing it.
                prepare(null, oldPackage);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
            return true;
        }
        return false;
    }
    // Return true if we do not need to revoke.
    if (newPackage == null || (newPackage.equals(mPackage) && !newPackage.equals(VpnConfig.LEGACY_VPN))) {
        return true;
    }
    // Check if the caller is authorized.
    enforceControlPermission();
    // Reset the interface.
    if (mInterface != null) {
        mStatusIntent = null;
        agentDisconnect();
        jniReset(mInterface);
        mInterface = null;
        mVpnUsers = null;
    }
    // Revoke the connection or stop LegacyVpnRunner.
    if (mConnection != null) {
        try {
            mConnection.mService.transact(IBinder.LAST_CALL_TRANSACTION, Parcel.obtain(), null, IBinder.FLAG_ONEWAY);
        } catch (Exception e) {
        // ignore
        }
        mContext.unbindService(mConnection);
        mConnection = null;
    } else if (mLegacyVpnRunner != null) {
        mLegacyVpnRunner.exit();
        mLegacyVpnRunner = null;
    }
    long token = Binder.clearCallingIdentity();
    try {
        mNetd.denyProtect(mOwnerUID);
    } catch (Exception e) {
        Log.wtf(TAG, "Failed to disallow UID " + mOwnerUID + " to call protect() " + e);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    Log.i(TAG, "Switched from " + mPackage + " to " + newPackage);
    mPackage = newPackage;
    mOwnerUID = getAppUid(newPackage, mUserHandle);
    token = Binder.clearCallingIdentity();
    try {
        mNetd.allowProtect(mOwnerUID);
    } catch (Exception e) {
        Log.wtf(TAG, "Failed to allow UID " + mOwnerUID + " to call protect() " + e);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mConfig = null;
    updateState(DetailedState.IDLE, "prepare");
    return true;
}
Body of Second Method:
{
    if (oldPackage != null && getAppUid(oldPackage, mUserHandle) != mOwnerUID) {
        // has already consented to that VPN package.
        if (!oldPackage.equals(VpnConfig.LEGACY_VPN) && isVpnUserPreConsented(oldPackage)) {
            prepareInternal(oldPackage);
            return true;
        }
        return false;
    }
    // Return true if we do not need to revoke.
    if (newPackage == null || (!newPackage.equals(VpnConfig.LEGACY_VPN) && getAppUid(newPackage, mUserHandle) == mOwnerUID)) {
        return true;
    }
    // Check if the caller is authorized.
    enforceControlPermission();
    prepareInternal(newPackage);
    return true;
}
------------------------
Find a functionally equivalent code:android.media.AudioService.handleConfigurationChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Handles device configuration changes that may map to a change in the orientation
 * or orientation.
 * Monitoring orientation and rotation is optional, and is defined by the definition and value
 * of the "ro.audio.monitorOrientation" and "ro.audio.monitorRotation" system properties.
 */

Body of Frist Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    if (!isPlatformTelevision()) {
                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                        if (cameraSoundForced) {
                            s.setAllIndexesToMax();
                            mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        } else {
                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        }
                        // take new state into account for streams muted by ringer mode
                        setRingerModeInt(getRingerMode(), false);
                    }
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
Body of Second Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            boolean cameraSoundForcedChanged = false;
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    cameraSoundForcedChanged = true;
                }
            }
            if (cameraSoundForcedChanged) {
                if (!isPlatformTelevision()) {
                    VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                    if (cameraSoundForced) {
                        s.setAllIndexesToMax();
                        mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    } else {
                        s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                        mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    }
                    // take new state into account for streams muted by ringer mode
                    setRingerModeInt(getRingerModeInternal(), false);
                }
                sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.onResume:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the Keyguard is actively shown on the screen.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "screen on, instance " + Integer.toHexString(hashCode()));
    mSecurityContainer.showPrimarySecurityScreen(false);
    mSecurityContainer.onResume(KeyguardSecurityView.SCREEN_ON);
    requestFocus();
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "screen on, instance " + Integer.toHexString(hashCode()));
    mSecurityContainer.onResume(KeyguardSecurityView.SCREEN_ON);
    requestFocus();
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
------------------------
Find a functionally equivalent code:android.content.pm.RegisteredServicesCache.getAllServices:COMMENT
Method Modifier: public      
Comment:/**
 * @return a collection of {@link RegisteredServicesCache.ServiceInfo} objects for all
 * registered authenticators.
 */

Body of Frist Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(userId);
        }
        return Collections.unmodifiableCollection(new ArrayList<ServiceInfo<V>>(user.services.values()));
    }
}
Body of Second Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(null, userId);
        }
        return Collections.unmodifiableCollection(new ArrayList<ServiceInfo<V>>(user.services.values()));
    }
}
------------------------
Find a functionally equivalent code:android.net.NetworkTemplate.matches:COMMENT
Method Modifier: public      
Comment:/**
 * Test if given {@link NetworkIdentity} matches this template.
 */

Body of Frist Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
Body of Second Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.isStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * get stream mute state.
 */

Body of Frist Method:
{
    return mStreamStates[streamType].isMuted();
}
Body of Second Method:
{
    if (streamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        streamType = getActiveStreamType(streamType);
    }
    synchronized (VolumeStreamState.class) {
        return mStreamStates[streamType].isMuted_syncVSS();
    }
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.removeSessionCookie:COMMENT
<android.webkit.CookieManager: void removeSessionCookie()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all session cookies, which are cookies without an expiration
 * date.
 * @deprecated use {@link #removeSessionCookies(ValueCallback)} instead.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setPluginsEnabled:COMMENT
<android.webkit.WebSettings: void setPluginsEnabled(boolean)>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView should enable plugins. The default is false.
 *
 * @param flag true if plugins should be enabled
 * @deprecated This method has been deprecated in favor of
 * {@link #setPluginState}
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.CookieManager.setCookie:COMMENT
<android.webkit.CookieManager: void setCookie(String,String,ValueCallback<Boolean>)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets a cookie for the given URL. Any existing cookie with the same host,
 * path and name will be replaced with the new cookie. The cookie being set
 * will be ignored if it is expired.
 * <p>
 * This method is asynchronous.
 * If a {@link ValueCallback} is provided,
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()} will be called on the current
 * thread's {@link android.os.Looper} once the operation is complete.
 * The value provided to the callback indicates whether the cookie was set successfully.
 * You can pass {@code null} as the callback if you don't need to know when the operation
 * completes or whether it succeeded, and in this case it is safe to call the method from a
 * thread without a Looper.
 *
 * @param url the URL for which the cookie is to be set
 * @param value the cookie as a string, using the format of the 'Set-Cookie'
 * HTTP response header
 * @param callback a callback to be executed when the cookie has been set
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getPluginsEnabled:COMMENT
<android.webkit.WebSettings: boolean getPluginsEnabled()>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether plugins are enabled.
 *
 * @return true if plugins are enabled
 * @see #setPluginsEnabled
 * @deprecated This method has been replaced by {@link #getPluginState}
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAcceptThirdPartyCookies:COMMENT
<android.webkit.WebSettings: void setAcceptThirdPartyCookies(boolean)>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets policy for third party cookies.
 * Developers should access this via {@link CookieManager#setShouldAcceptThirdPartyCookies}.
 * @hide Internal API.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getCursiveFontFamily:COMMENT
<android.webkit.WebSettings: String getCursiveFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the cursive font family name.
 *
 * @return the cursive font family name as a string
 * @see #setCursiveFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetterOrGetter:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the setter or getter requested. This utility function checks whether the
 * requested method exists in the propertyMapMap cache. If not, it calls another
 * utility function to request the Method from the targetClass directly.
 * @param targetClass The Class on which the requested method should exist.
 * @param propertyMapMap The cache of setters/getters derived so far.
 * @param prefix "set" or "get", for the setter or getter.
 * @param valueType The type of parameter passed into the method (null for getter).
 * @return Method the method associated with mPropertyName.
 */

Body of Frist Method:
{
    Method setterOrGetter = null;
    try {
        // Have to lock property map prior to reading it, to guard against
        // another thread putting something in there after we've checked it
        // but before we've added an entry to it
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
        if (propertyMap != null) {
            setterOrGetter = propertyMap.get(mPropertyName);
        }
        if (setterOrGetter == null) {
            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Method>();
                propertyMapMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, setterOrGetter);
        }
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    return setterOrGetter;
}
Body of Second Method:
{
    Method setterOrGetter = null;
    synchronized (propertyMapMap) {
        // Have to lock property map prior to reading it, to guard against
        // another thread putting something in there after we've checked it
        // but before we've added an entry to it
        HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                setterOrGetter = propertyMap.get(mPropertyName);
            }
        }
        if (!wasInMap) {
            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Method>();
                propertyMapMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, setterOrGetter);
        }
    }
    return setterOrGetter;
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowState.isVisibleNow:COMMENT
Method Modifier: 
Comment:/**
 * The same as isVisible(), but follows the current hidden state of
 * the associated app token, not the pending requested hidden state.
 */

Body of Frist Method:
{
    return mHasSurface && mPolicyVisibility && !mAttachedHidden && !mRootToken.hidden && !mExiting && !mDestroying;
}
Body of Second Method:
{
    return mHasSurface && mPolicyVisibility && !mAttachedHidden && (!mRootToken.hidden || mAttrs.type == TYPE_APPLICATION_STARTING) && !mExiting && !mDestroying;
}
------------------------
Find a functionally equivalent code:com.android.server.am.ActivityStack.completeResumeLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Once we know that we have asked an application to put an activity in
 * the resumed state (either by launching it or explicitly telling it),
 * this function updates the rest of our state to match that fact.
 */

Body of Frist Method:
{
    next.idle = false;
    next.results = null;
    next.newIntents = null;
    if (next.isHomeActivity() && next.isNotResolverActivity()) {
        ProcessRecord app = next.task.mActivities.get(0).app;
        if (app != null && app != mService.mHomeProcess) {
            mService.mHomeProcess = app;
        }
    }
    if (next.nowVisible) {
        // We won't get a call to reportActivityVisibleLocked() so dismiss lockscreen now.
        mStackSupervisor.notifyActivityDrawnForKeyguard();
    }
    // schedule an idle timeout in case the app doesn't do it for us.
    mStackSupervisor.scheduleIdleTimeoutLocked(next);
    mStackSupervisor.reportResumedActivityLocked(next);
    next.resumeKeyDispatchingLocked();
    mNoAnimActivities.clear();
    // not after the onResume. But for subsequent starts, onResume is fine.
    if (next.app != null) {
        next.cpuTimeAtResume = mService.mProcessCpuTracker.getCpuTimeForPid(next.app.pid);
    } else {
        // Couldn't get the cpu time of process
        next.cpuTimeAtResume = 0;
    }
    // updated, so invalidate the last screenshot to ensure we take a fresh one when requested
    if (next == mLastScreenshotActivity) {
        invalidateLastScreenshot();
    }
    next.returningOptions = null;
    if (mActivityContainer.mActivityDisplay.mVisibleBehindActivity == next) {
        // When resuming an activity, require it to call requestVisibleBehind() again.
        mActivityContainer.mActivityDisplay.setVisibleBehindActivity(null);
    }
}
Body of Second Method:
{
    next.idle = false;
    next.results = null;
    next.newIntents = null;
    if (next.isHomeActivity() && next.isNotResolverActivity()) {
        ProcessRecord app = next.task.mActivities.get(0).app;
        if (app != null && app != mService.mHomeProcess) {
            mService.mHomeProcess = app;
        }
    }
    if (next.nowVisible) {
        // We won't get a call to reportActivityVisibleLocked() so dismiss lockscreen now.
        mStackSupervisor.notifyActivityDrawnForKeyguard();
    }
    // schedule an idle timeout in case the app doesn't do it for us.
    mStackSupervisor.scheduleIdleTimeoutLocked(next);
    mStackSupervisor.reportResumedActivityLocked(next);
    next.resumeKeyDispatchingLocked();
    mNoAnimActivities.clear();
    // not after the onResume. But for subsequent starts, onResume is fine.
    if (next.app != null) {
        next.cpuTimeAtResume = mService.mProcessCpuTracker.getCpuTimeForPid(next.app.pid);
    } else {
        // Couldn't get the cpu time of process
        next.cpuTimeAtResume = 0;
    }
    next.returningOptions = null;
    if (mActivityContainer.mActivityDisplay.mVisibleBehindActivity == next) {
        // When resuming an activity, require it to call requestVisibleBehind() again.
        mActivityContainer.mActivityDisplay.setVisibleBehindActivity(null);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.clearFormData:COMMENT
<android.webkit.WebViewDatabase: void clearFormData()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clears any saved data for web forms.
 *
 * @see #hasFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.app.ResolverActivity.getReplacementIntent:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Replace me in subclasses!
 */

Body of Frist Method:
{
    return defIntent;
}
Body of Second Method:
{
    return defIntent;
}
------------------------
Find a functionally equivalent code:android.widget.DayPickerView.setUpListView:COMMENT
<android.widget.DayPickerView: void setUpListView()>
Method Modifier: protected   private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/*
     * Sets all the required fields for the list view. Override this method to
     * set a different list view behavior.
     */

Body of Frist Method:
{
    // Transparent background on scroll
    setCacheColorHint(0);
    // No dividers
    setDivider(null);
    // Items are clickable
    setItemsCanFocus(true);
    // The thumb gets in the way, so disable it
    setFastScrollEnabled(false);
    setVerticalScrollBarEnabled(false);
    setOnScrollListener(this);
    setFadingEdgeLength(0);
    // Make the scrolling behavior nicer
    setFriction(ViewConfiguration.getScrollFriction() * mFriction);
}
Body of Second Method:
{
    // Transparent background on scroll
    setCacheColorHint(0);
    // No dividers
    setDivider(null);
    // Items are clickable
    setItemsCanFocus(true);
    // The thumb gets in the way, so disable it
    setFastScrollEnabled(false);
    setVerticalScrollBarEnabled(false);
    setOnScrollListener(this);
    setFadingEdgeLength(0);
    // Make the scrolling behavior nicer
    setFriction(ViewConfiguration.getScrollFriction());
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAppCacheMaxSize:COMMENT
<android.webkit.WebSettings: void setAppCacheMaxSize(long)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the maximum size for the Application Cache content. The passed size
 * will be rounded to the nearest value that the database can support, so
 * this should be viewed as a guide, not a hard limit. Setting the
 * size to a value less than current database size does not cause the
 * database to be trimmed. The default size is {@link Long#MAX_VALUE}.
 * It is recommended to leave the maximum size set to the default value.
 *
 * @param appCacheMaxSize the maximum size in bytes
 * @deprecated In future quota will be managed automatically.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAllowContentAccess:COMMENT
<android.webkit.WebSettings: void setAllowContentAccess(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Enables or disables content URL access within WebView.  Content URL
 * access allows WebView to load content from a content provider installed
 * in the system. The default is enabled.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.startQuery:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Factory method to start query with a Uri query spec
 */

Body of Frist Method:
{
    CallerInfoAsyncQuery c = new CallerInfoAsyncQuery();
    c.allocate(context, contactRef);
    if (DBG)
        Rlog.d(LOG_TAG, "starting query for URI: " + contactRef + " handler: " + c.toString());
    // create cookieWrapper, start query
    CookieWrapper cw = new CookieWrapper();
    cw.listener = listener;
    cw.cookie = cookie;
    cw.event = EVENT_NEW_QUERY;
    c.mHandler.startQuery(token, cw, contactRef, null, null, null, null);
    return c;
}
Body of Second Method:
{
    CallerInfoAsyncQuery c = new CallerInfoAsyncQuery();
    c.allocate(context, contactRef);
    if (DBG)
        Rlog.d(LOG_TAG, "starting query for URI: " + contactRef + " handler: " + c.toString());
    // create cookieWrapper, start query
    CookieWrapper cw = new CookieWrapper();
    cw.listener = listener;
    cw.cookie = cookie;
    cw.event = EVENT_NEW_QUERY;
    c.mHandler.startQuery(token, cw, contactRef, null, null, null, null);
    return c;
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */

Body of Frist Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
Body of Second Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
------------------------
Find a functionally equivalent code:android.app.Activity.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Declare that the options menu has changed, so should be recreated.
 * The {@link #onCreateOptionsMenu(Menu)} method will be called the next
 * time it needs to be displayed.
 */

Body of Frist Method:
{
    if (mActionBar == null || !mActionBar.invalidateOptionsMenu()) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) && (mActionBar == null || !mActionBar.invalidateOptionsMenu())) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.model.TaskStack.setTasks:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a few tasks in one go
 */

Body of Frist Method:
{
    ArrayList<Task> taskList = mTaskList.getTasks();
    int taskCount = taskList.size();
    for (int i = 0; i < taskCount; i++) {
        Task t = taskList.get(i);
        // Remove the task from the list
        mTaskList.remove(t);
        // Remove it from the group as well, and if it is empty, remove the group
        TaskGrouping group = t.group;
        group.removeTask(t);
        if (group.getTaskCount() == 0) {
            removeGroup(group);
        }
        if (mCb != null) {
            // Notify that a task has been removed
            mCb.onStackTaskRemoved(this, t, null);
        }
    }
    mTaskList.set(tasks);
    for (Task t : tasks) {
        if (mCb != null) {
            mCb.onStackTaskAdded(this, t);
        }
    }
}
Body of Second Method:
{
    ArrayList<Task> taskList = mTaskList.getTasks();
    int taskCount = taskList.size();
    for (int i = 0; i < taskCount; i++) {
        Task t = taskList.get(i);
        // Remove the task from the list
        mTaskList.remove(t);
        // Remove it from the group as well, and if it is empty, remove the group
        TaskGrouping group = t.group;
        group.removeTask(t);
        if (group.getTaskCount() == 0) {
            removeGroup(group);
        }
        // Update the lock-to-app state
        t.lockToThisTask = false;
        if (mCb != null) {
            // Notify that a task has been removed
            mCb.onStackTaskRemoved(this, t, null);
        }
    }
    mTaskList.set(tasks);
    for (Task t : tasks) {
        if (mCb != null) {
            mCb.onStackTaskAdded(this, t);
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSupportMultipleWindows:COMMENT
<android.webkit.WebSettings: void setSupportMultipleWindows(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView whether supports multiple windows. If set to
 * true, {@link WebChromeClient#onCreateWindow} must be implemented by the
 * host application. The default is false.
 *
 * @param support whether to suport multiple windows
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.SearchView.rewriteQueryFromSuggestion:COMMENT
Method Modifier: private     
Comment:/**
 * Query rewriting.
 */

Body of Frist Method:
{
    CharSequence oldQuery = mQueryTextView.getText();
    Cursor c = mSuggestionsAdapter.getCursor();
    if (c == null) {
        return;
    }
    if (c.moveToPosition(position)) {
        // Get the new query from the suggestion.
        CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
        if (newQuery != null) {
            // The suggestion rewrites the query.
            // Update the text field, without getting new suggestions.
            setQuery(newQuery);
        } else {
            // The suggestion does not rewrite the query, restore the user's query.
            setQuery(oldQuery);
        }
    } else {
        // We got a bad position, restore the user's query.
        setQuery(oldQuery);
    }
}
Body of Second Method:
{
    CharSequence oldQuery = mSearchSrcTextView.getText();
    Cursor c = mSuggestionsAdapter.getCursor();
    if (c == null) {
        return;
    }
    if (c.moveToPosition(position)) {
        // Get the new query from the suggestion.
        CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
        if (newQuery != null) {
            // The suggestion rewrites the query.
            // Update the text field, without getting new suggestions.
            setQuery(newQuery);
        } else {
            // The suggestion does not rewrite the query, restore the user's query.
            setQuery(oldQuery);
        }
    } else {
        // We got a bad position, restore the user's query.
        setQuery(oldQuery);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.onFirstLayout:COMMENT
Method Modifier: 
Comment:/**
 * Handler for the first layout.
 */

Body of Frist Method:
{
    int offscreenY = mLayoutAlgorithm.mViewRect.bottom - (mLayoutAlgorithm.mTaskRect.top - mLayoutAlgorithm.mViewRect.top);
    // Find the launch target task
    Task launchTargetTask = null;
    int childCount = getChildCount();
    for (int i = childCount - 1; i >= 0; i--) {
        TaskView tv = (TaskView) getChildAt(i);
        Task task = tv.getTask();
        if (task.isLaunchTarget) {
            launchTargetTask = task;
            break;
        }
    }
    // Prepare the first view for its enter animation
    for (int i = childCount - 1; i >= 0; i--) {
        TaskView tv = (TaskView) getChildAt(i);
        Task task = tv.getTask();
        boolean occludesLaunchTarget = (launchTargetTask != null) && launchTargetTask.group.isTaskAboveTask(task, launchTargetTask);
        tv.prepareEnterRecentsAnimation(task.isLaunchTarget, occludesLaunchTarget, offscreenY);
    }
    // enter animation now
    if (mStartEnterAnimationRequestedAfterLayout) {
        startEnterRecentsAnimation(mStartEnterAnimationContext);
        mStartEnterAnimationRequestedAfterLayout = false;
        mStartEnterAnimationContext = null;
    }
    // When Alt-Tabbing, we scroll to and focus the previous task
    if (mConfig.launchedWithAltTab) {
        if (mConfig.launchedFromHome) {
            focusTask(Math.max(0, mStack.getTaskCount() - 1), false);
        } else {
            focusTask(Math.max(0, mStack.getTaskCount() - 2), false);
        }
    }
}
Body of Second Method:
{
    int offscreenY = mLayoutAlgorithm.mViewRect.bottom - (mLayoutAlgorithm.mTaskRect.top - mLayoutAlgorithm.mViewRect.top);
    // Find the launch target task
    Task launchTargetTask = null;
    int childCount = getChildCount();
    for (int i = childCount - 1; i >= 0; i--) {
        TaskView tv = (TaskView) getChildAt(i);
        Task task = tv.getTask();
        if (task.isLaunchTarget) {
            launchTargetTask = task;
            break;
        }
    }
    // Prepare the first view for its enter animation
    for (int i = childCount - 1; i >= 0; i--) {
        TaskView tv = (TaskView) getChildAt(i);
        Task task = tv.getTask();
        boolean occludesLaunchTarget = (launchTargetTask != null) && launchTargetTask.group.isTaskAboveTask(task, launchTargetTask);
        tv.prepareEnterRecentsAnimation(task.isLaunchTarget, occludesLaunchTarget, offscreenY);
    }
    // enter animation now
    if (mStartEnterAnimationRequestedAfterLayout) {
        startEnterRecentsAnimation(mStartEnterAnimationContext);
        mStartEnterAnimationRequestedAfterLayout = false;
        mStartEnterAnimationContext = null;
    }
    // enter animation).
    if (mConfig.launchedWithAltTab) {
        if (mConfig.launchedFromAppWithThumbnail) {
            focusTask(Math.max(0, mStack.getTaskCount() - 2), false, mConfig.launchedHasConfigurationChanged);
        } else {
            focusTask(Math.max(0, mStack.getTaskCount() - 1), false, mConfig.launchedHasConfigurationChanged);
        }
    }
    // Start dozing
    mUIDozeTrigger.startDozing();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.setClipViewInStack:COMMENT
Method Modifier: 
Comment:/**
 * Sets whether this view should be clipped, or clipped against.
 */

Body of Frist Method:
{
    if (clip != mClipViewInStack) {
        mClipViewInStack = clip;
        mCb.onTaskViewClipStateChanged(this);
    }
}
Body of Second Method:
{
    if (clip != mClipViewInStack) {
        mClipViewInStack = clip;
        if (mCb != null) {
            mCb.onTaskViewClipStateChanged(this);
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.ParceledListSlice.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Write this to another Parcel. Note that this discards the internal Parcel
 * and should not be used anymore. This is so we can pass this to a Binder
 * where we won't have a chance to call recycle on this.
 */

Body of Frist Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_FIRST_IPC_SIZE) {
            dest.writeInt(1);
            mList.get(i).writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        mList.get(i).writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
Body of Second Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        final Class<?> listElementClass = mList.get(0).getClass();
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_FIRST_IPC_SIZE) {
            dest.writeInt(1);
            final T parcelable = mList.get(i);
            verifySameType(listElementClass, parcelable.getClass());
            parcelable.writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        final T parcelable = mList.get(i);
                        verifySameType(listElementClass, parcelable.getClass());
                        parcelable.writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.postUrl:COMMENT
Method Modifier: public      
Comment:/**
 * Loads the URL with postData using "POST" method into this WebView. If url
 * is not a network URL, it will be loaded with {@link #loadUrl(String)}
 * instead, ignoring the postData param.
 *
 * @param url the URL of the resource to load
 * @param postData the data will be passed to "POST" request, which must be
 * be "application/x-www-form-urlencoded" encoded.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "postUrl=" + url);
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "postUrl=" + url);
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewScroller.animateScroll:COMMENT
Method Modifier: 
Comment:/**
 * Animates the stack scroll
 */

Body of Frist Method:
{
    // Abort any current animations
    stopScroller();
    stopBoundScrollAnimation();
    mScrollAnimator = ObjectAnimator.ofFloat(this, "stackScroll", curScroll, newScroll);
    mScrollAnimator.setDuration(mConfig.taskStackScrollDuration);
    mScrollAnimator.setInterpolator(mConfig.linearOutSlowInInterpolator);
    mScrollAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            setStackScroll((Float) animation.getAnimatedValue());
        }
    });
    mScrollAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            if (postRunnable != null) {
                postRunnable.run();
            }
            mScrollAnimator.removeAllListeners();
        }
    });
    mScrollAnimator.start();
}
Body of Second Method:
{
    // Finish any current scrolling animations
    if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
        setStackScroll(mFinalAnimatedScroll);
        mScroller.startScroll(0, progressToScrollRange(mFinalAnimatedScroll), 0, 0, 0);
    }
    stopScroller();
    stopBoundScrollAnimation();
    mFinalAnimatedScroll = newScroll;
    mScrollAnimator = ObjectAnimator.ofFloat(this, "stackScroll", curScroll, newScroll);
    mScrollAnimator.setDuration(mConfig.taskStackScrollDuration);
    mScrollAnimator.setInterpolator(mConfig.linearOutSlowInInterpolator);
    mScrollAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            setStackScroll((Float) animation.getAnimatedValue());
        }
    });
    mScrollAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            if (postRunnable != null) {
                postRunnable.run();
            }
            mScrollAnimator.removeAllListeners();
        }
    });
    mScrollAnimator.start();
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSerifFontFamily:COMMENT
<android.webkit.WebSettings: void setSerifFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the serif font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.graphics.drawable.RippleBackground.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draws the ripple centered at (0,0) using the specified paint.
 */

Body of Frist Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && mHardwareAnimating) {
        hasContent = drawHardware((HardwareCanvas) c);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
Body of Second Method:
{
    mColor = p.getColor();
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && (mHardwareAnimating || mHasPendingHardwareExit)) {
        hasContent = drawHardware((HardwareCanvas) c, p);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.SystemBarScrimViews.startEnterRecentsAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Starts animating the scrim views when entering Recents.
 */

Body of Frist Method:
{
    if (mHasStatusBarScrim && mShouldAnimateStatusBarScrim) {
        mStatusBarScrimView.setTranslationY(-mStatusBarScrimView.getMeasuredHeight());
        mStatusBarScrimView.animate().translationY(0).setStartDelay(mConfig.taskBarEnterAnimDelay).setDuration(mConfig.navBarScrimEnterDuration).setInterpolator(mConfig.quintOutInterpolator).withStartAction(new Runnable() {

            @Override
            public void run() {
                mStatusBarScrimView.setVisibility(View.VISIBLE);
            }
        }).start();
    }
    if (mHasNavBarScrim && mShouldAnimateNavBarScrim) {
        mNavBarScrimView.setTranslationY(mNavBarScrimView.getMeasuredHeight());
        mNavBarScrimView.animate().translationY(0).setStartDelay(mConfig.taskBarEnterAnimDelay).setDuration(mConfig.navBarScrimEnterDuration).setInterpolator(mConfig.quintOutInterpolator).withStartAction(new Runnable() {

            @Override
            public void run() {
                mNavBarScrimView.setVisibility(View.VISIBLE);
            }
        }).start();
    }
}
Body of Second Method:
{
    if (mHasStatusBarScrim && mShouldAnimateStatusBarScrim) {
        mStatusBarScrimView.setTranslationY(-mStatusBarScrimView.getMeasuredHeight());
        mStatusBarScrimView.animate().translationY(0).setStartDelay(mConfig.launchedFromHome ? mConfig.transitionEnterFromHomeDelay : mConfig.transitionEnterFromAppDelay).setDuration(mConfig.navBarScrimEnterDuration).setInterpolator(mConfig.quintOutInterpolator).withStartAction(new Runnable() {

            @Override
            public void run() {
                mStatusBarScrimView.setVisibility(View.VISIBLE);
            }
        }).start();
    }
    if (mHasNavBarScrim && mShouldAnimateNavBarScrim) {
        mNavBarScrimView.setTranslationY(mNavBarScrimView.getMeasuredHeight());
        mNavBarScrimView.animate().translationY(0).setStartDelay(mConfig.launchedFromHome ? mConfig.transitionEnterFromHomeDelay : mConfig.transitionEnterFromAppDelay).setDuration(mConfig.navBarScrimEnterDuration).setInterpolator(mConfig.quintOutInterpolator).withStartAction(new Runnable() {

            @Override
            public void run() {
                mNavBarScrimView.setVisibility(View.VISIBLE);
            }
        }).start();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeDispatching:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            // Go home!
            launchHomeFromHotKey();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction();
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
Body of Second Method:
{
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction();
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
------------------------
Find a functionally equivalent code:com.android.server.SystemServer.startBootstrapServices:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the small tangle of critical services that are needed to get
 * the system off the ground.  These services have complex mutual dependencies
 * which is why we initialize them all in one place here.  Unless your service
 * is also entwined in these dependencies, it should be initialized in one of
 * the other functions.
 */

Body of Frist Method:
{
    // Wait for installd to finish starting up so that it has a chance to
    // create critical directories such as /data/user with the appropriate
    // permissions.  We need this to complete before we initialize other services.
    mInstaller = mSystemServiceManager.startService(Installer.class);
    // Activity manager runs the show.
    mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    // Power manager needs to be started early because other services need it.
    // Native daemons may be watching for it to be registered so it must be ready
    // to handle incoming binder calls immediately (including being able to verify
    // the permissions for those calls).
    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
    // Now that the power manager has been started, let the activity manager
    // initialize power management features.
    mActivityManagerService.initPowerManagement();
    // Display manager is needed to provide display metrics before package manager
    // starts up.
    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);
    // We need the default display before we can initialize the package manager.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);
    // Only run "core" apps if we're encrypting the device.
    String cryptState = SystemProperties.get("vold.decrypt");
    if (ENCRYPTING_STATE.equals(cryptState)) {
        Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
        mOnlyCore = true;
    } else if (ENCRYPTED_STATE.equals(cryptState)) {
        Slog.w(TAG, "Device encrypted - only parsing core apps");
        mOnlyCore = true;
    }
    // Start the package manager.
    Slog.i(TAG, "Package Manager");
    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
    mFirstBoot = mPackageManagerService.isFirstBoot();
    mPackageManager = mSystemContext.getPackageManager();
    Slog.i(TAG, "User Service");
    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());
    // Initialize attribute cache used to cache resources from packages.
    AttributeCache.init(mSystemContext);
    // Set up the Application instance for the system process and get started.
    mActivityManagerService.setSystemProcess();
}
Body of Second Method:
{
    // Wait for installd to finish starting up so that it has a chance to
    // create critical directories such as /data/user with the appropriate
    // permissions.  We need this to complete before we initialize other services.
    Installer installer = mSystemServiceManager.startService(Installer.class);
    // Activity manager runs the show.
    mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);
    // Power manager needs to be started early because other services need it.
    // Native daemons may be watching for it to be registered so it must be ready
    // to handle incoming binder calls immediately (including being able to verify
    // the permissions for those calls).
    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
    // Now that the power manager has been started, let the activity manager
    // initialize power management features.
    mActivityManagerService.initPowerManagement();
    // Display manager is needed to provide display metrics before package manager
    // starts up.
    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);
    // We need the default display before we can initialize the package manager.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);
    // Only run "core" apps if we're encrypting the device.
    String cryptState = SystemProperties.get("vold.decrypt");
    if (ENCRYPTING_STATE.equals(cryptState)) {
        Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
        mOnlyCore = true;
    } else if (ENCRYPTED_STATE.equals(cryptState)) {
        Slog.w(TAG, "Device encrypted - only parsing core apps");
        mOnlyCore = true;
    }
    // Start the package manager.
    Slog.i(TAG, "Package Manager");
    mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
    mFirstBoot = mPackageManagerService.isFirstBoot();
    mPackageManager = mSystemContext.getPackageManager();
    Slog.i(TAG, "User Service");
    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());
    // Initialize attribute cache used to cache resources from packages.
    AttributeCache.init(mSystemContext);
    // Set up the Application instance for the system process and get started.
    mActivityManagerService.setSystemProcess();
}
------------------------
Find a functionally equivalent code:android.widget.ImageView.animateTransform:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (matrix == null) {
        mDrawable.setBounds(0, 0, getWidth(), getHeight());
    } else {
        mDrawable.setBounds(0, 0, mDrawableWidth, mDrawableHeight);
        if (mDrawMatrix == null) {
            mDrawMatrix = new Matrix();
        }
        mDrawMatrix.set(matrix);
    }
    invalidate();
}
Body of Second Method:
{
    if (mDrawable == null) {
        return;
    }
    if (matrix == null) {
        mDrawable.setBounds(0, 0, getWidth(), getHeight());
    } else {
        mDrawable.setBounds(0, 0, mDrawableWidth, mDrawableHeight);
        if (mDrawMatrix == null) {
            mDrawMatrix = new Matrix();
        }
        mDrawMatrix.set(matrix);
    }
    invalidate();
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
}
Body of Second Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, PorterDuff.Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    mTintFilter = updateTintFilter(mTintFilter, state.mTint, state.mTintMode);
}
------------------------
Find a functionally equivalent code:android.text.TextLine.recycle:COMMENT
Method Modifier: default     static      
Comment:/**
 * Puts a TextLine back into the shared pool. Do not use this TextLine once
 * it has been returned.
 * @param tl the textLine
 * @return null, as a convenience from clearing references to the provided
 * TextLine
 */

Body of Frist Method:
{
    tl.mText = null;
    tl.mPaint = null;
    tl.mDirections = null;
    tl.mMetricAffectingSpanSpanSet.recycle();
    tl.mCharacterStyleSpanSet.recycle();
    tl.mReplacementSpanSpanSet.recycle();
    synchronized (sCached) {
        for (int i = 0; i < sCached.length; ++i) {
            if (sCached[i] == null) {
                sCached[i] = tl;
                break;
            }
        }
    }
    return null;
}
Body of Second Method:
{
    tl.mText = null;
    tl.mPaint = null;
    tl.mDirections = null;
    tl.mSpanned = null;
    tl.mTabs = null;
    tl.mChars = null;
    tl.mMetricAffectingSpanSpanSet.recycle();
    tl.mCharacterStyleSpanSet.recycle();
    tl.mReplacementSpanSpanSet.recycle();
    synchronized (sCached) {
        for (int i = 0; i < sCached.length; ++i) {
            if (sCached[i] == null) {
                sCached[i] = tl;
                break;
            }
        }
    }
    return null;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getCacheMode:COMMENT
<android.webkit.WebSettings: int getCacheMode()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the current setting for overriding the cache mode.
 *
 * @return the current setting for overriding the cache mode
 * @see #setCacheMode
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebHistoryItem.getTitle:COMMENT
<android.webkit.WebHistoryItem: String getTitle()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the document title of this history item.
 * @return The document title of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.os.Debug.getPss:COMMENT
Method Modifier: public      static      native      
Comment:/**
 * Retrieves the PSS memory used by the process as given by the
 * smaps.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.PopupWindow.setContentView:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */

Body of Frist Method:
{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
}
Body of Second Method:
{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
    // app hasn't already set the attachedInDecor.
    if (mContext != null && !mAttachedInDecorSet) {
        // Attach popup window in decor frame of parent window by default for
        // {@link Build.VERSION_CODES.LOLLIPOP_MR1} or greater. Keep current
        // behavior of not attaching to decor frame for older SDKs.
        setAttachedInDecor(mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP_MR1);
    }
}
------------------------
Find a functionally equivalent code:android.app.ApplicationPackageManager.loadItemIcon:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
        Bitmap bitmap = getUserManager().getUserIcon(itemInfo.showUserIcon);
        if (bitmap == null) {
            return UserIcons.getDefaultUserIcon(itemInfo.showUserIcon, /* light= */
            false);
        }
        return new BitmapDrawable(bitmap);
    }
    Drawable dr = null;
    if (itemInfo.packageName != null) {
        dr = getDrawable(itemInfo.packageName, itemInfo.icon, appInfo);
    }
    if (dr == null) {
        dr = itemInfo.loadDefaultIcon(this);
    }
    return getUserBadgedIcon(dr, new UserHandle(mContext.getUserId()));
}
Body of Second Method:
{
    Drawable dr = loadUnbadgedItemIcon(itemInfo, appInfo);
    if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
        return dr;
    }
    return getUserBadgedIcon(dr, new UserHandle(mContext.getUserId()));
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getTextZoom:COMMENT
<android.webkit.WebSettings: int getTextZoom()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the text zoom of the page in percent.
 *
 * @return the text zoom of the page in percent
 * @see #setTextZoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.isEmergencyNumberInternal:COMMENT
Method Modifier: private     static      
Comment:/**
 * Helper function for isEmergencyNumber(String) and
 * isPotentialEmergencyNumber(String).
 *
 * @param subId the subscription id of the SIM.
 * @param number the number to look up.
 *
 * @param useExactMatch if true, consider a number to be an emergency
 * number only if it *exactly* matches a number listed in
 * the RIL / SIM.  If false, a number is considered to be an
 * emergency number if it simply starts with the same digits
 * as any of the emergency numbers listed in the RIL / SIM.
 * (Setting useExactMatch to false allows you to identify
 * number that could *potentially* result in emergency calls
 * since many networks will actually ignore trailing digits
 * after a valid emergency number.)
 *
 * @return true if the number is in the list of emergency numbers
 * listed in the RIL / sim, otherwise return false.
 */

Body of Frist Method:
{
    return isEmergencyNumberInternal(subId, number, null, useExactMatch);
}
Body of Second Method:
{
    return isEmergencyNumberInternal(subId, number, null, useExactMatch);
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setMasterMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setMasterMute(boolean, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, UserHandle.getCallingUserId(), null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
Body of Second Method:
{
    setMasterMuteInternal(state, flags, callingPackage, cb, Binder.getCallingUid());
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getUseWideViewPort:COMMENT
<android.webkit.WebSettings: boolean getUseWideViewPort()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports the &quot;viewport&quot;
 * HTML meta tag or will use a wide viewport.
 *
 * @return true if the WebView supports the viewport meta tag
 * @see #setUseWideViewPort
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.Network.bindSocket:COMMENT
Method Modifier: public      
Comment:/**
 * Binds the specified {@link Socket} to this {@code Network}. All data traffic on the socket
 * will be sent on this {@code Network}, irrespective of any process-wide network binding set by
 * {@link ConnectivityManager#setProcessDefaultNetwork}. The socket must not be connected.
 */

Body of Frist Method:
{
    if (socket.isConnected()) {
        throw new SocketException("Socket is connected");
    }
    // Query a property of the underlying socket to ensure the underlying
    // socket exists so a file descriptor is available to bind to a network.
    socket.getReuseAddress();
    int err = NetworkUtils.bindSocketToNetwork(socket.getFileDescriptor$().getInt$(), netId);
    if (err != 0) {
        // bindSocketToNetwork returns negative errno.
        throw new ErrnoException("Binding socket to network " + netId, -err).rethrowAsSocketException();
    }
}
Body of Second Method:
{
    // Apparently, the kernel doesn't update a connected TCP socket's routing upon mark changes.
    if (socket.isConnected()) {
        throw new SocketException("Socket is connected");
    }
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocketFd(socket.getFileDescriptor$());
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowStateAnimator.applyAnimationLocked:COMMENT
Method Modifier: 
Comment:/**
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawn
 * then the animation will be app_starting_exit. Any other value loads the animation from
 * the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep from
 * loading the same animation twice.
 * @return true if an animation has been loaded.
 */

Body of Frist Method:
{
    if (mLocalAnimating && mAnimationIsEntrance == isEntrance) {
        // an animation of the same type, then just leave that one alone.
        return true;
    }
    // is running.
    if (mService.okToDisplay()) {
        int anim = mPolicy.selectAnimationLw(mWin, transit);
        int attr = -1;
        Animation a = null;
        if (anim != 0) {
            a = anim != -1 ? AnimationUtils.loadAnimation(mContext, anim) : null;
        } else {
            switch(transit) {
                case WindowManagerPolicy.TRANSIT_ENTER:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_EXIT:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_SHOW:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_HIDE:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
                    break;
            }
            if (attr >= 0) {
                a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr);
            }
        }
        if (WindowManagerService.DEBUG_ANIM)
            Slog.v(TAG, "applyAnimation: win=" + this + " anim=" + anim + " attr=0x" + Integer.toHexString(attr) + " a=" + a + " transit=" + transit + " isEntrance=" + isEntrance + " Callers " + Debug.getCallers(3));
        if (a != null) {
            if (WindowManagerService.DEBUG_ANIM) {
                RuntimeException e = null;
                if (!WindowManagerService.HIDE_STACK_CRAWLS) {
                    e = new RuntimeException();
                    e.fillInStackTrace();
                }
                Slog.v(TAG, "Loaded animation " + a + " for " + this, e);
            }
            setAnimation(a);
            mAnimationIsEntrance = isEntrance;
        }
    } else {
        clearAnimation();
    }
    return mAnimation != null;
}
Body of Second Method:
{
    if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
        // keyguard exit animation such that it also fades out.
        if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
            applyFadeoutDuringKeyguardExitAnimation();
        }
        return true;
    }
    // is running.
    if (mService.okToDisplay()) {
        int anim = mPolicy.selectAnimationLw(mWin, transit);
        int attr = -1;
        Animation a = null;
        if (anim != 0) {
            a = anim != -1 ? AnimationUtils.loadAnimation(mContext, anim) : null;
        } else {
            switch(transit) {
                case WindowManagerPolicy.TRANSIT_ENTER:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_EXIT:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_SHOW:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
                    break;
                case WindowManagerPolicy.TRANSIT_HIDE:
                    attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
                    break;
            }
            if (attr >= 0) {
                a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr);
            }
        }
        if (WindowManagerService.DEBUG_ANIM)
            Slog.v(TAG, "applyAnimation: win=" + this + " anim=" + anim + " attr=0x" + Integer.toHexString(attr) + " a=" + a + " transit=" + transit + " isEntrance=" + isEntrance + " Callers " + Debug.getCallers(3));
        if (a != null) {
            if (WindowManagerService.DEBUG_ANIM) {
                RuntimeException e = null;
                if (!WindowManagerService.HIDE_STACK_CRAWLS) {
                    e = new RuntimeException();
                    e.fillInStackTrace();
                }
                Slog.v(TAG, "Loaded animation " + a + " for " + this, e);
            }
            setAnimation(a);
            mAnimationIsEntrance = isEntrance;
        }
    } else {
        clearAnimation();
    }
    return mAnimation != null;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSavePassword:COMMENT
<android.webkit.WebSettings: void setSavePassword(boolean)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView should save passwords. The default is true.
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.startEnterRecentsAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Requests this task stacks to start it's enter-recents animation
 */

Body of Frist Method:
{
    // If we are still waiting to layout, then just defer until then
    if (mAwaitingFirstLayout) {
        mStartEnterAnimationRequestedAfterLayout = true;
        mStartEnterAnimationContext = ctx;
        return;
    }
    if (mStack.getTaskCount() > 0) {
        // Find the launch target task
        Task launchTargetTask = null;
        int childCount = getChildCount();
        for (int i = childCount - 1; i >= 0; i--) {
            TaskView tv = (TaskView) getChildAt(i);
            Task task = tv.getTask();
            if (task.isLaunchTarget) {
                launchTargetTask = task;
                break;
            }
        }
        // Animate all the task views into view
        for (int i = childCount - 1; i >= 0; i--) {
            TaskView tv = (TaskView) getChildAt(i);
            Task task = tv.getTask();
            ctx.currentTaskTransform = new TaskViewTransform();
            ctx.currentStackViewIndex = i;
            ctx.currentStackViewCount = childCount;
            ctx.currentTaskRect = mLayoutAlgorithm.mTaskRect;
            ctx.currentTaskOccludesLaunchTarget = (launchTargetTask != null) && launchTargetTask.group.isTaskAboveTask(task, launchTargetTask);
            ctx.updateListener = mRequestUpdateClippingListener;
            mLayoutAlgorithm.getStackTransform(task, mStackScroller.getStackScroll(), ctx.currentTaskTransform, null);
            tv.startEnterRecentsAnimation(ctx);
        }
        // Add a runnable to the post animation ref counter to clear all the views
        ctx.postAnimationTrigger.addLastDecrementRunnable(new Runnable() {

            @Override
            public void run() {
                mStartEnterAnimationCompleted = true;
                // Start dozing
                mUIDozeTrigger.startDozing();
                // Focus the first view if accessibility is enabled
                RecentsTaskLoader loader = RecentsTaskLoader.getInstance();
                SystemServicesProxy ssp = loader.getSystemServicesProxy();
                int childCount = getChildCount();
                if (childCount > 0 && ssp.isTouchExplorationEnabled()) {
                    TaskView tv = ((TaskView) getChildAt(childCount - 1));
                    tv.requestAccessibilityFocus();
                    mPrevAccessibilityFocusedIndex = mStack.indexOfTask(tv.getTask());
                }
            }
        });
    }
}
Body of Second Method:
{
    // If we are still waiting to layout, then just defer until then
    if (mAwaitingFirstLayout) {
        mStartEnterAnimationRequestedAfterLayout = true;
        mStartEnterAnimationContext = ctx;
        return;
    }
    if (mStack.getTaskCount() > 0) {
        // Find the launch target task
        Task launchTargetTask = null;
        int childCount = getChildCount();
        for (int i = childCount - 1; i >= 0; i--) {
            TaskView tv = (TaskView) getChildAt(i);
            Task task = tv.getTask();
            if (task.isLaunchTarget) {
                launchTargetTask = task;
                break;
            }
        }
        // Animate all the task views into view
        for (int i = childCount - 1; i >= 0; i--) {
            TaskView tv = (TaskView) getChildAt(i);
            Task task = tv.getTask();
            ctx.currentTaskTransform = new TaskViewTransform();
            ctx.currentStackViewIndex = i;
            ctx.currentStackViewCount = childCount;
            ctx.currentTaskRect = mLayoutAlgorithm.mTaskRect;
            ctx.currentTaskOccludesLaunchTarget = (launchTargetTask != null) && launchTargetTask.group.isTaskAboveTask(task, launchTargetTask);
            ctx.updateListener = mRequestUpdateClippingListener;
            mLayoutAlgorithm.getStackTransform(task, mStackScroller.getStackScroll(), ctx.currentTaskTransform, null);
            tv.startEnterRecentsAnimation(ctx);
        }
        // Add a runnable to the post animation ref counter to clear all the views
        ctx.postAnimationTrigger.addLastDecrementRunnable(new Runnable() {

            @Override
            public void run() {
                mStartEnterAnimationCompleted = true;
                // Poke the dozer to restart the trigger after the animation completes
                mUIDozeTrigger.poke();
                RecentsTaskLoader loader = RecentsTaskLoader.getInstance();
                SystemServicesProxy ssp = loader.getSystemServicesProxy();
                int childCount = getChildCount();
                if (childCount > 0) {
                    // Focus the first view if accessibility is enabled
                    if (ssp.isTouchExplorationEnabled()) {
                        TaskView tv = ((TaskView) getChildAt(childCount - 1));
                        tv.requestAccessibilityFocus();
                        mPrevAccessibilityFocusedIndex = mStack.indexOfTask(tv.getTask());
                    }
                }
                // Start the focus animation when alt-tabbing
                if (mConfig.launchedWithAltTab && !mConfig.launchedHasConfigurationChanged) {
                    View tv = getChildAt(mFocusedTaskIndex);
                    if (tv != null) {
                        ((TaskView) tv).setFocusedTask(true);
                    }
                }
            }
        });
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDefaultZoom:COMMENT
<android.webkit.WebSettings: ZoomDensity getDefaultZoom()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the default zoom density of the page. This should be called from
 * the UI thread.
 *
 * This setting is not recommended for use in new applications.
 *
 * @return the zoom density
 * @see #setDefaultZoom
 * @deprecated Will only return the default value.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.wm.InputMonitor.updateInputWindowsLw:COMMENT
Method Modifier: public      
Comment:/* Updates the cached window information provided to the input dispatcher. */

Body of Frist Method:
{
    if (!force && !mUpdateInputWindowsNeeded) {
        return;
    }
    mUpdateInputWindowsNeeded = false;
    if (false)
        Slog.d(WindowManagerService.TAG, ">>>>>> ENTERED updateInputWindowsLw");
    // Populate the input window list with information about all of the windows that
    // could potentially receive input.
    // As an optimization, we could try to prune the list of windows but this turns
    // out to be difficult because only the native code knows for sure which window
    // currently has touch focus.
    final WindowStateAnimator universeBackground = mService.mAnimator.mUniverseBackground;
    final int aboveUniverseLayer = mService.mAnimator.mAboveUniverseLayer;
    boolean addedUniverse = false;
    // If there's a drag in flight, provide a pseudowindow to catch drag input
    final boolean inDrag = (mService.mDragState != null);
    if (inDrag) {
        if (WindowManagerService.DEBUG_DRAG) {
            Log.d(WindowManagerService.TAG, "Inserting drag window");
        }
        final InputWindowHandle dragWindowHandle = mService.mDragState.mDragWindowHandle;
        if (dragWindowHandle != null) {
            addInputWindowHandleLw(dragWindowHandle);
        } else {
            Slog.w(WindowManagerService.TAG, "Drag is in progress but there is no " + "drag window handle.");
        }
    }
    final int NFW = mService.mFakeWindows.size();
    for (int i = 0; i < NFW; i++) {
        addInputWindowHandleLw(mService.mFakeWindows.get(i).mWindowHandle);
    }
    // Add all windows on the default display.
    final int numDisplays = mService.mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList();
        for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
            final WindowState child = windows.get(winNdx);
            final InputChannel inputChannel = child.mInputChannel;
            final InputWindowHandle inputWindowHandle = child.mInputWindowHandle;
            if (inputChannel == null || inputWindowHandle == null || child.mRemoved) {
                // Skip this window because it cannot possibly receive input.
                continue;
            }
            final int flags = child.mAttrs.flags;
            final int privateFlags = child.mAttrs.privateFlags;
            final int type = child.mAttrs.type;
            final boolean hasFocus = (child == mInputFocus);
            final boolean isVisible = child.isVisibleLw();
            final boolean hasWallpaper = (child == mService.mWallpaperTarget) && (privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD) == 0;
            final boolean onDefaultDisplay = (child.getDisplayId() == Display.DEFAULT_DISPLAY);
            // make sure it's been told about the drag
            if (inDrag && isVisible && onDefaultDisplay) {
                mService.mDragState.sendDragStartedIfNeededLw(child);
            }
            if (universeBackground != null && !addedUniverse && child.mBaseLayer < aboveUniverseLayer && onDefaultDisplay) {
                final WindowState u = universeBackground.mWin;
                if (u.mInputChannel != null && u.mInputWindowHandle != null) {
                    addInputWindowHandleLw(u.mInputWindowHandle, u, u.mAttrs.flags, u.mAttrs.privateFlags, u.mAttrs.type, true, u == mInputFocus, false);
                }
                addedUniverse = true;
            }
            if (child.mWinAnimator != universeBackground) {
                addInputWindowHandleLw(inputWindowHandle, child, flags, privateFlags, type, isVisible, hasFocus, hasWallpaper);
            }
        }
    }
    // Send windows to native code.
    mService.mInputManager.setInputWindows(mInputWindowHandles);
    // Clear the list in preparation for the next round.
    clearInputWindowHandlesLw();
    if (false)
        Slog.d(WindowManagerService.TAG, "<<<<<<< EXITED updateInputWindowsLw");
}
Body of Second Method:
{
    if (!force && !mUpdateInputWindowsNeeded) {
        return;
    }
    mUpdateInputWindowsNeeded = false;
    if (false)
        Slog.d(WindowManagerService.TAG, ">>>>>> ENTERED updateInputWindowsLw");
    // Populate the input window list with information about all of the windows that
    // could potentially receive input.
    // As an optimization, we could try to prune the list of windows but this turns
    // out to be difficult because only the native code knows for sure which window
    // currently has touch focus.
    final WindowStateAnimator universeBackground = mService.mAnimator.mUniverseBackground;
    final int aboveUniverseLayer = mService.mAnimator.mAboveUniverseLayer;
    boolean addedUniverse = false;
    boolean disableWallpaperTouchEvents = false;
    // If there's a drag in flight, provide a pseudowindow to catch drag input
    final boolean inDrag = (mService.mDragState != null);
    if (inDrag) {
        if (WindowManagerService.DEBUG_DRAG) {
            Log.d(WindowManagerService.TAG, "Inserting drag window");
        }
        final InputWindowHandle dragWindowHandle = mService.mDragState.mDragWindowHandle;
        if (dragWindowHandle != null) {
            addInputWindowHandleLw(dragWindowHandle);
        } else {
            Slog.w(WindowManagerService.TAG, "Drag is in progress but there is no " + "drag window handle.");
        }
    }
    final int NFW = mService.mFakeWindows.size();
    for (int i = 0; i < NFW; i++) {
        addInputWindowHandleLw(mService.mFakeWindows.get(i).mWindowHandle);
    }
    // Add all windows on the default display.
    final int numDisplays = mService.mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList();
        for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
            final WindowState child = windows.get(winNdx);
            final InputChannel inputChannel = child.mInputChannel;
            final InputWindowHandle inputWindowHandle = child.mInputWindowHandle;
            if (inputChannel == null || inputWindowHandle == null || child.mRemoved) {
                // Skip this window because it cannot possibly receive input.
                continue;
            }
            final int flags = child.mAttrs.flags;
            final int privateFlags = child.mAttrs.privateFlags;
            final int type = child.mAttrs.type;
            final boolean hasFocus = (child == mInputFocus);
            final boolean isVisible = child.isVisibleLw();
            if ((privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_DISABLE_WALLPAPER_TOUCH_EVENTS) != 0) {
                disableWallpaperTouchEvents = true;
            }
            final boolean hasWallpaper = (child == mService.mWallpaperTarget) && (privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD) == 0 && !disableWallpaperTouchEvents;
            final boolean onDefaultDisplay = (child.getDisplayId() == Display.DEFAULT_DISPLAY);
            // make sure it's been told about the drag
            if (inDrag && isVisible && onDefaultDisplay) {
                mService.mDragState.sendDragStartedIfNeededLw(child);
            }
            if (universeBackground != null && !addedUniverse && child.mBaseLayer < aboveUniverseLayer && onDefaultDisplay) {
                final WindowState u = universeBackground.mWin;
                if (u.mInputChannel != null && u.mInputWindowHandle != null) {
                    addInputWindowHandleLw(u.mInputWindowHandle, u, u.mAttrs.flags, u.mAttrs.type, true, u == mInputFocus, false);
                }
                addedUniverse = true;
            }
            if (child.mWinAnimator != universeBackground) {
                addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus, hasWallpaper);
            }
        }
    }
    // Send windows to native code.
    mService.mInputManager.setInputWindows(mInputWindowHandles);
    // Clear the list in preparation for the next round.
    clearInputWindowHandlesLw();
    if (false)
        Slog.d(WindowManagerService.TAG, "<<<<<<< EXITED updateInputWindowsLw");
}
------------------------
Find a functionally equivalent code:android.media.AudioService.requestAudioFocus:COMMENT
Method Modifier: public      
Comment:// ==========================================================================================

Body of Frist Method:
{
    return mMediaFocusControl.requestAudioFocus(mainStreamType, durationHint, cb, fd, clientId, callingPackageName);
}
Body of Second Method:
{
    // permission checks
    if ((flags & AudioManager.AUDIOFOCUS_FLAG_LOCK) == AudioManager.AUDIOFOCUS_FLAG_LOCK) {
        if (mMediaFocusControl.IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
            if (PackageManager.PERMISSION_GRANTED != mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)) {
                Log.e(TAG, "Invalid permission to (un)lock audio focus", new Exception());
                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
            }
        } else {
            // only a registered audio policy can be used to lock focus
            synchronized (mAudioPolicies) {
                if (!mAudioPolicies.containsKey(pcb.asBinder())) {
                    Log.e(TAG, "Invalid unregistered AudioPolicy to (un)lock audio focus");
                    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
                }
            }
        }
    }
    return mMediaFocusControl.requestAudioFocus(aa, durationHint, cb, fd, clientId, callingPackageName, flags);
}
------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.reverse:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ValueAnimator in reverse. If the animation is already running,
 * it will stop itself and play backwards from the point reached when reverse was called.
 * If the animation is not currently running, then it will start from the end and
 * play backwards. This behavior is only set for the current animation; future playing
 * of the animation will use the default behavior of playing forward.
 */

Body of Frist Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
Body of Second Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        mReversing = !mReversing;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.releaseIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void releaseIconForPageUrl(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Release the icon for the given page url.
 * @param url The page's url.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.enableFocusAnimations:COMMENT
Method Modifier: 
Comment:/**
 * Enables all focus animations.
 */

Body of Frist Method:
{
    boolean wasFocusAnimationsEnabled = mFocusAnimationsEnabled;
    mFocusAnimationsEnabled = true;
    if (mIsFocused && !wasFocusAnimationsEnabled) {
        // Re-notify the header if we were focused and animations were not previously enabled
        mHeaderView.onTaskViewFocusChanged(true);
    }
}
Body of Second Method:
{
    boolean wasFocusAnimationsEnabled = mFocusAnimationsEnabled;
    mFocusAnimationsEnabled = true;
    if (mIsFocused && !wasFocusAnimationsEnabled) {
        // Re-notify the header if we were focused and animations were not previously enabled
        mHeaderView.onTaskViewFocusChanged(true, true);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.setStreamSolo:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamSolo(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    for (int stream = 0; stream < mStreamStates.length; stream++) {
        if (!isStreamAffectedByMute(stream) || stream == streamType)
            continue;
        mStreamStates[stream].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    int streamAlias = mStreamVolumeAlias[streamType];
    for (int stream = 0; stream < mStreamStates.length; stream++) {
        if (!isStreamAffectedByMute(streamAlias) || streamAlias == mStreamVolumeAlias[stream]) {
            continue;
        }
        mStreamStates[stream].mute(cb, state);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getJavaScriptEnabled:COMMENT
<android.webkit.WebSettings: boolean getJavaScriptEnabled()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether JavaScript is enabled.
 *
 * @return true if JavaScript is enabled
 * @see #setJavaScriptEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.setDefaultSmsSubId:COMMENT
<android.telephony.SubscriptionManager: void setDefaultSmsSubId(long)>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("setDefaultSmsSubId sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultSmsSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
Body of Second Method:
{
    if (VDBG)
        logd("setDefaultSmsSubId sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultSmsSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDefaultTextEncodingName:COMMENT
<android.webkit.WebSettings: void setDefaultTextEncodingName(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default text encoding name to use when decoding html pages.
 * The default is "UTF-8".
 *
 * @param encoding the text encoding name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewHeader.onTaskViewFocusChanged:COMMENT
Method Modifier: 
Comment:/**
 * Notifies the associated TaskView has been focused.
 */

Body of Frist Method:
{
    boolean isRunning = false;
    if (mFocusAnimator != null) {
        isRunning = mFocusAnimator.isRunning();
        mFocusAnimator.removeAllListeners();
        mFocusAnimator.cancel();
    }
    if (focused) {
        int secondaryColor = getSecondaryColor(mCurrentPrimaryColor, mCurrentPrimaryColorIsDark);
        int[][] states = new int[][] { new int[] { android.R.attr.state_enabled }, new int[] { android.R.attr.state_pressed } };
        int[] newStates = new int[] { android.R.attr.state_enabled, android.R.attr.state_pressed };
        int[] colors = new int[] { secondaryColor, secondaryColor };
        mBackground.setColor(new ColorStateList(states, colors));
        mBackground.setState(newStates);
        // Pulse the background color
        int currentColor = mBackgroundColor;
        int lightPrimaryColor = getSecondaryColor(mCurrentPrimaryColor, mCurrentPrimaryColorIsDark);
        ValueAnimator backgroundColor = ValueAnimator.ofObject(new ArgbEvaluator(), lightPrimaryColor, currentColor);
        backgroundColor.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationStart(Animator animation) {
                mBackground.setState(new int[] {});
            }
        });
        backgroundColor.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int color = (int) animation.getAnimatedValue();
                mBackgroundColorDrawable.setColor(color);
                mBackgroundColor = color;
            }
        });
        backgroundColor.setRepeatCount(ValueAnimator.INFINITE);
        backgroundColor.setRepeatMode(ValueAnimator.REVERSE);
        // Pulse the translation
        ObjectAnimator translation = ObjectAnimator.ofFloat(this, "translationZ", 15f);
        translation.setRepeatCount(ValueAnimator.INFINITE);
        translation.setRepeatMode(ValueAnimator.REVERSE);
        mFocusAnimator = new AnimatorSet();
        mFocusAnimator.playTogether(backgroundColor, translation);
        mFocusAnimator.setStartDelay(750);
        mFocusAnimator.setDuration(750);
        mFocusAnimator.start();
    } else {
        if (isRunning) {
            // Restore the background color
            int currentColor = mBackgroundColor;
            ValueAnimator backgroundColor = ValueAnimator.ofObject(new ArgbEvaluator(), currentColor, mCurrentPrimaryColor);
            backgroundColor.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    int color = (int) animation.getAnimatedValue();
                    mBackgroundColorDrawable.setColor(color);
                    mBackgroundColor = color;
                }
            });
            // Restore the translation
            ObjectAnimator translation = ObjectAnimator.ofFloat(this, "translationZ", 0f);
            mFocusAnimator = new AnimatorSet();
            mFocusAnimator.playTogether(backgroundColor, translation);
            mFocusAnimator.setDuration(150);
            mFocusAnimator.start();
        } else {
            mBackground.setState(new int[] {});
            setTranslationZ(0f);
        }
    }
}
Body of Second Method:
{
    // If we are not animating the visible state, just return
    if (!animateFocusedState)
        return;
    boolean isRunning = false;
    if (mFocusAnimator != null) {
        isRunning = mFocusAnimator.isRunning();
        Utilities.cancelAnimationWithoutCallbacks(mFocusAnimator);
    }
    if (focused) {
        int secondaryColor = getSecondaryColor(mCurrentPrimaryColor, mCurrentPrimaryColorIsDark);
        int[][] states = new int[][] { new int[] { android.R.attr.state_enabled }, new int[] { android.R.attr.state_pressed } };
        int[] newStates = new int[] { android.R.attr.state_enabled, android.R.attr.state_pressed };
        int[] colors = new int[] { secondaryColor, secondaryColor };
        mBackground.setColor(new ColorStateList(states, colors));
        mBackground.setState(newStates);
        // Pulse the background color
        int currentColor = mBackgroundColor;
        int lightPrimaryColor = getSecondaryColor(mCurrentPrimaryColor, mCurrentPrimaryColorIsDark);
        ValueAnimator backgroundColor = ValueAnimator.ofObject(new ArgbEvaluator(), currentColor, lightPrimaryColor);
        backgroundColor.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationStart(Animator animation) {
                mBackground.setState(new int[] {});
            }
        });
        backgroundColor.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int color = (int) animation.getAnimatedValue();
                mBackgroundColorDrawable.setColor(color);
                mBackgroundColor = color;
            }
        });
        backgroundColor.setRepeatCount(ValueAnimator.INFINITE);
        backgroundColor.setRepeatMode(ValueAnimator.REVERSE);
        // Pulse the translation
        ObjectAnimator translation = ObjectAnimator.ofFloat(this, "translationZ", 15f);
        translation.setRepeatCount(ValueAnimator.INFINITE);
        translation.setRepeatMode(ValueAnimator.REVERSE);
        mFocusAnimator = new AnimatorSet();
        mFocusAnimator.playTogether(backgroundColor, translation);
        mFocusAnimator.setStartDelay(750);
        mFocusAnimator.setDuration(750);
        mFocusAnimator.start();
    } else {
        if (isRunning) {
            // Restore the background color
            int currentColor = mBackgroundColor;
            ValueAnimator backgroundColor = ValueAnimator.ofObject(new ArgbEvaluator(), currentColor, mCurrentPrimaryColor);
            backgroundColor.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    int color = (int) animation.getAnimatedValue();
                    mBackgroundColorDrawable.setColor(color);
                    mBackgroundColor = color;
                }
            });
            // Restore the translation
            ObjectAnimator translation = ObjectAnimator.ofFloat(this, "translationZ", 0f);
            mFocusAnimator = new AnimatorSet();
            mFocusAnimator.playTogether(backgroundColor, translation);
            mFocusAnimator.setDuration(150);
            mFocusAnimator.start();
        } else {
            mBackground.setState(new int[] {});
            setTranslationZ(0f);
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.onLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * This is called with the size of the space not including the top or right insets, or the
 * search bar height in portrait (but including the search bar width in landscape, since we want
 * to draw under it.
 */

Body of Frist Method:
{
    // Layout each of the children
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        if (tv.isFullScreenView()) {
            tv.layout(left, top, left + tv.getMeasuredWidth(), top + tv.getMeasuredHeight());
        } else {
            if (tv.getBackground() != null) {
                tv.getBackground().getPadding(mTmpRect);
            } else {
                mTmpRect.setEmpty();
            }
            tv.layout(mLayoutAlgorithm.mTaskRect.left - mTmpRect.left, mLayoutAlgorithm.mTaskRect.top - mTmpRect.top, mLayoutAlgorithm.mTaskRect.right + mTmpRect.right, mLayoutAlgorithm.mTaskRect.bottom + mTmpRect.bottom + tv.getMaxFooterHeight());
        }
    }
    if (mAwaitingFirstLayout) {
        mAwaitingFirstLayout = false;
        onFirstLayout();
    }
}
Body of Second Method:
{
    // Layout each of the children
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        if (tv.getBackground() != null) {
            tv.getBackground().getPadding(mTmpRect);
        } else {
            mTmpRect.setEmpty();
        }
        tv.layout(mLayoutAlgorithm.mTaskRect.left - mTmpRect.left, mLayoutAlgorithm.mTaskRect.top - mTmpRect.top, mLayoutAlgorithm.mTaskRect.right + mTmpRect.right, mLayoutAlgorithm.mTaskRect.bottom + mTmpRect.bottom);
    }
    if (mAwaitingFirstLayout) {
        mAwaitingFirstLayout = false;
        onFirstLayout();
    }
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowManagerService.screenshotApplications:COMMENT
Method Modifier: public      
Comment:/**
 * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen.
 * In portrait mode, it grabs the upper region of the screen based on the vertical dimension
 * of the target image.
 *
 * @param displayId the Display to take a screenshot of.
 * @param width the width of the target bitmap
 * @param height the height of the target bitmap
 * @param force565 if true the returned bitmap will be RGB_565, otherwise it
 * will be the same config as the surface
 */

Body of Frist Method:
{
    if (!checkCallingPermission(Manifest.permission.READ_FRAME_BUFFER, "screenshotApplications()")) {
        throw new SecurityException("Requires READ_FRAME_BUFFER permission");
    }
    final DisplayContent displayContent = getDisplayContentLocked(displayId);
    if (displayContent == null) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. No Display for displayId=" + displayId);
        return null;
    }
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    int dw = displayInfo.logicalWidth;
    int dh = displayInfo.logicalHeight;
    if (dw == 0 || dh == 0) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. logical widthxheight=" + dw + "x" + dh);
        return null;
    }
    Bitmap bm = null;
    int maxLayer = 0;
    final Rect frame = new Rect();
    final Rect stackBounds = new Rect();
    float scale = 0;
    int rot = Surface.ROTATION_0;
    boolean screenshotReady;
    int minLayer;
    if (appToken == null) {
        screenshotReady = true;
        minLayer = 0;
    } else {
        screenshotReady = false;
        minLayer = Integer.MAX_VALUE;
    }
    int retryCount = 0;
    WindowState appWin = null;
    final boolean appIsImTarget = mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
    final int aboveAppLayer = (mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (true) {
        if (retryCount++ > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        synchronized (mWindowMap) {
            // Figure out the part of the screen that is actually the app.
            appWin = null;
            final WindowList windows = displayContent.getWindowList();
            for (int i = windows.size() - 1; i >= 0; i--) {
                WindowState ws = windows.get(i);
                if (!ws.mHasSurface) {
                    continue;
                }
                if (ws.mLayer >= aboveAppLayer) {
                    continue;
                }
                if (ws.mIsImWindow) {
                    if (!appIsImTarget) {
                        continue;
                    }
                } else if (ws.mIsWallpaper) {
                // Fall through.
                } else if (appToken != null) {
                    if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
                        // screenshot app.
                        continue;
                    }
                    appWin = ws;
                }
                // Include this window.
                final WindowStateAnimator winAnim = ws.mWinAnimator;
                if (maxLayer < winAnim.mSurfaceLayer) {
                    maxLayer = winAnim.mSurfaceLayer;
                }
                if (minLayer > winAnim.mSurfaceLayer) {
                    minLayer = winAnim.mSurfaceLayer;
                }
                // Don't include wallpaper in bounds calculation
                if (!ws.mIsWallpaper) {
                    final Rect wf = ws.mFrame;
                    final Rect cr = ws.mContentInsets;
                    int left = wf.left + cr.left;
                    int top = wf.top + cr.top;
                    int right = wf.right - cr.right;
                    int bottom = wf.bottom - cr.bottom;
                    frame.union(left, top, right, bottom);
                    ws.getStackBounds(stackBounds);
                    frame.intersect(stackBounds);
                }
                if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
                    screenshotReady = true;
                }
            }
            if (appToken != null && appWin == null) {
                // Can't find a window to snapshot.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: Couldn't find a surface matching " + appToken);
                return null;
            }
            if (!screenshotReady) {
                if (retryCount > MAX_SCREENSHOT_RETRIES) {
                    Slog.i(TAG, "Screenshot max retries " + retryCount + " of " + appToken + " appWin=" + (appWin == null ? "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
                    return null;
                }
                // Delay and hope that window gets drawn.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: No image ready for " + appToken + ", " + appWin + " drawState=" + appWin.mWinAnimator.mDrawState);
                continue;
            }
            if (maxLayer == 0) {
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot of " + appToken + ": returning null maxLayer=" + maxLayer);
                return null;
            }
            // Constrain frame to the screen size.
            frame.intersect(0, 0, dw, dh);
            // Tell surface flinger what part of the image to crop. Take the top
            // right part of the application, and crop the larger dimension to fit.
            Rect crop = new Rect(frame);
            if (width / (float) frame.width() < height / (float) frame.height()) {
                int cropWidth = (int) ((float) width / (float) height * frame.height());
                crop.right = crop.left + cropWidth;
            } else {
                int cropHeight = (int) ((float) height / (float) width * frame.width());
                crop.bottom = crop.top + cropHeight;
            }
            // The screenshot API does not apply the current screen rotation.
            rot = getDefaultDisplayContentLocked().getDisplay().getRotation();
            if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
                rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
            }
            // Surfaceflinger is not aware of orientation, so convert our logical
            // crop to surfaceflinger's portrait orientation.
            convertCropForSurfaceFlinger(crop, rot, dw, dh);
            if (DEBUG_SCREENSHOT) {
                Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to " + maxLayer + " appToken=" + appToken);
                for (int i = 0; i < windows.size(); i++) {
                    WindowState win = windows.get(i);
                    Slog.i(TAG, win + ": " + win.mLayer + " animLayer=" + win.mWinAnimator.mAnimLayer + " surfaceLayer=" + win.mWinAnimator.mSurfaceLayer);
                }
            }
            ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
            final boolean inRotation = screenRotationAnimation != null && screenRotationAnimation.isAnimating();
            if (DEBUG_SCREENSHOT && inRotation)
                Slog.v(TAG, "Taking screenshot while rotating");
            bm = SurfaceControl.screenshot(crop, width, height, minLayer, maxLayer, inRotation, rot);
            if (bm == null) {
                Slog.w(TAG, "Screenshot failure taking screenshot for (" + dw + "x" + dh + ") to layer " + maxLayer);
                return null;
            }
        }
        break;
    }
    if (DEBUG_SCREENSHOT) {
        // TEST IF IT's ALL BLACK
        int[] buffer = new int[bm.getWidth() * bm.getHeight()];
        bm.getPixels(buffer, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight());
        boolean allBlack = true;
        final int firstColor = buffer[0];
        for (int i = 0; i < buffer.length; i++) {
            if (buffer[i] != firstColor) {
                allBlack = false;
                break;
            }
        }
        if (allBlack) {
            Slog.i(TAG, "Screenshot " + appWin + " was monochrome(" + Integer.toHexString(firstColor) + ")! mSurfaceLayer=" + (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null") + " minLayer=" + minLayer + " maxLayer=" + maxLayer);
        }
    }
    // Copy the screenshot bitmap to another buffer so that the gralloc backed
    // bitmap will not have a long lifetime. Gralloc memory can be pinned or
    // duplicated and might have a higher cost than a skia backed buffer.
    Bitmap ret = bm.copy(bm.getConfig(), true);
    bm.recycle();
    return ret;
}
Body of Second Method:
{
    if (!checkCallingPermission(Manifest.permission.READ_FRAME_BUFFER, "screenshotApplications()")) {
        throw new SecurityException("Requires READ_FRAME_BUFFER permission");
    }
    final DisplayContent displayContent = getDisplayContentLocked(displayId);
    if (displayContent == null) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. No Display for displayId=" + displayId);
        return null;
    }
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    int dw = displayInfo.logicalWidth;
    int dh = displayInfo.logicalHeight;
    if (dw == 0 || dh == 0) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. logical widthxheight=" + dw + "x" + dh);
        return null;
    }
    Bitmap bm = null;
    int maxLayer = 0;
    final Rect frame = new Rect();
    final Rect stackBounds = new Rect();
    float scale = 0;
    int rot = Surface.ROTATION_0;
    boolean screenshotReady;
    int minLayer;
    if (appToken == null) {
        screenshotReady = true;
        minLayer = 0;
    } else {
        screenshotReady = false;
        minLayer = Integer.MAX_VALUE;
    }
    int retryCount = 0;
    WindowState appWin = null;
    final boolean appIsImTarget = mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
    final int aboveAppLayer = (mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (true) {
        if (retryCount++ > 0) {
            // Reset max/min layers on retries so we don't accidentally take a screenshot of a
            // layer based on the previous try.
            maxLayer = 0;
            minLayer = Integer.MAX_VALUE;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        synchronized (mWindowMap) {
            // Figure out the part of the screen that is actually the app.
            appWin = null;
            final WindowList windows = displayContent.getWindowList();
            for (int i = windows.size() - 1; i >= 0; i--) {
                WindowState ws = windows.get(i);
                if (!ws.mHasSurface) {
                    continue;
                }
                if (ws.mLayer >= aboveAppLayer) {
                    continue;
                }
                if (ws.mIsImWindow) {
                    if (!appIsImTarget) {
                        continue;
                    }
                } else if (ws.mIsWallpaper) {
                    if (appWin == null) {
                        // the layer of the target window.
                        continue;
                    }
                // Fall through. The target window is in front of the wallpaper. For this
                // case we want to include the wallpaper layer in the screenshot because
                // the target window might have some transparent areas.
                } else if (appToken != null) {
                    if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
                        // screenshot app.
                        continue;
                    }
                    appWin = ws;
                }
                // Include this window.
                final WindowStateAnimator winAnim = ws.mWinAnimator;
                if (maxLayer < winAnim.mSurfaceLayer) {
                    maxLayer = winAnim.mSurfaceLayer;
                }
                if (minLayer > winAnim.mSurfaceLayer) {
                    minLayer = winAnim.mSurfaceLayer;
                }
                // Don't include wallpaper in bounds calculation
                if (!ws.mIsWallpaper) {
                    final Rect wf = ws.mFrame;
                    final Rect cr = ws.mContentInsets;
                    int left = wf.left + cr.left;
                    int top = wf.top + cr.top;
                    int right = wf.right - cr.right;
                    int bottom = wf.bottom - cr.bottom;
                    frame.union(left, top, right, bottom);
                    ws.getStackBounds(stackBounds);
                    frame.intersect(stackBounds);
                }
                if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
                    screenshotReady = true;
                }
            }
            if (appToken != null && appWin == null) {
                // Can't find a window to snapshot.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: Couldn't find a surface matching " + appToken);
                return null;
            }
            if (!screenshotReady) {
                if (retryCount > MAX_SCREENSHOT_RETRIES) {
                    Slog.i(TAG, "Screenshot max retries " + retryCount + " of " + appToken + " appWin=" + (appWin == null ? "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
                    return null;
                }
                // Delay and hope that window gets drawn.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: No image ready for " + appToken + ", " + appWin + " drawState=" + appWin.mWinAnimator.mDrawState);
                continue;
            }
            if (maxLayer == 0) {
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot of " + appToken + ": returning null maxLayer=" + maxLayer);
                return null;
            }
            // Constrain frame to the screen size.
            frame.intersect(0, 0, dw, dh);
            // Tell surface flinger what part of the image to crop. Take the top
            // right part of the application, and crop the larger dimension to fit.
            Rect crop = new Rect(frame);
            if (width / (float) frame.width() < height / (float) frame.height()) {
                int cropWidth = (int) ((float) width / (float) height * frame.height());
                crop.right = crop.left + cropWidth;
            } else {
                int cropHeight = (int) ((float) height / (float) width * frame.width());
                crop.bottom = crop.top + cropHeight;
            }
            // The screenshot API does not apply the current screen rotation.
            rot = getDefaultDisplayContentLocked().getDisplay().getRotation();
            if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
                rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
            }
            // Surfaceflinger is not aware of orientation, so convert our logical
            // crop to surfaceflinger's portrait orientation.
            convertCropForSurfaceFlinger(crop, rot, dw, dh);
            if (DEBUG_SCREENSHOT) {
                Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to " + maxLayer + " appToken=" + appToken);
                for (int i = 0; i < windows.size(); i++) {
                    WindowState win = windows.get(i);
                    Slog.i(TAG, win + ": " + win.mLayer + " animLayer=" + win.mWinAnimator.mAnimLayer + " surfaceLayer=" + win.mWinAnimator.mSurfaceLayer);
                }
            }
            ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
            final boolean inRotation = screenRotationAnimation != null && screenRotationAnimation.isAnimating();
            if (DEBUG_SCREENSHOT && inRotation)
                Slog.v(TAG, "Taking screenshot while rotating");
            bm = SurfaceControl.screenshot(crop, width, height, minLayer, maxLayer, inRotation, rot);
            if (bm == null) {
                Slog.w(TAG, "Screenshot failure taking screenshot for (" + dw + "x" + dh + ") to layer " + maxLayer);
                return null;
            }
        }
        break;
    }
    if (DEBUG_SCREENSHOT) {
        // TEST IF IT's ALL BLACK
        int[] buffer = new int[bm.getWidth() * bm.getHeight()];
        bm.getPixels(buffer, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight());
        boolean allBlack = true;
        final int firstColor = buffer[0];
        for (int i = 0; i < buffer.length; i++) {
            if (buffer[i] != firstColor) {
                allBlack = false;
                break;
            }
        }
        if (allBlack) {
            Slog.i(TAG, "Screenshot " + appWin + " was monochrome(" + Integer.toHexString(firstColor) + ")! mSurfaceLayer=" + (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null") + " minLayer=" + minLayer + " maxLayer=" + maxLayer);
        }
    }
    // Copy the screenshot bitmap to another buffer so that the gralloc backed
    // bitmap will not have a long lifetime. Gralloc memory can be pinned or
    // duplicated and might have a higher cost than a skia backed buffer.
    Bitmap ret = bm.copy(bm.getConfig(), true);
    bm.recycle();
    return ret;
}
------------------------
Find a functionally equivalent code:com.android.server.net.LockdownVpnTracker.handleStateChangedLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Watch for state changes to both active egress network, kicking off a VPN
 * connection when ready, or setting firewall rules once VPN is connected.
 */

Body of Frist Method:
{
    final NetworkInfo egressInfo = mConnService.getActiveNetworkInfoUnfiltered();
    final LinkProperties egressProp = mConnService.getActiveLinkProperties();
    final NetworkInfo vpnInfo = mVpn.getNetworkInfo();
    final VpnConfig vpnConfig = mVpn.getLegacyVpnConfig();
    // Restart VPN when egress network disconnected or changed
    final boolean egressDisconnected = egressInfo == null || State.DISCONNECTED.equals(egressInfo.getState());
    final boolean egressChanged = egressProp == null || !TextUtils.equals(mAcceptedEgressIface, egressProp.getInterfaceName());
    final String egressTypeName = (egressInfo == null) ? null : ConnectivityManager.getNetworkTypeName(egressInfo.getType());
    final String egressIface = (egressProp == null) ? null : egressProp.getInterfaceName();
    Slog.d(TAG, "handleStateChanged: egress=" + egressTypeName + " " + mAcceptedEgressIface + "->" + egressIface);
    if (egressDisconnected || egressChanged) {
        clearSourceRulesLocked();
        mAcceptedEgressIface = null;
        mVpn.stopLegacyVpn();
    }
    if (egressDisconnected) {
        hideNotification();
        return;
    }
    final int egressType = egressInfo.getType();
    if (vpnInfo.getDetailedState() == DetailedState.FAILED) {
        EventLogTags.writeLockdownVpnError(egressType);
    }
    if (mErrorCount > MAX_ERROR_COUNT) {
        showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
    } else if (egressInfo.isConnected() && !vpnInfo.isConnectedOrConnecting()) {
        if (mProfile.isValidLockdownProfile()) {
            Slog.d(TAG, "Active network connected; starting VPN");
            EventLogTags.writeLockdownVpnConnecting(egressType);
            showNotification(R.string.vpn_lockdown_connecting, R.drawable.vpn_disconnected);
            mAcceptedEgressIface = egressProp.getInterfaceName();
            try {
                mVpn.startLegacyVpn(mProfile, KeyStore.getInstance(), egressProp);
            } catch (IllegalStateException e) {
                mAcceptedEgressIface = null;
                Slog.e(TAG, "Failed to start VPN", e);
                showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
            }
        } else {
            Slog.e(TAG, "Invalid VPN profile; requires IP-based server and DNS");
            showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
        }
    } else if (vpnInfo.isConnected() && vpnConfig != null) {
        final String iface = vpnConfig.interfaze;
        final List<LinkAddress> sourceAddrs = vpnConfig.addresses;
        if (TextUtils.equals(iface, mAcceptedIface) && sourceAddrs.equals(mAcceptedSourceAddr)) {
            return;
        }
        Slog.d(TAG, "VPN connected using iface=" + iface + ", sourceAddr=" + sourceAddrs.toString());
        EventLogTags.writeLockdownVpnConnected(egressType);
        showNotification(R.string.vpn_lockdown_connected, R.drawable.vpn_connected);
        try {
            clearSourceRulesLocked();
            mNetService.setFirewallInterfaceRule(iface, true);
            for (LinkAddress addr : sourceAddrs) {
                setFirewallEgressSourceRule(addr, true);
            }
            mNetService.setFirewallUidRule(ROOT_UID, true);
            mNetService.setFirewallUidRule(Os.getuid(), true);
            mErrorCount = 0;
            mAcceptedIface = iface;
            mAcceptedSourceAddr = sourceAddrs;
        } catch (RemoteException e) {
            throw new RuntimeException("Problem setting firewall rules", e);
        }
        mConnService.sendConnectedBroadcast(augmentNetworkInfo(egressInfo));
    }
}
Body of Second Method:
{
    final NetworkInfo egressInfo = mConnService.getActiveNetworkInfoUnfiltered();
    final LinkProperties egressProp = mConnService.getActiveLinkProperties();
    final NetworkInfo vpnInfo = mVpn.getNetworkInfo();
    final VpnConfig vpnConfig = mVpn.getLegacyVpnConfig();
    // Restart VPN when egress network disconnected or changed
    final boolean egressDisconnected = egressInfo == null || State.DISCONNECTED.equals(egressInfo.getState());
    final boolean egressChanged = egressProp == null || !TextUtils.equals(mAcceptedEgressIface, egressProp.getInterfaceName());
    final String egressTypeName = (egressInfo == null) ? null : ConnectivityManager.getNetworkTypeName(egressInfo.getType());
    final String egressIface = (egressProp == null) ? null : egressProp.getInterfaceName();
    Slog.d(TAG, "handleStateChanged: egress=" + egressTypeName + " " + mAcceptedEgressIface + "->" + egressIface);
    if (egressDisconnected || egressChanged) {
        clearSourceRulesLocked();
        mAcceptedEgressIface = null;
        mVpn.stopLegacyVpnPrivileged();
    }
    if (egressDisconnected) {
        hideNotification();
        return;
    }
    final int egressType = egressInfo.getType();
    if (vpnInfo.getDetailedState() == DetailedState.FAILED) {
        EventLogTags.writeLockdownVpnError(egressType);
    }
    if (mErrorCount > MAX_ERROR_COUNT) {
        showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
    } else if (egressInfo.isConnected() && !vpnInfo.isConnectedOrConnecting()) {
        if (mProfile.isValidLockdownProfile()) {
            Slog.d(TAG, "Active network connected; starting VPN");
            EventLogTags.writeLockdownVpnConnecting(egressType);
            showNotification(R.string.vpn_lockdown_connecting, R.drawable.vpn_disconnected);
            mAcceptedEgressIface = egressProp.getInterfaceName();
            try {
                // Use the privileged method because Lockdown VPN is initiated by the system, so
                // no additional permission checks are necessary.
                mVpn.startLegacyVpnPrivileged(mProfile, KeyStore.getInstance(), egressProp);
            } catch (IllegalStateException e) {
                mAcceptedEgressIface = null;
                Slog.e(TAG, "Failed to start VPN", e);
                showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
            }
        } else {
            Slog.e(TAG, "Invalid VPN profile; requires IP-based server and DNS");
            showNotification(R.string.vpn_lockdown_error, R.drawable.vpn_disconnected);
        }
    } else if (vpnInfo.isConnected() && vpnConfig != null) {
        final String iface = vpnConfig.interfaze;
        final List<LinkAddress> sourceAddrs = vpnConfig.addresses;
        if (TextUtils.equals(iface, mAcceptedIface) && sourceAddrs.equals(mAcceptedSourceAddr)) {
            return;
        }
        Slog.d(TAG, "VPN connected using iface=" + iface + ", sourceAddr=" + sourceAddrs.toString());
        EventLogTags.writeLockdownVpnConnected(egressType);
        showNotification(R.string.vpn_lockdown_connected, R.drawable.vpn_connected);
        try {
            clearSourceRulesLocked();
            mNetService.setFirewallInterfaceRule(iface, true);
            for (LinkAddress addr : sourceAddrs) {
                setFirewallEgressSourceRule(addr, true);
            }
            mNetService.setFirewallUidRule(ROOT_UID, true);
            mNetService.setFirewallUidRule(Os.getuid(), true);
            mErrorCount = 0;
            mAcceptedIface = iface;
            mAcceptedSourceAddr = sourceAddrs;
        } catch (RemoteException e) {
            throw new RuntimeException("Problem setting firewall rules", e);
        }
        mConnService.sendConnectedBroadcast(augmentNetworkInfo(egressInfo));
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testReplaceMatchMoreCerts:COMMENT
Method Modifier: public      
Comment:/*
     * Test that an app signed with a certificate can be upgraded by app
     * signed with a superset of certificates.
     */

Body of Frist Method:
{
    replaceCerts(APP1_CERT1, APP1_CERT1_CERT2, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(APP1_CERT1, APP1_CERT1_CERT2, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowStateAnimator.stepAnimationLocked:COMMENT
Method Modifier: 
Comment:// there is more animation to run.

Body of Frist Method:
{
    // Save the animation state as it was before this step so WindowManagerService can tell if
    // we just started or just stopped animating by comparing mWasAnimating with isAnimating().
    mWasAnimating = mAnimating;
    final DisplayContent displayContent = mWin.getDisplayContent();
    if (displayContent != null && mService.okToDisplay()) {
        if (mWin.isDrawnLw() && mAnimation != null) {
            mHasTransformation = true;
            mHasLocalTransformation = true;
            if (!mLocalAnimating) {
                if (DEBUG_ANIM)
                    Slog.v(TAG, "Starting animation in " + this + " @ " + currentTime + ": ww=" + mWin.mFrame.width() + " wh=" + mWin.mFrame.height() + " dw=" + mAnimDw + " dh=" + mAnimDh + " scale=" + mService.getWindowAnimationScaleLocked());
                mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), mAnimDw, mAnimDh);
                final DisplayInfo displayInfo = displayContent.getDisplayInfo();
                mAnimDw = displayInfo.appWidth;
                mAnimDh = displayInfo.appHeight;
                mAnimation.setStartTime(currentTime);
                mLocalAnimating = true;
                mAnimating = true;
            }
            if ((mAnimation != null) && mLocalAnimating) {
                if (stepAnimation(currentTime)) {
                    return true;
                }
            }
            if (DEBUG_ANIM)
                Slog.v(TAG, "Finished animation in " + this + " @ " + currentTime);
        // WindowManagerService.this.dump();
        }
        mHasLocalTransformation = false;
        if ((!mLocalAnimating || mAnimationIsEntrance) && mAppAnimator != null && mAppAnimator.animation != null) {
            // When our app token is animating, we kind-of pretend like
            // we are as well.  Note the mLocalAnimating mAnimationIsEntrance
            // part of this check means that we will only do this if
            // our window is not currently exiting, or it is not
            // locally animating itself.  The idea being that one that
            // is exiting and doing a local animation should be removed
            // once that animation is done.
            mAnimating = true;
            mHasTransformation = true;
            mTransformation.clear();
            return false;
        } else if (mHasTransformation) {
            // Little trick to get through the path below to act like
            // we have finished an animation.
            mAnimating = true;
        } else if (isAnimating()) {
            mAnimating = true;
        }
    } else if (mAnimation != null) {
        // If the display is frozen, and there is a pending animation,
        // clear it and make sure we run the cleanup code.
        mAnimating = true;
    }
    if (!mAnimating && !mLocalAnimating) {
        return false;
    }
    // Done animating, clean up.
    if (DEBUG_ANIM)
        Slog.v(TAG, "Animation done in " + this + ": exiting=" + mWin.mExiting + ", reportedVisible=" + (mWin.mAppToken != null ? mWin.mAppToken.reportedVisible : false));
    mAnimating = false;
    keyguardGoingAwayAnimation = false;
    mLocalAnimating = false;
    if (mAnimation != null) {
        mAnimation.cancel();
        mAnimation = null;
    }
    if (mAnimator.mWindowDetachedWallpaper == mWin) {
        mAnimator.mWindowDetachedWallpaper = null;
    }
    mAnimLayer = mWin.mLayer;
    if (mWin.mIsImWindow) {
        mAnimLayer += mService.mInputMethodAnimLayerAdjustment;
    } else if (mIsWallpaper) {
        mAnimLayer += mService.mWallpaperAnimLayerAdjustment;
    }
    if (DEBUG_LAYERS)
        Slog.v(TAG, "Stepping win " + this + " anim layer: " + mAnimLayer);
    mHasTransformation = false;
    mHasLocalTransformation = false;
    if (mWin.mPolicyVisibility != mWin.mPolicyVisibilityAfterAnim) {
        if (DEBUG_VISIBILITY) {
            Slog.v(TAG, "Policy visibility changing after anim in " + this + ": " + mWin.mPolicyVisibilityAfterAnim);
        }
        mWin.mPolicyVisibility = mWin.mPolicyVisibilityAfterAnim;
        if (displayContent != null) {
            displayContent.layoutNeeded = true;
        }
        if (!mWin.mPolicyVisibility) {
            if (mService.mCurrentFocus == mWin) {
                if (WindowManagerService.DEBUG_FOCUS_LIGHT)
                    Slog.i(TAG, "setAnimationLocked: setting mFocusMayChange true");
                mService.mFocusMayChange = true;
            }
            // Window is no longer visible -- make sure if we were waiting
            // for it to be displayed before enabling the display, that
            // we allow the display to be enabled now.
            mService.enableScreenIfNeededLocked();
        }
    }
    mTransformation.clear();
    if (mDrawState == HAS_DRAWN && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING && mWin.mAppToken != null && mWin.mAppToken.firstWindowDrawn && mWin.mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW)
            Slog.v(TAG, "Finish starting " + mWin.mToken + ": first real window done animating");
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
    } else if (mAttrType == LayoutParams.TYPE_STATUS_BAR && mWin.mPolicyVisibility) {
        // required.
        if (displayContent != null) {
            displayContent.layoutNeeded = true;
        }
    }
    finishExit();
    final int displayId = mWin.getDisplayId();
    mAnimator.setPendingLayoutChanges(displayId, WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
    if (WindowManagerService.DEBUG_LAYOUT_REPEATS)
        mService.debugLayoutRepeats("WindowStateAnimator", mAnimator.getPendingLayoutChanges(displayId));
    if (mWin.mAppToken != null) {
        mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return false;
}
Body of Second Method:
{
    // Save the animation state as it was before this step so WindowManagerService can tell if
    // we just started or just stopped animating by comparing mWasAnimating with isAnimating().
    mWasAnimating = mAnimating;
    final DisplayContent displayContent = mWin.getDisplayContent();
    if (displayContent != null && mService.okToDisplay()) {
        if (mWin.isDrawnLw() && mAnimation != null) {
            mHasTransformation = true;
            mHasLocalTransformation = true;
            if (!mLocalAnimating) {
                if (DEBUG_ANIM)
                    Slog.v(TAG, "Starting animation in " + this + " @ " + currentTime + ": ww=" + mWin.mFrame.width() + " wh=" + mWin.mFrame.height() + " dw=" + mAnimDw + " dh=" + mAnimDh + " scale=" + mService.getWindowAnimationScaleLocked());
                mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), mAnimDw, mAnimDh);
                final DisplayInfo displayInfo = displayContent.getDisplayInfo();
                mAnimDw = displayInfo.appWidth;
                mAnimDh = displayInfo.appHeight;
                mAnimation.setStartTime(mAnimationStartTime != -1 ? mAnimationStartTime : currentTime);
                mLocalAnimating = true;
                mAnimating = true;
            }
            if ((mAnimation != null) && mLocalAnimating) {
                mLastAnimationTime = currentTime;
                if (stepAnimation(currentTime)) {
                    return true;
                }
            }
            if (DEBUG_ANIM)
                Slog.v(TAG, "Finished animation in " + this + " @ " + currentTime);
        // WindowManagerService.this.dump();
        }
        mHasLocalTransformation = false;
        if ((!mLocalAnimating || mAnimationIsEntrance) && mAppAnimator != null && mAppAnimator.animation != null) {
            // When our app token is animating, we kind-of pretend like
            // we are as well.  Note the mLocalAnimating mAnimationIsEntrance
            // part of this check means that we will only do this if
            // our window is not currently exiting, or it is not
            // locally animating itself.  The idea being that one that
            // is exiting and doing a local animation should be removed
            // once that animation is done.
            mAnimating = true;
            mHasTransformation = true;
            mTransformation.clear();
            return false;
        } else if (mHasTransformation) {
            // Little trick to get through the path below to act like
            // we have finished an animation.
            mAnimating = true;
        } else if (isAnimating()) {
            mAnimating = true;
        }
    } else if (mAnimation != null) {
        // If the display is frozen, and there is a pending animation,
        // clear it and make sure we run the cleanup code.
        mAnimating = true;
    }
    if (!mAnimating && !mLocalAnimating) {
        return false;
    }
    // Done animating, clean up.
    if (DEBUG_ANIM)
        Slog.v(TAG, "Animation done in " + this + ": exiting=" + mWin.mExiting + ", reportedVisible=" + (mWin.mAppToken != null ? mWin.mAppToken.reportedVisible : false));
    mAnimating = false;
    mKeyguardGoingAwayAnimation = false;
    mLocalAnimating = false;
    if (mAnimation != null) {
        mAnimation.cancel();
        mAnimation = null;
    }
    if (mAnimator.mWindowDetachedWallpaper == mWin) {
        mAnimator.mWindowDetachedWallpaper = null;
    }
    mAnimLayer = mWin.mLayer;
    if (mWin.mIsImWindow) {
        mAnimLayer += mService.mInputMethodAnimLayerAdjustment;
    } else if (mIsWallpaper) {
        mAnimLayer += mService.mWallpaperAnimLayerAdjustment;
    }
    if (DEBUG_LAYERS)
        Slog.v(TAG, "Stepping win " + this + " anim layer: " + mAnimLayer);
    mHasTransformation = false;
    mHasLocalTransformation = false;
    if (mWin.mPolicyVisibility != mWin.mPolicyVisibilityAfterAnim) {
        if (DEBUG_VISIBILITY) {
            Slog.v(TAG, "Policy visibility changing after anim in " + this + ": " + mWin.mPolicyVisibilityAfterAnim);
        }
        mWin.mPolicyVisibility = mWin.mPolicyVisibilityAfterAnim;
        if (displayContent != null) {
            displayContent.layoutNeeded = true;
        }
        if (!mWin.mPolicyVisibility) {
            if (mService.mCurrentFocus == mWin) {
                if (WindowManagerService.DEBUG_FOCUS_LIGHT)
                    Slog.i(TAG, "setAnimationLocked: setting mFocusMayChange true");
                mService.mFocusMayChange = true;
            }
            // Window is no longer visible -- make sure if we were waiting
            // for it to be displayed before enabling the display, that
            // we allow the display to be enabled now.
            mService.enableScreenIfNeededLocked();
        }
    }
    mTransformation.clear();
    if (mDrawState == HAS_DRAWN && mWin.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING && mWin.mAppToken != null && mWin.mAppToken.firstWindowDrawn && mWin.mAppToken.startingData != null) {
        if (DEBUG_STARTING_WINDOW)
            Slog.v(TAG, "Finish starting " + mWin.mToken + ": first real window done animating");
        mService.mFinishedStarting.add(mWin.mAppToken);
        mService.mH.sendEmptyMessage(H.FINISHED_STARTING);
    } else if (mAttrType == LayoutParams.TYPE_STATUS_BAR && mWin.mPolicyVisibility) {
        // required.
        if (displayContent != null) {
            displayContent.layoutNeeded = true;
        }
    }
    finishExit();
    final int displayId = mWin.getDisplayId();
    mAnimator.setPendingLayoutChanges(displayId, WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
    if (WindowManagerService.DEBUG_LAYOUT_REPEATS)
        mService.debugLayoutRepeats("WindowStateAnimator", mAnimator.getPendingLayoutChanges(displayId));
    if (mWin.mAppToken != null) {
        mWin.mAppToken.updateReportedVisibilityLocked();
    }
    return false;
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.createActionBar:COMMENT
Method Modifier: private     
Comment:/**
 * Creates the action bar. Also queries the project callback for missing information.
 */

Body of Frist Method:
{
    ActionBarLayout actionBar = new ActionBarLayout(context, params);
    actionBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    return actionBar;
}
Body of Second Method:
{
    if (mIsThemeAppCompat == Boolean.TRUE) {
        return new AppCompatActionBar(context, params, parentView);
    } else {
        return new FrameworkActionBar(context, params, parentView);
    }
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getDefaultDataPhoneId:COMMENT
<android.telephony.SubscriptionManager: int getDefaultDataPhoneId()>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getPhoneId(getDefaultDataSubId());
}
Body of Second Method:
{
    return getPhoneId(getDefaultDataSubId());
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.setPictureListener:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the Picture listener. This is an interface used to receive
 * notifications of a new Picture.
 *
 * @param listener an implementation of WebView.PictureListener
 * @deprecated This method is now obsolete.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setPictureListener=" + listener);
    mProvider.setPictureListener(listener);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setPictureListener=" + listener);
    mProvider.setPictureListener(listener);
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.isBeingKeptAwakeLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Returns true if the device is being kept awake by a wake lock, user activity
 * or the stay on while powered setting.  We also keep the phone awake when
 * the proximity sensor returns a positive result so that the device does not
 * lock while in a phone call.  This function only controls whether the device
 * will go to sleep or dream which is independent of whether it will be allowed
 * to suspend.
 */

Body of Frist Method:
{
    return mStayOn || mProximityPositive || (mWakeLockSummary & WAKE_LOCK_STAY_AWAKE) != 0 || (mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0;
}
Body of Second Method:
{
    return mStayOn || mProximityPositive || (mWakeLockSummary & WAKE_LOCK_STAY_AWAKE) != 0 || (mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0 || mScreenBrightnessBoostInProgress;
}
------------------------
Find a functionally equivalent code:android.media.session.MediaSession.notifyRemoteVolumeChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify the system that the remote volume changed.
 *
 * @param provider The provider that is handling volume changes.
 * @hide
 */

Body of Frist Method:
{
    if (provider == null || provider != mVolumeProvider) {
        Log.w(TAG, "Received update from stale volume provider");
        return;
    }
    try {
        mBinder.setCurrentVolume(provider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.e(TAG, "Error in notifyVolumeChanged", e);
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (provider == null || provider != mVolumeProvider) {
            Log.w(TAG, "Received update from stale volume provider");
            return;
        }
    }
    try {
        mBinder.setCurrentVolume(provider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.e(TAG, "Error in notifyVolumeChanged", e);
    }
}
------------------------
Find a functionally equivalent code:android.widget.ImageView.setImageResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class="note">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */

Body of Frist Method:
{
    if (mUri != null || mResource != resId) {
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
Body of Second Method:
{
    // The resource configuration may have changed, so we should always
    // try to load the resource even if the resId hasn't changed.
    final int oldWidth = mDrawableWidth;
    final int oldHeight = mDrawableHeight;
    updateDrawable(null);
    mResource = resId;
    mUri = null;
    resolveUri();
    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
        requestLayout();
    }
    invalidate();
}
------------------------
Find a functionally equivalent code:android.widget.SimpleMonthAdapter.setSelectedDay:COMMENT
Method Modifier: public      
Comment:/**
 * Updates the selected day and related parameters.
 *
 * @param day The day to highlight
 */

Body of Frist Method:
{
    if (mSelectedDay != day) {
        mSelectedDay = day;
        notifyDataSetChanged();
    }
}
Body of Second Method:
{
    mSelectedDay = day;
    notifyDataSetChanged();
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDatabasePath:COMMENT
<android.webkit.WebSettings: String getDatabasePath()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the path to where database storage API databases are saved.
 *
 * @return the String path to the database storage API databases
 * @see #setDatabasePath
 * @deprecated Database paths are managed by the implementation this method is obsolete.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDisplayZoomControls:COMMENT
<android.webkit.WebSettings: boolean getDisplayZoomControls()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms.
 *
 * @return true if the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms
 * @see #setDisplayZoomControls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.SystemServer.startOtherServices:COMMENT
Method Modifier: private     
Comment:/**
 * Starts a miscellaneous grab bag of stuff that has yet to be refactored
 * and organized.
 */

Body of Frist Method:
{
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    MountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    BluetoothManagerService bluetooth = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableMedia = SystemProperties.getBoolean("config.disable_media", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableTelephony = SystemProperties.getBoolean("config.disable_telephony", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer(context));
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Manager Service");
            bluetooth = new BluetoothManagerService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        // if (!disableNonCoreServices) { // TODO: View depends on these; mock them?
        if (true) {
            try {
                Slog.i(TAG, "Input Method Service");
                imm = new InputMethodManagerService(context, wm);
                ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
            } catch (Throwable e) {
                reportWtf("starting Input Manager Service", e);
            }
            try {
                Slog.i(TAG, "Accessibility Manager");
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Accessibility Manager", e);
            }
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            mountService.waitForAsecScan();
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!disableMedia && !"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                audioService = new AudioService(context);
                ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
        }
        if (!disableMedia) {
            try {
                Slog.i(TAG, "Wired Accessory Manager");
                // Listen for wired headset changes
                inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
            } catch (Throwable e) {
                reportWtf("starting WiredAccessoryManager", e);
            }
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(UiModeManagerService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        if (!disableMedia) {
            try {
                Slog.i(TAG, "CommonTimeManagementService");
                commonTimeMgmtService = new CommonTimeManagementService(context);
                ServiceManager.addService("commontime_management", commonTimeMgmtService);
            } catch (Throwable e) {
                reportWtf("starting CommonTimeManagementService service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final MountService mountServiceF = mountService;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (mountServiceF != null)
                    mountServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Mount Service ready", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
Body of Second Method:
{
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    MountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    BluetoothManagerService bluetooth = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableMedia = SystemProperties.getBoolean("config.disable_media", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableTelephony = SystemProperties.getBoolean("config.disable_telephony", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        ServiceManager.addService("entropy", new EntropyMixer(context));
        mContentResolver = context.getContentResolver();
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Manager Service");
            bluetooth = new BluetoothManagerService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        // if (!disableNonCoreServices) { // TODO: View depends on these; mock them?
        if (true) {
            try {
                Slog.i(TAG, "Input Method Service");
                imm = new InputMethodManagerService(context, wm);
                ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
            } catch (Throwable e) {
                reportWtf("starting Input Manager Service", e);
            }
            try {
                Slog.i(TAG, "Accessibility Manager");
                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Accessibility Manager", e);
            }
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                Slog.i(TAG, "Mount Service");
                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            mountService.waitForAsecScan();
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        if (!disableMedia && !"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                Slog.i(TAG, "Audio Service");
                audioService = new AudioService(context);
                ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
            } catch (Throwable e) {
                reportWtf("starting Audio Service", e);
            }
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
        }
        if (!disableMedia) {
            try {
                Slog.i(TAG, "Wired Accessory Manager");
                // Listen for wired headset changes
                inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
            } catch (Throwable e) {
                reportWtf("starting WiredAccessoryManager", e);
            }
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(UiModeManagerService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        if (!disableMedia) {
            try {
                Slog.i(TAG, "CommonTimeManagementService");
                commonTimeMgmtService = new CommonTimeManagementService(context);
                ServiceManager.addService("commontime_management", commonTimeMgmtService);
            } catch (Throwable e) {
                reportWtf("starting CommonTimeManagementService service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final MountService mountServiceF = mountService;
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (mountServiceF != null)
                    mountServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Mount Service ready", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
------------------------
Find a functionally equivalent code:android.provider.Settings.Secure.setLocationModeForUser:COMMENT
Method Modifier: private     static      final       
Comment:/**
 * Thread-safe method for setting the location mode to one of
 * {@link #LOCATION_MODE_HIGH_ACCURACY}, {@link #LOCATION_MODE_SENSORS_ONLY},
 * {@link #LOCATION_MODE_BATTERY_SAVING}, or {@link #LOCATION_MODE_OFF}.
 *
 * @param cr the content resolver to use
 * @param mode such as {@link #LOCATION_MODE_HIGH_ACCURACY}
 * @param userId the userId for which to change mode
 * @return true if the value was set, false on database errors
 *
 * @throws IllegalArgumentException if mode is not one of the supported values
 */

Body of Frist Method:
{
    synchronized (mLocationSettingsLock) {
        boolean gps = false;
        boolean network = false;
        switch(mode) {
            case LOCATION_MODE_OFF:
                break;
            case LOCATION_MODE_SENSORS_ONLY:
                gps = true;
                break;
            case LOCATION_MODE_BATTERY_SAVING:
                network = true;
                break;
            case LOCATION_MODE_HIGH_ACCURACY:
                gps = true;
                network = true;
                break;
            default:
                throw new IllegalArgumentException("Invalid location mode: " + mode);
        }
        boolean gpsSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.GPS_PROVIDER, gps, userId);
        boolean nlpSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.NETWORK_PROVIDER, network, userId);
        return gpsSuccess && nlpSuccess;
    }
}
Body of Second Method:
{
    synchronized (mLocationSettingsLock) {
        boolean gps = false;
        boolean network = false;
        switch(mode) {
            case LOCATION_MODE_OFF:
                break;
            case LOCATION_MODE_SENSORS_ONLY:
                gps = true;
                break;
            case LOCATION_MODE_BATTERY_SAVING:
                network = true;
                break;
            case LOCATION_MODE_HIGH_ACCURACY:
                gps = true;
                network = true;
                break;
            default:
                throw new IllegalArgumentException("Invalid location mode: " + mode);
        }
        // Note it's important that we set the NLP mode first. The Google implementation
        // of NLP clears its NLP consent setting any time it receives a
        // LocationManager.PROVIDERS_CHANGED_ACTION broadcast and NLP is disabled. Also,
        // it shows an NLP consent dialog any time it receives the broadcast, NLP is
        // enabled, and the NLP consent is not set. If 1) we were to enable GPS first,
        // 2) a setup wizard has its own NLP consent UI that sets the NLP consent setting,
        // and 3) the receiver happened to complete before we enabled NLP, then the Google
        // NLP would detect the attempt to enable NLP and show a redundant NLP consent
        // dialog. Then the people who wrote the setup wizard would be sad.
        boolean nlpSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.NETWORK_PROVIDER, network, userId);
        boolean gpsSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.GPS_PROVIDER, gps, userId);
        return gpsSuccess && nlpSuccess;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getLoadWithOverviewMode:COMMENT
<android.webkit.WebSettings: boolean getLoadWithOverviewMode()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView loads pages in overview mode.
 *
 * @return whether this WebView loads pages in overview mode
 * @see #setLoadWithOverviewMode
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.SystemServer.startCoreServices:COMMENT
Method Modifier: private     
Comment:/**
 * Starts some essential services that are not tangled up in the bootstrap process.
 */

Body of Frist Method:
{
    // Manages LEDs and display backlight.
    mSystemServiceManager.startService(LightsService.class);
    // Tracks the battery level.  Requires LightService.
    mSystemServiceManager.startService(BatteryService.class);
    // Tracks application usage stats.
    mSystemServiceManager.startService(UsageStatsService.class);
    mActivityManagerService.setUsageStatsManager(LocalServices.getService(UsageStatsManagerInternal.class));
    // Tracks whether the updatable WebView is in a ready state and watches for update installs.
    mSystemServiceManager.startService(WebViewUpdateService.class);
}
Body of Second Method:
{
    // Manages LEDs and display backlight.
    mSystemServiceManager.startService(LightsService.class);
    // Tracks the battery level.  Requires LightService.
    mSystemServiceManager.startService(BatteryService.class);
    // Tracks application usage stats.
    mSystemServiceManager.startService(UsageStatsService.class);
    mActivityManagerService.setUsageStatsManager(LocalServices.getService(UsageStatsManagerInternal.class));
    // Update after UsageStatsService is available, needed before performBootDexOpt.
    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();
    // Tracks whether the updatable WebView is in a ready state and watches for update installs.
    mSystemServiceManager.startService(WebViewUpdateService.class);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAppCachePath:COMMENT
<android.webkit.WebSettings: void setAppCachePath(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the path to the Application Caches files. In order for the
 * Application Caches API to be enabled, this method must be called with a
 * path to which the application can write. This method should only be
 * called once: repeated calls are ignored.
 *
 * @param appCachePath a String path to the directory containing
 * Application Caches files.
 * @see #setAppCacheEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.Dialog.closeOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#closeOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a functionally equivalent code:android.os.BaseBundle.getBooleanArray:COMMENT
<android.os.BaseBundle: boolean[] getBooleanArray(String)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (boolean[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
Body of Second Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (boolean[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioManager.handleKeyDown:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                if (mUseMasterVolume) {
                    setMasterMute(!isMasterMute());
                } else {
                // TODO: Actually handle MUTE.
                }
            }
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.InsetDrawable.getHotspotBounds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mInsetState.mDrawable.getHotspotBounds(outRect);
}
Body of Second Method:
{
    mState.mDrawable.getHotspotBounds(outRect);
}
------------------------
Find a functionally equivalent code:android.media.MediaCodecInfo.VideoCapabilities.supportsFormat:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * @throws java.lang.ClassCastException
 */

Body of Frist Method:
{
    final Map<String, Object> map = format.getMap();
    Integer width = (Integer) map.get(MediaFormat.KEY_WIDTH);
    Integer height = (Integer) map.get(MediaFormat.KEY_HEIGHT);
    Double rate = (Double) map.get(MediaFormat.KEY_FRAME_RATE);
    return supports(width, height, rate);
}
Body of Second Method:
{
    final Map<String, Object> map = format.getMap();
    Integer width = (Integer) map.get(MediaFormat.KEY_WIDTH);
    Integer height = (Integer) map.get(MediaFormat.KEY_HEIGHT);
    Number rate = (Number) map.get(MediaFormat.KEY_FRAME_RATE);
    return supports(width, height, rate);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getUseWebViewBackgroundForOverscrollBackground:COMMENT
<android.webkit.WebSettings: boolean getUseWebViewBackgroundForOverscrollBackground()>
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether this WebView uses WebView's background instead of
 * internal pattern for over scroll background.
 *
 * @see #setUseWebViewBackgroundForOverscrollBackground
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebView.freeMemory:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 * @deprecated Memory caches are automatically dropped when no longer needed, and in response
 * to system memory pressure.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "freeMemory");
    mProvider.freeMemory();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "freeMemory");
    mProvider.freeMemory();
}
------------------------
Find a functionally equivalent code:android.media.tv.TvInputManager.Session.getSelectedTrack:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the selected track for a given type. Returns {@code null} if the information is
 * not available or any of the tracks for the given type is not selected.
 *
 * @return the ID of the selected track.
 * @see #selectTrack
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        return mSelectedAudioTrackId;
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        return mSelectedVideoTrackId;
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        return mSelectedSubtitleTrackId;
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            return mSelectedAudioTrackId;
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            return mSelectedVideoTrackId;
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            return mSelectedSubtitleTrackId;
        }
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
------------------------
Find a functionally equivalent code:android.text.StaticLayout.generate:COMMENT
Method Modifier: 
Comment:/* package */

Body of Frist Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    int ellipseEnd = endPos;
                    if (mMaximumVisibleLineCount == 1 && ellipsize == TextUtils.TruncateAt.MIDDLE) {
                        ellipseEnd = paraEnd;
                    }
                    v = out(source, here, ellipseEnd, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, true);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.hasHttpAuthUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: boolean hasHttpAuthUsernamePassword()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether there are any saved credentials for HTTP authentication.
 *
 * @return whether there are any saved credentials
 * @see WebView#getHttpAuthUsernamePassword
 * @see WebView#setHttpAuthUsernamePassword
 * @see #clearHttpAuthUsernamePassword
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getDefaultVoiceSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultVoiceSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultVoiceSubId, sub id = " + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultVoiceSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultVoiceSubId, sub id = " + subId);
    return subId;
}
------------------------
Find a functionally equivalent code:com.android.systemui.volume.VolumePanel.updateSlider:COMMENT
Method Modifier: private     
Comment:/**
 * Update the mute and progress state of a slider
 */

Body of Frist Method:
{
    updateSliderProgress(sc, -1);
    final boolean muted = isMuted(sc.streamType);
    // Force reloading the image resource
    sc.icon.setImageDrawable(null);
    updateSliderIcon(sc, muted);
    updateSliderEnabled(sc, muted, false);
    updateSliderSupressor(sc);
}
Body of Second Method:
{
    updateSliderProgress(sc, -1);
    final boolean muted = isMuted(sc.streamType);
    if (forceReloadIcon) {
        sc.icon.setImageDrawable(null);
    }
    updateSliderIcon(sc, muted);
    updateSliderEnabled(sc, muted, false);
    updateSliderSuppressor(sc);
}
------------------------
Find a functionally equivalent code:android.content.Intent.prepareToEnterProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        fixUris(mContentUserHint);
        mContentUserHint = UserHandle.USER_CURRENT;
    }
}
Body of Second Method:
{
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (UserHandle.getAppId(Process.myUid()) != Process.SYSTEM_UID) {
            fixUris(mContentUserHint);
            mContentUserHint = UserHandle.USER_CURRENT;
        }
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebViewDatabase.hasUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: boolean hasUsernamePassword()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether there are any saved username/password pairs for web forms.
 * Note that these are unrelated to HTTP authentication credentials.
 *
 * @return true if there are any saved username/password pairs
 * @see WebView#savePassword
 * @see #clearUsernamePassworda
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.model.RecentsPackageMonitor.register:COMMENT
Method Modifier: public      
Comment:/**
 * Registers the broadcast receivers with the specified callbacks.
 */

Body of Frist Method:
{
    mSystemServicesProxy = new SystemServicesProxy(context);
    mCb = cb;
    try {
        register(context, Looper.getMainLooper(), true);
    } catch (IllegalStateException e) {
        e.printStackTrace();
    }
}
Body of Second Method:
{
    mSystemServicesProxy = new SystemServicesProxy(context);
    mCb = cb;
    try {
        // We register for events from all users, but will cross-reference them with
        // packages for the current user and any profiles they have
        register(context, Looper.getMainLooper(), UserHandle.ALL, true);
    } catch (IllegalStateException e) {
        e.printStackTrace();
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteHost:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

Body of Frist Method:
{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        sService.deleteHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:android.app.Notification.BigPictureStyle.restoreFromExtras:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.restoreFromExtras(extras);
    if (extras.containsKey(EXTRA_LARGE_ICON_BIG)) {
        mBigLargeIcon = extras.getParcelable(EXTRA_LARGE_ICON_BIG);
    }
    mPicture = extras.getParcelable(EXTRA_PICTURE);
}
Body of Second Method:
{
    super.restoreFromExtras(extras);
    if (extras.containsKey(EXTRA_LARGE_ICON_BIG)) {
        mBigLargeIconSet = true;
        mBigLargeIcon = extras.getParcelable(EXTRA_LARGE_ICON_BIG);
    }
    mPicture = extras.getParcelable(EXTRA_PICTURE);
}
------------------------
Find a functionally equivalent code:com.android.server.am.ActivityStack.moveTaskToBackLocked:COMMENT
Method Modifier: default     final       
Comment:/**
 * Worker method for rearranging history stack. Implements the function of moving all
 * activities for a specific task (gathering them if disjoint) into a single group at the
 * bottom of the stack.
 *
 * If a watcher is installed, the action is preflighted and the watcher has an opportunity
 * to premeptively cancel the move.
 *
 * @param taskId The taskId to collect and move to the bottom.
 * @return Returns true if the move completed, false if not.
 */

Body of Frist Method:
{
    final TaskRecord tr = taskForIdLocked(taskId);
    if (tr == null) {
        Slog.i(TAG, "moveTaskToBack: bad taskId=" + taskId);
        return false;
    }
    Slog.i(TAG, "moveTaskToBack: " + tr);
    mStackSupervisor.endLockTaskModeIfTaskEnding(tr);
    // current task to be selected.
    if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
        ActivityRecord next = topRunningActivityLocked(null, taskId);
        if (next == null) {
            next = topRunningActivityLocked(null, 0);
        }
        if (next != null) {
            // ask watcher if this is allowed
            boolean moveOK = true;
            try {
                moveOK = mService.mController.activityResuming(next.packageName);
            } catch (RemoteException e) {
                mService.mController = null;
                Watchdog.getInstance().setActivityController(null);
            }
            if (!moveOK) {
                return false;
            }
        }
    }
    if (DEBUG_TRANSITION)
        Slog.v(TAG, "Prepare to back transition: task=" + taskId);
    mTaskHistory.remove(tr);
    mTaskHistory.add(0, tr);
    updateTaskMovement(tr, false);
    // There is an assumption that moving a task to the back moves it behind the home activity.
    // We make sure here that some activity in the stack will launch home.
    int numTasks = mTaskHistory.size();
    for (int taskNdx = numTasks - 1; taskNdx >= 1; --taskNdx) {
        final TaskRecord task = mTaskHistory.get(taskNdx);
        if (task.isOverHomeStack()) {
            break;
        }
        if (taskNdx == 1) {
            // Set the last task before tr to go to home.
            task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
        }
    }
    if (reason != null && (reason.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false);
        ActivityRecord r = topRunningActivityLocked(null);
        if (r != null) {
            mNoAnimActivities.add(r);
        }
    } else {
        mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK, false);
    }
    mWindowManager.moveTaskToBottom(taskId);
    if (VALIDATE_TOKENS) {
        validateAppTokensLocked();
    }
    final TaskRecord task = mResumedActivity != null ? mResumedActivity.task : null;
    if (task == tr && tr.isOverHomeStack() || numTasks <= 1 && isOnHomeDisplay()) {
        if (!mService.mBooting && !mService.mBooted) {
            // Not ready yet!
            return false;
        }
        final int taskToReturnTo = tr.getTaskToReturnTo();
        tr.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE);
        return mStackSupervisor.resumeHomeStackTask(taskToReturnTo, null);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    return true;
}
Body of Second Method:
{
    final TaskRecord tr = taskForIdLocked(taskId);
    if (tr == null) {
        Slog.i(TAG, "moveTaskToBack: bad taskId=" + taskId);
        return false;
    }
    Slog.i(TAG, "moveTaskToBack: " + tr);
    mStackSupervisor.endLockTaskModeIfTaskEnding(tr);
    // current task to be selected.
    if (mStackSupervisor.isFrontStack(this) && mService.mController != null) {
        ActivityRecord next = topRunningActivityLocked(null, taskId);
        if (next == null) {
            next = topRunningActivityLocked(null, 0);
        }
        if (next != null) {
            // ask watcher if this is allowed
            boolean moveOK = true;
            try {
                moveOK = mService.mController.activityResuming(next.packageName);
            } catch (RemoteException e) {
                mService.mController = null;
                Watchdog.getInstance().setActivityController(null);
            }
            if (!moveOK) {
                return false;
            }
        }
    }
    if (DEBUG_TRANSITION)
        Slog.v(TAG, "Prepare to back transition: task=" + taskId);
    mTaskHistory.remove(tr);
    mTaskHistory.add(0, tr);
    updateTaskMovement(tr, false);
    // There is an assumption that moving a task to the back moves it behind the home activity.
    // We make sure here that some activity in the stack will launch home.
    int numTasks = mTaskHistory.size();
    for (int taskNdx = numTasks - 1; taskNdx >= 1; --taskNdx) {
        final TaskRecord task = mTaskHistory.get(taskNdx);
        if (task.isOverHomeStack()) {
            break;
        }
        if (taskNdx == 1) {
            // Set the last task before tr to go to home.
            task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);
        }
    }
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_TO_BACK, false);
    mWindowManager.moveTaskToBottom(taskId);
    if (VALIDATE_TOKENS) {
        validateAppTokensLocked();
    }
    final TaskRecord task = mResumedActivity != null ? mResumedActivity.task : null;
    if (task == tr && tr.isOverHomeStack() || numTasks <= 1 && isOnHomeDisplay()) {
        if (!mService.mBooting && !mService.mBooted) {
            // Not ready yet!
            return false;
        }
        final int taskToReturnTo = tr.getTaskToReturnTo();
        tr.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE);
        return mStackSupervisor.resumeHomeStackTask(taskToReturnTo, null, "moveTaskToBack");
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    return true;
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.getOperatorAlphaLong:COMMENT
Method Modifier: public      
Comment:/**
 * Get current registered operator name in long alphanumeric format.
 *
 * In GSM/UMTS, long format can be up to 16 characters long.
 * In CDMA, returns the ERI text, if set. Otherwise, returns the ONS.
 *
 * @return long name of operator, null if unregistered or unknown
 */

Body of Frist Method:
{
    return mOperatorAlphaLong;
}
Body of Second Method:
{
    return mVoiceOperatorAlphaLong;
}
------------------------
Find a functionally equivalent code:android.bluetooth.BluetoothDevice.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return True if there is at least one open connection to this device.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.isConnected(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.getConnectionState(this) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.StatusBarWindowManager.add:COMMENT
Method Modifier: public      
Comment:/**
 * Adds the status bar view to the window manager.
 *
 * @param statusBarView The view to add.
 * @param barHeight The height of the status bar in collapsed state.
 */

Body of Frist Method:
{
    // Now that the status bar window encompasses the sliding panel and its
    // translucent backdrop, the entire thing is made TRANSLUCENT and is
    // hardware-accelerated.
    mLp = new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, barHeight, WindowManager.LayoutParams.TYPE_STATUS_BAR, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, PixelFormat.TRANSLUCENT);
    mLp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    mLp.gravity = Gravity.TOP;
    mLp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    mLp.setTitle("StatusBar");
    mLp.packageName = mContext.getPackageName();
    mStatusBarView = statusBarView;
    mBarHeight = barHeight;
    mWindowManager.addView(mStatusBarView, mLp);
}
Body of Second Method:
{
    // Now that the status bar window encompasses the sliding panel and its
    // translucent backdrop, the entire thing is made TRANSLUCENT and is
    // hardware-accelerated.
    mLp = new WindowManager.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, barHeight, WindowManager.LayoutParams.TYPE_STATUS_BAR, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, PixelFormat.TRANSLUCENT);
    mLp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    mLp.gravity = Gravity.TOP;
    mLp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    mLp.setTitle("StatusBar");
    mLp.packageName = mContext.getPackageName();
    mStatusBarView = statusBarView;
    mBarHeight = barHeight;
    mWindowManager.addView(mStatusBarView, mLp);
    mLpChanged = new WindowManager.LayoutParams();
    mLpChanged.copyFrom(mLp);
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsConfiguration.updateOnConfigurationChange:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the configuration has changed, and we want to reset any configuration specific
 * members.
 */

Body of Frist Method:
{
    launchedWithAltTab = false;
    launchedWithNoRecentTasks = false;
    launchedFromAppWithThumbnail = false;
    launchedFromAppWithScreenshot = false;
    launchedFromHome = false;
    launchedToTaskId = -1;
}
Body of Second Method:
{
    // Reset this flag on configuration change to ensure that we recreate new task views
    launchedReuseTaskStackViews = false;
    // Set this flag to indicate that the configuration has changed since Recents last launched
    launchedHasConfigurationChanged = true;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.onCreate:COMMENT
Method Modifier: public      
Comment:/**
 * Called with the activity is first created.
 */

Body of Frist Method:
{
    super.onCreate(savedInstanceState);
    // For the non-primary user, ensure that the SystemSericesProxy is initialized
    RecentsTaskLoader.initialize(this);
    // Initialize the loader and the configuration
    mConfig = RecentsConfiguration.reinitialize(this, RecentsTaskLoader.getInstance().getSystemServicesProxy());
    // Initialize the widget host (the host id is static and does not change)
    mAppWidgetHost = new RecentsAppWidgetHost(this, Constants.Values.App.AppWidgetHostId);
    // Set the Recents layout
    setContentView(R.layout.recents);
    mRecentsView = (RecentsView) findViewById(R.id.recents_view);
    mRecentsView.setCallbacks(this);
    mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mEmptyViewStub = (ViewStub) findViewById(R.id.empty_view_stub);
    mDebugOverlayStub = (ViewStub) findViewById(R.id.debug_overlay_stub);
    mScrimViews = new SystemBarScrimViews(this, mConfig);
    inflateDebugOverlay();
    // Bind the search app widget when we first start up
    bindSearchBarAppWidget();
    // Update the recent tasks
    updateRecentsTasks(getIntent());
    // Register the broadcast receiver to handle messages when the screen is turned off
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
    registerReceiver(mSystemBroadcastReceiver, filter);
    // Private API calls to make the shadows look better
    try {
        Utilities.setShadowProperty("ambientRatio", String.valueOf(1.5f));
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
    // Update if we are getting a configuration change
    if (savedInstanceState != null) {
        mConfig.updateOnConfigurationChange();
        onConfigurationChange();
    }
    // want it stalling the startup
    if (mConfig.searchBarAppWidgetId >= 0) {
        final WeakReference<RecentsAppWidgetHost.RecentsAppWidgetHostCallbacks> callback = new WeakReference<RecentsAppWidgetHost.RecentsAppWidgetHostCallbacks>(this);
        mRecentsView.post(new Runnable() {

            @Override
            public void run() {
                RecentsAppWidgetHost.RecentsAppWidgetHostCallbacks cb = callback.get();
                if (cb != null) {
                    mAppWidgetHost.startListening(cb);
                }
            }
        });
    }
}
Body of Second Method:
{
    super.onCreate(savedInstanceState);
    // For the non-primary user, ensure that the SystemServicesProxy and configuration is
    // initialized
    RecentsTaskLoader.initialize(this);
    SystemServicesProxy ssp = RecentsTaskLoader.getInstance().getSystemServicesProxy();
    mConfig = RecentsConfiguration.reinitialize(this, ssp);
    // Initialize the widget host (the host id is static and does not change)
    mAppWidgetHost = new RecentsAppWidgetHost(this, Constants.Values.App.AppWidgetHostId);
    // Set the Recents layout
    setContentView(R.layout.recents);
    mRecentsView = (RecentsView) findViewById(R.id.recents_view);
    mRecentsView.setCallbacks(this);
    mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mEmptyViewStub = (ViewStub) findViewById(R.id.empty_view_stub);
    mDebugOverlayStub = (ViewStub) findViewById(R.id.debug_overlay_stub);
    mScrimViews = new SystemBarScrimViews(this, mConfig);
    mStatusBar = ((SystemUIApplication) getApplication()).getComponent(PhoneStatusBar.class);
    inflateDebugOverlay();
    // Bind the search app widget when we first start up
    bindSearchBarAppWidget();
    // Register the broadcast receiver to handle messages when the screen is turned off
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
    registerReceiver(mSystemBroadcastReceiver, filter);
    // Private API calls to make the shadows look better
    try {
        Utilities.setShadowProperty("ambientRatio", String.valueOf(1.5f));
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.getAppWidgetIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.applyInvokeWithSystemProperty:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Applies invoke-with system properties to the zygote arguments.
 *
 * @param args non-null; zygote args
 */

Body of Frist Method:
{
    if (args.invokeWith == null && args.niceName != null) {
        if (args.niceName != null) {
            String property = "wrap." + args.niceName;
            if (property.length() > 31) {
                property = property.substring(0, 31);
            }
            args.invokeWith = SystemProperties.get(property);
            if (args.invokeWith != null && args.invokeWith.length() == 0) {
                args.invokeWith = null;
            }
        }
    }
}
Body of Second Method:
{
    if (args.invokeWith == null && args.niceName != null) {
        if (args.niceName != null) {
            String property = "wrap." + args.niceName;
            if (property.length() > 31) {
                // Avoid creating an illegal property name when truncating.
                if (property.charAt(30) != '.') {
                    property = property.substring(0, 31);
                } else {
                    property = property.substring(0, 30);
                }
            }
            args.invokeWith = SystemProperties.get(property);
            if (args.invokeWith != null && args.invokeWith.length() == 0) {
                args.invokeWith = null;
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.onTaskBound:COMMENT
Method Modifier: public      
Comment:/**
 * Binds this task view to the task
 */

Body of Frist Method:
{
    mTask = t;
    mTask.setCallbacks(this);
    if (getMeasuredWidth() == 0) {
        // If we haven't yet measured, we should just set the footer height with any animation
        animateFooterVisibility(t.lockToThisTask, 0);
    } else {
        animateFooterVisibility(t.lockToThisTask, mConfig.taskViewLockToAppLongAnimDuration);
    }
    // Hide the action button if lock to app is disabled
    if (!t.lockToTaskEnabled && mActionButtonView.getVisibility() != View.GONE) {
        mActionButtonView.setVisibility(View.GONE);
    }
}
Body of Second Method:
{
    mTask = t;
    mTask.setCallbacks(this);
    // Hide the action button if lock to app is disabled for this view
    int lockButtonVisibility = (!t.lockToTaskEnabled || !t.lockToThisTask) ? GONE : VISIBLE;
    if (mActionButtonView.getVisibility() != lockButtonVisibility) {
        mActionButtonView.setVisibility(lockButtonVisibility);
        requestLayout();
    }
}
------------------------
Find a functionally equivalent code:android.accessibilityservice.AccessibilityService.onBind:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */

Body of Frist Method:
{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}
Body of Second Method:
{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}
------------------------
Find a functionally equivalent code:android.app.Notification.WearableExtender.extend:COMMENT
Method Modifier: public      
Comment:/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */

Body of Frist Method:
{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
Body of Second Method:
{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
------------------------
Find a functionally equivalent code:android.webkit.WebBackForwardList.getCurrentItem:COMMENT
<android.webkit.WebBackForwardList: WebHistoryItem getCurrentItem()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the current history item. This method returns null if the list is
 * empty.
 * @return The current history item.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackViewTouchHandler.onInterceptTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Touch preprocessing for handling below
 */

Body of Frist Method:
{
    // Return early if we have no children
    boolean hasChildren = (mSv.getChildCount() > 0);
    if (!hasChildren) {
        return false;
    }
    // Pass through to swipe helper if we are swiping
    mInterceptedBySwipeHelper = mSwipeHelper.onInterceptTouchEvent(ev);
    if (mInterceptedBySwipeHelper) {
        return true;
    }
    boolean wasScrolling = mScroller.isScrolling() || (mScroller.mScrollAnimator != null && mScroller.mScrollAnimator.isRunning());
    int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                // Save the touch down info
                mInitialMotionX = mLastMotionX = (int) ev.getX();
                mInitialMotionY = mLastMotionY = (int) ev.getY();
                mInitialP = mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mActivePointerId = ev.getPointerId(0);
                mActiveTaskView = findViewAtPoint(mLastMotionX, mLastMotionY);
                // Stop the current scroll if it is still flinging
                mScroller.stopScroller();
                mScroller.stopBoundScrollAnimation();
                // Initialize the velocity tracker
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                // Check if the scroller is finished yet
                mIsScrolling = mScroller.isScrolling();
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mActivePointerId == INACTIVE_POINTER_ID)
                    break;
                int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                int y = (int) ev.getY(activePointerIndex);
                int x = (int) ev.getX(activePointerIndex);
                if (Math.abs(y - mInitialMotionY) > mScrollTouchSlop) {
                    // Save the touch move info
                    mIsScrolling = true;
                    // Initialize the velocity tracker if necessary
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                    // Disallow parents from intercepting touch events
                    final ViewParent parent = mSv.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                mLastMotionX = x;
                mLastMotionY = y;
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                // Animate the scroll back if we've cancelled
                mScroller.animateBoundScroll();
                // Reset the drag state and the velocity tracker
                mIsScrolling = false;
                mActivePointerId = INACTIVE_POINTER_ID;
                mActiveTaskView = null;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
    }
    return wasScrolling || mIsScrolling;
}
Body of Second Method:
{
    // Return early if we have no children
    boolean hasChildren = (mSv.getChildCount() > 0);
    if (!hasChildren) {
        return false;
    }
    // Pass through to swipe helper if we are swiping
    mInterceptedBySwipeHelper = mSwipeHelper.onInterceptTouchEvent(ev);
    if (mInterceptedBySwipeHelper) {
        return true;
    }
    boolean wasScrolling = mScroller.isScrolling() || (mScroller.mScrollAnimator != null && mScroller.mScrollAnimator.isRunning());
    int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                // Save the touch down info
                mInitialMotionX = mLastMotionX = (int) ev.getX();
                mInitialMotionY = mLastMotionY = (int) ev.getY();
                mInitialP = mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                mActivePointerId = ev.getPointerId(0);
                mActiveTaskView = findViewAtPoint(mLastMotionX, mLastMotionY);
                // Stop the current scroll if it is still flinging
                mScroller.stopScroller();
                mScroller.stopBoundScrollAnimation();
                // Initialize the velocity tracker
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mActivePointerId == INACTIVE_POINTER_ID)
                    break;
                // Initialize the velocity tracker if necessary
                initVelocityTrackerIfNotExists();
                mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
                int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                int y = (int) ev.getY(activePointerIndex);
                int x = (int) ev.getX(activePointerIndex);
                if (Math.abs(y - mInitialMotionY) > mScrollTouchSlop) {
                    // Save the touch move info
                    mIsScrolling = true;
                    // Disallow parents from intercepting touch events
                    final ViewParent parent = mSv.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                mLastMotionX = x;
                mLastMotionY = y;
                mLastP = mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                // Animate the scroll back if we've cancelled
                mScroller.animateBoundScroll();
                // Reset the drag state and the velocity tracker
                mIsScrolling = false;
                mActivePointerId = INACTIVE_POINTER_ID;
                mActiveTaskView = null;
                mTotalPMotion = 0;
                recycleVelocityTracker();
                break;
            }
    }
    return wasScrolling || mIsScrolling;
}
------------------------
Find a functionally equivalent code:android.telephony.ServiceState.setOperatorAlphaLong:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * In CDMA, mOperatorAlphaLong can be set from the ERI text.
 * This is done from the CDMAPhone and not from the CdmaServiceStateTracker.
 *
 * @hide
 */

Body of Frist Method:
{
    mOperatorAlphaLong = longName;
}
Body of Second Method:
{
    mVoiceOperatorAlphaLong = longName;
    mDataOperatorAlphaLong = longName;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.showBootMessage:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                int theme;
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                } else {
                    theme = 0;
                }
                mBootMsgDialog = new ProgressDialog(mContext, theme) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            mBootMsgDialog.setMessage(msg);
        }
    });
}
Body of Second Method:
{
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                int theme;
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                } else {
                    theme = 0;
                }
                mBootMsgDialog = new ProgressDialog(mContext, theme) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                if (mContext.getPackageManager().isUpgrade()) {
                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                } else {
                    mBootMsgDialog.setTitle(R.string.android_start_title);
                }
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            mBootMsgDialog.setMessage(msg);
        }
    });
}
------------------------
Find a functionally equivalent code:android.content.res.Configuration.resourceQualifierString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a string representation of the configuration that can be parsed
 * by build tools (like AAPT).
 *
 * @hide
 */

Body of Frist Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add(config.mcc + "mcc");
        if (config.mnc != 0) {
            parts.add(config.mnc + "mnc");
        }
    }
    if (!config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
Body of Second Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add("mcc" + config.mcc);
        if (config.mnc != 0) {
            parts.add("mnc" + config.mnc);
        }
    }
    if (config.locale != null && !config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.Bridge.resolveResourceId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns details of a framework resource from its integer value.
 * @param value the integer value
 * @return a Pair containing the resource type and name, or null if the id
 * does not match any resource.
 */

Body of Frist Method:
{
    Pair<ResourceType, String> pair = sRMap.get(value);
    if (pair == null) {
        pair = sDynamicIds.resolveId(value);
        if (pair == null) {
        // System.out.println(String.format("Missing id: %1$08X (%1$d)", value));
        }
    }
    return pair;
}
Body of Second Method:
{
    Pair<ResourceType, String> pair = sRMap.get(value);
    if (pair == null) {
        pair = sDynamicIds.resolveId(value);
        if (pair == null) {
        // System.out.println(String.format("Missing id: %1$08X (%1$d)", value));
        }
    }
    return pair;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setUseWideViewPort:COMMENT
<android.webkit.WebSettings: void setUseWideViewPort(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should enable support for the &quot;viewport&quot;
 * HTML meta tag or should use a wide viewport.
 * When the value of the setting is false, the layout width is always set to the
 * width of the WebView control in device-independent (CSS) pixels.
 * When the value is true and the page contains the viewport meta tag, the value
 * of the width specified in the tag is used. If the page does not contain the tag or
 * does not provide a width, then a wide viewport will be used.
 *
 * @param use whether to enable support for the viewport meta tag
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.accounts.AccountManagerService.validateAccountsInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Validate internal set of accounts against installed authenticators for
 * given user. Clear cached authenticators before validating when requested.
 */

Body of Frist Method:
{
    if (invalidateAuthenticatorCache) {
        mAuthenticatorCache.invalidateCache(accounts.userId);
    }
    final HashSet<AuthenticatorDescription> knownAuth = Sets.newHashSet();
    for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : mAuthenticatorCache.getAllServices(accounts.userId)) {
        knownAuth.add(service.type);
    }
    synchronized (accounts.cacheLock) {
        final SQLiteDatabase db = accounts.openHelper.getWritableDatabase();
        boolean accountDeleted = false;
        Cursor cursor = db.query(TABLE_ACCOUNTS, new String[] { ACCOUNTS_ID, ACCOUNTS_TYPE, ACCOUNTS_NAME }, null, null, null, null, null);
        try {
            accounts.accountCache.clear();
            final HashMap<String, ArrayList<String>> accountNamesByType = new LinkedHashMap<String, ArrayList<String>>();
            while (cursor.moveToNext()) {
                final long accountId = cursor.getLong(0);
                final String accountType = cursor.getString(1);
                final String accountName = cursor.getString(2);
                if (!knownAuth.contains(AuthenticatorDescription.newKey(accountType))) {
                    Slog.w(TAG, "deleting account " + accountName + " because type " + accountType + " no longer has a registered authenticator");
                    db.delete(TABLE_ACCOUNTS, ACCOUNTS_ID + "=" + accountId, null);
                    accountDeleted = true;
                    final Account account = new Account(accountName, accountType);
                    accounts.userDataCache.remove(account);
                    accounts.authTokenCache.remove(account);
                } else {
                    ArrayList<String> accountNames = accountNamesByType.get(accountType);
                    if (accountNames == null) {
                        accountNames = new ArrayList<String>();
                        accountNamesByType.put(accountType, accountNames);
                    }
                    accountNames.add(accountName);
                }
            }
            for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {
                final String accountType = cur.getKey();
                final ArrayList<String> accountNames = cur.getValue();
                final Account[] accountsForType = new Account[accountNames.size()];
                int i = 0;
                for (String accountName : accountNames) {
                    accountsForType[i] = new Account(accountName, accountType);
                    ++i;
                }
                accounts.accountCache.put(accountType, accountsForType);
            }
        } finally {
            cursor.close();
            if (accountDeleted) {
                sendAccountsChangedBroadcast(accounts.userId);
            }
        }
    }
}
Body of Second Method:
{
    if (invalidateAuthenticatorCache) {
        mAuthenticatorCache.invalidateCache(accounts.userId);
    }
    final HashSet<AuthenticatorDescription> knownAuth = Sets.newHashSet();
    for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : mAuthenticatorCache.getAllServices(accounts.userId)) {
        knownAuth.add(service.type);
    }
    synchronized (accounts.cacheLock) {
        final SQLiteDatabase db = accounts.openHelper.getWritableDatabase();
        boolean accountDeleted = false;
        Cursor cursor = db.query(TABLE_ACCOUNTS, new String[] { ACCOUNTS_ID, ACCOUNTS_TYPE, ACCOUNTS_NAME }, null, null, null, null, ACCOUNTS_ID);
        try {
            accounts.accountCache.clear();
            final HashMap<String, ArrayList<String>> accountNamesByType = new LinkedHashMap<String, ArrayList<String>>();
            while (cursor.moveToNext()) {
                final long accountId = cursor.getLong(0);
                final String accountType = cursor.getString(1);
                final String accountName = cursor.getString(2);
                if (!knownAuth.contains(AuthenticatorDescription.newKey(accountType))) {
                    Slog.w(TAG, "deleting account " + accountName + " because type " + accountType + " no longer has a registered authenticator");
                    db.delete(TABLE_ACCOUNTS, ACCOUNTS_ID + "=" + accountId, null);
                    accountDeleted = true;
                    final Account account = new Account(accountName, accountType);
                    accounts.userDataCache.remove(account);
                    accounts.authTokenCache.remove(account);
                } else {
                    ArrayList<String> accountNames = accountNamesByType.get(accountType);
                    if (accountNames == null) {
                        accountNames = new ArrayList<String>();
                        accountNamesByType.put(accountType, accountNames);
                    }
                    accountNames.add(accountName);
                }
            }
            for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {
                final String accountType = cur.getKey();
                final ArrayList<String> accountNames = cur.getValue();
                final Account[] accountsForType = new Account[accountNames.size()];
                int i = 0;
                for (String accountName : accountNames) {
                    accountsForType[i] = new Account(accountName, accountType);
                    ++i;
                }
                accounts.accountCache.put(accountType, accountsForType);
            }
        } finally {
            cursor.close();
            if (accountDeleted) {
                sendAccountsChangedBroadcast(accounts.userId);
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.backup.PackageManagerBackupAgent.onBackup:COMMENT
Method Modifier: public      
Comment:// the package name.

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, "onBackup()");
    // we'll reuse these
    ByteArrayOutputStream outputBuffer = new ByteArrayOutputStream();
    DataOutputStream outputBufferStream = new DataOutputStream(outputBuffer);
    parseStateFile(oldState);
    // "already backed up" map built by parseStateFile().
    if (mStoredIncrementalVersion == null || !mStoredIncrementalVersion.equals(Build.VERSION.INCREMENTAL)) {
        Slog.i(TAG, "Previous metadata " + mStoredIncrementalVersion + " mismatch vs " + Build.VERSION.INCREMENTAL + " - rewriting");
        mExisting.clear();
    }
    long homeVersion = 0;
    ArrayList<byte[]> homeSigHashes = null;
    PackageInfo homeInfo = null;
    String homeInstaller = null;
    ComponentName home = getPreferredHomeComponent();
    if (home != null) {
        try {
            homeInfo = mPackageManager.getPackageInfo(home.getPackageName(), PackageManager.GET_SIGNATURES);
            homeInstaller = mPackageManager.getInstallerPackageName(home.getPackageName());
            homeVersion = homeInfo.versionCode;
            homeSigHashes = hashSignatureArray(homeInfo.signatures);
        } catch (NameNotFoundException e) {
            Slog.w(TAG, "Can't access preferred home info");
            // proceed as though there were no preferred home set
            home = null;
        }
    }
    try {
        // We need to push a new preferred-home-app record if:
        // 1. the version of the home app has changed since our last backup;
        // 2. the home app [or absence] we now use differs from the prior state,
        // OR 3. it looks like we use the same home app + version as before, but
        // the signatures don't match so we treat them as different apps.
        final boolean needHomeBackup = (homeVersion != mStoredHomeVersion) || Objects.equals(home, mStoredHomeComponent) || (home != null && !BackupManagerService.signaturesMatch(mStoredHomeSigHashes, homeInfo));
        if (needHomeBackup) {
            if (DEBUG) {
                Slog.i(TAG, "Home preference changed; backing up new state " + home);
            }
            if (home != null) {
                outputBufferStream.writeUTF(home.flattenToString());
                outputBufferStream.writeLong(homeVersion);
                outputBufferStream.writeUTF(homeInstaller != null ? homeInstaller : "");
                writeSignatureHashArray(outputBufferStream, homeSigHashes);
                writeEntity(data, DEFAULT_HOME_KEY, outputBuffer.toByteArray());
            } else {
                data.writeEntityHeader(DEFAULT_HOME_KEY, -1);
            }
        }
        /*
             * Global metadata:
             *
             * int SDKversion -- the SDK version of the OS itself on the device
             *                   that produced this backup set.  Used to reject
             *                   backups from later OSes onto earlier ones.
             * String incremental -- the incremental release name of the OS stored in
             *                       the backup set.
             */
        outputBuffer.reset();
        if (!mExisting.contains(GLOBAL_METADATA_KEY)) {
            if (DEBUG)
                Slog.v(TAG, "Storing global metadata key");
            outputBufferStream.writeInt(Build.VERSION.SDK_INT);
            outputBufferStream.writeUTF(Build.VERSION.INCREMENTAL);
            writeEntity(data, GLOBAL_METADATA_KEY, outputBuffer.toByteArray());
        } else {
            if (DEBUG)
                Slog.v(TAG, "Global metadata key already stored");
            // don't consider it to have been skipped/deleted
            mExisting.remove(GLOBAL_METADATA_KEY);
        }
        // write its signature block to the output, keyed on the package name.
        for (PackageInfo pkg : mAllPackages) {
            String packName = pkg.packageName;
            if (packName.equals(GLOBAL_METADATA_KEY)) {
                // We've already handled the metadata key; skip it here
                continue;
            } else {
                PackageInfo info = null;
                try {
                    info = mPackageManager.getPackageInfo(packName, PackageManager.GET_SIGNATURES);
                } catch (NameNotFoundException e) {
                    // Weird; we just found it, and now are told it doesn't exist.
                    // Treat it as having been removed from the device.
                    mExisting.add(packName);
                    continue;
                }
                if (mExisting.contains(packName)) {
                    // We have backed up this app before.  Check whether the version
                    // of the backup matches the version of the current app; if they
                    // don't match, the app has been updated and we need to store its
                    // metadata again.  In either case, take it out of mExisting so that
                    // we don't consider it deleted later.
                    mExisting.remove(packName);
                    if (info.versionCode == mStateVersions.get(packName).versionCode) {
                        continue;
                    }
                }
                if (info.signatures == null || info.signatures.length == 0) {
                    Slog.w(TAG, "Not backing up package " + packName + " since it appears to have no signatures.");
                    continue;
                }
                // We need to store this app's metadata
                /*
                     * Metadata for each package:
                     *
                     * int version       -- [4] the package's versionCode
                     * byte[] signatures -- [len] flattened signature hash array of the package
                     */
                // marshal the version code in a canonical form
                outputBuffer.reset();
                outputBufferStream.writeInt(info.versionCode);
                writeSignatureHashArray(outputBufferStream, hashSignatureArray(info.signatures));
                if (DEBUG) {
                    Slog.v(TAG, "+ writing metadata for " + packName + " version=" + info.versionCode + " entityLen=" + outputBuffer.size());
                }
                // Now we can write the backup entity for this package
                writeEntity(data, packName, outputBuffer.toByteArray());
            }
        }
        // on the device.  Write a deletion entity for them.
        for (String app : mExisting) {
            if (DEBUG)
                Slog.v(TAG, "- removing metadata for deleted pkg " + app);
            try {
                data.writeEntityHeader(app, -1);
            } catch (IOException e) {
                Slog.e(TAG, "Unable to write package deletions!");
                return;
            }
        }
    } catch (IOException e) {
        // Real error writing data
        Slog.e(TAG, "Unable to write package backup data file!");
        return;
    }
    // Finally, write the new state blob -- just the list of all apps we handled
    writeStateFile(mAllPackages, home, homeVersion, homeSigHashes, newState);
}
Body of Second Method:
{
    if (DEBUG)
        Slog.v(TAG, "onBackup()");
    // we'll reuse these
    ByteArrayOutputStream outputBuffer = new ByteArrayOutputStream();
    DataOutputStream outputBufferStream = new DataOutputStream(outputBuffer);
    parseStateFile(oldState);
    // "already backed up" map built by parseStateFile().
    if (mStoredIncrementalVersion == null || !mStoredIncrementalVersion.equals(Build.VERSION.INCREMENTAL)) {
        Slog.i(TAG, "Previous metadata " + mStoredIncrementalVersion + " mismatch vs " + Build.VERSION.INCREMENTAL + " - rewriting");
        mExisting.clear();
    }
    long homeVersion = 0;
    ArrayList<byte[]> homeSigHashes = null;
    PackageInfo homeInfo = null;
    String homeInstaller = null;
    ComponentName home = getPreferredHomeComponent();
    if (home != null) {
        try {
            homeInfo = mPackageManager.getPackageInfo(home.getPackageName(), PackageManager.GET_SIGNATURES);
            homeInstaller = mPackageManager.getInstallerPackageName(home.getPackageName());
            homeVersion = homeInfo.versionCode;
            homeSigHashes = hashSignatureArray(homeInfo.signatures);
        } catch (NameNotFoundException e) {
            Slog.w(TAG, "Can't access preferred home info");
            // proceed as though there were no preferred home set
            home = null;
        }
    }
    try {
        // We need to push a new preferred-home-app record if:
        // 1. the version of the home app has changed since our last backup;
        // 2. the home app [or absence] we now use differs from the prior state,
        // OR 3. it looks like we use the same home app + version as before, but
        // the signatures don't match so we treat them as different apps.
        final boolean needHomeBackup = (homeVersion != mStoredHomeVersion) || !Objects.equals(home, mStoredHomeComponent) || (home != null && !BackupManagerService.signaturesMatch(mStoredHomeSigHashes, homeInfo));
        if (needHomeBackup) {
            if (DEBUG) {
                Slog.i(TAG, "Home preference changed; backing up new state " + home);
            }
            if (home != null) {
                outputBufferStream.writeUTF(home.flattenToString());
                outputBufferStream.writeLong(homeVersion);
                outputBufferStream.writeUTF(homeInstaller != null ? homeInstaller : "");
                writeSignatureHashArray(outputBufferStream, homeSigHashes);
                writeEntity(data, DEFAULT_HOME_KEY, outputBuffer.toByteArray());
            } else {
                data.writeEntityHeader(DEFAULT_HOME_KEY, -1);
            }
        }
        /*
             * Global metadata:
             *
             * int SDKversion -- the SDK version of the OS itself on the device
             *                   that produced this backup set.  Used to reject
             *                   backups from later OSes onto earlier ones.
             * String incremental -- the incremental release name of the OS stored in
             *                       the backup set.
             */
        outputBuffer.reset();
        if (!mExisting.contains(GLOBAL_METADATA_KEY)) {
            if (DEBUG)
                Slog.v(TAG, "Storing global metadata key");
            outputBufferStream.writeInt(Build.VERSION.SDK_INT);
            outputBufferStream.writeUTF(Build.VERSION.INCREMENTAL);
            writeEntity(data, GLOBAL_METADATA_KEY, outputBuffer.toByteArray());
        } else {
            if (DEBUG)
                Slog.v(TAG, "Global metadata key already stored");
            // don't consider it to have been skipped/deleted
            mExisting.remove(GLOBAL_METADATA_KEY);
        }
        // write its signature block to the output, keyed on the package name.
        for (PackageInfo pkg : mAllPackages) {
            String packName = pkg.packageName;
            if (packName.equals(GLOBAL_METADATA_KEY)) {
                // We've already handled the metadata key; skip it here
                continue;
            } else {
                PackageInfo info = null;
                try {
                    info = mPackageManager.getPackageInfo(packName, PackageManager.GET_SIGNATURES);
                } catch (NameNotFoundException e) {
                    // Weird; we just found it, and now are told it doesn't exist.
                    // Treat it as having been removed from the device.
                    mExisting.add(packName);
                    continue;
                }
                if (mExisting.contains(packName)) {
                    // We have backed up this app before.  Check whether the version
                    // of the backup matches the version of the current app; if they
                    // don't match, the app has been updated and we need to store its
                    // metadata again.  In either case, take it out of mExisting so that
                    // we don't consider it deleted later.
                    mExisting.remove(packName);
                    if (info.versionCode == mStateVersions.get(packName).versionCode) {
                        continue;
                    }
                }
                if (info.signatures == null || info.signatures.length == 0) {
                    Slog.w(TAG, "Not backing up package " + packName + " since it appears to have no signatures.");
                    continue;
                }
                // We need to store this app's metadata
                /*
                     * Metadata for each package:
                     *
                     * int version       -- [4] the package's versionCode
                     * byte[] signatures -- [len] flattened signature hash array of the package
                     */
                // marshal the version code in a canonical form
                outputBuffer.reset();
                outputBufferStream.writeInt(info.versionCode);
                writeSignatureHashArray(outputBufferStream, hashSignatureArray(info.signatures));
                if (DEBUG) {
                    Slog.v(TAG, "+ writing metadata for " + packName + " version=" + info.versionCode + " entityLen=" + outputBuffer.size());
                }
                // Now we can write the backup entity for this package
                writeEntity(data, packName, outputBuffer.toByteArray());
            }
        }
        // on the device.  Write a deletion entity for them.
        for (String app : mExisting) {
            if (DEBUG)
                Slog.v(TAG, "- removing metadata for deleted pkg " + app);
            try {
                data.writeEntityHeader(app, -1);
            } catch (IOException e) {
                Slog.e(TAG, "Unable to write package deletions!");
                return;
            }
        }
    } catch (IOException e) {
        // Real error writing data
        Slog.e(TAG, "Unable to write package backup data file!");
        return;
    }
    // Finally, write the new state blob -- just the list of all apps we handled
    writeStateFile(mAllPackages, home, homeVersion, homeSigHashes, newState);
}
------------------------
Find a functionally equivalent code:android.content.res.ColorStateList.addFirstIfMissing:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * If the color state list does not already have an entry matching the
 * specified state, prepends a state set and color pair to a color state
 * list.
 * <p>
 * This is a workaround used in TimePicker and DatePicker until we can
 * add support for theme attributes in ColorStateList.
 *
 * @param colorStateList the source color state list
 * @param state the state to prepend
 * @param color the color to use for the given state
 * @return a new color state list, or the source color state list if there
 * was already a matching state set
 *
 * @hide Remove when we can support theme attributes.
 */

Body of Frist Method:
{
    final int[][] inputStates = colorStateList.getStates();
    for (int i = 0; i < inputStates.length; i++) {
        final int[] inputState = inputStates[i];
        for (int j = 0; j < inputState.length; j++) {
            if (inputState[i] == state) {
                return colorStateList;
            }
        }
    }
    final int[][] outputStates = new int[inputStates.length + 1][];
    System.arraycopy(inputStates, 0, outputStates, 1, inputStates.length);
    outputStates[0] = new int[] { state };
    final int[] inputColors = colorStateList.getColors();
    final int[] outputColors = new int[inputColors.length + 1];
    System.arraycopy(inputColors, 0, outputColors, 1, inputColors.length);
    outputColors[0] = color;
    return new ColorStateList(outputStates, outputColors);
}
Body of Second Method:
{
    final int[][] inputStates = colorStateList.getStates();
    for (int i = 0; i < inputStates.length; i++) {
        final int[] inputState = inputStates[i];
        for (int j = 0; j < inputState.length; j++) {
            if (inputState[j] == state) {
                return colorStateList;
            }
        }
    }
    final int[][] outputStates = new int[inputStates.length + 1][];
    System.arraycopy(inputStates, 0, outputStates, 1, inputStates.length);
    outputStates[0] = new int[] { state };
    final int[] inputColors = colorStateList.getColors();
    final int[] outputColors = new int[inputColors.length + 1];
    System.arraycopy(inputColors, 0, outputColors, 1, inputColors.length);
    outputColors[0] = color;
    return new ColorStateList(outputStates, outputColors);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getLoadsImagesAutomatically:COMMENT
<android.webkit.WebSettings: boolean getLoadsImagesAutomatically()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView loads image resources. This includes
 * images embedded using the data URI scheme.
 *
 * @return true if the WebView loads image resources
 * @see #setLoadsImagesAutomatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getAllowContentAccess:COMMENT
<android.webkit.WebSettings: boolean getAllowContentAccess()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView supports content URL access.
 *
 * @see #setAllowContentAccess
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebBackForwardList.getCurrentIndex:COMMENT
<android.webkit.WebBackForwardList: int getCurrentIndex()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the index of the current history item. This index can be used to
 * directly index into the array list.
 * @return The current index from 0...n or -1 if the list is empty.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.SecureCameraLaunchManager.onSwipingStarted:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the user is starting to swipe horizontally, possibly to start the secure camera.
 * Although this swipe ultimately may not result in the secure camera opening, we need to stop
 * all other camera usage (e.g., Face Unlock) as soon as possible.  We send out a broadcast to
 * notify other apps that they should close the camera immediately.  The broadcast is sent even
 * if the camera appears to be available, because there could be an app that is about to open
 * the camera.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "onSwipingStarted");
    AsyncTask.execute(new Runnable() {

        @Override
        public void run() {
            Intent intent = new Intent();
            intent.setAction(CLOSE_CAMERA_ACTION_NAME);
            mContext.sendBroadcast(intent);
        }
    });
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "onSwipingStarted");
    AsyncTask.execute(new Runnable() {

        @Override
        public void run() {
            Intent intent = new Intent();
            intent.setAction(CLOSE_CAMERA_ACTION_NAME);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            mContext.sendBroadcast(intent);
        }
    });
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.usingBiometricWeak:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return true if the lockscreen method is set to biometric weak
 */

Body of Frist Method:
{
    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    return quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
}
Body of Second Method:
{
    return usingBiometricWeak(getCurrentOrCallingUserId());
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setAllowFileAccess:COMMENT
<android.webkit.WebSettings: void setAllowFileAccess(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Enables or disables file access within WebView. File access is enabled by
 * default.  Note that this enables or disables file system access only.
 * Assets and resources are still accessible using file:///android_asset and
 * file:///android_res.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.RssiCurve.lookupScore:COMMENT
Method Modifier: public      
Comment:/**
 * Lookup the score for a given RSSI value.
 *
 * @param rssi The RSSI to lookup. If the RSSI falls below the start of the curve, the score at
 * the start of the curve will be returned. If it falls after the end of the curve, the
 * score at the end of the curve will be returned.
 * @return the score for the given RSSI.
 */

Body of Frist Method:
{
    int index = (rssi - start) / bucketWidth;
    // Snap the index to the closest bucket if it falls outside the curve.
    if (index < 0) {
        index = 0;
    } else if (index > rssiBuckets.length - 1) {
        index = rssiBuckets.length - 1;
    }
    return rssiBuckets[index];
}
Body of Second Method:
{
    return lookupScore(rssi, false);
}
------------------------
Find a functionally equivalent code:com.android.server.wm.AppTransition.createAspectScaledThumbnailEnterExitAnimationLocked:COMMENT
Method Modifier: 
Comment:/**
 * This alternate animation is created when we are doing a thumbnail transition, for the
 * activity that is leaving, and the activity that is entering.
 */

Body of Frist Method:
{
    Animation a;
    final int thumbWidthI = mNextAppTransitionStartWidth;
    final float thumbWidth = thumbWidthI > 0 ? thumbWidthI : 1;
    final int thumbHeightI = mNextAppTransitionStartHeight;
    final float thumbHeight = thumbHeightI > 0 ? thumbHeightI : 1;
    // Used for the ENTER_SCALE_UP and EXIT_SCALE_DOWN transitions
    float scale = 1f;
    int scaledTopDecor = 0;
    switch(thumbTransitState) {
        case THUMBNAIL_TRANSITION_ENTER_SCALE_UP:
            {
                // App window scaling up to become full screen
                if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                    // In portrait, we scale the width and clip to the top/left square
                    scale = thumbWidth / appWidth;
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpFromClipRect.top = contentInsets.top;
                    }
                    mTmpFromClipRect.bottom = (mTmpFromClipRect.top + unscaledThumbHeight);
                    mTmpToClipRect.set(containingFrame);
                } else {
                    // In landscape, we scale the height and clip to the top/left square
                    scale = thumbHeight / (appHeight - contentInsets.top);
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbWidth = (int) (thumbWidth / scale);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpFromClipRect.top = contentInsets.top;
                        mTmpFromClipRect.bottom = (mTmpFromClipRect.top + unscaledThumbHeight);
                    }
                    mTmpFromClipRect.right = (mTmpFromClipRect.left + unscaledThumbWidth);
                    mTmpToClipRect.set(containingFrame);
                }
                mNextAppTransitionInsets.set(contentInsets);
                Animation scaleAnim = new ScaleAnimation(scale, 1, scale, 1, computePivot(mNextAppTransitionStartX, scale), computePivot(mNextAppTransitionStartY, scale));
                Animation clipAnim = new ClipRectAnimation(mTmpFromClipRect, mTmpToClipRect);
                Animation translateAnim = new TranslateAnimation(0, 0, -scaledTopDecor, 0);
                AnimationSet set = new AnimationSet(true);
                set.addAnimation(clipAnim);
                set.addAnimation(scaleAnim);
                set.addAnimation(translateAnim);
                a = set;
                break;
            }
        case THUMBNAIL_TRANSITION_EXIT_SCALE_UP:
            {
                // Previous app window during the scale up
                if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
                    // Fade out the source activity if we are animating to a wallpaper
                    // activity.
                    a = new AlphaAnimation(1, 0);
                } else {
                    a = new AlphaAnimation(1, 1);
                }
                break;
            }
        case THUMBNAIL_TRANSITION_ENTER_SCALE_DOWN:
            {
                // Target app window during the scale down
                if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
                    // Fade in the destination activity if we are animating from a wallpaper
                    // activity.
                    a = new AlphaAnimation(0, 1);
                } else {
                    a = new AlphaAnimation(1, 1);
                }
                break;
            }
        case THUMBNAIL_TRANSITION_EXIT_SCALE_DOWN:
            {
                // App window scaling down from full screen
                if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                    // In portrait, we scale the width and clip to the top/left square
                    scale = thumbWidth / appWidth;
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    mTmpToClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpToClipRect.top = contentInsets.top;
                    }
                    mTmpToClipRect.bottom = (mTmpToClipRect.top + unscaledThumbHeight);
                } else {
                    // In landscape, we scale the height and clip to the top/left square
                    scale = thumbHeight / (appHeight - contentInsets.top);
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbWidth = (int) (thumbWidth / scale);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    mTmpToClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpToClipRect.top = contentInsets.top;
                        mTmpToClipRect.bottom = (mTmpToClipRect.top + unscaledThumbHeight);
                    }
                    mTmpToClipRect.right = (mTmpToClipRect.left + unscaledThumbWidth);
                }
                mNextAppTransitionInsets.set(contentInsets);
                Animation scaleAnim = new ScaleAnimation(1, scale, 1, scale, computePivot(mNextAppTransitionStartX, scale), computePivot(mNextAppTransitionStartY, scale));
                Animation clipAnim = new ClipRectAnimation(mTmpFromClipRect, mTmpToClipRect);
                Animation translateAnim = new TranslateAnimation(0, 0, 0, -scaledTopDecor);
                AnimationSet set = new AnimationSet(true);
                set.addAnimation(clipAnim);
                set.addAnimation(scaleAnim);
                set.addAnimation(translateAnim);
                a = set;
                a.setZAdjustment(Animation.ZORDER_TOP);
                break;
            }
        default:
            throw new RuntimeException("Invalid thumbnail transition state");
    }
    return prepareThumbnailAnimationWithDuration(a, appWidth, appHeight, THUMBNAIL_APP_TRANSITION_DURATION, mThumbnailFastOutSlowInInterpolator);
}
Body of Second Method:
{
    Animation a;
    final int thumbWidthI = mNextAppTransitionStartWidth;
    final float thumbWidth = thumbWidthI > 0 ? thumbWidthI : 1;
    final int thumbHeightI = mNextAppTransitionStartHeight;
    final float thumbHeight = thumbHeightI > 0 ? thumbHeightI : 1;
    // Used for the ENTER_SCALE_UP and EXIT_SCALE_DOWN transitions
    float scale = 1f;
    int scaledTopDecor = 0;
    switch(thumbTransitState) {
        case THUMBNAIL_TRANSITION_ENTER_SCALE_UP:
            {
                // App window scaling up to become full screen
                if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                    // In portrait, we scale the width and clip to the top/left square
                    scale = thumbWidth / appWidth;
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpFromClipRect.top = contentInsets.top;
                    }
                    mTmpFromClipRect.bottom = (mTmpFromClipRect.top + unscaledThumbHeight);
                    mTmpToClipRect.set(containingFrame);
                } else {
                    // In landscape, we scale the height and clip to the top/left square
                    scale = thumbHeight / (appHeight - contentInsets.top);
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbWidth = (int) (thumbWidth / scale);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpFromClipRect.top = contentInsets.top;
                        mTmpFromClipRect.bottom = (mTmpFromClipRect.top + unscaledThumbHeight);
                    }
                    mTmpFromClipRect.right = (mTmpFromClipRect.left + unscaledThumbWidth);
                    mTmpToClipRect.set(containingFrame);
                }
                mNextAppTransitionInsets.set(contentInsets);
                Animation scaleAnim = new ScaleAnimation(scale, 1, scale, 1, computePivot(mNextAppTransitionStartX, scale), computePivot(mNextAppTransitionStartY, scale));
                Animation clipAnim = new ClipRectAnimation(mTmpFromClipRect, mTmpToClipRect);
                Animation translateAnim = new TranslateAnimation(0, 0, -scaledTopDecor, 0);
                AnimationSet set = new AnimationSet(true);
                set.addAnimation(clipAnim);
                set.addAnimation(scaleAnim);
                set.addAnimation(translateAnim);
                a = set;
                break;
            }
        case THUMBNAIL_TRANSITION_EXIT_SCALE_UP:
            {
                // Previous app window during the scale up
                if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
                    // Fade out the source activity if we are animating to a wallpaper
                    // activity.
                    a = new AlphaAnimation(1, 0);
                } else {
                    a = new AlphaAnimation(1, 1);
                }
                break;
            }
        case THUMBNAIL_TRANSITION_ENTER_SCALE_DOWN:
            {
                // Target app window during the scale down
                if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
                    // Fade in the destination activity if we are animating from a wallpaper
                    // activity.
                    a = new AlphaAnimation(0, 1);
                } else {
                    a = new AlphaAnimation(1, 1);
                }
                break;
            }
        case THUMBNAIL_TRANSITION_EXIT_SCALE_DOWN:
            {
                // App window scaling down from full screen
                if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                    // In portrait, we scale the width and clip to the top/left square
                    scale = thumbWidth / appWidth;
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    mTmpToClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpToClipRect.top = contentInsets.top;
                    }
                    mTmpToClipRect.bottom = (mTmpToClipRect.top + unscaledThumbHeight);
                } else {
                    // In landscape, we scale the height and clip to the top/left square
                    scale = thumbHeight / (appHeight - contentInsets.top);
                    scaledTopDecor = (int) (scale * contentInsets.top);
                    int unscaledThumbWidth = (int) (thumbWidth / scale);
                    int unscaledThumbHeight = (int) (thumbHeight / scale);
                    mTmpFromClipRect.set(containingFrame);
                    mTmpToClipRect.set(containingFrame);
                    if (isFullScreen) {
                        mTmpToClipRect.top = contentInsets.top;
                        mTmpToClipRect.bottom = (mTmpToClipRect.top + unscaledThumbHeight);
                    }
                    mTmpToClipRect.right = (mTmpToClipRect.left + unscaledThumbWidth);
                }
                mNextAppTransitionInsets.set(contentInsets);
                Animation scaleAnim = new ScaleAnimation(1, scale, 1, scale, computePivot(mNextAppTransitionStartX, scale), computePivot(mNextAppTransitionStartY, scale));
                Animation clipAnim = new ClipRectAnimation(mTmpFromClipRect, mTmpToClipRect);
                Animation translateAnim = new TranslateAnimation(0, 0, 0, -scaledTopDecor);
                AnimationSet set = new AnimationSet(true);
                set.addAnimation(clipAnim);
                set.addAnimation(scaleAnim);
                set.addAnimation(translateAnim);
                a = set;
                a.setZAdjustment(Animation.ZORDER_TOP);
                break;
            }
        default:
            throw new RuntimeException("Invalid thumbnail transition state");
    }
    int duration = Math.max(THUMBNAIL_APP_TRANSITION_ALPHA_DURATION, THUMBNAIL_APP_TRANSITION_DURATION);
    return prepareThumbnailAnimationWithDuration(a, appWidth, appHeight, duration, mThumbnailFastOutSlowInInterpolator);
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RotateDrawable.setPivotYRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the Y pivot value represents a fraction of the drawable
 * height or an absolute value in pixels.
 *
 * @param relative True if the Y pivot represents a fraction of the drawable
 * height, or false if it represents an absolute value in pixels
 *
 * @see #isPivotYRelative()
 */

Body of Frist Method:
{
    if (mState.mPivotYRel == relative) {
        mState.mPivotYRel = relative;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotYRel != relative) {
        mState.mPivotYRel = relative;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:com.android.server.TextServicesManagerService.calledFromValidUser:COMMENT
Method Modifier: private     
Comment:// 2) the calling process' user id is identical to the current user id TSMS thinks.

Body of Frist Method:
{
    final int uid = Binder.getCallingUid();
    final int userId = UserHandle.getUserId(uid);
    if (DBG) {
        Slog.d(TAG, "--- calledFromForegroundUserOrSystemProcess ? " + "calling uid = " + uid + " system uid = " + Process.SYSTEM_UID + " calling userId = " + userId + ", foreground user id = " + mSettings.getCurrentUserId());
        try {
            final String[] packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);
            for (int i = 0; i < packageNames.length; ++i) {
                if (DBG) {
                    Slog.d(TAG, "--- process name for " + uid + " = " + packageNames[i]);
                }
            }
        } catch (RemoteException e) {
        }
    }
    if (uid == Process.SYSTEM_UID || userId == mSettings.getCurrentUserId()) {
        return true;
    } else {
        Slog.w(TAG, "--- IPC called from background users. Ignore. \n" + getStackTrace());
        return false;
    }
}
Body of Second Method:
{
    final int uid = Binder.getCallingUid();
    final int userId = UserHandle.getUserId(uid);
    if (DBG) {
        Slog.d(TAG, "--- calledFromForegroundUserOrSystemProcess ? " + "calling uid = " + uid + " system uid = " + Process.SYSTEM_UID + " calling userId = " + userId + ", foreground user id = " + mSettings.getCurrentUserId() + ", calling pid = " + Binder.getCallingPid());
        try {
            final String[] packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid);
            for (int i = 0; i < packageNames.length; ++i) {
                if (DBG) {
                    Slog.d(TAG, "--- process name for " + uid + " = " + packageNames[i]);
                }
            }
        } catch (RemoteException e) {
        }
    }
    if (uid == Process.SYSTEM_UID || userId == mSettings.getCurrentUserId()) {
        return true;
    }
    // Permits current profile to use TSFM as long as the current text service is the system's
    // one. This is a tentative solution and should be replaced with fully functional multiuser
    // support.
    // TODO: Implement multiuser support in TSMS.
    final boolean isCurrentProfile = mSettings.isCurrentProfile(userId);
    if (DBG) {
        Slog.d(TAG, "--- userId = " + userId + " isCurrentProfile = " + isCurrentProfile);
    }
    if (mSettings.isCurrentProfile(userId)) {
        final SpellCheckerInfo spellCheckerInfo = getCurrentSpellCheckerWithoutVerification();
        if (spellCheckerInfo != null) {
            final ServiceInfo serviceInfo = spellCheckerInfo.getServiceInfo();
            final boolean isSystemSpellChecker = (serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
            if (DBG) {
                Slog.d(TAG, "--- current spell checker = " + spellCheckerInfo.getPackageName() + " isSystem = " + isSystemSpellChecker);
            }
            if (isSystemSpellChecker) {
                return true;
            }
        }
    }
    // support is implemented.
    if (DBG) {
        Slog.d(TAG, "--- IPC from userId:" + userId + " is being ignored. \n" + getStackTrace());
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.getDefaultDataSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultDataSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultDataSubId, sub id = " + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultDataSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultDataSubId, sub id = " + subId);
    return subId;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.shouldClipViewInStack:COMMENT
Method Modifier: 
Comment:/**
 * Returns whether this view should be clipped, or any views below should clip against this
 * view.
 */

Body of Frist Method:
{
    return mClipViewInStack && !mIsFullScreenView && (getVisibility() == View.VISIBLE);
}
Body of Second Method:
{
    return mClipViewInStack && (getVisibility() == View.VISIBLE);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.supportMultipleWindows:COMMENT
<android.webkit.WebSettings: boolean supportMultipleWindows()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports multiple windows.
 *
 * @return true if the WebView supports multiple windows
 * @see #setSupportMultipleWindows
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.location.GpsLocationProvider.setEngineCapabilities:COMMENT
Method Modifier: private     
Comment:/**
 * called from native code to inform us what the GPS engine capabilities are
 */

Body of Frist Method:
{
    mEngineCapabilities = capabilities;
    if (!hasCapability(GPS_CAPABILITY_ON_DEMAND_TIME) && !mPeriodicTimeInjection) {
        mPeriodicTimeInjection = true;
        requestUtcTime();
    }
}
Body of Second Method:
{
    mEngineCapabilities = capabilities;
    if (!hasCapability(GPS_CAPABILITY_ON_DEMAND_TIME) && !mPeriodicTimeInjection) {
        mPeriodicTimeInjection = true;
        requestUtcTime();
    }
    mGpsMeasurementsProvider.onCapabilitiesUpdated((capabilities & GPS_CAPABILITY_MEASUREMENTS) == GPS_CAPABILITY_MEASUREMENTS);
    mGpsNavigationMessageProvider.onCapabilitiesUpdated((capabilities & GPS_CAPABILITY_NAV_MESSAGES) == GPS_CAPABILITY_NAV_MESSAGES);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.savedPatternExists:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Check to see if the user has stored a lock pattern.
 * @return Whether a saved pattern exists.
 */

Body of Frist Method:
{
    try {
        return getLockSettings().havePattern(getCurrentOrCallingUserId());
    } catch (RemoteException re) {
        return false;
    }
}
Body of Second Method:
{
    return savedPatternExists(getCurrentOrCallingUserId());
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.putPhoneIdAndSubIdExtra:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long[] subIds = SubscriptionManager.getSubId(phoneId);
    if (subIds != null && subIds.length > 0) {
        putPhoneIdAndSubIdExtra(intent, phoneId, subIds[0]);
    } else {
        logd("putPhoneIdAndSubIdExtra: no valid subs");
    }
}
Body of Second Method:
{
    int[] subIds = SubscriptionManager.getSubId(phoneId);
    if (subIds != null && subIds.length > 0) {
        putPhoneIdAndSubIdExtra(intent, phoneId, subIds[0]);
    } else {
        logd("putPhoneIdAndSubIdExtra: no valid subs");
    }
}
------------------------
Find a functionally equivalent code:android.widget.Switch.hitThumb:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if (x, y) is within the target area of the switch thumb
 */

Body of Frist Method:
{
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
Body of Second Method:
{
    if (mThumbDrawable == null) {
        return false;
    }
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDefaultFontSize:COMMENT
<android.webkit.WebSettings: int getDefaultFontSize()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.hardware.camera2.DngCreator.convertToRGB:COMMENT
Method Modifier: private     static      
Comment:/**
 * Generate a direct RGB {@link ByteBuffer} from a YUV420_888 {@link Image}.
 */

Body of Frist Method:
{
    // TODO: Optimize this with renderscript intrinsic.
    int width = yuvImage.getWidth();
    int height = yuvImage.getHeight();
    ByteBuffer buf = ByteBuffer.allocateDirect(BYTES_PER_RGB_PIX * width * height);
    Image.Plane yPlane = yuvImage.getPlanes()[0];
    Image.Plane uPlane = yuvImage.getPlanes()[1];
    Image.Plane vPlane = yuvImage.getPlanes()[2];
    ByteBuffer yBuf = yPlane.getBuffer();
    ByteBuffer uBuf = uPlane.getBuffer();
    ByteBuffer vBuf = vPlane.getBuffer();
    yBuf.rewind();
    uBuf.rewind();
    vBuf.rewind();
    int yRowStride = yPlane.getRowStride();
    int vRowStride = vPlane.getRowStride();
    int uRowStride = uPlane.getRowStride();
    int yPixStride = yPlane.getPixelStride();
    int vPixStride = vPlane.getPixelStride();
    int uPixStride = uPlane.getPixelStride();
    byte[] yuvPixel = { 0, 0, 0 };
    byte[] yFullRow = new byte[yPixStride * width];
    byte[] uFullRow = new byte[uPixStride * width / 2];
    byte[] vFullRow = new byte[vPixStride * width / 2];
    byte[] finalRow = new byte[BYTES_PER_RGB_PIX * width];
    for (int i = 0; i < height; i++) {
        int halfH = i / 2;
        yBuf.position(yRowStride * i);
        yBuf.get(yFullRow);
        uBuf.position(uRowStride * halfH);
        uBuf.get(uFullRow);
        vBuf.position(vRowStride * halfH);
        vBuf.get(vFullRow);
        for (int j = 0; j < width; j++) {
            int halfW = j / 2;
            yuvPixel[0] = yFullRow[yPixStride * j];
            yuvPixel[1] = uFullRow[uPixStride * halfW];
            yuvPixel[2] = vFullRow[vPixStride * halfW];
            yuvToRgb(yuvPixel, j * BYTES_PER_RGB_PIX, /*out*/
            finalRow);
        }
        buf.put(finalRow);
    }
    yBuf.rewind();
    uBuf.rewind();
    vBuf.rewind();
    buf.rewind();
    return buf;
}
Body of Second Method:
{
    // TODO: Optimize this with renderscript intrinsic.
    int width = yuvImage.getWidth();
    int height = yuvImage.getHeight();
    ByteBuffer buf = ByteBuffer.allocateDirect(BYTES_PER_RGB_PIX * width * height);
    Image.Plane yPlane = yuvImage.getPlanes()[0];
    Image.Plane uPlane = yuvImage.getPlanes()[1];
    Image.Plane vPlane = yuvImage.getPlanes()[2];
    ByteBuffer yBuf = yPlane.getBuffer();
    ByteBuffer uBuf = uPlane.getBuffer();
    ByteBuffer vBuf = vPlane.getBuffer();
    yBuf.rewind();
    uBuf.rewind();
    vBuf.rewind();
    int yRowStride = yPlane.getRowStride();
    int vRowStride = vPlane.getRowStride();
    int uRowStride = uPlane.getRowStride();
    int yPixStride = yPlane.getPixelStride();
    int vPixStride = vPlane.getPixelStride();
    int uPixStride = uPlane.getPixelStride();
    byte[] yuvPixel = { 0, 0, 0 };
    byte[] yFullRow = new byte[yPixStride * (width - 1) + 1];
    byte[] uFullRow = new byte[uPixStride * (width / 2 - 1) + 1];
    byte[] vFullRow = new byte[vPixStride * (width / 2 - 1) + 1];
    byte[] finalRow = new byte[BYTES_PER_RGB_PIX * width];
    for (int i = 0; i < height; i++) {
        int halfH = i / 2;
        yBuf.position(yRowStride * i);
        yBuf.get(yFullRow);
        uBuf.position(uRowStride * halfH);
        uBuf.get(uFullRow);
        vBuf.position(vRowStride * halfH);
        vBuf.get(vFullRow);
        for (int j = 0; j < width; j++) {
            int halfW = j / 2;
            yuvPixel[0] = yFullRow[yPixStride * j];
            yuvPixel[1] = uFullRow[uPixStride * halfW];
            yuvPixel[2] = vFullRow[vPixStride * halfW];
            yuvToRgb(yuvPixel, j * BYTES_PER_RGB_PIX, /*out*/
            finalRow);
        }
        buf.put(finalRow);
    }
    yBuf.rewind();
    uBuf.rewind();
    vBuf.rewind();
    buf.rewind();
    return buf;
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.setSearchableInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
 * to display labels, hints, suggestions, create intents for launching search results screens
 * and controlling other affordances such as a voice button.
 *
 * @param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific
 * activity or a global search provider.
 */

Body of Frist Method:
{
    mSearchable = searchable;
    if (mSearchable != null) {
        updateSearchAutoComplete();
        updateQueryHint();
    }
    // Cache the voice search capability
    mVoiceButtonEnabled = hasVoiceSearch();
    if (mVoiceButtonEnabled) {
        // Disable the microphone on the keyboard, as a mic is displayed near the text box
        // TODO: use imeOptions to disable voice input when the new API will be available
        mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
    updateViewsVisibility(isIconified());
}
Body of Second Method:
{
    mSearchable = searchable;
    if (mSearchable != null) {
        updateSearchAutoComplete();
        updateQueryHint();
    }
    // Cache the voice search capability
    mVoiceButtonEnabled = hasVoiceSearch();
    if (mVoiceButtonEnabled) {
        // Disable the microphone on the keyboard, as a mic is displayed near the text box
        // TODO: use imeOptions to disable voice input when the new API will be available
        mSearchSrcTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
    updateViewsVisibility(isIconified());
}
------------------------
Find a functionally equivalent code:android.app.ContextImpl.ensureDirsExistOrFilter:COMMENT
Method Modifier: private     
Comment:/**
 * Ensure that given directories exist, trying to create them if missing. If
 * unable to create, they are filtered by replacing with {@code null}.
 */

Body of Frist Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    int res = -1;
                    try {
                        res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                    } catch (RemoteException e) {
                    }
                    if (res != 0) {
                        Log.w(TAG, "Failed to ensure directory: " + dir);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
Body of Second Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    int res = -1;
                    try {
                        res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                    } catch (Exception ignored) {
                    }
                    if (res != 0) {
                        Log.w(TAG, "Failed to ensure directory: " + dir);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.bulkRequestIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void bulkRequestIconForPageUrl(ContentResolver,String,IconListener)>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.widget.SearchView.getQuery:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the query string currently in the text field.
 *
 * @return the query string
 */

Body of Frist Method:
{
    return mQueryTextView.getText();
}
Body of Second Method:
{
    return mSearchSrcTextView.getText();
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.removeAllCookie:COMMENT
<android.webkit.CookieManager: void removeAllCookie()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all cookies.
 * @deprecated Use {@link #removeAllCookies(ValueCallback)} instead.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.tv.TvInputManager.Session.getTracks:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of tracks for a given type. Returns {@code null} if the information is
 * not available.
 *
 * @param type The type of the tracks. The type can be {@link TvTrackInfo#TYPE_AUDIO},
 * {@link TvTrackInfo#TYPE_VIDEO} or {@link TvTrackInfo#TYPE_SUBTITLE}.
 * @return the list of tracks for the given type.
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        if (mAudioTracks == null) {
            return null;
        }
        return mAudioTracks;
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        if (mVideoTracks == null) {
            return null;
        }
        return mVideoTracks;
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        if (mSubtitleTracks == null) {
            return null;
        }
        return mSubtitleTracks;
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            if (mAudioTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mAudioTracks);
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            if (mVideoTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mVideoTracks);
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            if (mSubtitleTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mSubtitleTracks);
        }
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.getImeOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the IME options set on the query text field.
 * @return the ime options
 * @see TextView#setImeOptions(int)
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */

Body of Frist Method:
{
    return mQueryTextView.getImeOptions();
}
Body of Second Method:
{
    return mSearchSrcTextView.getImeOptions();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.misc.SystemServicesProxy.bindSearchAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Resolves and binds the search app widget that is to appear in the recents.
 */

Body of Frist Method:
{
    if (mAwm == null)
        return null;
    if (mAssistComponent == null)
        return null;
    // Find the first Recents widget from the same package as the global assist activity
    AppWidgetProviderInfo searchWidgetInfo = resolveSearchAppWidget();
    // Return early if there is no search widget
    if (searchWidgetInfo == null)
        return null;
    // Allocate a new widget id and try and bind the app widget (if that fails, then just skip)
    int searchWidgetId = host.allocateAppWidgetId();
    Bundle opts = new Bundle();
    opts.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX);
    if (!mAwm.bindAppWidgetIdIfAllowed(searchWidgetId, searchWidgetInfo.provider, opts)) {
        return null;
    }
    return new Pair<Integer, AppWidgetProviderInfo>(searchWidgetId, searchWidgetInfo);
}
Body of Second Method:
{
    if (mAwm == null)
        return null;
    if (mAssistComponent == null)
        return null;
    // Find the first Recents widget from the same package as the global assist activity
    AppWidgetProviderInfo searchWidgetInfo = resolveSearchAppWidget();
    // Return early if there is no search widget
    if (searchWidgetInfo == null)
        return null;
    // Allocate a new widget id and try and bind the app widget (if that fails, then just skip)
    int searchWidgetId = host.allocateAppWidgetId();
    Bundle opts = new Bundle();
    opts.putInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY, AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX);
    if (!mAwm.bindAppWidgetIdIfAllowed(searchWidgetId, searchWidgetInfo.provider, opts)) {
        host.deleteAppWidgetId(searchWidgetId);
        return null;
    }
    return new Pair<Integer, AppWidgetProviderInfo>(searchWidgetId, searchWidgetInfo);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.clearLock:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Clear any lock pattern or password.
 */

Body of Frist Method:
{
    if (!isFallback)
        deleteGallery();
    saveLockPassword(null, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
    setLockPatternEnabled(false);
    saveLockPattern(null);
    setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
    onAfterChangingPassword();
}
Body of Second Method:
{
    if (!isFallback)
        deleteGallery(userHandle);
    saveLockPassword(null, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING, isFallback, userHandle);
    setLockPatternEnabled(false, userHandle);
    saveLockPattern(null, isFallback, userHandle);
    setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, userHandle);
    setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, userHandle);
    onAfterChangingPassword(userHandle);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDisplayZoomControls:COMMENT
<android.webkit.WebSettings: void setDisplayZoomControls(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should display on-screen zoom controls when
 * using the built-in zoom mechanisms. See {@link #setBuiltInZoomControls}.
 * The default is true.
 *
 * @param enabled whether the WebView should display on-screen zoom controls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.net.NetworkIdentity.buildNetworkIdentity:COMMENT
Method Modifier: public      static      
Comment:/**
 * Build a {@link NetworkIdentity} from the given {@link NetworkState},
 * assuming that any mobile networks are using the current IMSI.
 */

Body of Frist Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    // TODO: consider moving subscriberId over to LinkCapabilities, so it
    // comes from an authoritative source.
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    if (isNetworkTypeMobile(type)) {
        final TelephonyManager telephony = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
        roaming = telephony.isNetworkRoaming();
        if (state.subscriberId != null) {
            subscriberId = state.subscriberId;
        } else {
            subscriberId = telephony.getSubscriberId();
        }
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
}
Body of Second Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            Slog.w(TAG, "Active mobile network without subscriber!");
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setSansSerifFontFamily:COMMENT
<android.webkit.WebSettings: void setSansSerifFontFamily(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the sans-serif font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.AudioManager.unregisterAudioPortUpdateListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Unregister an audio port list update listener.
 * @hide
 */

Body of Frist Method:
{
    mAudioPortEventHandler.unregisterListener(l);
}
Body of Second Method:
{
    sAudioPortEventHandler.unregisterListener(l);
}
------------------------
Find a functionally equivalent code:android.os.BaseBundle.putBooleanArray:COMMENT
<android.os.BaseBundle: void putBooleanArray(String,boolean[])>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Inserts a boolean array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a boolean array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.init:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes this instance from another one.
 *
 * @param other The other instance.
 */

Body of Frist Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
Body of Second Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mTraversalBefore = other.mTraversalBefore;
    mTraversalAfter = other.mTraversalAfter;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
------------------------
Find a functionally equivalent code:com.android.keyguard.KeyguardSecurityContainer.showNextSecurityScreenOrFinish:COMMENT
Method Modifier: 
Comment:/**
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @param authenticated
 * @return true if keyguard is done
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.d(TAG, "showNextSecurityScreenOrFinish(" + authenticated + ")");
    boolean finish = false;
    if (mUpdateMonitor.getUserHasTrust(mLockPatternUtils.getCurrentUser())) {
        finish = true;
    } else if (SecurityMode.None == mCurrentSecuritySelection) {
        SecurityMode securityMode = mSecurityModel.getSecurityMode();
        // Allow an alternate, such as biometric unlock
        securityMode = mSecurityModel.getAlternateFor(securityMode);
        if (SecurityMode.None == securityMode) {
            // no security required
            finish = true;
        } else {
            // switch to the alternate security view
            showSecurityScreen(securityMode);
        }
    } else if (authenticated) {
        switch(mCurrentSecuritySelection) {
            case Pattern:
            case Password:
            case PIN:
            case Account:
            case Biometric:
                finish = true;
                break;
            case SimPin:
            case SimPuk:
                // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                SecurityMode securityMode = mSecurityModel.getSecurityMode();
                if (securityMode != SecurityMode.None) {
                    showSecurityScreen(securityMode);
                } else {
                    finish = true;
                }
                break;
            default:
                Log.v(TAG, "Bad security screen " + mCurrentSecuritySelection + ", fail safe");
                showPrimarySecurityScreen(false);
                break;
        }
    } else {
        showPrimarySecurityScreen(false);
    }
    if (finish) {
        mSecurityCallback.finish();
    }
    return finish;
}
Body of Second Method:
{
    if (DEBUG)
        Log.d(TAG, "showNextSecurityScreenOrFinish(" + authenticated + ")");
    boolean finish = false;
    if (mUpdateMonitor.getUserHasTrust(mLockPatternUtils.getCurrentUser())) {
        finish = true;
    } else if (SecurityMode.None == mCurrentSecuritySelection) {
        SecurityMode securityMode = mSecurityModel.getSecurityMode();
        // Allow an alternate, such as biometric unlock
        securityMode = mSecurityModel.getAlternateFor(securityMode);
        if (SecurityMode.None == securityMode) {
            // no security required
            finish = true;
        } else {
            // switch to the alternate security view
            showSecurityScreen(securityMode);
        }
    } else if (authenticated) {
        switch(mCurrentSecuritySelection) {
            case Pattern:
            case Password:
            case PIN:
            case Account:
            case Biometric:
                finish = true;
                break;
            case SimPin:
            case SimPuk:
                // Shortcut for SIM PIN/PUK to go to directly to user's security screen or home
                SecurityMode securityMode = mSecurityModel.getSecurityMode();
                if (securityMode != SecurityMode.None) {
                    showSecurityScreen(securityMode);
                } else {
                    finish = true;
                }
                break;
            default:
                Log.v(TAG, "Bad security screen " + mCurrentSecuritySelection + ", fail safe");
                showPrimarySecurityScreen(false);
                break;
        }
    }
    if (finish) {
        mSecurityCallback.finish();
    }
    return finish;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] colors = st.mColors;
        if (colors != null) {
            RectF r = mRect;
            float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, colors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    radius *= Math.min(st.mWidth, st.mHeight);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius == 0) {
                    // We can't have a shader with zero radius, so let's
                    // have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, colors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = colors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = colors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(colors, 0, tempColors, 0, length);
                    tempColors[length] = colors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mColorStateList == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] colors = st.mColors;
        if (colors != null) {
            RectF r = mRect;
            float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, colors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, colors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = colors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = colors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(colors, 0, tempColors, 0, length);
                    tempColors[length] = colors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mColorStateList == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.resolvePadding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resolvePadding();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited()) {
            child.resolvePadding();
        }
    }
}
Body of Second Method:
{
    super.resolvePadding();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited() && !child.isPaddingResolved()) {
            child.resolvePadding();
        }
    }
}
------------------------
Find a functionally equivalent code:android.hardware.camera2.legacy.SurfaceTextureRenderer.configureSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */

Body of Frist Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Surface s : surfaces) {
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                EGLSurfaceHolder holder = new EGLSurfaceHolder();
                holder.surface = s;
                mConversionSurfaces.add(holder);
            } else {
                EGLSurfaceHolder holder = new EGLSurfaceHolder();
                holder.surface = s;
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
Body of Second Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.beginPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    mTopFullscreenOpaqueWindowState = null;
    mAppsToBeHidden.clear();
    mAppsThatDismissKeyguard.clear();
    mForceStatusBar = false;
    mForceStatusBarFromKeyguard = false;
    mForcingShowNavBar = false;
    mForcingShowNavBarLayer = -1;
    mHideLockScreen = false;
    mAllowLockscreenWhenOn = false;
    mDismissKeyguard = DISMISS_KEYGUARD_NONE;
    mShowingLockscreen = false;
    mShowingDream = false;
    mWinShowWhenLocked = null;
}
Body of Second Method:
{
    mTopFullscreenOpaqueWindowState = null;
    mAppsToBeHidden.clear();
    mAppsThatDismissKeyguard.clear();
    mForceStatusBar = false;
    mForceStatusBarFromKeyguard = false;
    mForcingShowNavBar = false;
    mForcingShowNavBarLayer = -1;
    mHideLockScreen = false;
    mAllowLockscreenWhenOn = false;
    mDismissKeyguard = DISMISS_KEYGUARD_NONE;
    mShowingLockscreen = false;
    mShowingDream = false;
    mWinShowWhenLocked = null;
    mKeyguardSecure = isKeyguardSecure();
    mKeyguardSecureIncludingHidden = mKeyguardSecure && (mKeyguardDelegate != null && mKeyguardDelegate.isShowing());
}
------------------------
Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: 
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

Body of Frist Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
Body of Second Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                }
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testMultipleUpgradeKSWithSigningKey:COMMENT
Method Modifier: public      
Comment:/*
     * Check if an apk signed by multiple keys, one of which is its signing key,
     * but none of which is an upgrade key, can upgrade an app.
     */

Body of Frist Method:
{
    replaceCerts(R.raw.keyset_sau_ub, R.raw.keyset_sa_ua, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(R.raw.keyset_sau_ub, R.raw.keyset_sa_ua, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.flush:COMMENT
<android.webkit.CookieManager: void flush()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Ensures all cookies currently accessible through the getCookie API are
 * written to persistent storage.
 * This call will block the caller until it is done and may perform I/O.
 */

Body of Frist Method:
{
    flushCookieStore();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.isValidSlotId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // value is invalid.
    return slotId != INVALID_SLOT_ID && slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount();
}
Body of Second Method:
{
    return slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount();
}
------------------------
Find a functionally equivalent code:android.net.LinkAddress.isGlobalPreferred:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if this {@code LinkAddress} is global scope and preferred.
 * @hide
 */

Body of Frist Method:
{
    return (scope == RT_SCOPE_UNIVERSE && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED | IFA_F_TENTATIVE)) == 0L);
}
Body of Second Method:
{
    /**
     * Note that addresses flagged as IFA_F_OPTIMISTIC are
     * simultaneously flagged as IFA_F_TENTATIVE (when the tentative
     * state has cleared either DAD has succeeded or failed, and both
     * flags are cleared regardless).
     */
    return (scope == RT_SCOPE_UNIVERSE && !isIPv6ULA() && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED)) == 0L && ((flags & IFA_F_TENTATIVE) == 0L || (flags & IFA_F_OPTIMISTIC) != 0L));
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsConfiguration.update:COMMENT
Method Modifier: 
Comment:/**
 * Updates the state, given the specified context
 */

Body of Frist Method:
{
    SharedPreferences settings = context.getSharedPreferences(context.getPackageName(), 0);
    Resources res = context.getResources();
    DisplayMetrics dm = res.getDisplayMetrics();
    // Debug mode
    debugModeEnabled = settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled, false);
    if (debugModeEnabled) {
        Console.Enabled = true;
    }
    // Layout
    isLandscape = res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
    hasTransposedSearchBar = res.getBoolean(R.bool.recents_has_transposed_search_bar);
    hasTransposedNavBar = res.getBoolean(R.bool.recents_has_transposed_nav_bar);
    // Insets
    displayRect.set(0, 0, dm.widthPixels, dm.heightPixels);
    // Animations
    animationPxMovementPerSecond = res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
    // Filtering
    filteringCurrentViewsAnimDuration = res.getInteger(R.integer.recents_filter_animate_current_views_duration);
    filteringNewViewsAnimDuration = res.getInteger(R.integer.recents_filter_animate_new_views_duration);
    // Loading
    maxNumTasksToLoad = ActivityManager.getMaxRecentTasksStatic();
    // Search Bar
    searchBarSpaceHeightPx = res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
    searchBarAppWidgetId = settings.getInt(Constants.Values.App.Key_SearchAppWidgetId, -1);
    // Task stack
    taskStackScrollDuration = res.getInteger(R.integer.recents_animate_task_stack_scroll_duration);
    TypedValue widthPaddingPctValue = new TypedValue();
    res.getValue(R.dimen.recents_stack_width_padding_percentage, widthPaddingPctValue, true);
    taskStackWidthPaddingPct = widthPaddingPctValue.getFloat();
    TypedValue stackOverscrollPctValue = new TypedValue();
    res.getValue(R.dimen.recents_stack_overscroll_percentage, stackOverscrollPctValue, true);
    taskStackOverscrollPct = stackOverscrollPctValue.getFloat();
    taskStackMaxDim = res.getInteger(R.integer.recents_max_task_stack_view_dim);
    taskStackTopPaddingPx = res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
    // Task view animation and styles
    taskViewEnterFromHomeDelay = res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
    taskViewEnterFromHomeDuration = res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
    taskViewEnterFromHomeStaggerDelay = res.getInteger(R.integer.recents_animate_task_enter_from_home_stagger_delay);
    taskViewExitToHomeDuration = res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
    taskViewRemoveAnimDuration = res.getInteger(R.integer.recents_animate_task_view_remove_duration);
    taskViewRemoveAnimTranslationXPx = res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
    taskViewRoundedCornerRadiusPx = res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
    taskViewHighlightPx = res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
    taskViewTranslationZMinPx = res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
    taskViewTranslationZMaxPx = res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
    taskViewAffiliateGroupEnterOffsetPx = res.getDimensionPixelSize(R.dimen.recents_task_view_affiliate_group_enter_offset);
    TypedValue thumbnailAlphaValue = new TypedValue();
    res.getValue(R.dimen.recents_task_view_thumbnail_alpha, thumbnailAlphaValue, true);
    taskViewThumbnailAlpha = thumbnailAlphaValue.getFloat();
    // Task bar colors
    taskBarViewDefaultBackgroundColor = res.getColor(R.color.recents_task_bar_default_background_color);
    taskBarViewLightTextColor = res.getColor(R.color.recents_task_bar_light_text_color);
    taskBarViewDarkTextColor = res.getColor(R.color.recents_task_bar_dark_text_color);
    taskBarViewHighlightColor = res.getColor(R.color.recents_task_bar_highlight_color);
    TypedValue affMinAlphaPctValue = new TypedValue();
    res.getValue(R.dimen.recents_task_affiliation_color_min_alpha_percentage, affMinAlphaPctValue, true);
    taskBarViewAffiliationColorMinAlpha = affMinAlphaPctValue.getFloat();
    // Task bar size & animations
    taskBarHeight = res.getDimensionPixelSize(R.dimen.recents_task_bar_height);
    taskBarEnterAnimDuration = res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
    taskBarEnterAnimDelay = res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
    taskBarExitAnimDuration = res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
    taskBarDismissDozeDelaySeconds = res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
    // Lock to app
    taskViewLockToAppButtonHeight = res.getDimensionPixelSize(R.dimen.recents_task_view_lock_to_app_button_height);
    taskViewLockToAppShortAnimDuration = res.getInteger(R.integer.recents_animate_lock_to_app_button_short_duration);
    taskViewLockToAppLongAnimDuration = res.getInteger(R.integer.recents_animate_lock_to_app_button_long_duration);
    // Nav bar scrim
    navBarScrimEnterDuration = res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
    // Misc
    useHardwareLayers = res.getBoolean(R.bool.config_recents_use_hardware_layers);
    altTabKeyDelay = res.getInteger(R.integer.recents_alt_tab_key_delay);
    fakeShadows = res.getBoolean(R.bool.config_recents_fake_shadows);
}
Body of Second Method:
{
    SharedPreferences settings = context.getSharedPreferences(context.getPackageName(), 0);
    Resources res = context.getResources();
    DisplayMetrics dm = res.getDisplayMetrics();
    // Debug mode
    debugModeEnabled = settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled, false);
    if (debugModeEnabled) {
        Console.Enabled = true;
    }
    // Layout
    isLandscape = res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
    hasTransposedSearchBar = res.getBoolean(R.bool.recents_has_transposed_search_bar);
    hasTransposedNavBar = res.getBoolean(R.bool.recents_has_transposed_nav_bar);
    // Insets
    displayRect.set(0, 0, dm.widthPixels, dm.heightPixels);
    // Animations
    animationPxMovementPerSecond = res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
    // Filtering
    filteringCurrentViewsAnimDuration = res.getInteger(R.integer.recents_filter_animate_current_views_duration);
    filteringNewViewsAnimDuration = res.getInteger(R.integer.recents_filter_animate_new_views_duration);
    // Loading
    maxNumTasksToLoad = ActivityManager.getMaxRecentTasksStatic();
    // Search Bar
    searchBarSpaceHeightPx = res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
    searchBarAppWidgetId = settings.getInt(Constants.Values.App.Key_SearchAppWidgetId, -1);
    // Task stack
    taskStackScrollDuration = res.getInteger(R.integer.recents_animate_task_stack_scroll_duration);
    TypedValue widthPaddingPctValue = new TypedValue();
    res.getValue(R.dimen.recents_stack_width_padding_percentage, widthPaddingPctValue, true);
    taskStackWidthPaddingPct = widthPaddingPctValue.getFloat();
    TypedValue stackOverscrollPctValue = new TypedValue();
    res.getValue(R.dimen.recents_stack_overscroll_percentage, stackOverscrollPctValue, true);
    taskStackOverscrollPct = stackOverscrollPctValue.getFloat();
    taskStackMaxDim = res.getInteger(R.integer.recents_max_task_stack_view_dim);
    taskStackTopPaddingPx = res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
    // Transition
    transitionEnterFromAppDelay = res.getInteger(R.integer.recents_enter_from_app_transition_duration);
    transitionEnterFromHomeDelay = res.getInteger(R.integer.recents_enter_from_home_transition_duration);
    // Task view animation and styles
    taskViewEnterFromAppDuration = res.getInteger(R.integer.recents_task_enter_from_app_duration);
    taskViewEnterFromHomeDuration = res.getInteger(R.integer.recents_task_enter_from_home_duration);
    taskViewEnterFromHomeStaggerDelay = res.getInteger(R.integer.recents_task_enter_from_home_stagger_delay);
    taskViewExitToAppDuration = res.getInteger(R.integer.recents_task_exit_to_app_duration);
    taskViewExitToHomeDuration = res.getInteger(R.integer.recents_task_exit_to_home_duration);
    taskViewRemoveAnimDuration = res.getInteger(R.integer.recents_animate_task_view_remove_duration);
    taskViewRemoveAnimTranslationXPx = res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
    taskViewRoundedCornerRadiusPx = res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
    taskViewHighlightPx = res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
    taskViewTranslationZMinPx = res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
    taskViewTranslationZMaxPx = res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
    taskViewAffiliateGroupEnterOffsetPx = res.getDimensionPixelSize(R.dimen.recents_task_view_affiliate_group_enter_offset);
    TypedValue thumbnailAlphaValue = new TypedValue();
    res.getValue(R.dimen.recents_task_view_thumbnail_alpha, thumbnailAlphaValue, true);
    taskViewThumbnailAlpha = thumbnailAlphaValue.getFloat();
    // Task bar colors
    taskBarViewDefaultBackgroundColor = res.getColor(R.color.recents_task_bar_default_background_color);
    taskBarViewLightTextColor = res.getColor(R.color.recents_task_bar_light_text_color);
    taskBarViewDarkTextColor = res.getColor(R.color.recents_task_bar_dark_text_color);
    taskBarViewHighlightColor = res.getColor(R.color.recents_task_bar_highlight_color);
    TypedValue affMinAlphaPctValue = new TypedValue();
    res.getValue(R.dimen.recents_task_affiliation_color_min_alpha_percentage, affMinAlphaPctValue, true);
    taskBarViewAffiliationColorMinAlpha = affMinAlphaPctValue.getFloat();
    // Task bar size & animations
    taskBarHeight = res.getDimensionPixelSize(R.dimen.recents_task_bar_height);
    taskBarDismissDozeDelaySeconds = res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
    // Nav bar scrim
    navBarScrimEnterDuration = res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
    // Misc
    useHardwareLayers = res.getBoolean(R.bool.config_recents_use_hardware_layers);
    altTabKeyDelay = res.getInteger(R.integer.recents_alt_tab_key_delay);
    fakeShadows = res.getBoolean(R.bool.config_recents_fake_shadows);
    svelteLevel = res.getInteger(R.integer.recents_svelte_level);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getPluginState:COMMENT
<android.webkit.WebSettings: PluginState getPluginState()>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the current state regarding whether plugins are enabled.
 *
 * @return the plugin state as a {@link PluginState} value
 * @see #setPluginState
 * @deprecated Plugins will not be supported in future, and should not be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getDatabaseEnabled:COMMENT
<android.webkit.WebSettings: boolean getDatabaseEnabled()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the database storage API is enabled.
 *
 * @return true if the database storage API is enabled
 * @see #setDatabaseEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.app.ActivityThread.ApplicationThread.scheduleLaunchActivity:COMMENT
Method Modifier: public      final       
Comment:// activity itself back to the activity manager. (matters more with ipc)

Body of Frist Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
Body of Second Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.referrer = referrer;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
------------------------
Find a functionally equivalent code:android.widget.RadialTimePickerView.getCurrentMinute:COMMENT
Method Modifier: public      
Comment:// Returns minutes in 0-59 range

Body of Frist Method:
{
    return (mSelectionDegrees[MINUTES] / DEGREES_FOR_ONE_MINUTE);
}
Body of Second Method:
{
    return getMinuteForDegrees(mSelectionDegrees[MINUTES]);
}
------------------------
Find a functionally equivalent code:android.net.RssiCurve.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Determine if two RSSI curves are defined in the same way.
 *
 * <p>Note that two curves can be equivalent but defined differently, e.g. if one bucket in one
 * curve is split into two buckets in another. For the purpose of this method, these curves are
 * not considered equal to each other.
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    RssiCurve rssiCurve = (RssiCurve) o;
    return start == rssiCurve.start && bucketWidth == rssiCurve.bucketWidth && Arrays.equals(rssiBuckets, rssiCurve.rssiBuckets);
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    RssiCurve rssiCurve = (RssiCurve) o;
    return start == rssiCurve.start && bucketWidth == rssiCurve.bucketWidth && Arrays.equals(rssiBuckets, rssiCurve.rssiBuckets) && activeNetworkRssiBoost == rssiCurve.activeNetworkRssiBoost;
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.clearClientCertPreferences:COMMENT
Method Modifier: public      static      
Comment:/**
 * Clears the client certificate preferences stored in response
 * to proceeding/cancelling client cert requests. Note that Webview
 * automatically clears these preferences when it receives a
 * {@link KeyChain#ACTION_STORAGE_CHANGED} intent. The preferences are
 * shared by all the webviews that are created by the embedder application.
 *
 * @param onCleared  A runnable to be invoked when client certs are cleared.
 * The embedder can pass null if not interested in the
 * callback. The runnable will be called in UI thread.
 */

Body of Frist Method:
{
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "clearClientCertPreferences");
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
Body of Second Method:
{
    if (TRACE)
        Log.d(LOGTAG, "clearClientCertPreferences");
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
------------------------
Find a functionally equivalent code:android.webkit.URLUtil.guessUrl:COMMENT
Method Modifier: public      static      
Comment:/**
 * Cleans up (if possible) user-entered web addresses
 */

Body of Frist Method:
{
    String retVal = inUrl;
    WebAddress webAddress;
    if (DebugFlags.URL_UTIL)
        Log.v(LOGTAG, "guessURL before queueRequest: " + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith("about:"))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith("data:"))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith("file:"))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith("javascript:"))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(".") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (DebugFlags.URL_UTIL) {
            Log.v(LOGTAG, "smartUrlFilter: failed to parse url = " + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost("www." + webAddress.getHost() + ".com");
    }
    return webAddress.toString();
}
Body of Second Method:
{
    String retVal = inUrl;
    WebAddress webAddress;
    if (TRACE)
        Log.v(LOGTAG, "guessURL before queueRequest: " + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith("about:"))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith("data:"))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith("file:"))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith("javascript:"))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(".") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (TRACE) {
            Log.v(LOGTAG, "smartUrlFilter: failed to parse url = " + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost("www." + webAddress.getHost() + ".com");
    }
    return webAddress.toString();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.AlternateRecentsComponent.getThumbnailTransitionTransform:COMMENT
Method Modifier: 
Comment:/**
 * Returns the transition rect for the given task id.
 */

Body of Frist Method:
{
    // Get the stack of tasks that we are animating into
    RecentsTaskLoader loader = RecentsTaskLoader.getInstance();
    TaskStack stack = loader.getTaskStack(mSystemServicesProxy, mContext.getResources(), runningTaskId, -1, false, isTopTaskHome, null, null);
    if (stack.getTaskCount() == 0) {
        return null;
    }
    // Find the running task in the TaskStack
    Task task = null;
    ArrayList<Task> tasks = stack.getTasks();
    if (runningTaskId != -1) {
        // Otherwise, try and find the task with the
        int taskCount = tasks.size();
        for (int i = taskCount - 1; i >= 0; i--) {
            Task t = tasks.get(i);
            if (t.key.id == runningTaskId) {
                task = t;
                runningTaskOut.copyFrom(t);
                break;
            }
        }
    }
    if (task == null) {
        // If no task is specified or we can not find the task just use the front most one
        task = tasks.get(tasks.size() - 1);
    }
    // Get the transform for the running task
    mDummyStackView.updateMinMaxScrollForStack(stack, mTriggeredFromAltTab, isTopTaskHome);
    mDummyStackView.getScroller().setStackScrollToInitialState();
    mTmpTransform = mDummyStackView.getStackAlgorithm().getStackTransform(task, mDummyStackView.getScroller().getStackScroll(), mTmpTransform, null);
    return mTmpTransform;
}
Body of Second Method:
{
    // Find the running task in the TaskStack
    Task task = null;
    ArrayList<Task> tasks = stack.getTasks();
    if (runningTaskId != -1) {
        // Otherwise, try and find the task with the
        int taskCount = tasks.size();
        for (int i = taskCount - 1; i >= 0; i--) {
            Task t = tasks.get(i);
            if (t.key.id == runningTaskId) {
                task = t;
                runningTaskOut.copyFrom(t);
                break;
            }
        }
    }
    if (task == null) {
        // If no task is specified or we can not find the task just use the front most one
        task = tasks.get(tasks.size() - 1);
    }
    // Get the transform for the running task
    stackView.getScroller().setStackScrollToInitialState();
    mTmpTransform = stackView.getStackAlgorithm().getStackTransform(task, stackView.getScroller().getStackScroll(), mTmpTransform, null);
    return mTmpTransform;
}
------------------------
Find a functionally equivalent code:android.widget.TextView.getIterableTextForAccessibility:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!(mText instanceof Spannable)) {
        setText(mText, BufferType.SPANNABLE);
    }
    return mText;
}
Body of Second Method:
{
    return mText;
}
------------------------
Find a functionally equivalent code:com.android.providers.settings.DatabaseHelper.loadVolumeLevels:COMMENT
Method Modifier: private     
Comment:/**
 * Loads the default volume levels. It is actually inserting the index of
 * the volume array for each of the volume controls.
 *
 * @param db the database to insert the volume levels into
 */

Body of Frist Method:
{
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)" + " VALUES(?,?);");
        loadSetting(stmt, Settings.System.VOLUME_MUSIC, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_MUSIC]);
        loadSetting(stmt, Settings.System.VOLUME_RING, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_RING]);
        loadSetting(stmt, Settings.System.VOLUME_SYSTEM, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_SYSTEM]);
        loadSetting(stmt, Settings.System.VOLUME_VOICE, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_VOICE_CALL]);
        loadSetting(stmt, Settings.System.VOLUME_ALARM, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_ALARM]);
        loadSetting(stmt, Settings.System.VOLUME_NOTIFICATION, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_NOTIFICATION]);
        loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO, AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
        // By default:
        // - ringtones, notification, system and music streams are affected by ringer mode
        // on non voice capable devices (tablets)
        // - ringtones, notification and system streams are affected by ringer mode
        // on voice capable devices (phones)
        int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM) | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_voice_capable)) {
            ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
        }
        loadSetting(stmt, Settings.System.MODE_RINGER_STREAMS_AFFECTED, ringerModeAffectedStreams);
        loadSetting(stmt, Settings.System.MUTE_STREAMS_AFFECTED, ((1 << AudioManager.STREAM_MUSIC) | (1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)));
    } finally {
        if (stmt != null)
            stmt.close();
    }
    loadVibrateWhenRingingSetting(db);
}
Body of Second Method:
{
    SQLiteStatement stmt = null;
    try {
        stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)" + " VALUES(?,?);");
        loadSetting(stmt, Settings.System.VOLUME_MUSIC, AudioService.getDefaultStreamVolume(AudioManager.STREAM_MUSIC));
        loadSetting(stmt, Settings.System.VOLUME_RING, AudioService.getDefaultStreamVolume(AudioManager.STREAM_RING));
        loadSetting(stmt, Settings.System.VOLUME_SYSTEM, AudioService.getDefaultStreamVolume(AudioManager.STREAM_SYSTEM));
        loadSetting(stmt, Settings.System.VOLUME_VOICE, AudioService.getDefaultStreamVolume(AudioManager.STREAM_VOICE_CALL));
        loadSetting(stmt, Settings.System.VOLUME_ALARM, AudioService.getDefaultStreamVolume(AudioManager.STREAM_ALARM));
        loadSetting(stmt, Settings.System.VOLUME_NOTIFICATION, AudioService.getDefaultStreamVolume(AudioManager.STREAM_NOTIFICATION));
        loadSetting(stmt, Settings.System.VOLUME_BLUETOOTH_SCO, AudioService.getDefaultStreamVolume(AudioManager.STREAM_BLUETOOTH_SCO));
        // By default:
        // - ringtones, notification, system and music streams are affected by ringer mode
        // on non voice capable devices (tablets)
        // - ringtones, notification and system streams are affected by ringer mode
        // on voice capable devices (phones)
        int ringerModeAffectedStreams = (1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM) | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_voice_capable)) {
            ringerModeAffectedStreams |= (1 << AudioManager.STREAM_MUSIC);
        }
        loadSetting(stmt, Settings.System.MODE_RINGER_STREAMS_AFFECTED, ringerModeAffectedStreams);
        loadSetting(stmt, Settings.System.MUTE_STREAMS_AFFECTED, ((1 << AudioManager.STREAM_MUSIC) | (1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)));
    } finally {
        if (stmt != null)
            stmt.close();
    }
    loadVibrateWhenRingingSetting(db);
}
------------------------
Find a functionally equivalent code:com.android.internal.util.StateMachine.dump:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Dump the current state.
 *
 * @param fd
 * @param pw
 * @param args
 */

Body of Frist Method:
{
    pw.println(getName() + ":");
    pw.println(" total records=" + getLogRecCount());
    for (int i = 0; i < getLogRecSize(); i++) {
        pw.printf(" rec[%d]: %s\n", i, getLogRec(i).toString());
        pw.flush();
    }
    pw.println("curState=" + getCurrentState().getName());
}
Body of Second Method:
{
    // Cannot just invoke pw.println(this.toString()) because if the
    // resulting string is to long it won't be displayed.
    pw.println(getName() + ":");
    pw.println(" total records=" + getLogRecCount());
    for (int i = 0; i < getLogRecSize(); i++) {
        pw.println(" rec[" + i + "]: " + getLogRec(i).toString());
        pw.flush();
    }
    pw.println("curState=" + getCurrentState().getName());
}
------------------------
Find a functionally equivalent code:com.android.server.power.PowerManagerService.reallyGoToSleepNoUpdateLocked:COMMENT
Method Modifier: private     
Comment:// Done dozing, drop everything and go to sleep.

Body of Frist Method:
{
    if (DEBUG_SPEW) {
        Slog.d(TAG, "reallyGoToSleepNoUpdateLocked: eventTime=" + eventTime + ", uid=" + uid);
    }
    if (eventTime < mLastWakeTime || mWakefulness == WAKEFULNESS_ASLEEP || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "reallyGoToSleep");
    try {
        Slog.i(TAG, "Sleeping (uid " + uid + ")...");
        mDirty |= DIRTY_WAKEFULNESS;
        mWakefulness = WAKEFULNESS_ASLEEP;
        setInteractiveStateLocked(false, PowerManager.GO_TO_SLEEP_REASON_TIMEOUT);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG_SPEW) {
        Slog.d(TAG, "reallyGoToSleepNoUpdateLocked: eventTime=" + eventTime + ", uid=" + uid);
    }
    if (eventTime < mLastWakeTime || mWakefulness == WAKEFULNESS_ASLEEP || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "reallyGoToSleep");
    try {
        Slog.i(TAG, "Sleeping (uid " + uid + ")...");
        setWakefulnessLocked(WAKEFULNESS_ASLEEP, PowerManager.GO_TO_SLEEP_REASON_TIMEOUT);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return true;
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowManagerService.handleNotObscuredLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
 *
 * @param w WindowState this method is applied to.
 * @param currentTime The time which animations use for calculating transitions.
 * @param innerDw Width of app window.
 * @param innerDh Height of app window.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = w.mAttrs;
    final int attrFlags = attrs.flags;
    final boolean canBeSeen = w.isDisplayedLw();
    final boolean opaqueDrawn = canBeSeen && w.isOpaqueDrawn();
    if (opaqueDrawn && w.isFullscreen(innerDw, innerDh)) {
        // This window completely covers everything behind it,
        // so we want to leave all of them as undimmed (for
        // performance reasons).
        mInnerFields.mObscured = true;
    }
    if (w.mHasSurface) {
        if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            mInnerFields.mHoldScreen = w.mSession;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.screenBrightness >= 0 && mInnerFields.mScreenBrightness < 0) {
            mInnerFields.mScreenBrightness = w.mAttrs.screenBrightness;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.buttonBrightness >= 0 && mInnerFields.mButtonBrightness < 0) {
            mInnerFields.mButtonBrightness = w.mAttrs.buttonBrightness;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.userActivityTimeout >= 0 && mInnerFields.mUserActivityTimeout < 0) {
            mInnerFields.mUserActivityTimeout = w.mAttrs.userActivityTimeout;
        }
        final int type = attrs.type;
        if (canBeSeen && (type == TYPE_SYSTEM_DIALOG || type == TYPE_RECENTS_OVERLAY || type == TYPE_SYSTEM_ERROR || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0)) {
            mInnerFields.mSyswin = true;
        }
        if (canBeSeen) {
            // This function assumes that the contents of the default display are
            // processed first before secondary displays.
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && displayContent.isDefaultDisplay) {
                // keyguard dialogs to be shown.
                if (type == TYPE_DREAM || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = true;
                }
                mInnerFields.mDisplayHasContent = true;
            } else if (displayContent != null && (!mInnerFields.mObscureApplicationContentOnSecondaryDisplays || (mInnerFields.mObscured && type == TYPE_KEYGUARD_DIALOG))) {
                // Allow full screen keyguard presentation dialogs to be seen.
                mInnerFields.mDisplayHasContent = true;
            }
            if (mInnerFields.mPreferredRefreshRate == 0 && w.mAttrs.preferredRefreshRate != 0) {
                mInnerFields.mPreferredRefreshRate = w.mAttrs.preferredRefreshRate;
            }
        }
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = w.mAttrs;
    final int attrFlags = attrs.flags;
    final boolean canBeSeen = w.isDisplayedLw();
    final boolean opaqueDrawn = canBeSeen && w.isOpaqueDrawn();
    if (opaqueDrawn && w.isFullscreen(innerDw, innerDh)) {
        // This window completely covers everything behind it,
        // so we want to leave all of them as undimmed (for
        // performance reasons).
        mInnerFields.mObscured = true;
    }
    if (w.mHasSurface) {
        if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            mInnerFields.mHoldScreen = w.mSession;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.screenBrightness >= 0 && mInnerFields.mScreenBrightness < 0) {
            mInnerFields.mScreenBrightness = w.mAttrs.screenBrightness;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.buttonBrightness >= 0 && mInnerFields.mButtonBrightness < 0) {
            mInnerFields.mButtonBrightness = w.mAttrs.buttonBrightness;
        }
        if (!mInnerFields.mSyswin && w.mAttrs.userActivityTimeout >= 0 && mInnerFields.mUserActivityTimeout < 0) {
            mInnerFields.mUserActivityTimeout = w.mAttrs.userActivityTimeout;
        }
        final int type = attrs.type;
        if (canBeSeen && (type == TYPE_SYSTEM_DIALOG || type == TYPE_SYSTEM_ERROR || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0)) {
            mInnerFields.mSyswin = true;
        }
        if (canBeSeen) {
            // This function assumes that the contents of the default display are
            // processed first before secondary displays.
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && displayContent.isDefaultDisplay) {
                // keyguard dialogs to be shown.
                if (type == TYPE_DREAM || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = true;
                }
                mInnerFields.mDisplayHasContent = true;
            } else if (displayContent != null && (!mInnerFields.mObscureApplicationContentOnSecondaryDisplays || (mInnerFields.mObscured && type == TYPE_KEYGUARD_DIALOG))) {
                // Allow full screen keyguard presentation dialogs to be seen.
                mInnerFields.mDisplayHasContent = true;
            }
            if (mInnerFields.mPreferredRefreshRate == 0 && w.mAttrs.preferredRefreshRate != 0) {
                mInnerFields.mPreferredRefreshRate = w.mAttrs.preferredRefreshRate;
            }
        }
    }
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RotateDrawable.setPivotY:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Y position around which the drawable is rotated.
 *
 * @param pivotY Y position around which to rotate. If the Y pivot is
 * relative, the position represents a fraction of the drawable
 * height. Otherwise, the position represents an absolute value
 * in pixels.
 *
 * @see #getPivotY()
 * @attr ref android.R.styleable#RotateDrawable_pivotY
 */

Body of Frist Method:
{
    if (mState.mPivotY == pivotY) {
        mState.mPivotY = pivotY;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotY != pivotY) {
        mState.mPivotY = pivotY;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testUpgradeKSWithWrongKey:COMMENT
Method Modifier: public      
Comment:/*
     * Check if an apk signed by a key other than the upgrade keyset can update
     * an app
     */

Body of Frist Method:
{
    replaceCerts(R.raw.keyset_sa_ua, R.raw.keyset_sb_ua, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(R.raw.keyset_sa_ua, R.raw.keyset_sb_ua, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.stack.AnimationFilter.applyCombination:COMMENT
Method Modifier: public      
Comment:/**
 * Combines multiple filters into {@code this} filter, using or as the operand .
 *
 * @param events The animation events from the filters to combine.
 */

Body of Frist Method:
{
    reset();
    int size = events.size();
    for (int i = 0; i < size; i++) {
        combineFilter(events.get(i).filter);
        if (events.get(i).animationType == NotificationStackScrollLayout.AnimationEvent.ANIMATION_TYPE_GO_TO_FULL_SHADE) {
            hasGoToFullShadeEvent = true;
        }
    }
}
Body of Second Method:
{
    reset();
    int size = events.size();
    for (int i = 0; i < size; i++) {
        NotificationStackScrollLayout.AnimationEvent ev = events.get(i);
        combineFilter(events.get(i).filter);
        if (ev.animationType == NotificationStackScrollLayout.AnimationEvent.ANIMATION_TYPE_GO_TO_FULL_SHADE) {
            hasGoToFullShadeEvent = true;
        }
        if (ev.animationType == NotificationStackScrollLayout.AnimationEvent.ANIMATION_TYPE_DARK) {
            hasDarkEvent = true;
            darkAnimationOriginIndex = ev.darkAnimationOriginIndex;
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.am.ActivityStack.startPausingLocked:COMMENT
Method Modifier: default     final       
Comment:/**
 * Start pausing the currently resumed activity.  It is an error to call this if there
 * is already an activity being paused or there is no resumed activity.
 *
 * @param userLeaving True if this should result in an onUserLeaving to the current activity.
 * @param uiSleeping True if this is happening with the user interface going to sleep (the
 * screen turning off).
 * @param resuming True if this is being called as part of resuming the top activity, so
 * we shouldn't try to instigate a resume here.
 * @param dontWait True if the caller does not want to wait for the pause to complete.  If
 * set to true, we will immediately complete the pause here before returning.
 * @return Returns true if an activity now is in the PAUSING state, and we are waiting for
 * it to tell us when it is done.
 */

Body of Frist Method:
{
    if (mPausingActivity != null) {
        Slog.wtf(TAG, "Going to pause when pause is already pending for " + mPausingActivity);
        completePauseLocked(false);
    }
    ActivityRecord prev = mResumedActivity;
    if (prev == null) {
        if (!resuming) {
            Slog.wtf(TAG, "Trying to pause when nothing is resumed");
            mStackSupervisor.resumeTopActivitiesLocked();
        }
        return false;
    }
    if (mActivityContainer.mParentActivity == null) {
        // Top level stack, not a child. Look for child stacks.
        mStackSupervisor.pauseChildStacks(prev, userLeaving, uiSleeping, resuming, dontWait);
    }
    if (DEBUG_STATES)
        Slog.v(TAG, "Moving to PAUSING: " + prev);
    else if (DEBUG_PAUSE)
        Slog.v(TAG, "Start pausing: " + prev);
    mResumedActivity = null;
    mPausingActivity = prev;
    mLastPausedActivity = prev;
    mLastNoHistoryActivity = (prev.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (prev.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null;
    prev.state = ActivityState.PAUSING;
    prev.task.touchActiveTime();
    clearLaunchTime(prev);
    final ActivityRecord next = mStackSupervisor.topRunningActivityLocked();
    if (mService.mHasRecents && (next == null || next.noDisplay || next.task != prev.task)) {
        prev.updateThumbnail(screenshotActivities(prev), null);
    }
    stopFullyDrawnTraceIfNeeded();
    mService.updateCpuStats();
    if (prev.app != null && prev.app.thread != null) {
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Enqueueing pending pause: " + prev);
        try {
            EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName);
            mService.updateUsageStats(prev, false);
            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait);
        } catch (Exception e) {
            // Ignore exception, if process died other code will cleanup.
            Slog.w(TAG, "Exception thrown during pause", e);
            mPausingActivity = null;
            mLastPausedActivity = null;
            mLastNoHistoryActivity = null;
        }
    } else {
        mPausingActivity = null;
        mLastPausedActivity = null;
        mLastNoHistoryActivity = null;
    }
    // awake until the next activity is started.
    if (!mService.isSleepingOrShuttingDown()) {
        mStackSupervisor.acquireLaunchWakelock();
    }
    if (mPausingActivity != null) {
        // key dispatch; the same activity will pick it up again on wakeup.
        if (!uiSleeping) {
            prev.pauseKeyDispatchingLocked();
        } else {
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Key dispatch not paused for screen off");
        }
        if (dontWait) {
            // If the caller said they don't want to wait for the pause, then complete
            // the pause now.
            completePauseLocked(false);
            return false;
        } else {
            // Schedule a pause timeout in case the app doesn't respond.
            // We don't give it much time because this directly impacts the
            // responsiveness seen by the user.
            Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
            msg.obj = prev;
            prev.pauseTime = SystemClock.uptimeMillis();
            mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Waiting for pause to complete...");
            return true;
        }
    } else {
        // pause, so just treat it as being paused now.
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Activity not running, resuming next.");
        if (!resuming) {
            mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
        }
        return false;
    }
}
Body of Second Method:
{
    if (mPausingActivity != null) {
        Slog.wtf(TAG, "Going to pause when pause is already pending for " + mPausingActivity);
        completePauseLocked(false);
    }
    ActivityRecord prev = mResumedActivity;
    if (prev == null) {
        if (!resuming) {
            Slog.wtf(TAG, "Trying to pause when nothing is resumed");
            mStackSupervisor.resumeTopActivitiesLocked();
        }
        return false;
    }
    if (mActivityContainer.mParentActivity == null) {
        // Top level stack, not a child. Look for child stacks.
        mStackSupervisor.pauseChildStacks(prev, userLeaving, uiSleeping, resuming, dontWait);
    }
    if (DEBUG_STATES)
        Slog.v(TAG, "Moving to PAUSING: " + prev);
    else if (DEBUG_PAUSE)
        Slog.v(TAG, "Start pausing: " + prev);
    mResumedActivity = null;
    mPausingActivity = prev;
    mLastPausedActivity = prev;
    mLastNoHistoryActivity = (prev.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (prev.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0 ? prev : null;
    prev.state = ActivityState.PAUSING;
    prev.task.touchActiveTime();
    clearLaunchTime(prev);
    final ActivityRecord next = mStackSupervisor.topRunningActivityLocked();
    if (mService.mHasRecents && (next == null || next.noDisplay || next.task != prev.task || uiSleeping)) {
        prev.updateThumbnailLocked(screenshotActivities(prev), null);
    }
    stopFullyDrawnTraceIfNeeded();
    mService.updateCpuStats();
    if (prev.app != null && prev.app.thread != null) {
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Enqueueing pending pause: " + prev);
        try {
            EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName);
            mService.updateUsageStats(prev, false);
            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait);
        } catch (Exception e) {
            // Ignore exception, if process died other code will cleanup.
            Slog.w(TAG, "Exception thrown during pause", e);
            mPausingActivity = null;
            mLastPausedActivity = null;
            mLastNoHistoryActivity = null;
        }
    } else {
        mPausingActivity = null;
        mLastPausedActivity = null;
        mLastNoHistoryActivity = null;
    }
    // awake until the next activity is started.
    if (!mService.isSleepingOrShuttingDown()) {
        mStackSupervisor.acquireLaunchWakelock();
    }
    if (mPausingActivity != null) {
        // key dispatch; the same activity will pick it up again on wakeup.
        if (!uiSleeping) {
            prev.pauseKeyDispatchingLocked();
        } else {
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Key dispatch not paused for screen off");
        }
        if (dontWait) {
            // If the caller said they don't want to wait for the pause, then complete
            // the pause now.
            completePauseLocked(false);
            return false;
        } else {
            // Schedule a pause timeout in case the app doesn't respond.
            // We don't give it much time because this directly impacts the
            // responsiveness seen by the user.
            Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
            msg.obj = prev;
            prev.pauseTime = SystemClock.uptimeMillis();
            mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);
            if (DEBUG_PAUSE)
                Slog.v(TAG, "Waiting for pause to complete...");
            return true;
        }
    } else {
        // pause, so just treat it as being paused now.
        if (DEBUG_PAUSE)
            Slog.v(TAG, "Activity not running, resuming next.");
        if (!resuming) {
            mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);
        }
        return false;
    }
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.android.BridgeContext.searchAttrs:COMMENT
Method Modifier: private     
Comment:/**
 * The input int[] attrs is a list of attributes. The returns a list of information about
 * each attributes. The information is (name, isFramework)
 * <p/>
 *
 * @param attrs An attribute array reference given to obtainStyledAttributes.
 * @return List of attribute information.
 */

Body of Frist Method:
{
    List<Pair<String, Boolean>> results = new ArrayList<Pair<String, Boolean>>(attrs.length);
    // for each attribute, get its name so that we can search it in the style
    for (int i = 0; i < attrs.length; i++) {
        Pair<ResourceType, String> resolvedResource = Bridge.resolveResourceId(attrs[i]);
        boolean isFramework = false;
        if (resolvedResource != null) {
            isFramework = true;
        } else {
            resolvedResource = mProjectCallback.resolveResourceId(attrs[i]);
        }
        if (resolvedResource != null) {
            results.add(Pair.of(resolvedResource.getSecond(), isFramework));
        } else {
            results.add(null);
        }
    }
    return results;
}
Body of Second Method:
{
    List<Pair<String, Boolean>> results = new ArrayList<Pair<String, Boolean>>(attrs.length);
    // for each attribute, get its name so that we can search it in the style
    for (int attr : attrs) {
        Pair<ResourceType, String> resolvedResource = Bridge.resolveResourceId(attr);
        boolean isFramework = false;
        if (resolvedResource != null) {
            isFramework = true;
        } else {
            resolvedResource = mProjectCallback.resolveResourceId(attr);
        }
        if (resolvedResource != null) {
            results.add(Pair.of(resolvedResource.getSecond(), isFramework));
        } else {
            results.add(null);
        }
    }
    return results;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.RotateDrawable.setPivotX:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the X position around which the drawable is rotated.
 *
 * @param pivotX X position around which to rotate. If the X pivot is
 * relative, the position represents a fraction of the drawable
 * width. Otherwise, the position represents an absolute value in
 * pixels.
 *
 * @see #setPivotXRelative(boolean)
 * @attr ref android.R.styleable#RotateDrawable_pivotX
 */

Body of Frist Method:
{
    if (mState.mPivotX == pivotX) {
        mState.mPivotX = pivotX;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotX != pivotX) {
        mState.mPivotX = pivotX;
        invalidateSelf();
    }
}
------------------------
Find a functionally equivalent code:android.widget.ProgressBar.applyPrimaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.wm.AppWindowAnimator.stepAnimationLocked:COMMENT
Method Modifier: 
Comment:// This must be called while inside a transaction.

Body of Frist Method:
{
    if (mService.okToDisplay()) {
        if (animation == sDummyAnimation) {
            // a real animation and the next call will execute normally.
            return false;
        }
        if ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed) && animation != null) {
            if (!animating) {
                if (WindowManagerService.DEBUG_ANIM)
                    Slog.v(TAG, "Starting animation in " + mAppToken + " @ " + currentTime + " scale=" + mService.getTransitionAnimationScaleLocked() + " allDrawn=" + mAppToken.allDrawn + " animating=" + animating);
                animation.setStartTime(currentTime);
                animating = true;
                if (thumbnail != null) {
                    thumbnail.show();
                    thumbnailAnimation.setStartTime(currentTime);
                }
            }
            if (stepAnimation(currentTime)) {
                // it for now.
                if (thumbnail != null) {
                    stepThumbnailAnimation(currentTime);
                }
                return true;
            }
        }
    } else if (animation != null) {
        // If the display is frozen, and there is a pending animation,
        // clear it and make sure we run the cleanup code.
        animating = true;
        animation = null;
    }
    hasTransformation = false;
    if (!animating && animation == null) {
        return false;
    }
    mAnimator.setAppLayoutChanges(this, WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM, "AppWindowToken");
    clearAnimation();
    animating = false;
    if (animLayerAdjustment != 0) {
        animLayerAdjustment = 0;
        updateLayers();
    }
    if (mService.mInputMethodTarget != null && mService.mInputMethodTarget.mAppToken == mAppToken) {
        mService.moveInputMethodWindowsIfNeededLocked(true);
    }
    if (WindowManagerService.DEBUG_ANIM)
        Slog.v(TAG, "Animation done in " + mAppToken + ": reportedVisible=" + mAppToken.reportedVisible);
    transformation.clear();
    final int N = mAllAppWinAnimators.size();
    for (int i = 0; i < N; i++) {
        final WindowStateAnimator winAnim = mAllAppWinAnimators.get(i);
        if (mAppToken.mLaunchTaskBehind) {
            winAnim.mWin.mExiting = true;
        }
        winAnim.finishExit();
    }
    if (mAppToken.mLaunchTaskBehind) {
        try {
            mService.mActivityManager.notifyLaunchTaskBehindComplete(mAppToken.token);
        } catch (RemoteException e) {
        }
        mAppToken.mLaunchTaskBehind = false;
    } else {
        mAppToken.updateReportedVisibilityLocked();
        if (mAppToken.mEnteringAnimation) {
            mAppToken.mEnteringAnimation = false;
            try {
                mService.mActivityManager.notifyEnterAnimationComplete(mAppToken.token);
            } catch (RemoteException e) {
            }
        }
    }
    return false;
}
Body of Second Method:
{
    if (mService.okToDisplay()) {
        if (animation == sDummyAnimation) {
            // a real animation and the next call will execute normally.
            return false;
        }
        if ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed) && animation != null) {
            if (!animating) {
                if (WindowManagerService.DEBUG_ANIM)
                    Slog.v(TAG, "Starting animation in " + mAppToken + " @ " + currentTime + " scale=" + mService.getTransitionAnimationScaleLocked() + " allDrawn=" + mAppToken.allDrawn + " animating=" + animating);
                animation.setStartTime(currentTime);
                animating = true;
                if (thumbnail != null) {
                    thumbnail.show();
                    thumbnailAnimation.setStartTime(currentTime);
                }
            }
            if (stepAnimation(currentTime)) {
                // it for now.
                if (thumbnail != null) {
                    stepThumbnailAnimation(currentTime);
                }
                return true;
            }
        }
    } else if (animation != null) {
        // If the display is frozen, and there is a pending animation,
        // clear it and make sure we run the cleanup code.
        animating = true;
        animation = null;
    }
    hasTransformation = false;
    if (!animating && animation == null) {
        return false;
    }
    mAnimator.setAppLayoutChanges(this, WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM, "AppWindowToken");
    clearAnimation();
    animating = false;
    if (animLayerAdjustment != 0) {
        animLayerAdjustment = 0;
        updateLayers();
    }
    if (mService.mInputMethodTarget != null && mService.mInputMethodTarget.mAppToken == mAppToken) {
        mService.moveInputMethodWindowsIfNeededLocked(true);
    }
    if (WindowManagerService.DEBUG_ANIM)
        Slog.v(TAG, "Animation done in " + mAppToken + ": reportedVisible=" + mAppToken.reportedVisible);
    transformation.clear();
    final int numAllAppWinAnimators = mAllAppWinAnimators.size();
    for (int i = 0; i < numAllAppWinAnimators; i++) {
        mAllAppWinAnimators.get(i).finishExit();
    }
    if (mAppToken.mLaunchTaskBehind) {
        try {
            mService.mActivityManager.notifyLaunchTaskBehindComplete(mAppToken.token);
        } catch (RemoteException e) {
        }
        mAppToken.mLaunchTaskBehind = false;
    } else {
        mAppToken.updateReportedVisibilityLocked();
        if (mAppToken.mEnteringAnimation) {
            mAppToken.mEnteringAnimation = false;
            try {
                mService.mActivityManager.notifyEnterAnimationComplete(mAppToken.token);
            } catch (RemoteException e) {
            }
        }
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setDomStorageEnabled:COMMENT
<android.webkit.WebSettings: void setDomStorageEnabled(boolean)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the DOM storage API is enabled. The default value is false.
 *
 * @param flag true if the WebView should use the DOM storage API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.test.ActivityUnitTestCase.startActivity:COMMENT
Method Modifier: protected   
Comment:/**
 * Start the activity under test, in the same way as if it was started by
 * {@link android.content.Context#startActivity Context.startActivity()}, providing the
 * arguments it supplied.  When you use this method to start the activity, it will automatically
 * be stopped by {@link #tearDown}.
 *
 * <p>This method will call onCreate(), but if you wish to further exercise Activity life
 * cycle methods, you must call them yourself from your test case.
 *
 * <p><i>Do not call from your setUp() method.  You must call this method from each of your
 * test methods.</i>
 *
 * @param intent The Intent as if supplied to {@link android.content.Context#startActivity}.
 * @param savedInstanceState The instance state, if you are simulating this part of the life
 * cycle.  Typically null.
 * @param lastNonConfigurationInstance This Object will be available to the
 * Activity if it calls {@link android.app.Activity#getLastNonConfigurationInstance()}.
 * Typically null.
 * @return Returns the Activity that was created
 */

Body of Frist Method:
{
    assertFalse("Activity already created", mCreated);
    if (!mAttached) {
        assertNotNull(mActivityClass);
        setActivity(null);
        T newActivity = null;
        try {
            IBinder token = null;
            if (mApplication == null) {
                setApplication(new MockApplication());
            }
            ComponentName cn = new ComponentName(mActivityClass.getPackage().getName(), mActivityClass.getName());
            intent.setComponent(cn);
            ActivityInfo info = new ActivityInfo();
            CharSequence title = mActivityClass.getName();
            mMockParent = new MockParent();
            String id = null;
            newActivity = (T) getInstrumentation().newActivity(mActivityClass, mActivityContext, token, mApplication, intent, info, title, mMockParent, id, lastNonConfigurationInstance);
        } catch (Exception e) {
            assertNotNull(newActivity);
        }
        assertNotNull(newActivity);
        setActivity(newActivity);
        mAttached = true;
    }
    T result = getActivity();
    if (result != null) {
        getInstrumentation().callActivityOnCreate(getActivity(), savedInstanceState);
        mCreated = true;
    }
    return result;
}
Body of Second Method:
{
    assertFalse("Activity already created", mCreated);
    if (!mAttached) {
        assertNotNull(mActivityClass);
        setActivity(null);
        T newActivity = null;
        try {
            IBinder token = null;
            if (mApplication == null) {
                setApplication(new MockApplication());
            }
            ComponentName cn = new ComponentName(mActivityClass.getPackage().getName(), mActivityClass.getName());
            intent.setComponent(cn);
            ActivityInfo info = new ActivityInfo();
            CharSequence title = mActivityClass.getName();
            mMockParent = new MockParent();
            String id = null;
            newActivity = (T) getInstrumentation().newActivity(mActivityClass, mActivityContext, token, mApplication, intent, info, title, mMockParent, id, lastNonConfigurationInstance);
        } catch (Exception e) {
            Log.w(TAG, "Catching exception", e);
            assertNotNull(newActivity);
        }
        assertNotNull(newActivity);
        setActivity(newActivity);
        mAttached = true;
    }
    T result = getActivity();
    if (result != null) {
        getInstrumentation().callActivityOnCreate(getActivity(), savedInstanceState);
        mCreated = true;
    }
    return result;
}
------------------------
Find a functionally equivalent code:android.graphics.drawable.Ripple.exit:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the exit animation.
 */

Body of Frist Method:
{
    cancel();
    final float radius = MathUtils.lerp(0, mOuterRadius, mTweenRadius);
    final float remaining;
    if (mAnimRadius != null && mAnimRadius.isRunning()) {
        remaining = mOuterRadius - radius;
    } else {
        remaining = mOuterRadius;
    }
    final int radiusDuration = (int) (1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
    final int opacityDuration = (int) (1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    if (mCanUseHardware) {
        exitHardware(radiusDuration, opacityDuration);
    } else {
        exitSoftware(radiusDuration, opacityDuration);
    }
}
Body of Second Method:
{
    final float radius = MathUtils.lerp(0, mOuterRadius, mTweenRadius);
    final float remaining;
    if (mAnimRadius != null && mAnimRadius.isRunning()) {
        remaining = mOuterRadius - radius;
    } else {
        remaining = mOuterRadius;
    }
    cancel();
    final int radiusDuration = (int) (1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
    final int opacityDuration = (int) (1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    if (mCanUseHardware) {
        createPendingHardwareExit(radiusDuration, opacityDuration);
    } else {
        exitSoftware(radiusDuration, opacityDuration);
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioService.getStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#getStreamVolume(int)
 */

Body of Frist Method:
{
    ensureValidStreamType(streamType);
    int device = getDeviceForStream(streamType);
    int index = mStreamStates[streamType].getIndex(device);
    // by convention getStreamVolume() returns 0 when a stream is muted.
    if (mStreamStates[streamType].isMuted()) {
        index = 0;
    }
    if (index != 0 && (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) && (device & mFixedVolumeDevices) != 0) {
        index = mStreamStates[streamType].getMaxIndex();
    }
    return (index + 5) / 10;
}
Body of Second Method:
{
    ensureValidStreamType(streamType);
    int device = getDeviceForStream(streamType);
    synchronized (VolumeStreamState.class) {
        int index = mStreamStates[streamType].getIndex(device);
        // by convention getStreamVolume() returns 0 when a stream is muted.
        if (mStreamStates[streamType].isMuted_syncVSS()) {
            index = 0;
        }
        if (index != 0 && (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) && (device & mFixedVolumeDevices) != 0) {
            index = mStreamStates[streamType].getMaxIndex();
        }
        return (index + 5) / 10;
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.misc.SystemServicesProxy.getTaskThumbnail:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the top task thumbnail for the given task id
 */

Body of Frist Method:
{
    if (mAm == null)
        return null;
    // If we are mocking, then just return a dummy thumbnail
    if (Constants.DebugFlags.App.EnableSystemServicesProxy) {
        Bitmap thumbnail = Bitmap.createBitmap(mDummyThumbnailWidth, mDummyThumbnailHeight, Bitmap.Config.ARGB_8888);
        thumbnail.eraseColor(0xff333333);
        return thumbnail;
    }
    Bitmap thumbnail = SystemServicesProxy.getThumbnail(mAm, taskId);
    if (thumbnail != null) {
        // screenshots are always composed onto a bitmap that has no alpha.
        if (Color.alpha(thumbnail.getPixel(0, 0)) == 0) {
            mBgProtectionCanvas.setBitmap(thumbnail);
            mBgProtectionCanvas.drawRect(0, 0, thumbnail.getWidth(), thumbnail.getHeight(), mBgProtectionPaint);
            mBgProtectionCanvas.setBitmap(null);
            Log.e(TAG, "Invalid screenshot detected from getTaskThumbnail()");
        }
    }
    return thumbnail;
}
Body of Second Method:
{
    if (mAm == null)
        return null;
    // If we are mocking, then just return a dummy thumbnail
    if (Constants.DebugFlags.App.EnableSystemServicesProxy) {
        Bitmap thumbnail = Bitmap.createBitmap(mDummyThumbnailWidth, mDummyThumbnailHeight, Bitmap.Config.ARGB_8888);
        thumbnail.eraseColor(0xff333333);
        return thumbnail;
    }
    Bitmap thumbnail = SystemServicesProxy.getThumbnail(mAm, taskId);
    if (thumbnail != null) {
        thumbnail.setHasAlpha(false);
        // screenshots are always composed onto a bitmap that has no alpha.
        if (Color.alpha(thumbnail.getPixel(0, 0)) == 0) {
            mBgProtectionCanvas.setBitmap(thumbnail);
            mBgProtectionCanvas.drawRect(0, 0, thumbnail.getWidth(), thumbnail.getHeight(), mBgProtectionPaint);
            mBgProtectionCanvas.setBitmap(null);
            Log.e(TAG, "Invalid screenshot detected from getTaskThumbnail()");
        }
    }
    return thumbnail;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.onDebugModeTriggered:COMMENT
Method Modifier: public      
Comment:/**
 * Called when debug mode is triggered
 */

Body of Frist Method:
{
    if (mConfig.developerOptionsEnabled) {
        SharedPreferences settings = getSharedPreferences(getPackageName(), 0);
        if (settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled, false)) {
            // Disable the debug mode
            settings.edit().remove(Constants.Values.App.Key_DebugModeEnabled).apply();
            mConfig.debugModeEnabled = false;
            inflateDebugOverlay();
            mDebugOverlay.disable();
        } else {
            // Enable the debug mode
            settings.edit().putBoolean(Constants.Values.App.Key_DebugModeEnabled, true).apply();
            mConfig.debugModeEnabled = true;
            inflateDebugOverlay();
            mDebugOverlay.enable();
        }
        Toast.makeText(this, "Debug mode (" + Constants.Values.App.DebugModeVersion + ") " + (mConfig.debugModeEnabled ? "Enabled" : "Disabled") + ", please restart Recents now", Toast.LENGTH_SHORT).show();
    }
}
Body of Second Method:
{
    if (mConfig.developerOptionsEnabled) {
        SharedPreferences settings = getSharedPreferences(getPackageName(), 0);
        if (settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled, false)) {
            // Disable the debug mode
            settings.edit().remove(Constants.Values.App.Key_DebugModeEnabled).apply();
            mConfig.debugModeEnabled = false;
            inflateDebugOverlay();
            if (mDebugOverlay != null) {
                mDebugOverlay.disable();
            }
        } else {
            // Enable the debug mode
            settings.edit().putBoolean(Constants.Values.App.Key_DebugModeEnabled, true).apply();
            mConfig.debugModeEnabled = true;
            inflateDebugOverlay();
            if (mDebugOverlay != null) {
                mDebugOverlay.enable();
            }
        }
        Toast.makeText(this, "Debug mode (" + Constants.Values.App.DebugModeVersion + ") " + (mConfig.debugModeEnabled ? "Enabled" : "Disabled") + ", please restart Recents now", Toast.LENGTH_SHORT).show();
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebIconDatabase.open:COMMENT
<android.webkit.WebIconDatabase: void open(String)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Open a the icon database and store the icons in the given path.
 * @param path The directory path where the icon database will be stored.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.location.GpsLocationProvider.reportStatus:COMMENT
Method Modifier: private     
Comment:/**
 * called from native code to update our status
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "reportStatus status: " + status);
    boolean wasNavigating = mNavigating;
    switch(status) {
        case GPS_STATUS_SESSION_BEGIN:
            mNavigating = true;
            mEngineOn = true;
            break;
        case GPS_STATUS_SESSION_END:
            mNavigating = false;
            break;
        case GPS_STATUS_ENGINE_ON:
            mEngineOn = true;
            break;
        case GPS_STATUS_ENGINE_OFF:
            mEngineOn = false;
            mNavigating = false;
            break;
    }
    if (wasNavigating != mNavigating) {
        mListenerHelper.onStatusChanged(mNavigating);
        // send an intent to notify that the GPS has been enabled or disabled
        Intent intent = new Intent(LocationManager.GPS_ENABLED_CHANGE_ACTION);
        intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, mNavigating);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "reportStatus status: " + status);
    boolean wasNavigating = mNavigating;
    switch(status) {
        case GPS_STATUS_SESSION_BEGIN:
            mNavigating = true;
            mEngineOn = true;
            break;
        case GPS_STATUS_SESSION_END:
            mNavigating = false;
            break;
        case GPS_STATUS_ENGINE_ON:
            mEngineOn = true;
            break;
        case GPS_STATUS_ENGINE_OFF:
            mEngineOn = false;
            mNavigating = false;
            break;
    }
    if (wasNavigating != mNavigating) {
        mListenerHelper.onGpsEnabledChanged(mNavigating);
        mGpsMeasurementsProvider.onGpsEnabledChanged(mNavigating);
        mGpsNavigationMessageProvider.onGpsEnabledChanged(mNavigating);
        // send an intent to notify that the GPS has been enabled or disabled
        Intent intent = new Intent(LocationManager.GPS_ENABLED_CHANGE_ACTION);
        intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, mNavigating);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
    }
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.ExploreByTouchHelper.getVisibleVirtualViews:COMMENT
Method Modifier: protected   abstract    internal    
Comment:/**
 * Populates a list with the view's visible items. The ordering of items
 * within {@code virtualViewIds} specifies order of accessibility focus
 * traversal.
 *
 * @param virtualViewIds The list to populate with visible items
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.dismissFocusedTask:COMMENT
Method Modifier: public      
Comment:/**
 * Dismisses the focused task.
 */

Body of Frist Method:
{
    // Return early if there is no focused task index
    if (mFocusedTaskIndex < 0)
        return;
    Task t = mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv = getChildViewForTask(t);
    tv.dismissTask();
}
Body of Second Method:
{
    // Return early if the focused task index is invalid
    if (mFocusedTaskIndex < 0 || mFocusedTaskIndex >= mStack.getTaskCount()) {
        mFocusedTaskIndex = -1;
        return;
    }
    Task t = mStack.getTasks().get(mFocusedTaskIndex);
    TaskView tv = getChildViewForTask(t);
    tv.dismissTask();
}
------------------------
Find a functionally equivalent code:android.content.pm.PackageManagerTests.testUpgradeKSWithWrongSigningKey:COMMENT
Method Modifier: public      
Comment:/*
     * Check if an apk signed by its signing key, which is not an upgrade key,
     * can upgrade an app.
     */

Body of Frist Method:
{
    replaceCerts(R.raw.keyset_sa_ub, R.raw.keyset_sa_ub, true, true, PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES);
}
Body of Second Method:
{
    replaceCerts(R.raw.keyset_sa_ub, R.raw.keyset_sa_ub, true, true, PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE);
}
------------------------
Find a functionally equivalent code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

Body of Frist Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = isChecked();
    }
    setChecked(newState);
    cancelSuperTouch(ev);
}
Body of Second Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean oldState = isChecked();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = oldState;
    }
    if (newState != oldState) {
        playSoundEffect(SoundEffectConstants.CLICK);
        setChecked(newState);
    }
    cancelSuperTouch(ev);
}
------------------------
Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes and acquires the scene, creating various Android objects such as context,
 * inflater, and parser.
 *
 * @param timeout the time to wait if another rendering is happening.
 *
 * @return whether the scene was prepared
 *
 * @see #acquire(long)
 * @see #release()
 */

Body of Frist Method:
{
    Result result = super.init(timeout);
    if (!result.isSuccess()) {
        return result;
    }
    SessionParams params = getParams();
    BridgeContext context = getContext();
    RenderResources resources = getParams().getResources();
    DisplayMetrics metrics = getContext().getMetrics();
    // use default of true in case it's not found to use alpha by default
    mIsAlphaChannelImage = getBooleanThemeValue(resources, "windowIsFloating", true);
    mWindowIsFloating = getBooleanThemeValue(resources, "windowIsFloating", true);
    findBackground(resources);
    findStatusBar(resources, metrics);
    findActionBar(resources, metrics);
    findNavigationBar(resources, metrics);
    // FIXME: find those out, and possibly add them to the render params
    boolean hasNavigationBar = true;
    // noinspection ConstantConditions
    IWindowManager iwm = new IWindowManagerImpl(getContext().getConfiguration(), metrics, Surface.ROTATION_0, hasNavigationBar);
    WindowManagerGlobal_Delegate.setWindowManagerService(iwm);
    // build the inflater and parser.
    mInflater = new BridgeInflater(context, params.getProjectCallback());
    context.setBridgeInflater(mInflater);
    mBlockParser = new BridgeXmlBlockParser(params.getLayoutDescription(), context, false);
    return SUCCESS.createResult();
}
Body of Second Method:
{
    Result result = super.init(timeout);
    if (!result.isSuccess()) {
        return result;
    }
    SessionParams params = getParams();
    BridgeContext context = getContext();
    RenderResources resources = getParams().getResources();
    DisplayMetrics metrics = getContext().getMetrics();
    // use default of true in case it's not found to use alpha by default
    mIsAlphaChannelImage = getBooleanThemeValue(resources, "windowIsFloating", true, true);
    // FIXME: Find out why both variables are taking the same value.
    mWindowIsFloating = getBooleanThemeValue(resources, "windowIsFloating", true, true);
    findBackground(resources);
    findStatusBar(resources, metrics);
    findActionBar(resources, metrics);
    findNavigationBar(resources, metrics);
    // FIXME: find those out, and possibly add them to the render params
    boolean hasNavigationBar = true;
    // noinspection ConstantConditions
    IWindowManager iwm = new IWindowManagerImpl(getContext().getConfiguration(), metrics, Surface.ROTATION_0, hasNavigationBar);
    WindowManagerGlobal_Delegate.setWindowManagerService(iwm);
    // build the inflater and parser.
    mInflater = new BridgeInflater(context, params.getProjectCallback());
    context.setBridgeInflater(mInflater);
    mBlockParser = new BridgeXmlBlockParser(params.getLayoutDescription(), context, false);
    return SUCCESS.createResult();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.dismissRecentsToHome:COMMENT
Method Modifier: 
Comment:/**
 * Dismisses Recents directly to Home if we currently aren't transitioning.
 */

Body of Frist Method:
{
    if (mVisible) {
        // Return to Home
        dismissRecentsToHomeRaw(animated);
        return true;
    }
    return false;
}
Body of Second Method:
{
    SystemServicesProxy ssp = RecentsTaskLoader.getInstance().getSystemServicesProxy();
    if (ssp.isRecentsTopMost(ssp.getTopMostTask(), null)) {
        // Return to Home
        dismissRecentsToHomeRaw(animated);
        return true;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.preference.ListPreference.getSummary:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the summary of this ListPreference. If the summary
 * has a {@linkplain java.lang.String#format String formatting}
 * marker in it (i.e. "%s" or "%1$s"), then the current entry
 * value will be substituted in its place.
 *
 * @return the summary with appropriate string substitution
 */

Body of Frist Method:
{
    final CharSequence entry = getEntry();
    if (mSummary == null || entry == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry);
    }
}
Body of Second Method:
{
    final CharSequence entry = getEntry();
    if (mSummary == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry == null ? "" : entry);
    }
}
------------------------
Find a functionally equivalent code:android.widget.PopupWindow.setBackgroundDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the background drawable for this popup window. The background
 * can be set to {@code null}.
 *
 * @param background the popup's background
 * @see #getBackground()
 * @attr ref android.R.styleable#PopupWindow_popupBackground
 */

Body of Frist Method:
{
    mBackground = background;
}
Body of Second Method:
{
    mBackground = background;
    // at least one other drawable, intended for the 'below-anchor state'.
    if (mBackground instanceof StateListDrawable) {
        StateListDrawable stateList = (StateListDrawable) mBackground;
        // Find the above-anchor view - this one's easy, it should be labeled as such.
        int aboveAnchorStateIndex = stateList.getStateDrawableIndex(ABOVE_ANCHOR_STATE_SET);
        // Now, for the below-anchor view, look for any other drawable specified in the
        // StateListDrawable which is not for the above-anchor state and use that.
        int count = stateList.getStateCount();
        int belowAnchorStateIndex = -1;
        for (int i = 0; i < count; i++) {
            if (i != aboveAnchorStateIndex) {
                belowAnchorStateIndex = i;
                break;
            }
        }
        // to null so that we'll just use refreshDrawableState.
        if (aboveAnchorStateIndex != -1 && belowAnchorStateIndex != -1) {
            mAboveAnchorBackgroundDrawable = stateList.getStateDrawable(aboveAnchorStateIndex);
            mBelowAnchorBackgroundDrawable = stateList.getStateDrawable(belowAnchorStateIndex);
        } else {
            mBelowAnchorBackgroundDrawable = null;
            mAboveAnchorBackgroundDrawable = null;
        }
    }
}
------------------------
Find a functionally equivalent code:com.android.server.media.MediaSessionStack.addSession:COMMENT
Method Modifier: public      
Comment:/**
 * Add a record to the priority tracker.
 *
 * @param record The record to add.
 */

Body of Frist Method:
{
    mSessions.add(record);
    clearCache();
}
Body of Second Method:
{
    mSessions.add(record);
    clearCache();
    mLastInterestingRecord = record;
}
------------------------
Find a functionally equivalent code:com.android.systemui.volume.VolumePanel.onVolumeChanged:COMMENT
Method Modifier: protected   
Comment:/**
 * Override this if you have other work to do when the volume changes (for
 * example, vibrating, playing a sound, etc.). Make sure to call through to
 * the superclass implementation.
 */

Body of Frist Method:
{
    if (LOGD)
        Log.d(mTag, "onVolumeChanged(streamType: " + streamType + ", flags: " + flags + ")");
    if ((flags & AudioManager.FLAG_SHOW_UI) != 0) {
        synchronized (this) {
            if (mActiveStreamType != streamType) {
                reorderSliders(streamType);
            }
            onShowVolumeChanged(streamType, flags, null);
        }
    }
    if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && !mRingIsSilent) {
        removeMessages(MSG_PLAY_SOUND);
        sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
    }
    if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
        removeMessages(MSG_PLAY_SOUND);
        removeMessages(MSG_VIBRATE);
        onStopSounds();
    }
    removeMessages(MSG_FREE_RESOURCES);
    sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
    resetTimeout();
}
Body of Second Method:
{
    if (LOGD)
        Log.d(mTag, "onVolumeChanged(streamType: " + streamToString(streamType) + ", flags: " + flagsToString(flags) + ")");
    if ((flags & AudioManager.FLAG_SHOW_UI) != 0) {
        synchronized (this) {
            if (mActiveStreamType != streamType) {
                reorderSliders(streamType);
            }
            onShowVolumeChanged(streamType, flags, null);
        }
    }
    if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 && !mRingIsSilent) {
        removeMessages(MSG_PLAY_SOUND);
        sendMessageDelayed(obtainMessage(MSG_PLAY_SOUND, streamType, flags), PLAY_SOUND_DELAY);
    }
    if ((flags & AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE) != 0) {
        removeMessages(MSG_PLAY_SOUND);
        removeMessages(MSG_VIBRATE);
        onStopSounds();
    }
    removeMessages(MSG_FREE_RESOURCES);
    sendMessageDelayed(obtainMessage(MSG_FREE_RESOURCES), FREE_DELAY);
    resetTimeout();
}
------------------------
Find a functionally equivalent code:android.media.AudioService.sendMasterMuteUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumeController.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
Body of Second Method:
{
    mVolumeController.postMasterMuteChanged(updateFlagsForSystemAudio(flags));
    broadcastMasterMuteStatus(muted);
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.removeView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    removeViewInternal(view);
    requestLayout();
    invalidate(true);
}
Body of Second Method:
{
    if (removeViewInternal(view)) {
        requestLayout();
        invalidate(true);
    }
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setPluginsPath:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Sets a custom path to plugins used by the WebView. This method is
 * obsolete since each plugin is now loaded from its own package.
 *
 * @param pluginsPath a String path to the directory containing plugins
 * @deprecated This method is no longer used as plugins are loaded from
 * their own APK via the system's package manager.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
// Specified to do nothing, so no need for derived classes to override.
}
Body of Second Method:
{
// Specified to do nothing, so no need for derived classes to override.
}
------------------------
Find a functionally equivalent code:com.android.server.media.MediaSessionStack.onPlaystateChange:COMMENT
Method Modifier: public      
Comment:/**
 * Notify the priority tracker that a session's state changed.
 *
 * @param record The record that changed.
 * @param oldState Its old playback state.
 * @param newState Its new playback state.
 * @return true if the priority order was updated, false otherwise.
 */

Body of Frist Method:
{
    if (shouldUpdatePriority(oldState, newState)) {
        mSessions.remove(record);
        mSessions.add(0, record);
        clearCache();
        return true;
    } else if (!MediaSession.isActiveState(newState)) {
        // Just clear the volume cache when a state goes inactive
        mCachedVolumeDefault = null;
    }
    return false;
}
Body of Second Method:
{
    if (shouldUpdatePriority(oldState, newState)) {
        mSessions.remove(record);
        mSessions.add(0, record);
        clearCache();
        // This becomes the last interesting record since it entered a
        // playing state
        mLastInterestingRecord = record;
        return true;
    } else if (!MediaSession.isActiveState(newState)) {
        // Just clear the volume cache when a state goes inactive
        mCachedVolumeDefault = null;
    }
    return false;
}
------------------------
Find a functionally equivalent code:android.animation.Keyframes.getKeyframes:COMMENT
Method Modifier: 
Comment:/**
 * @return A list of all Keyframes contained by this. This may return null if this is
 * not made up of Keyframes.
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.animation.ValueAnimator.endAnimation:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Called internally to end an animation by removing it from the animations list. Must be
 * called on the UI thread.
 * @hide
 */

Body of Frist Method:
{
    handler.mAnimations.remove(this);
    handler.mPendingAnimations.remove(this);
    handler.mDelayedAnims.remove(this);
    mPlayingState = STOPPED;
    mPaused = false;
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mPlayingBackwards = false;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
Body of Second Method:
{
    handler.mAnimations.remove(this);
    handler.mPendingAnimations.remove(this);
    handler.mDelayedAnims.remove(this);
    mPlayingState = STOPPED;
    mPaused = false;
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mPlayingBackwards = false;
    mReversing = false;
    mCurrentIteration = 0;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
------------------------
Find a functionally equivalent code:android.media.AudioAttributes.Builder.setUsage:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the attribute describing what is the intended use of the the audio signal,
 * such as alarm or ringtone.
 * @param usage one of {@link AudioAttributes#USAGE_UNKNOWN},
 * {@link AudioAttributes#USAGE_MEDIA},
 * {@link AudioAttributes#USAGE_VOICE_COMMUNICATION},
 * {@link AudioAttributes#USAGE_VOICE_COMMUNICATION_SIGNALLING},
 * {@link AudioAttributes#USAGE_ALARM}, {@link AudioAttributes#USAGE_NOTIFICATION},
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_REQUEST},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_INSTANT},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_DELAYED},
 * {@link AudioAttributes#USAGE_NOTIFICATION_EVENT},
 * {@link AudioAttributes#USAGE_ASSISTANCE_ACCESSIBILITY},
 * {@link AudioAttributes#USAGE_ASSISTANCE_NAVIGATION_GUIDANCE},
 * {@link AudioAttributes#USAGE_ASSISTANCE_SONIFICATION},
 * {@link AudioAttributes#USAGE_GAME}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
        case USAGE_MEDIA:
        case USAGE_VOICE_COMMUNICATION:
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
        case USAGE_ALARM:
        case USAGE_NOTIFICATION:
        case USAGE_NOTIFICATION_RINGTONE:
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
        case USAGE_NOTIFICATION_EVENT:
        case USAGE_ASSISTANCE_ACCESSIBILITY:
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
        case USAGE_ASSISTANCE_SONIFICATION:
        case USAGE_GAME:
            mUsage = usage;
            break;
        default:
            mUsage = USAGE_UNKNOWN;
    }
    return this;
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
        case USAGE_MEDIA:
        case USAGE_VOICE_COMMUNICATION:
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
        case USAGE_ALARM:
        case USAGE_NOTIFICATION:
        case USAGE_NOTIFICATION_RINGTONE:
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
        case USAGE_NOTIFICATION_EVENT:
        case USAGE_ASSISTANCE_ACCESSIBILITY:
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
        case USAGE_ASSISTANCE_SONIFICATION:
        case USAGE_GAME:
        case USAGE_VIRTUAL_SOURCE:
            mUsage = usage;
            break;
        default:
            mUsage = USAGE_UNKNOWN;
    }
    return this;
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.AnimateableViewBounds.setClipBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the bottom clip.
 */

Body of Frist Method:
{
    if (bottom != mClipRect.bottom) {
        mClipRect.bottom = bottom;
        mSourceView.invalidateOutline();
        updateClipBounds();
        if (!mConfig.useHardwareLayers) {
            mSourceView.mThumbnailView.updateVisibility(bottom - mSourceView.getPaddingBottom());
        }
    }
}
Body of Second Method:
{
    if (bottom != mClipRect.bottom) {
        mClipRect.bottom = bottom;
        mSourceView.invalidateOutline();
        updateClipBounds();
        if (!mConfig.useHardwareLayers) {
            mSourceView.mThumbnailView.updateThumbnailVisibility(bottom - mSourceView.getPaddingBottom());
        }
    }
}
------------------------
Find a functionally equivalent code:android.telephony.PhoneNumberUtils.getDefaultVoiceSubId:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns Default voice subscription Id.
 */

Body of Frist Method:
{
    return SubscriptionManager.getDefaultVoiceSubId();
}
Body of Second Method:
{
    return SubscriptionManager.getDefaultVoiceSubId();
}
------------------------
Find a functionally equivalent code:android.widget.TextView.shouldSpeakPasswordsForAccessibility:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if the user has explicitly allowed accessibility services
 * to speak passwords.
 */

Body of Frist Method:
{
    return (Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD, 0) == 1);
}
Body of Second Method:
{
    return (Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD, 0, UserHandle.USER_CURRENT_OR_SELF) == 1);
}
------------------------
Find a functionally equivalent code:android.util.PathParser.PathDataNode.nodesToPath:COMMENT
Method Modifier: public      static      
Comment:/**
 * Convert an array of PathDataNode to Path.
 *
 * @param node The source array of PathDataNode.
 * @param path The target Path object.
 */

Body of Frist Method:
{
    float[] current = new float[4];
    char previousCommand = 'm';
    for (int i = 0; i < node.length; i++) {
        addCommand(path, current, previousCommand, node[i].mType, node[i].mParams);
        previousCommand = node[i].mType;
    }
}
Body of Second Method:
{
    float[] current = new float[6];
    char previousCommand = 'm';
    for (int i = 0; i < node.length; i++) {
        addCommand(path, current, previousCommand, node[i].mType, node[i].mParams);
        previousCommand = node[i].mType;
    }
}
------------------------
Find a functionally equivalent code:android.webkit.CookieManager.removeAllCookies:COMMENT
<android.webkit.CookieManager: void removeAllCookies(ValueCallback<Boolean>)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Removes all cookies.
 * <p>
 * This method is asynchronous.
 * If a {@link ValueCallback} is provided,
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()} will be called on the current
 * thread's {@link android.os.Looper} once the operation is complete.
 * The value provided to the callback indicates whether any cookies were removed.
 * You can pass {@code null} as the callback if you don't need to know when the operation
 * completes or whether any cookies were removed, and in this case it is safe to call the
 * method from a thread without a Looper.
 * @param callback a callback which is executed when the cookies have been removed
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.server.display.DisplayDeviceInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayDeviceInfo{\"");
    sb.append(name).append("\": ").append(width).append(" x ").append(height);
    sb.append(", ").append(refreshRate).append(" fps");
    sb.append(", supportedRefreshRates ").append(Arrays.toString(supportedRefreshRates));
    sb.append(", density ").append(densityDpi);
    sb.append(", ").append(xDpi).append(" x ").append(yDpi).append(" dpi");
    sb.append(", appVsyncOff ").append(appVsyncOffsetNanos);
    sb.append(", presDeadline ").append(presentationDeadlineNanos);
    sb.append(", touch ").append(touchToString(touch));
    sb.append(", rotation ").append(rotation);
    sb.append(", type ").append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ").append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayDeviceInfo{\"");
    sb.append(name).append("\": uniqueId=\"").append(uniqueId).append("\", ");
    sb.append(width).append(" x ").append(height);
    sb.append(", ").append(refreshRate).append(" fps");
    sb.append(", supportedRefreshRates ").append(Arrays.toString(supportedRefreshRates));
    sb.append(", density ").append(densityDpi);
    sb.append(", ").append(xDpi).append(" x ").append(yDpi).append(" dpi");
    sb.append(", appVsyncOff ").append(appVsyncOffsetNanos);
    sb.append(", presDeadline ").append(presentationDeadlineNanos);
    sb.append(", touch ").append(touchToString(touch));
    sb.append(", rotation ").append(rotation);
    sb.append(", type ").append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ").append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.RecentsActivity.inflateDebugOverlay:COMMENT
Method Modifier: 
Comment:/**
 * Inflates the debug overlay if debug mode is enabled.
 */

Body of Frist Method:
{
    if (mConfig.debugModeEnabled && mDebugOverlay == null) {
        // Inflate the overlay and seek bars
        mDebugOverlay = (DebugOverlayView) mDebugOverlayStub.inflate();
        mDebugOverlay.setCallbacks(this);
        mRecentsView.setDebugOverlay(mDebugOverlay);
    }
}
Body of Second Method:
{
    if (!Constants.DebugFlags.App.EnableDebugMode)
        return;
    if (mConfig.debugModeEnabled && mDebugOverlay == null) {
        // Inflate the overlay and seek bars
        mDebugOverlay = (DebugOverlayView) mDebugOverlayStub.inflate();
        mDebugOverlay.setCallbacks(this);
        mRecentsView.setDebugOverlay(mDebugOverlay);
    }
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.setDefaultDataSubId:COMMENT
<android.telephony.SubscriptionManager: void setDefaultDataSubId(long)>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("setDataSubscription sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultDataSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
Body of Second Method:
{
    if (VDBG)
        logd("setDataSubscription sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultDataSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
------------------------
Find a functionally equivalent code:com.android.connectivitymanagertest.stress.WifiStressTest.testWifiReconnectionAfterSleep:COMMENT
Method Modifier: public      
Comment:// Stress Wifi reconnection to secure net after sleep

Body of Frist Method:
{
    // set always scan to false
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0);
    // set wifi sleep policy to never on while in sleep
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_NEVER);
    // set idle timeout for wifi to 15s
    Settings.Global.putLong(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_IDLE_MS, WIFI_IDLE_MS);
    WifiConfiguration config;
    if (mPassword == null) {
        config = WifiConfigurationHelper.createOpenConfig(mSsid);
    } else {
        config = WifiConfigurationHelper.createPskConfig(mSsid, mPassword);
    }
    assertTrue("Failed to connect to Wi-Fi network: " + mSsid, connectToWifiWithConfiguration(config));
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // Run ping test to verify the data connection
    assertTrue("Wi-Fi is connected, but no data connection.", pingTest());
    long i, sum = 0, avgReconnectTime = 0;
    for (i = 1; i <= mReconnectIterations; i++) {
        // 1. Put device into sleep mode
        // 2. Wait for the device to sleep for sometime, verify wi-fi is off and mobile is on.
        // 3. Maintain the sleep mode for some time,
        // 4. Verify the Wi-Fi is still off, and data is on
        // 5. Wake up the device, verify Wi-Fi is enabled and connected.
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
        logv("iteration: " + i);
        turnScreenOff();
        // Use clock time since boot for intervals.
        long start = SystemClock.uptimeMillis();
        PowerManager pm = (PowerManager) mRunner.getContext().getSystemService(Context.POWER_SERVICE);
        while (pm.isInteractive() && ((SystemClock.uptimeMillis() - start) < SCREEN_OFF_TIMER)) {
            SystemClock.sleep(100);
        }
        assertFalse("screen still on", pm.isInteractive());
        // wait for WiFi timeout
        SystemClock.sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY);
        // 6 * SHORT_TIMEOUT));
        if (mWifiOnlyFlag) {
            assertTrue("expected wifi disconnect, still has active connection", waitUntilNoActiveNetworkConnection(2 * LONG_TIMEOUT));
        } else {
            // use long timeout as the pppd startup may take several retries.
            assertTrue("no fallback on mobile or wifi didn't disconnect", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
        }
        SystemClock.sleep(mWifiSleepTime);
        // verify the wi-fi is still off and either we have no connectivity or fallback on mobile
        if (mWifiOnlyFlag) {
            NetworkInfo ni = mCm.getActiveNetworkInfo();
            if (ni != null) {
                Log.e(mLogTag, "has active network while in wifi sleep: " + ni.toString());
                fail("active network detected");
            }
        } else {
            assertEquals("mobile not connected", State.CONNECTED, mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
            assertTrue("no connectivity over mobile", pingTest());
        }
        // Turn screen on again
        turnScreenOn();
        // Measure the time for Wi-Fi to get connected
        long startTime = SystemClock.uptimeMillis();
        assertTrue("screen on: wifi not enabled before timeout", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
        assertTrue("screen on: wifi not connected before timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, LONG_TIMEOUT));
        long connectionTime = SystemClock.uptimeMillis() - startTime;
        sum += connectionTime;
        avgReconnectTime = sum / i;
        logv("average reconnection time is: " + avgReconnectTime);
        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest());
    }
    Bundle result = new Bundle();
    result.putLong("actual-iterations", i - 1);
    result.putLong("avg-reconnect-time", avgReconnectTime);
    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
    if (i == mReconnectIterations + 1) {
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
    }
}
Body of Second Method:
{
    // set always scan to false
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0);
    // set wifi sleep policy to never on while in sleep
    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_DEFAULT);
    // set idle timeout for wifi to 15s
    Settings.Global.putLong(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_IDLE_MS, WIFI_IDLE_MS);
    WifiConfiguration config;
    if (mPassword == null) {
        config = WifiConfigurationHelper.createOpenConfig(mSsid);
    } else {
        config = WifiConfigurationHelper.createPskConfig(mSsid, mPassword);
    }
    assertTrue("Failed to connect to Wi-Fi network: " + mSsid, connectToWifiWithConfiguration(config));
    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
    // Run ping test to verify the data connection
    assertTrue("Wi-Fi is connected, but no data connection.", pingTest());
    long i, sum = 0, avgReconnectTime = 0;
    for (i = 1; i <= mReconnectIterations; i++) {
        // 1. Put device into sleep mode
        // 2. Wait for the device to sleep for sometime, verify wi-fi is off and mobile is on.
        // 3. Maintain the sleep mode for some time,
        // 4. Verify the Wi-Fi is still off, and data is on
        // 5. Wake up the device, verify Wi-Fi is enabled and connected.
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
        logv("iteration: " + i);
        turnScreenOff();
        // Use clock time since boot for intervals.
        long start = SystemClock.uptimeMillis();
        PowerManager pm = (PowerManager) mRunner.getContext().getSystemService(Context.POWER_SERVICE);
        while (pm.isInteractive() && ((SystemClock.uptimeMillis() - start) < SCREEN_OFF_TIMER)) {
            SystemClock.sleep(100);
        }
        assertFalse("screen still on", pm.isInteractive());
        // wait for WiFi timeout
        SystemClock.sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY);
        // 6 * SHORT_TIMEOUT));
        if (mWifiOnlyFlag) {
            assertTrue("expected wifi disconnect, still has active connection", waitUntilNoActiveNetworkConnection(2 * LONG_TIMEOUT));
        } else {
            // use long timeout as the pppd startup may take several retries.
            assertTrue("no fallback on mobile or wifi didn't disconnect", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
        }
        SystemClock.sleep(mWifiSleepTime);
        // verify the wi-fi is still off and either we have no connectivity or fallback on mobile
        if (mWifiOnlyFlag) {
            NetworkInfo ni = mCm.getActiveNetworkInfo();
            if (ni != null) {
                Log.e(mLogTag, "has active network while in wifi sleep: " + ni.toString());
                fail("active network detected");
            }
        } else {
            assertEquals("mobile not connected", State.CONNECTED, mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
            assertTrue("no connectivity over mobile", pingTest());
        }
        // Turn screen on again
        turnScreenOn();
        // Measure the time for Wi-Fi to get connected
        long startTime = SystemClock.uptimeMillis();
        assertTrue("screen on: wifi not enabled before timeout", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
        assertTrue("screen on: wifi not connected before timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, LONG_TIMEOUT));
        long connectionTime = SystemClock.uptimeMillis() - startTime;
        sum += connectionTime;
        avgReconnectTime = sum / i;
        logv("average reconnection time is: " + avgReconnectTime);
        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest());
    }
    Bundle result = new Bundle();
    result.putLong("actual-iterations", i - 1);
    result.putLong("avg-reconnect-time", avgReconnectTime);
    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
    if (i == mReconnectIterations + 1) {
        writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskView.startEnterRecentsAnimation:COMMENT
Method Modifier: 
Comment:/**
 * Animates this task view as it enters recents
 */

Body of Frist Method:
{
    final TaskViewTransform transform = ctx.currentTaskTransform;
    int startDelay = 0;
    if (mConfig.launchedFromAppWithScreenshot) {
        if (mTask.isLaunchTarget) {
            Rect taskRect = ctx.currentTaskRect;
            int duration = mConfig.taskViewEnterFromHomeDuration * 10;
            // XXX: Should be for the window
            int windowInsetTop = mConfig.systemInsets.top;
            float taskScale = ((float) taskRect.width() / getMeasuredWidth()) * transform.scale;
            float scaledYOffset = ((1f - taskScale) * getMeasuredHeight()) / 2;
            float scaledWindowInsetTop = (int) (taskScale * windowInsetTop);
            float scaledTranslationY = taskRect.top + transform.translationY - (scaledWindowInsetTop + scaledYOffset);
            startDelay = mConfig.taskViewEnterFromHomeStaggerDelay;
            // Animate the top clip
            mViewBounds.animateClipTop(windowInsetTop, duration, new ValueAnimator.AnimatorUpdateListener() {

                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    int y = (Integer) animation.getAnimatedValue();
                    mHeaderView.setTranslationY(y);
                }
            });
            // Animate the bottom or right clip
            int size = Math.round((taskRect.width() / taskScale));
            if (mConfig.hasHorizontalLayout()) {
                mViewBounds.animateClipRight(getMeasuredWidth() - size, duration);
            } else {
                mViewBounds.animateClipBottom(getMeasuredHeight() - (windowInsetTop + size), duration);
            }
            // Animate the task bar of the first task view
            animate().scaleX(taskScale).scaleY(taskScale).translationY(scaledTranslationY).setDuration(duration).withEndAction(new Runnable() {

                @Override
                public void run() {
                    setIsFullScreen(false);
                    requestLayout();
                    // Reset the clip
                    mViewBounds.setClipTop(0);
                    mViewBounds.setClipBottom(0);
                    mViewBounds.setClipRight(0);
                    // Reset the bar translation
                    mHeaderView.setTranslationY(0);
                    // Animate the footer into view (if it is the front most task)
                    animateFooterVisibility(true, mConfig.taskBarEnterAnimDuration);
                    // Unbind the thumbnail from the screenshot
                    RecentsTaskLoader.getInstance().loadTaskData(mTask);
                    // Recycle the full screen screenshot
                    AlternateRecentsComponent.consumeLastScreenshot();
                    mCb.onTaskViewFullScreenTransitionCompleted();
                    // Decrement the post animation trigger
                    ctx.postAnimationTrigger.decrement();
                }
            }).start();
        } else {
            // Animate the footer into view
            animateFooterVisibility(true, 0);
        }
        ctx.postAnimationTrigger.increment();
    } else if (mConfig.launchedFromAppWithThumbnail) {
        if (mTask.isLaunchTarget) {
            // Animate the dim/overlay
            if (Constants.DebugFlags.App.EnableThumbnailAlphaOnFrontmost) {
                // Animate the thumbnail alpha before the dim animation (to prevent updating the
                // hardware layer)
                mThumbnailView.startEnterRecentsAnimation(mConfig.taskBarEnterAnimDelay, new Runnable() {

                    @Override
                    public void run() {
                        animateDimToProgress(0, mConfig.taskBarEnterAnimDuration, ctx.postAnimationTrigger.decrementOnAnimationEnd());
                    }
                });
            } else {
                // Immediately start the dim animation
                animateDimToProgress(mConfig.taskBarEnterAnimDelay, mConfig.taskBarEnterAnimDuration, ctx.postAnimationTrigger.decrementOnAnimationEnd());
            }
            ctx.postAnimationTrigger.increment();
            // Animate the footer into view
            animateFooterVisibility(true, mConfig.taskBarEnterAnimDuration);
            // Animate the action button in
            mActionButtonView.animate().alpha(1f).setStartDelay(mConfig.taskBarEnterAnimDelay).setDuration(mConfig.taskBarEnterAnimDuration).setInterpolator(mConfig.fastOutLinearInInterpolator).withLayer().start();
        } else {
            // Animate the task up if it was occluding the launch target
            if (ctx.currentTaskOccludesLaunchTarget) {
                setTranslationY(transform.translationY + mConfig.taskViewAffiliateGroupEnterOffsetPx);
                setAlpha(0f);
                animate().alpha(1f).translationY(transform.translationY).setStartDelay(mConfig.taskBarEnterAnimDelay).setUpdateListener(null).setInterpolator(mConfig.fastOutSlowInInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration).withEndAction(new Runnable() {

                    @Override
                    public void run() {
                        // Decrement the post animation trigger
                        ctx.postAnimationTrigger.decrement();
                    }
                }).start();
                ctx.postAnimationTrigger.increment();
            }
        }
        startDelay = mConfig.taskBarEnterAnimDelay;
    } else if (mConfig.launchedFromHome) {
        // Animate the tasks up
        int frontIndex = (ctx.currentStackViewCount - ctx.currentStackViewIndex - 1);
        int delay = mConfig.taskViewEnterFromHomeDelay + frontIndex * mConfig.taskViewEnterFromHomeStaggerDelay;
        setScaleX(transform.scale);
        setScaleY(transform.scale);
        if (!mConfig.fakeShadows) {
            animate().translationZ(transform.translationZ);
        }
        animate().translationY(transform.translationY).setStartDelay(delay).setUpdateListener(ctx.updateListener).setInterpolator(mConfig.quintOutInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration + frontIndex * mConfig.taskViewEnterFromHomeStaggerDelay).withEndAction(new Runnable() {

            @Override
            public void run() {
                // Decrement the post animation trigger
                ctx.postAnimationTrigger.decrement();
            }
        }).start();
        ctx.postAnimationTrigger.increment();
        // Animate the footer into view
        animateFooterVisibility(true, mConfig.taskViewEnterFromHomeDuration);
        startDelay = delay;
    } else {
        // Animate the footer into view
        animateFooterVisibility(true, 0);
    }
    // Enable the focus animations from this point onwards so that they aren't affected by the
    // window transitions
    postDelayed(new Runnable() {

        @Override
        public void run() {
            enableFocusAnimations();
        }
    }, (startDelay / 2));
}
Body of Second Method:
{
    final TaskViewTransform transform = ctx.currentTaskTransform;
    int startDelay = 0;
    if (mConfig.launchedFromAppWithThumbnail) {
        if (mTask.isLaunchTarget) {
            // Animate the dim/overlay
            if (Constants.DebugFlags.App.EnableThumbnailAlphaOnFrontmost) {
                // Animate the thumbnail alpha before the dim animation (to prevent updating the
                // hardware layer)
                mThumbnailView.startEnterRecentsAnimation(mConfig.transitionEnterFromAppDelay, new Runnable() {

                    @Override
                    public void run() {
                        animateDimToProgress(0, mConfig.taskViewEnterFromAppDuration, ctx.postAnimationTrigger.decrementOnAnimationEnd());
                    }
                });
            } else {
                // Immediately start the dim animation
                animateDimToProgress(mConfig.transitionEnterFromAppDelay, mConfig.taskViewEnterFromAppDuration, ctx.postAnimationTrigger.decrementOnAnimationEnd());
            }
            ctx.postAnimationTrigger.increment();
            // Animate the action button in
            fadeInActionButton(mConfig.transitionEnterFromAppDelay, mConfig.taskViewEnterFromAppDuration);
        } else {
            // Animate the task up if it was occluding the launch target
            if (ctx.currentTaskOccludesLaunchTarget) {
                setTranslationY(transform.translationY + mConfig.taskViewAffiliateGroupEnterOffsetPx);
                setAlpha(0f);
                animate().alpha(1f).translationY(transform.translationY).setStartDelay(mConfig.transitionEnterFromAppDelay).setUpdateListener(null).setInterpolator(mConfig.fastOutSlowInInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration).withEndAction(new Runnable() {

                    @Override
                    public void run() {
                        // Decrement the post animation trigger
                        ctx.postAnimationTrigger.decrement();
                    }
                }).start();
                ctx.postAnimationTrigger.increment();
            }
        }
        startDelay = mConfig.transitionEnterFromAppDelay;
    } else if (mConfig.launchedFromHome) {
        // Animate the tasks up
        int frontIndex = (ctx.currentStackViewCount - ctx.currentStackViewIndex - 1);
        int delay = mConfig.transitionEnterFromHomeDelay + frontIndex * mConfig.taskViewEnterFromHomeStaggerDelay;
        setScaleX(transform.scale);
        setScaleY(transform.scale);
        if (!mConfig.fakeShadows) {
            animate().translationZ(transform.translationZ);
        }
        animate().translationY(transform.translationY).setStartDelay(delay).setUpdateListener(ctx.updateListener).setInterpolator(mConfig.quintOutInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration + frontIndex * mConfig.taskViewEnterFromHomeStaggerDelay).withEndAction(new Runnable() {

            @Override
            public void run() {
                // Decrement the post animation trigger
                ctx.postAnimationTrigger.decrement();
            }
        }).start();
        ctx.postAnimationTrigger.increment();
        startDelay = delay;
    }
    // Enable the focus animations from this point onwards so that they aren't affected by the
    // window transitions
    postDelayed(new Runnable() {

        @Override
        public void run() {
            enableFocusAnimations();
        }
    }, startDelay);
}
------------------------
Find a functionally equivalent code:com.android.internal.widget.ExploreByTouchHelper.createNodeForHost:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Constructs and returns an {@link AccessibilityNodeInfo} for the
 * host view populated with its virtual descendants.
 *
 * @return An {@link AccessibilityNodeInfo} for the parent node.
 */

Body of Frist Method:
{
    final AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(mView);
    onInitializeAccessibilityNodeInfo(mView, node);
    // Add the virtual descendants.
    final LinkedList<Integer> virtualViewIds = new LinkedList<Integer>();
    getVisibleVirtualViews(virtualViewIds);
    for (Integer childVirtualViewId : virtualViewIds) {
        node.addChild(mView, childVirtualViewId);
    }
    return node;
}
Body of Second Method:
{
    final AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(mView);
    onInitializeAccessibilityNodeInfo(mView, node);
    // Add the virtual descendants.
    if (mTempArray == null) {
        mTempArray = new IntArray();
    } else {
        mTempArray.clear();
    }
    final IntArray virtualViewIds = mTempArray;
    getVisibleVirtualViews(virtualViewIds);
    final int N = virtualViewIds.size();
    for (int i = 0; i < N; i++) {
        node.addChild(mView, virtualViewIds.get(i));
    }
    return node;
}
------------------------
Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.checkAddPermission:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int type = attrs.type;
    outAppOp[0] = AppOpsManager.OP_NONE;
    if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
        return WindowManagerGlobal.ADD_OKAY;
    }
    String permission = null;
    switch(type) {
        case TYPE_TOAST:
            // XXX right now the app process has complete control over
            // this...  should introduce a token to let the system
            // monitor/control what they are doing.
            outAppOp[0] = AppOpsManager.OP_TOAST_WINDOW;
            break;
        case TYPE_DREAM:
        case TYPE_INPUT_METHOD:
        case TYPE_WALLPAPER:
        case TYPE_PRIVATE_PRESENTATION:
        case TYPE_VOICE_INTERACTION:
            // The window manager will check these.
            break;
        case TYPE_PHONE:
        case TYPE_PRIORITY_PHONE:
        case TYPE_SYSTEM_ALERT:
        case TYPE_SYSTEM_ERROR:
        case TYPE_SYSTEM_OVERLAY:
            permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
            outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW;
            break;
        default:
            permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
    }
    if (permission != null) {
        if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
    }
    return WindowManagerGlobal.ADD_OKAY;
}
Body of Second Method:
{
    int type = attrs.type;
    outAppOp[0] = AppOpsManager.OP_NONE;
    if (!((type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) || (type >= FIRST_SUB_WINDOW && type <= LAST_SUB_WINDOW) || (type >= FIRST_SYSTEM_WINDOW && type <= LAST_SYSTEM_WINDOW))) {
        return WindowManagerGlobal.ADD_INVALID_TYPE;
    }
    if (type < FIRST_SYSTEM_WINDOW || type > LAST_SYSTEM_WINDOW) {
        // Window manager will make sure these are okay.
        return WindowManagerGlobal.ADD_OKAY;
    }
    String permission = null;
    switch(type) {
        case TYPE_TOAST:
            // XXX right now the app process has complete control over
            // this...  should introduce a token to let the system
            // monitor/control what they are doing.
            outAppOp[0] = AppOpsManager.OP_TOAST_WINDOW;
            break;
        case TYPE_DREAM:
        case TYPE_INPUT_METHOD:
        case TYPE_WALLPAPER:
        case TYPE_PRIVATE_PRESENTATION:
        case TYPE_VOICE_INTERACTION:
        case TYPE_ACCESSIBILITY_OVERLAY:
            // The window manager will check these.
            break;
        case TYPE_PHONE:
        case TYPE_PRIORITY_PHONE:
        case TYPE_SYSTEM_ALERT:
        case TYPE_SYSTEM_ERROR:
        case TYPE_SYSTEM_OVERLAY:
            permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;
            outAppOp[0] = AppOpsManager.OP_SYSTEM_ALERT_WINDOW;
            break;
        default:
            permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
    }
    if (permission != null) {
        if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
    }
    return WindowManagerGlobal.ADD_OKAY;
}
------------------------
Find a functionally equivalent code:android.view.Surface.release:COMMENT
Method Modifier: public      
Comment:/**
 * Release the local reference to the server-side surface.
 * Always call release() when you're done with a Surface.
 * This will make the surface invalid.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
        if (mHwuiContext != null) {
            mHwuiContext.destroy();
            mHwuiContext = null;
        }
    }
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.setImeOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the IME options on the query text field.
 *
 * @see TextView#setImeOptions(int)
 * @param imeOptions the options to set on the query text field
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */

Body of Frist Method:
{
    mQueryTextView.setImeOptions(imeOptions);
}
Body of Second Method:
{
    mSearchSrcTextView.setImeOptions(imeOptions);
}
------------------------
Find a functionally equivalent code:android.widget.SearchView.setSuggestionsAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * You can set a custom adapter if you wish. Otherwise the default adapter is used to
 * display the suggestions from the suggestions provider associated with the SearchableInfo.
 *
 * @see #setSearchableInfo(SearchableInfo)
 */

Body of Frist Method:
{
    mSuggestionsAdapter = adapter;
    mQueryTextView.setAdapter(mSuggestionsAdapter);
}
Body of Second Method:
{
    mSuggestionsAdapter = adapter;
    mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
}
------------------------
Find a functionally equivalent code:android.view.accessibility.AccessibilityWindowInfo.isAccessibilityFocused:COMMENT
Method Modifier: public      
Comment:/**
 * Gets if this window has accessibility focus.
 *
 * @return Whether has accessibility focus.
 */

Body of Frist Method:
{
    return getBooleanProperty(BOOLEAN_PROPERTY_ACCESSIBLITY_FOCUSED);
}
Body of Second Method:
{
    return getBooleanProperty(BOOLEAN_PROPERTY_ACCESSIBILITY_FOCUSED);
}
------------------------
Find a functionally equivalent code:android.telephony.SubscriptionManager.setDefaultVoiceSubId:COMMENT
<android.telephony.SubscriptionManager: void setDefaultVoiceSubId(long)>
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("setDefaultVoiceSubId sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultVoiceSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
Body of Second Method:
{
    if (VDBG)
        logd("setDefaultVoiceSubId sub id = " + subId);
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            iSub.setDefaultVoiceSubId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
------------------------
Find a functionally equivalent code:android.view.ViewGroup.addViewInLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @return true if the child was added, false otherwise
 */

Body of Frist Method:
{
    return addViewInLayout(child, index, params, false);
}
Body of Second Method:
{
    return addViewInLayout(child, index, params, false);
}
------------------------
Find a functionally equivalent code:com.android.systemui.statusbar.phone.KeyguardAffordanceHelper.Callback.onAnimationToSideStarted:COMMENT
Method Modifier: 
Comment:/**
 * Notifies the callback when an animation to a side page was started.
 *
 * @param rightPage Is the page animated to the right page?
 */

Body of Frist Method:

Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getBlockNetworkImage:COMMENT
<android.webkit.WebSettings: boolean getBlockNetworkImage()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView does not load image resources from the network.
 *
 * @return true if the WebView does not load image resources from the network
 * @see #setBlockNetworkImage
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.media.session.MediaSession.setMetadata:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current metadata. New metadata can be created using
 * {@link android.media.MediaMetadata.Builder}.
 *
 * @param metadata The new metadata
 */

Body of Frist Method:
{
    try {
        mBinder.setMetadata(metadata);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Dead object in setPlaybackState.", e);
    }
}
Body of Second Method:
{
    if (metadata != null) {
        metadata = (new MediaMetadata.Builder(metadata, mMaxBitmapSize)).build();
    }
    try {
        mBinder.setMetadata(metadata);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Dead object in setPlaybackState.", e);
    }
}
------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskViewThumbnail.unbindFromTask:COMMENT
Method Modifier: 
Comment:/**
 * Unbinds the thumbnail view from the task
 */

Body of Frist Method:
{
    setImageBitmap(null);
}
Body of Second Method:
{
    setThumbnail(null);
}
------------------------
Find a functionally equivalent code:android.webkit.WebView.evaluateJavascript:COMMENT
Method Modifier: public      
Comment:/**
 * Asynchronously evaluates JavaScript in the context of the currently displayed page.
 * If non-null, |resultCallback| will be invoked with any result returned from that
 * execution. This method must be called on the UI thread and the callback will
 * be made on the UI thread.
 *
 * @param script the JavaScript to execute.
 * @param resultCallback A callback to be invoked when the script execution
 * completes with the result of the execution (if any).
 * May be null if no notificaion of the result is required.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "evaluateJavascript=" + script);
    mProvider.evaluateJavaScript(script, resultCallback);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "evaluateJavascript=" + script);
    mProvider.evaluateJavaScript(script, resultCallback);
}
------------------------
Find a functionally equivalent code:com.android.server.wm.WindowManagerService.saveANRStateLocked:COMMENT
Method Modifier: public      
Comment:/**
 * Saves information about the state of the window manager at
 * the time an ANR occurred before anything else in the system changes
 * in response.
 *
 * @param appWindowToken The application that ANR'd, may be null.
 * @param windowState The window that ANR'd, may be null.
 * @param reason The reason for the ANR, may be null.
 */

Body of Frist Method:
{
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 1024);
    pw.println("  ANR time: " + DateFormat.getInstance().format(new Date()));
    if (appWindowToken != null) {
        pw.println("  Application at fault: " + appWindowToken.stringName);
    }
    if (windowState != null) {
        pw.println("  Window at fault: " + windowState.mAttrs.getTitle());
    }
    if (reason != null) {
        pw.println("  Reason: " + reason);
    }
    pw.println();
    dumpWindowsNoHeaderLocked(pw, true, null);
    pw.close();
    mLastANRState = sw.toString();
}
Body of Second Method:
{
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 1024);
    pw.println("  ANR time: " + DateFormat.getInstance().format(new Date()));
    if (appWindowToken != null) {
        pw.println("  Application at fault: " + appWindowToken.stringName);
    }
    if (windowState != null) {
        pw.println("  Window at fault: " + windowState.mAttrs.getTitle());
    }
    if (reason != null) {
        pw.println("  Reason: " + reason);
    }
    pw.println();
    dumpWindowsNoHeaderLocked(pw, true, null);
    pw.println();
    pw.println("Last ANR continued");
    dumpDisplayContentsLocked(pw, true);
    pw.close();
    mLastANRState = sw.toString();
    mH.removeMessages(H.RESET_ANR_MESSAGE);
    mH.sendEmptyMessageDelayed(H.RESET_ANR_MESSAGE, LAST_ANR_LIFETIME_DURATION_MSECS);
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getSaveFormData:COMMENT
<android.webkit.WebSettings: boolean getSaveFormData()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView saves form data.
 *
 * @return whether the WebView saves form data
 * @see #setSaveFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:com.android.systemui.recents.views.TaskStackView.startExitToHomeAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Requests this task stacks to start it's exit-recents animation.
 */

Body of Frist Method:
{
    // Stop any scrolling
    mStackScroller.stopScroller();
    mStackScroller.stopBoundScrollAnimation();
    // Animate all the task views out of view
    ctx.offscreenTranslationY = mLayoutAlgorithm.mViewRect.bottom - (mLayoutAlgorithm.mTaskRect.top - mLayoutAlgorithm.mViewRect.top);
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        tv.startExitToHomeAnimation(ctx);
    }
    // Add a runnable to the post animation ref counter to clear all the views
    ctx.postAnimationTrigger.addLastDecrementRunnable(mReturnAllViewsToPoolRunnable);
}
Body of Second Method:
{
    // Stop any scrolling
    mStackScroller.stopScroller();
    mStackScroller.stopBoundScrollAnimation();
    // Animate all the task views out of view
    ctx.offscreenTranslationY = mLayoutAlgorithm.mViewRect.bottom - (mLayoutAlgorithm.mTaskRect.top - mLayoutAlgorithm.mViewRect.top);
    int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        TaskView tv = (TaskView) getChildAt(i);
        tv.startExitToHomeAnimation(ctx);
    }
}
------------------------
Find a functionally equivalent code:android.appwidget.AppWidgetHost.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */

Body of Frist Method:
{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
Body of Second Method:
{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
------------------------
Find a functionally equivalent code:com.android.server.hdmi.SendKeyAction.processKeyEvent:COMMENT
Method Modifier: 
Comment:/**
 * Called when a key event should be handled for the action.
 *
 * @param keycode key code of {@link KeyEvent} object
 * @param isPressed true if the key event is of {@link KeyEvent#ACTION_DOWN}
 */

Body of Frist Method:
{
    if (mState != STATE_PROCESSING_KEYCODE) {
        Slog.w(TAG, "Not in a valid state");
        return;
    }
    // command and terminate the action. Other release events are ignored.
    if (isPressed) {
        if (keycode != mLastKeycode) {
            sendKeyDown(keycode);
            if (!HdmiCecKeycode.isRepeatableKey(keycode)) {
                sendKeyUp();
                finish();
                return;
            }
            mActionTimer.clearTimerMessage();
            addTimer(mState, IRT_MS);
            mLastKeycode = keycode;
        }
    } else {
        if (keycode == mLastKeycode) {
            sendKeyUp();
            finish();
        }
    }
}
Body of Second Method:
{
    if (mState != STATE_CHECKING_LONGPRESS && mState != STATE_PROCESSING_KEYCODE) {
        Slog.w(TAG, "Not in a valid state");
        return;
    }
    if (isPressed) {
        // one becomes a new key code to be used for press-and-hold operation.
        if (keycode != mLastKeycode) {
            sendKeyDown(keycode);
            mLastSendKeyTime = getCurrentTime();
            if (!HdmiCecKeycode.isRepeatableKey(keycode)) {
                sendKeyUp();
                finish();
                return;
            }
        } else {
            // press-and-hold key transmission.
            if (getCurrentTime() - mLastSendKeyTime >= IRT_MS) {
                sendKeyDown(keycode);
                mLastSendKeyTime = getCurrentTime();
            }
        }
        mActionTimer.clearTimerMessage();
        addTimer(mState, AWAIT_RELEASE_KEY_MS);
        mLastKeycode = keycode;
    } else {
        // command and terminate the action. Other release events are ignored.
        if (keycode == mLastKeycode) {
            sendKeyUp();
            finish();
        }
    }
}
------------------------
Find a functionally equivalent code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getProjectCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a functionally equivalent code:android.webkit.WebSettings.setEnableSmoothTransition:COMMENT
<android.webkit.WebSettings: void setEnableSmoothTransition(boolean)>
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView will enable smooth transition while panning or
 * zooming or while the window hosting the WebView does not have focus.
 * If it is true, WebView will choose a solution to maximize the performance.
 * e.g. the WebView's content may not be updated during the transition.
 * If it is false, WebView will keep its fidelity. The default value is false.
 *
 * @deprecated This method is now obsolete, and will become a no-op in future.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.webkit.WebSettings.getStandardFontFamily:COMMENT
<android.webkit.WebSettings: String getStandardFontFamily()>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the standard font family name.
 *
 * @return the standard font family name as a string
 * @see #setStandardFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a functionally equivalent code:android.util.PathParser.getFloats:COMMENT
Method Modifier: private     static      
Comment:/**
 * Parse the floats in the string.
 * This is an optimized version of parseFloat(s.split(",|\\s"));
 *
 * @param s the string containing a command and list of floats
 * @return array of floats
 */

Body of Frist Method:
{
    if (s.charAt(0) == 'z' | s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegSign) {
                // Keep the '-' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        Log.e(LOGTAG, "error in parsing \"" + s + "\"");
        throw e;
    }
}
Body of Second Method:
{
    if (s.charAt(0) == 'z' | s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        throw new RuntimeException("error in parsing \"" + s + "\"", e);
    }
}
------------------------
