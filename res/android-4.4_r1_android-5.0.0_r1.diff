Find a functionally equivalent code:android.provider.Settings.Global.getStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,7 @@
 {
+    if (MOVED_TO_SECURE.contains(name)) {
+        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, returning read-only value.");
+        return Secure.getStringForUser(resolver, name, userHandle);
+    }
     return sNameValueCache.getStringForUser(resolver, name, userHandle);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.applyPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,50 +1,79 @@
 {
     if (DEBUG_LAYOUT)
         Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
-    if (mTopFullscreenOpaqueWindowState == null && (win.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_SHOW_NAV_BAR) != 0 || (win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD)) {
-        if (mForcingShowNavBarLayer < 0) {
-            mForcingShowNavBar = true;
-            mForcingShowNavBarLayer = win.getSurfaceLayer();
-        }
+    final int fl = PolicyControl.getWindowFlags(win, attrs);
+    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
+        mForcingShowNavBar = true;
+        mForcingShowNavBarLayer = win.getSurfaceLayer();
+    }
+    if (attrs.type == TYPE_STATUS_BAR && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
+        mForceStatusBarFromKeyguard = true;
     }
     if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
-        if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
-            if (attrs.type == TYPE_KEYGUARD) {
+        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
+            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                 mForceStatusBarFromKeyguard = true;
             } else {
                 mForceStatusBar = true;
             }
         }
-        if (attrs.type == TYPE_KEYGUARD) {
+        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
             mShowingLockscreen = true;
         }
-        boolean applyWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW;
+        boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
         if (attrs.type == TYPE_DREAM) {
             // for the dream to draw before hiding the lockscreen.
             if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                 mShowingDream = true;
-                applyWindow = true;
+                appWindow = true;
             }
         }
-        if (applyWindow && attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
-            if (DEBUG_LAYOUT)
-                Slog.v(TAG, "Fullscreen window: " + win);
-            mTopFullscreenOpaqueWindowState = win;
-            if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
-                if (DEBUG_LAYOUT)
-                    Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
-                mHideLockScreen = true;
-                mForceStatusBarFromKeyguard = false;
+        final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
+        final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
+        final boolean secureKeyguard = isKeyguardSecure();
+        if (appWindow) {
+            final IApplicationToken appToken = win.getAppToken();
+            if (showWhenLocked) {
+                // Remove any previous windows with the same appToken.
+                mAppsToBeHidden.remove(appToken);
+                mAppsThatDismissKeyguard.remove(appToken);
+                if (mAppsToBeHidden.isEmpty() && isKeyguardSecureIncludingHidden()) {
+                    mWinShowWhenLocked = win;
+                    mHideLockScreen = true;
+                    mForceStatusBarFromKeyguard = false;
+                }
+            } else if (dismissKeyguard) {
+                if (secureKeyguard) {
+                    mAppsToBeHidden.add(appToken);
+                } else {
+                    mAppsToBeHidden.remove(appToken);
+                }
+                mAppsThatDismissKeyguard.add(appToken);
+            } else {
+                mAppsToBeHidden.add(appToken);
             }
-            if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0 && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
+            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                 if (DEBUG_LAYOUT)
-                    Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
-                mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
-                mWinDismissingKeyguard = win;
-                mForceStatusBarFromKeyguard = mShowingLockscreen && isKeyguardSecure();
+                    Slog.v(TAG, "Fullscreen window: " + win);
+                mTopFullscreenOpaqueWindowState = win;
+                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
+                    if (DEBUG_LAYOUT)
+                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
+                    mDismissKeyguard = mWinDismissingKeyguard == win ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
+                    mWinDismissingKeyguard = win;
+                    mForceStatusBarFromKeyguard = mShowingLockscreen && secureKeyguard;
+                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked) {
+                    if (DEBUG_LAYOUT)
+                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
+                    mHideLockScreen = true;
+                    mForceStatusBarFromKeyguard = false;
+                }
+                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
+                    mAllowLockscreenWhenOn = true;
+                }
             }
-            if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
-                mAllowLockscreenWhenOn = true;
+            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken()) {
+                win.hideLw(false);
             }
         }
     }

Find a functionally equivalent code:android.media.AudioService.startBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#startBluetoothSco()
 */

@@ -1,14 +1,4 @@
 {
-    if (!checkAudioSettingsPermission("startBluetoothSco()") || !mBootCompleted) {
-        return;
-    }
-    ScoClient client = getScoClient(cb, true);
-    // The calling identity must be cleared before calling ScoClient.incCount().
-    // inCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
-    // and this must be done on behalf of system server to make sure permissions are granted.
-    // The caller identity must be cleared after getScoClient() because it is needed if a new
-    // client is created.
-    final long ident = Binder.clearCallingIdentity();
-    client.incCount(targetSdkVersion);
-    Binder.restoreCallingIdentity(ident);
+    int scoAudioMode = (targetSdkVersion < Build.VERSION_CODES.JELLY_BEAN_MR2) ? SCO_MODE_VIRTUAL_CALL : SCO_MODE_UNDEFINED;
+    startBluetoothScoInt(cb, scoAudioMode);
 }

Find a functionally equivalent code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

@@ -1,11 +1,16 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
     if (type == TypedValue.TYPE_NULL) {
         return defValue;
     } else if (type == TypedValue.TYPE_DIMENSION) {
-        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
+        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:android.test.ProviderTestCase2.newResolverWithContentProviderFromSql:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>
 * Creates a new content provider of the same type as that passed to the test case class,
 * with an authority name set to the authority parameter, and using an SQLite database as
 * the underlying data source. The SQL statement parameter is used to create the database.
 * This method also creates a new {@link MockContentResolver} and adds the provider to it.
 * </p>
 * <p>
 * Both the new provider and the new resolver are put into an {@link IsolatedContext}
 * that uses the targetContext parameter for file operations and a {@link MockContext}
 * for everything else. The IsolatedContext prepends the filenamePrefix parameter to
 * file, database, and directory names.
 * </p>
 * <p>
 * This is a convenience method for creating a "mock" provider that can contain test data.
 * </p>
 *
 * @param targetContext The context to use as the basis of the IsolatedContext
 * @param filenamePrefix A string that is prepended to file, database, and directory names
 * @param providerClass The type of the provider being tested
 * @param authority The authority string to associated with the test provider
 * @param databaseName The name assigned to the database
 * @param databaseVersion The version assigned to the database
 * @param sql A string containing the SQL statements that are needed to create the desired
 * database and its tables. The format is the same as that generated by the
 * <a href="http://www.sqlite.org/sqlite.html">sqlite3</a> tool's <code>.dump</code> command.
 * @return ContentResolver A new {@link MockContentResolver} linked to the provider
 *
 * @throws IllegalAccessException
 * @throws InstantiationException
 */

@@ -5,12 +5,11 @@
     targetContext, filenamePrefix);
     Context context = new IsolatedContext(resolver, targetContextWrapper);
     DatabaseUtils.createDbFromSqlStatements(context, databaseName, databaseVersion, sql);
-    T provider = providerClass.newInstance();
-    provider.attachInfoForTesting(context, null);
+    T provider = createProviderForTest(context, providerClass, authority);
     resolver.addProvider(authority, provider);
     return resolver;
 }

Find a functionally equivalent code:android.net.http.CertificateChainValidator.verifyServerDomainAndCertificates:COMMENT
Method Modifier: private     static      
Comment:/**
 * Common code of doHandshakeAndValidateServerCertificates and verifyServerCertificates.
 * Calls DomainNamevalidator to verify the domain, and TrustManager to verify the certs.
 * @param chain the cert chain in X509 cert format.
 * @param domain The full website hostname and domain
 * @param authType The authentication type for the cert chain
 * @return An SSL error object if there is an error and null otherwise
 */

@@ -4,10 +4,10 @@
     if (currCertificate == null) {
         throw new IllegalArgumentException("certificate for this site is null");
     }
-    boolean valid = domain != null && !domain.isEmpty() && sVerifier.verify(domain, currCertificate);
+    boolean valid = domain != null && !domain.isEmpty() && NoPreloadHolder.sVerifier.verify(domain, new DelegatingSSLSession.CertificateWrap(currCertificate));
     if (!valid) {
         if (HttpLog.LOGV) {
             HttpLog.v("certificate not for this host: " + domain);
@@ -12,18 +12,18 @@
         return new SslError(SslError.SSL_IDMISMATCH, currCertificate);
     }
     try {
-        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
+        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultX509TrustManager();
         if (x509TrustManager instanceof TrustManagerImpl) {
             TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
             trustManager.checkServerTrusted(chain, authType, domain);

Find a functionally equivalent code:android.graphics.Paint.setXfermode:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the xfermode object.
 * <p />
 * Pass null to clear any previous xfermode.
 * As a convenience, the parameter passed is also returned.
 *
 * @param xfermode May be null. The xfermode to be installed in the paint
 * @return         xfermode
 */

@@ -1,5 +1,5 @@
 {
-    int xfermodeNative = 0;
+    long xfermodeNative = 0;
     if (xfermode != null)
         xfermodeNative = xfermode.native_instance;
     native_setXfermode(mNativePaint, xfermodeNative);

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */

@@ -1,14 +1,7 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
+    if (!hasValue(index)) {
         return null;
     }
-    if (mResourceData[index] == null) {
-        return null;
-    }
     ResourceValue value = mResourceData[index];
-    String stringValue = value.getValue();
-    if (stringValue == null || RenderResources.REFERENCE_NULL.equals(stringValue)) {
-        return null;
-    }
     return ResourceHelper.getDrawable(value, mContext);
 }

Find a functionally equivalent code:android.content.res.Resources.loadDrawable:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -3,114 +3,52 @@
         // Log only framework resources
         if ((id >>> 24) == 0x1) {
             final String name = getResourceName(id);
-            if (name != null)
-                android.util.Log.d("PreloadDrawable", name);
+            if (name != null) {
+                Log.d("PreloadDrawable", name);
+            }
         }
     }
-    boolean isColorDrawable = false;
+    final boolean isColorDrawable;
+    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
+    final long key;
     if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
         isColorDrawable = true;
-    }
-    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
-    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
-    if (dr != null) {
-        return dr;
+        caches = mColorDrawableCache;
+        key = value.data;
+    } else {
+        isColorDrawable = false;
+        caches = mDrawableCache;
+        key = (((long) value.assetCookie) << 32) | value.data;
+    }
+    // that was inflated against the specified theme.
+    if (!mPreloading) {
+        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
+        if (cachedDrawable != null) {
+            return cachedDrawable;
+        }
     }
-    Drawable.ConstantState cs;
+    // Next, check preloaded drawables. These are unthemed but may have
+    // themeable attributes.
+    final ConstantState cs;
     if (isColorDrawable) {
         cs = sPreloadedColorDrawables.get(key);
     } else {
         cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
     }
+    final Drawable dr;
     if (cs != null) {
-        dr = cs.newDrawable(this);
+        dr = cs.newDrawable(this, theme);
+    } else if (isColorDrawable) {
+        dr = new ColorDrawable(value.data);
     } else {
-        if (isColorDrawable) {
-            dr = new ColorDrawable(value.data);
-        }
-        if (dr == null) {
-            if (value.string == null) {
-                throw new NotFoundException("Resource is not a Drawable (color or path): " + value);
-            }
-            String file = value.string.toString();
-            if (TRACE_FOR_MISS_PRELOAD) {
-                // Log only framework resources
-                if ((id >>> 24) == 0x1) {
-                    final String name = getResourceName(id);
-                    if (name != null)
-                        android.util.Log.d(TAG, "Loading framework drawable #" + Integer.toHexString(id) + ": " + name + " at " + file);
-                }
-            }
-            if (DEBUG_LOAD)
-                Log.v(TAG, "Loading drawable for cookie " + value.assetCookie + ": " + file);
-            if (file.endsWith(".xml")) {
-                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
-                try {
-                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "drawable");
-                    dr = Drawable.createFromXml(this, rp);
-                    rp.close();
-                } catch (Exception e) {
-                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
-                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
-                    rnf.initCause(e);
-                    throw rnf;
-                }
-                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
-            } else {
-                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
-                try {
-                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
-                    // System.out.println("Opened file " + file + ": " + is);
-                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
-                    is.close();
-                // System.out.println("Created stream: " + dr);
-                } catch (Exception e) {
-                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
-                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
-                    rnf.initCause(e);
-                    throw rnf;
-                }
-                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
-            }
-        }
+        dr = loadDrawableForCookie(value, id, theme);
     }
+    // cache (either preload or themed).
     if (dr != null) {
         dr.setChangingConfigurations(value.changingConfigurations);
-        cs = dr.getConstantState();
-        if (cs != null) {
-            if (mPreloading) {
-                final int changingConfigs = cs.getChangingConfigurations();
-                if (isColorDrawable) {
-                    if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, "drawable")) {
-                        sPreloadedColorDrawables.put(key, cs);
-                    }
-                } else {
-                    if (verifyPreloadConfig(changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, "drawable")) {
-                        if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {
-                            // If this resource does not vary based on layout direction,
-                            // we can put it in all of the preload maps.
-                            sPreloadedDrawables[0].put(key, cs);
-                            sPreloadedDrawables[1].put(key, cs);
-                        } else {
-                            // Otherwise, only in the layout dir we loaded it for.
-                            final LongSparseArray<Drawable.ConstantState> preloads = sPreloadedDrawables[mConfiguration.getLayoutDirection()];
-                            preloads.put(key, cs);
-                        }
-                    }
-                }
-            } else {
-                synchronized (mAccessLock) {
-                    // + " in " + this + ": " + cs);
-                    if (isColorDrawable) {
-                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
-                    } else {
-                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
-                    }
-                }
-            }
-        }
+        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
     }
     return dr;
 }

Find a functionally equivalent code:android.widget.FastScroller.createPreviewTextView:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a view into which preview text can be placed.
 */

@@ -1,13 +1,7 @@
 {
     final LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
-    final Resources res = context.getResources();
-    final int minSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_size);
-    final ColorStateList textColor = ta.getColorStateList(TEXT_COLOR);
-    final float textSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_text_size);
     final TextView textView = new TextView(context);
     textView.setLayoutParams(params);
-    textView.setTextColor(textColor);
-    textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
     textView.setSingleLine(true);
     textView.setEllipsize(TruncateAt.MIDDLE);
     textView.setGravity(Gravity.CENTER);

Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.updateSlider:COMMENT
Method Modifier: private     
Comment:/**
 * Fetch the brightness from the system settings and update the slider
 */

@@ -1,10 +1,12 @@
 {
-    int value;
-    try {
-        value = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, UserHandle.USER_CURRENT);
-    } catch (SettingNotFoundException ex) {
-        value = mMaximumBacklight;
+    if (mAutomatic) {
+        float value = Settings.System.getFloatForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0, UserHandle.USER_CURRENT);
+        mControl.setMax((int) BRIGHTNESS_ADJ_RESOLUTION);
+        mControl.setValue((int) ((value + 1) * BRIGHTNESS_ADJ_RESOLUTION / 2f));
+    } else {
+        int value;
+        value = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT);
+        mControl.setMax(mMaximumBacklight - mMinimumBacklight);
+        mControl.setValue(value - mMinimumBacklight);
     }
-    mControl.setMax(mMaximumBacklight - mMinimumBacklight);
-    mControl.setValue(value - mMinimumBacklight);
 }

Find a functionally equivalent code:android.app.SharedPreferencesImpl.hasFileChangedUnexpectedly:COMMENT
Method Modifier: private     
Comment:// we didn't instigate.

@@ -14,20 +14,20 @@
              * violation, but we explicitly want this one.
              */
         BlockGuard.getThreadPolicy().onReadFromDisk();
-        stat = Libcore.os.stat(mFile.getPath());
+        stat = Os.stat(mFile.getPath());
     } catch (ErrnoException e) {
         return true;
     }

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.verifyFileDownloadSucceeded:COMMENT
Method Modifier: public      
Comment:/**
 * Waits for a previously-initiated download and verifies it has completed successfully.
 *
 * @throws Exception if unsuccessful
 */

@@ -1,6 +1,6 @@
 {
-    String filename = DOWNLOAD_5MB_FILENAME;
-    long filesize = DOWNLOAD_5MB_FILESIZE;
+    String filename = DOWNLOAD_FILENAME;
+    long filesize = DOWNLOAD_FILESIZE;
     long dlRequest = -1;
     boolean rebootMarkerValid = false;
     DataInputStream dataInputFile = null;
@@ -20,26 +20,26 @@
         }
         mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
     }
-    assertTrue(dlRequest != -1);
+    assertTrue("request id is -1 from download manager", dlRequest != -1);
     Cursor cursor = getCursor(dlRequest);
     ParcelFileDescriptor pfd = null;
     try {
@@ -28,36 +28,34 @@
         int columnIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);
         int status = cursor.getInt(columnIndex);
         int currentWaitTime = 0;
-        // Wait until the download finishes; don't wait for a notification b/c
-        // the download may well have been completed before the last reboot.
-        waitForDownloadOrTimeout_skipNotification(dlRequest);
+        assertTrue("download not finished", waitForDownload(dlRequest, 15 * 60 * 1000));
         Log.i(LOG_TAG, "Verifying download information...");
         // Verify specific info about the file (size, name, etc)...
         pfd = mDownloadManager.openDownloadedFile(dlRequest);

Find a functionally equivalent code:android.hardware.SystemSensorManager.cancelTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,5 +1,5 @@
 {
-    if (sensor != null && Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT) {
+    if (sensor != null && sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT) {
         return false;
     }
     synchronized (mTriggerListeners) {

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onKeyguardVisibilityChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onKeyguardVisibilityChanged(boolean)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the visibility of the keyguard changes.
 * @param showing Indicates if the keyguard is now visible.
 */


Find a functionally equivalent code:com.android.tools.layoutlib.create.DependencyFinder.DependencyVisitor.considerName:COMMENT
Method Modifier: public      
Comment:/**
 * Considers the given class name as a dependency.
 */

@@ -13,19 +13,17 @@
     }
     // Add it to the dependency set for the currently visited class, as needed.
     assert mCurrentDepSet != null;
-    if (mCurrentDepSet != null) {
-        mCurrentDepSet.add(className);
-    }
+    mCurrentDepSet.add(className);
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onEmergencyCallAction:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onEmergencyCallAction()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the emergency call button is pressed.
 */


Find a functionally equivalent code:android.os.Bundle.putCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<CharSequence> object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putCharSequenceArrayList(key, value);
 }

Find a functionally equivalent code:android.widget.Switch.setThumbDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param thumb Thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

@@ -1,4 +1,10 @@
 {
+    if (mThumbDrawable != null) {
+        mThumbDrawable.setCallback(null);
+    }
     mThumbDrawable = thumb;
+    if (thumb != null) {
+        thumb.setCallback(this);
+    }
     requestLayout();
 }

Find a functionally equivalent code:android.media.MediaRouter.selectRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use
 */

@@ -1,3 +1,3 @@
 {
-    selectRouteStatic(types, route);
+    selectRouteStatic(types, route, explicit);
 }

Find a functionally equivalent code:android.animation.ValueAnimator.start:COMMENT
Method Modifier: private     
Comment:/**
 * Start the animation playing. This version of start() takes a boolean flag that indicates
 * whether the animation should play in reverse. The flag is usually false, but may be set
 * to true if called from the reverse() method.
 *
 * <p>The animation started by calling this method will be run on the thread that called
 * this method. This thread should have a Looper on it (a runtime exception will be thrown if
 * this is not the case). Also, if the animation will animate
 * properties of objects in the view hierarchy, then the calling thread should be the UI
 * thread for that view hierarchy.</p>
 *
 * @param playBackwards Whether the ValueAnimator should start playing in reverse.
 */

@@ -8,13 +8,15 @@
     mStarted = true;
     mStartedDelay = false;
     mPaused = false;
+    // in case the scale factor has changed since creation time
+    updateScaledDuration();
     AnimationHandler animationHandler = getOrCreateAnimationHandler();
     animationHandler.mPendingAnimations.add(this);
     if (mStartDelay == 0) {

Find a functionally equivalent code:android.widget.CalendarView.setShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

@@ -1,8 +1,3 @@
 {
-    if (mShowWeekNumber == showWeekNumber) {
-        return;
-    }
-    mShowWeekNumber = showWeekNumber;
-    mAdapter.notifyDataSetChanged();
-    setUpHeader();
+    mDelegate.setShowWeekNumber(showWeekNumber);
 }

Find a functionally equivalent code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

@@ -30,35 +30,35 @@
         if (ident != newIdent) {
             Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
         }
-        msg.recycle();
+        msg.recycleUnchecked();
     }
 }

Find a functionally equivalent code:android.widget.CalendarView.getShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether to show the week number.
 *
 * @return True if showing the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

@@ -1,3 +1,3 @@
 {
-    return mShowWeekNumber;
+    return mDelegate.getShowWeekNumber();
 }

Find a functionally equivalent code:android.graphics.Canvas.restore:COMMENT
<android.graphics.Canvas: void restore()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * This call balances a previous call to save(), and is used to remove all
 * modifications to the matrix/clip state since the last save call. It is
 * an error to call restore() more times than save() was called.
 */

@@ -1 +1,3 @@
-
+{
+    native_restore(mNativeCanvasWrapper);
+}

Find a functionally equivalent code:android.media.MediaScanner.scanSingleFile:COMMENT
Method Modifier: public      
Comment:// this function is used to scan a single file

@@ -13,17 +13,19 @@
     } catch (RemoteException e) {
         Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
         return null;
+    } finally {
+        releaseResources();
     }
 }

Find a functionally equivalent code:android.graphics.Canvas.drawARGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified ARGB color, using srcover porterduff mode.
 *
 * @param a alpha component (0..255) of the color to draw onto the canvas
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

@@ -1,3 +1,3 @@
 {
-    native_drawARGB(mNativeCanvas, a, r, g, b);
+    drawColor(Color.argb(a, r, g, b));
 }

Find a functionally equivalent code:android.media.MediaPlayer.prepare:COMMENT
<android.media.MediaPlayer: void prepare()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Prepares the player for playback, synchronously.
 *
 * After setting the datasource and the display surface, you need to either
 * call prepare() or prepareAsync(). For files, it is OK to call prepare(),
 * which blocks until MediaPlayer is ready for playback.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

@@ -1 +1,4 @@
-
+{
+    _prepare();
+    scanInternalSubtitleTracks();
+}

Find a functionally equivalent code:android.media.MiniThumbFile.getMiniThumbFromFile:COMMENT
Method Modifier: public      
Comment:/**
 * Gallery app can use this method to retrieve mini-thumbnail. Full size
 * images share the same IDs with their corresponding thumbnails.
 *
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */

@@ -14,20 +14,20 @@
             byte flag = mBuffer.get();
             long magic = mBuffer.getLong();
             int length = mBuffer.getInt();
-            if (size >= 1 + 8 + 4 + length && data.length >= length) {
+            if (size >= 1 + 8 + 4 + length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
                 mBuffer.get(data, 0, length);
                 return data;
             }

Find a functionally equivalent code:android.service.dreams.DreamService.attach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called when the Dream is ready to be shown.
 *
 * Must run on mHandler.
 *
 * @param windowToken A window token that will allow a window to be created in the correct layer.
 */

@@ -3,51 +3,65 @@
         Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
         return;
     }
-    if (mDebug)
-        Slog.v(TAG, "Attached on thread " + Thread.currentThread().getId());
-    if (mSandman == null) {
-        loadSandman();
+    if (mFinished || mWaking) {
+        Slog.w(TAG, "attach() called after dream already finished");
+        try {
+            mSandman.finishSelf(windowToken, true);
+        } catch (RemoteException ex) {
+        // system server died
+        }
+        return;
     }
     mWindowToken = windowToken;
-    mWindow = PolicyManager.makeNewWindow(this);
-    mWindow.setCallback(this);
-    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
-    mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
-    mWindow.setFormat(PixelFormat.OPAQUE);
-    if (mDebug)
-        Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
-    WindowManager.LayoutParams lp = mWindow.getAttributes();
-    lp.type = WindowManager.LayoutParams.TYPE_DREAM;
-    lp.token = windowToken;
-    lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
-    lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
-    mWindow.setAttributes(lp);
-    if (mDebug)
-        Slog.v(TAG, "Created and attached window: " + mWindow);
-    mWindow.setWindowManager(null, windowToken, "dream", true);
-    mWindowManager = mWindow.getWindowManager();
-    if (mDebug)
-        Slog.v(TAG, "Window added on thread " + Thread.currentThread().getId());
-    try {
+    mCanDoze = canDoze;
+    if (mWindowless && !mCanDoze) {
+        throw new IllegalStateException("Only doze dreams can be windowless");
+    }
+    if (!mWindowless) {
+        mWindow = PolicyManager.makeNewWindow(this);
+        mWindow.setCallback(this);
+        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
+        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
+        mWindow.setFormat(PixelFormat.OPAQUE);
+        if (mDebug)
+            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
+        WindowManager.LayoutParams lp = mWindow.getAttributes();
+        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
+        lp.token = windowToken;
+        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
+        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
+        mWindow.setAttributes(lp);
+        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
+        // along well. Dreams usually don't need such bars anyways, so disable them by default.
+        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+        mWindow.setWindowManager(null, windowToken, "dream", true);
         applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
-        getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
-    } catch (Throwable t) {
-        Slog.w(TAG, "Crashed adding window view", t);
-        safelyFinish();
-        return;
+        try {
+            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
+        } catch (WindowManager.BadTokenException ex) {
+            // This can happen because the dream manager service will remove the token
+            // immediately without necessarily waiting for the dream to start.
+            // We should receive a finish message soon.
+            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
+            mWindow = null;
+            return;
+        }
     }
-    // start it up
+    // We need to defer calling onDreamingStarted until after onWindowAttached,
+    // which is posted to the handler by addView, so we post onDreamingStarted
+    // to the handler also.  Need to watch out here in case detach occurs before
+    // this callback is invoked.
     mHandler.post(new Runnable() {
 
         @Override
         public void run() {
-            try {
+            if (mWindow != null || mWindowless) {
+                if (mDebug)
+                    Slog.v(TAG, "Calling onDreamingStarted()");
+                mStarted = true;
                 onDreamingStarted();
-            } catch (Throwable t) {
-                Slog.w(TAG, "Crashed in onDreamingStarted()", t);
-                safelyFinish();
             }
         }
     });

Find a functionally equivalent code:android.graphics.Paint.clearShadowLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Clear the shadow layer.
 */

@@ -1,4 +1,3 @@
 {
-    hasShadow = false;
-    nSetShadowLayer(0, 0, 0, 0);
+    setShadowLayer(0, 0, 0, 0);
 }

Find a functionally equivalent code:android.view.Window.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flags of the window, as per the
 * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
 * flags.
 *
 * <p>Note that some flags must be set before the window decoration is
 * created (by the first call to
 * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
 * {@link #getDecorView()}:
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
 * will be set for you based on the {@link android.R.attr#windowIsFloating}
 * attribute.
 *
 * @param flags The new window flags (see WindowManager.LayoutParams).
 * @param mask Which of the window flag bits to modify.
 * @see #addFlags
 * @see #clearFlags
 */

@@ -5,11 +5,9 @@
         attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
     }
     mForcedWindowFlags |= mask;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.webkit.WebSyncManager.startSync:COMMENT
Method Modifier: public      
Comment:/**
 * startSync() requests sync manager to start sync
 */

@@ -1,12 +1,2 @@
 {
-    if (DebugFlags.WEB_SYNC_MANAGER) {
-        Log.v(LOGTAG, "***  WebSyncManager startSync ***, Ref count:" + mStartSyncRefCount);
-    }
-    if (mHandler == null) {
-        return;
-    }
-    if (++mStartSyncRefCount == 1) {
-        Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
-        mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
-    }
 }

Find a functionally equivalent code:android.media.MediaFocusControl.removeFocusStackEntry:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove a focus listener from the focus stack.
 * @param clientToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
 * focus, notify the next item in the stack it gained focus.
 */

@@ -7,16 +7,12 @@
         if (signal) {
             // notify the new top of the stack it gained focus
             notifyTopOfAudioFocusStack();
-            // there's a new top of the stack, let the remote control know
-            synchronized (mRCStack) {
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
         }
     } else {
         // focus is abandoned by a client that's not at the top of the stack,
@@ -19,25 +15,21 @@
         // evaluated it, traversal order doesn't matter here)
         Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
         while (stackIterator.hasNext()) {
-            FocusRequester fr = (FocusRequester) stackIterator.next();
+            FocusRequester fr = stackIterator.next();
             if (fr.hasSameClient(clientToRemove)) {
                 Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                 stackIterator.remove();

Find a functionally equivalent code:android.os.Bundle.readFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */

@@ -1,7 +1,5 @@
 {
-    int length = parcel.readInt();
-    if (length < 0) {
-        throw new RuntimeException("Bad length in parcel: " + length);
-    }
-    readFromParcelInner(parcel, length);
+    super.readFromParcelInner(parcel);
+    mHasFds = mParcelledData.hasFileDescriptors();
+    mFdsKnown = true;
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.dumpGeneratedClass:COMMENT
Method Modifier: private     
Comment:/**
 * For debugging, it's useful to dump the content of the generated classes
 * along with the exception that was generated.
 *
 * However to make it work you need to pull in the org.objectweb.asm.util.TraceClassVisitor
 * class and associated utilities which are found in the ASM source jar. Since we don't
 * want that dependency in the source code, we only put it manually for development and
 * access the TraceClassVisitor via reflection if present.
 *
 * @param t The exception thrown by {@link ClassLoader2#testModifiedInstance()}
 * @param cl2 The {@link ClassLoader2} instance with the generated bytecode.
 * @return Either original {@code t} or a new wrapper {@link Throwable}
 */

@@ -14,28 +14,27 @@
             StringWriter sw = new StringWriter();
             PrintWriter pw = new PrintWriter(sw);
             // next 2 lines do: TraceClassVisitor tcv = new TraceClassVisitor(pw);
-            Constructor<?> cons = tcvClass.getConstructor(new Class<?>[] { pw.getClass() });
-            Object tcv = cons.newInstance(new Object[] { pw });
+            Constructor<?> cons = tcvClass.getConstructor(pw.getClass());
+            Object tcv = cons.newInstance(pw);
             ClassReader cr2 = new ClassReader(bytes);
             cr2.accept((ClassVisitor) tcv, 0);
             sb.append("\nBytecode dump: <").append(className).append(">:\n").append(sw.toString());
         }
         // Re-throw exception with new message
-        RuntimeException ex = new RuntimeException(sb.toString(), t);
-        return ex;
+        return new RuntimeException(sb.toString(), t);
     } catch (Throwable ignore) {
         // In case of problem, just throw the original exception as-is.
         return t;

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleSimultaneously:COMMENT
Method Modifier: public      
Comment:/**
 * Tests 15 concurrent downloads of 1,000,000-byte files.
 *
 * @throws Exception if test failed
 */

@@ -1,7 +1,6 @@
 {
     final int TOTAL_DOWNLOADS = 15;
     HashSet<Long> downloadIds = new HashSet<Long>(TOTAL_DOWNLOADS);
-    MultipleDownloadsCompletedReceiver receiver = registerNewMultipleDownloadsReceiver();
     // Make sure there are no pending downloads currently going on
     removeAllCurrentDownloads();
     try {
@@ -12,23 +11,21 @@
             Request request = new Request(remoteUri);
             request.setTitle(filename);
             dlRequest = mDownloadManager.enqueue(request);
-            assertTrue(dlRequest != -1);
+            assertTrue("request id is -1 from download manager", dlRequest != -1);
             downloadIds.add(dlRequest);
         }
         // wait 15 mins max
-        waitForDownloadsOrTimeout(DEFAULT_WAIT_POLL_TIME, 15 * 60 * 2000);
-        assertEquals(TOTAL_DOWNLOADS, receiver.numDownloadsCompleted());
+        assertTrue("download not finished", waitForMultipleDownloads(downloadIds, 15 * 60 * 2000));
     } finally {
         removeAllCurrentDownloads();
     }

Find a functionally equivalent code:android.os.BatteryStats.getBluetoothOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that bluetooth has been on while the device was
 * running on battery.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

@@ -17,23 +17,23 @@
         return null;
     }
     try {
-        String type = ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId());
+        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
         return type;
     } catch (RemoteException e) {
         // Manager will kill this process shortly anyway.

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.initFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityNodeInfo}.
 */

@@ -6,16 +6,20 @@
     mLabelForId = parcel.readLong();
     mLabeledById = parcel.readLong();
     mConnectionId = parcel.readInt();
-    SparseLongArray childIds = mChildNodeIds;
     final int childrenSize = parcel.readInt();
-    for (int i = 0; i < childrenSize; i++) {
-        final long childId = parcel.readLong();
-        childIds.put(i, childId);
+    if (childrenSize <= 0) {
+        mChildNodeIds = null;
+    } else {
+        mChildNodeIds = new LongArray(childrenSize);
+        for (int i = 0; i < childrenSize; i++) {
+            final long childId = parcel.readLong();
+            mChildNodeIds.add(childId);
+        }
     }
     mBoundsInParent.top = parcel.readInt();
     mBoundsInParent.bottom = parcel.readInt();
@@ -20,31 +24,46 @@
     mBoundsInScreen.bottom = parcel.readInt();
     mBoundsInScreen.left = parcel.readInt();
     mBoundsInScreen.right = parcel.readInt();
-    mActions = parcel.readInt();
+    final int actionCount = parcel.readInt();
+    if (actionCount > 0) {
+        final int legacyStandardActions = parcel.readInt();
+        addLegacyStandardActions(legacyStandardActions);
+        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
+        for (int i = 0; i < nonLegacyActionCount; i++) {
+            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
+            addAction(action);
+        }
+    }
+    mMaxTextLength = parcel.readInt();
     mMovementGranularities = parcel.readInt();
     mBooleanProperties = parcel.readInt();
     mPackageName = parcel.readCharSequence();
     mClassName = parcel.readCharSequence();
     mText = parcel.readCharSequence();
+    mError = parcel.readCharSequence();
     mContentDescription = parcel.readCharSequence();
     mViewIdResourceName = parcel.readString();
     mTextSelectionStart = parcel.readInt();
@@ -39,47 +54,62 @@
         mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
     }
     if (parcel.readInt() == 1) {
-        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
+        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
     }
     if (parcel.readInt() == 1) {
-        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
+        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
     }
 }

Find a functionally equivalent code:android.media.AudioRecord.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

@@ -1,7 +1,7 @@
 {
     // NB: this section is only valid with PCM data.
     // To update when supporting compressed formats
-    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
+    int frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
     if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
         throw new IllegalArgumentException("Invalid audio buffer size.");
     }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeQueueing:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -3,8 +3,9 @@
         // If we have not yet booted, don't let key events do anything.
         return 0;
     }
+    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
     final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
     final boolean canceled = event.isCanceled();
     final int keyCode = event.getKeyCode();
@@ -11,51 +12,51 @@
     // the same as if it were open and in front.
     // This will prevent any keys other than the power button from waking the screen
     // when the keyguard is hidden by another activity.
-    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (isScreenOn ? mKeyguardDelegate.isShowingAndNotHidden() : mKeyguardDelegate.isShowing()));
-    if (keyCode == KeyEvent.KEYCODE_POWER) {
-        policyFlags |= WindowManagerPolicy.FLAG_WAKE;
-    }
-    final boolean isWakeKey = (policyFlags & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
+    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? mKeyguardDelegate.isShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
     if (DEBUG_INPUT) {
-        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags) + " isWakeKey=" + isWakeKey);
-    }
-    if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0) {
-        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
+        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
     }
-    // Basic policy based on screen state and keyguard.
-    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
-    // is on or off, really.  We should care about whether the device is in an
-    // interactive state or is in suspend pretending to be "off".
-    // The primary screen might be turned off due to proximity sensor or
-    // because we are presenting media on an auxiliary screen or remotely controlling
-    // the device some other way (which is why we have an exemption here for injected
-    // events).
+    // Basic policy based on interactive state.
     int result;
-    if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
-        // When the screen is on or if the key is injected pass the key to the application.
+    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
+    if (interactive || (isInjected && !isWakeKey)) {
+        // When the device is interactive or the key is injected pass the
+        // key to the application.
         result = ACTION_PASS_TO_USER;
+        isWakeKey = false;
+    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
+        // If we're currently dozing with the screen on and the keyguard showing, pass the key
+        // to the application but preserve its wake key status to make sure we still move
+        // from dozing to fully interactive if we would normally go from off to fully
+        // interactive.
+        result = ACTION_PASS_TO_USER;
     } else {
         // When the screen is off and the key is not injected, determine whether
         // to wake the device but don't pass the key to the application.
         result = 0;
-        if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
-            result |= ACTION_WAKE_UP;
+        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
+            isWakeKey = false;
         }
     }
     // key processing.
     if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
+        if (isWakeKey) {
+            mPowerManager.wakeUp(event.getEventTime());
+        }
         return result;
     }
+    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
     // Handle special keys.
     switch(keyCode) {
         case KeyEvent.KEYCODE_VOLUME_DOWN:
@@ -54,60 +54,60 @@
             {
                 if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                     if (down) {
-                        if (isScreenOn && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                        if (interactive && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                             mVolumeDownKeyTriggered = true;
                             mVolumeDownKeyTime = event.getDownTime();
                             mVolumeDownKeyConsumedByScreenshotChord = false;
@@ -67,73 +67,73 @@
                     }
                 } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                     if (down) {
-                        if (isScreenOn && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                        if (interactive && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                             mVolumeUpKeyTriggered = true;
                             cancelPendingPowerKeyAction();
                             cancelPendingScreenshotChordAction();
@@ -78,116 +78,113 @@
                     }
                 }
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // If an incoming call is ringing, either VOLUME key means
-                                // "silence ringer".  We handle these keys here, rather than
-                                // in the InCallScreen, to make sure we'll respond to them
-                                // even if the InCallScreen hasn't come to the foreground yet.
-                                // Look for the DOWN event here, to agree with the "fallback"
-                                // behavior in the InCallScreen.
-                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
-                                // Silence the ringer.  (It's safe to call this
-                                // even if the ringer has already been silenced.)
-                                telephonyService.silenceRinger();
-                                // And *don't* pass this key thru to the current activity
-                                // (which is probably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                                break;
-                            }
-                            if (telephonyService.isOffhook() && (result & ACTION_PASS_TO_USER) == 0) {
-                                // If we are in call but we decided not to pass the key to
-                                // the application, handle the volume change here.
-                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
-                                break;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    TelecomManager telecomManager = getTelecommService();
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            // If an incoming call is ringing, either VOLUME key means
+                            // "silence ringer".  We handle these keys here, rather than
+                            // in the InCallScreen, to make sure we'll respond to them
+                            // even if the InCallScreen hasn't come to the foreground yet.
+                            // Look for the DOWN event here, to agree with the "fallback"
+                            // behavior in the InCallScreen.
+                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
+                            // Silence the ringer.  (It's safe to call this
+                            // even if the ringer has already been silenced.)
+                            telecomManager.silenceRinger();
+                            // And *don't* pass this key thru to the current activity
+                            // (which is probably the InCallScreen.)
+                            result &= ~ACTION_PASS_TO_USER;
+                            break;
+                        }
+                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
+                            // If we are in call but we decided not to pass the key to
+                            // the application, just pass it to the session service.
+                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
+                            break;
                         }
                     }
-                    if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
-                        // If music is playing but we decided not to pass the key to the
-                        // application, handle the volume change here.
-                        handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
+                    if ((result & ACTION_PASS_TO_USER) == 0) {
+                        // If we aren't passing to the user and no one else
+                        // handled it send it to the session manager to figure
+                        // out.
+                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                         break;
                     }
                 }
@@ -120,135 +117,128 @@
             {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
+                    TelecomManager telecomManager = getTelecommService();
                     boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            hungUp = telephonyService.endCall();
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
+                    if (telecomManager != null) {
+                        hungUp = telecomManager.endCall();
                     }
-                    interceptPowerKeyDown(!isScreenOn || hungUp);
+                    interceptPowerKeyDown(!interactive || hungUp);
                 } else {
                     if (interceptPowerKeyUp(canceled)) {
                         if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
@@ -138,144 +131,138 @@
                             }
                         }
                         if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
-                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                            mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
+                            isWakeKey = false;
                         }
                     }
                 }
@@ -148,203 +142,205 @@
             {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
-                    mImmersiveModeConfirmation.onPowerKeyDown(isScreenOn, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
-                    if (isScreenOn && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
+                    if (panic) {
+                        mHandler.post(mRequestTransientNav);
+                    }
+                    if (interactive && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                         mPowerKeyTriggered = true;
                         mPowerKeyTime = event.getDownTime();
                         interceptScreenshotChord();
                     }
-                    ITelephony telephonyService = getTelephonyService();
+                    TelecomManager telecomManager = getTelecommService();
                     boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // Pressing Power while there's a ringing incoming
-                                // call should silence the ringer.
-                                telephonyService.silenceRinger();
-                            } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telephonyService.isOffhook()) {
-                                // Otherwise, if "Power button ends call" is enabled,
-                                // the Power button will hang up any current active call.
-                                hungUp = telephonyService.endCall();
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            // Pressing Power while there's a ringing incoming
+                            // call should silence the ringer.
+                            telecomManager.silenceRinger();
+                        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
+                            // Otherwise, if "Power button ends call" is enabled,
+                            // the Power button will hang up any current active call.
+                            hungUp = telecomManager.endCall();
                         }
                     }
-                    interceptPowerKeyDown(!isScreenOn || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
+                    interceptPowerKeyDown(!interactive || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                 } else {
                     mPowerKeyTriggered = false;
                     cancelPendingScreenshotChordAction();
                     if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
-                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                        if (mScreenOnEarly && !mScreenOnFully) {
+                            Slog.i(TAG, "Suppressed redundant power key press while " + "already in the process of turning the screen on.");
+                        } else {
+                            powerShortPress(event.getEventTime());
+                        }
+                        isWakeKey = false;
                     }
                     mPendingPowerKeyUpCanceled = false;
                 }
                 break;
             }
+        case KeyEvent.KEYCODE_SLEEP:
+            {
+                result &= ~ACTION_PASS_TO_USER;
+                if (!mPowerManager.isInteractive()) {
+                    // suppress feedback if already non-interactive
+                    useHapticFeedback = false;
+                }
+                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
+                isWakeKey = false;
+                break;
+            }
+        case KeyEvent.KEYCODE_WAKEUP:
+            {
+                result &= ~ACTION_PASS_TO_USER;
+                isWakeKey = true;
+                break;
+            }
         case KeyEvent.KEYCODE_MEDIA_PLAY:
         case KeyEvent.KEYCODE_MEDIA_PAUSE:
         case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            if (down) {
-                ITelephony telephonyService = getTelephonyService();
-                if (telephonyService != null) {
-                    try {
-                        if (!telephonyService.isIdle()) {
-                            // to avoid music playback.
-                            break;
-                        }
-                    } catch (RemoteException ex) {
-                        Log.w(TAG, "ITelephony threw RemoteException", ex);
-                    }
-                }
-            }
         case KeyEvent.KEYCODE_HEADSETHOOK:
         case KeyEvent.KEYCODE_MUTE:
         case KeyEvent.KEYCODE_MEDIA_STOP:
@@ -208,213 +210,220 @@
         case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
         case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
             {
+                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
+                    // If the global session is active pass all media keys to it
+                    // instead of the active window.
+                    result &= ~ACTION_PASS_TO_USER;
+                }
                 if ((result & ACTION_PASS_TO_USER) == 0) {
                     // Only do this if we would otherwise not pass it to the user. In that
                     // case, the PhoneWindow class will do the same thing, except it will
@@ -224,246 +231,265 @@
         case KeyEvent.KEYCODE_CALL:
             {
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
-                                telephonyService.answerRingingCall();
-                                // And *don't* pass this key thru to the current activity
-                                // (which is presumably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    TelecomManager telecomManager = getTelecommService();
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
+                            telecomManager.acceptRingingCall();
+                            // And *don't* pass this key thru to the current activity
+                            // (which is presumably the InCallScreen.)
+                            result &= ~ACTION_PASS_TO_USER;
                         }
                     }
                 }
                 break;
             }
+        case KeyEvent.KEYCODE_VOICE_ASSIST:
+            {
+                // key event here because the original key event will be recycled when we return.
+                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
+                    mBroadcastWakeLock.acquire();
+                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
+                    msg.setAsynchronous(true);
+                    msg.sendToTarget();
+                }
+            }
+    }
+    if (useHapticFeedback) {
+        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
+    }
+    if (isWakeKey) {
+        mPowerManager.wakeUp(event.getEventTime());
     }
     return result;
 }

Find a functionally equivalent code:com.android.wallpapercropper.WallpaperCropActivity.BitmapCropTask.regenerateInputStream:COMMENT
Method Modifier: private     
Comment:// Helper to setup input stream

@@ -2,20 +2,20 @@
     if (mInUri == null && mInResId == 0 && mInFilePath == null && mInImageBytes == null) {
         Log.w(LOGTAG, "cannot read original file, no input URI, resource ID, or " + "image byte array given");
     } else {
-        Utils.closeSilently(mInStream);
         try {
             if (mInUri != null) {
-                mInStream = new BufferedInputStream(mContext.getContentResolver().openInputStream(mInUri));
+                return new BufferedInputStream(mContext.getContentResolver().openInputStream(mInUri));
             } else if (mInFilePath != null) {
-                mInStream = mContext.openFileInput(mInFilePath);
+                return mContext.openFileInput(mInFilePath);
             } else if (mInImageBytes != null) {
-                mInStream = new BufferedInputStream(new ByteArrayInputStream(mInImageBytes));
+                return new BufferedInputStream(new ByteArrayInputStream(mInImageBytes));
             } else {
-                mInStream = new BufferedInputStream(mResources.openRawResource(mInResId));
+                return new BufferedInputStream(mResources.openRawResource(mInResId));
             }
         } catch (FileNotFoundException e) {
             Log.w(LOGTAG, "cannot read file: " + mInUri.toString(), e);
         }
     }
+    return null;
 }

Find a functionally equivalent code:android.os.BatteryStats.getWifiOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that wifi has been on while the device was
 * running on battery.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.util.ArraySet.contains:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether a value exists in the set.
 *
 * @param key The value to search for.
 * @return Returns true if the value exists, else false.
 */

@@ -1,3 +1,3 @@
 {
-    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
+    return indexOf(key) >= 0;
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setEvaluator:COMMENT
Method Modifier: public      
Comment:/**
 * The TypeEvaluator will be automatically determined based on the type of values
 * supplied to PropertyValuesHolder. The evaluator can be manually set, however, if so
 * desired. This may be important in cases where either the type of the values supplied
 * do not match the way that they should be interpolated between, or if the values
 * are of a custom type or one not currently understood by the animation system. Currently,
 * only values of type float and int (and their Object equivalents: Float
 * and Integer) are  correctly interpolated; all other types require setting a TypeEvaluator.
 * @param evaluator
 */

@@ -1,4 +1,4 @@
 {
     mEvaluator = evaluator;
-    mKeyframeSet.setEvaluator(evaluator);
+    mKeyframes.setEvaluator(evaluator);
 }

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.setUp:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc }
 */

@@ -2,8 +2,8 @@
     super.setUp();
     DownloadManagerTestRunner mRunner = (DownloadManagerTestRunner) getInstrumentation();
     externalDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
-    assertNotNull(externalDownloadUriValue);
+    assertNotNull("download url is null", externalDownloadUriValue);
     externalLargeDownloadUriValue = normalizeUri(mRunner.externalDownloadUriValue);
-    assertNotNull(externalLargeDownloadUriValue);
+    assertNotNull("large download url is null", externalLargeDownloadUriValue);
 }

Find a functionally equivalent code:android.view.LayoutInflater.setPrivateFactory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide for use by framework
 */

@@ -1,3 +1,7 @@
 {
-    mPrivateFactory = factory;
+    if (mPrivateFactory == null) {
+        mPrivateFactory = factory;
+    } else {
+        mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);
+    }
 }

Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setPlaybackStream:COMMENT
Method Modifier: public      
Comment:/**
 * Defines over what stream type the media is presented.
 * @param stream
 */

@@ -1,6 +1,6 @@
 {
     if (mPlaybackStream != stream) {
         mPlaybackStream = stream;
-        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_USES_STREAM, stream);
+        configureSessionVolume();
     }
 }

Find a functionally equivalent code:android.util.JsonReader.skipValue:COMMENT
Method Modifier: public      
Comment:/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */

@@ -1,6 +1,9 @@
 {
     skipping = true;
     try {
+        if (!hasNext() || peek() == JsonToken.END_DOCUMENT) {
+            throw new IllegalStateException("No element left to skip");
+        }
         int count = 0;
         do {
             JsonToken token = advance();

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readValueXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a flattened object from an XmlPullParser.  The XML data could
 * previously have been written with writeMapXml(), writeListXml(), or
 * writeValueXml().  The XmlPullParser must be positioned <em>at</em> the
 * tag that defines the value.
 *
 * @param parser The XmlPullParser from which to read the object.
 * @param name An array of one string, used to return the name attribute
 * of the value's tag.
 *
 * @return Object The newly generated value object.
 *
 * @see #readMapXml
 * @see #readListXml
 * @see #writeValueXml
 */

@@ -2,8 +2,8 @@
     int eventType = parser.getEventType();
     do {
         if (eventType == parser.START_TAG) {
-            return readThisValueXml(parser, name);
+            return readThisValueXml(parser, name, null);
         } else if (eventType == parser.END_TAG) {
             throw new XmlPullParserException("Unexpected end tag at: " + parser.getName());
         } else if (eventType == parser.TEXT) {

Find a functionally equivalent code:android.media.MediaRouter.Static.startMonitoringRoutes:COMMENT
Method Modifier: 
Comment:// Called after sStatic is initialized

@@ -2,8 +2,8 @@
     mDefaultAudioVideo = new RouteInfo(mSystemCategory);
     mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
     mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
-    mDefaultAudioVideo.mPresentationDisplay = choosePresentationDisplayForRoute(mDefaultAudioVideo, getAllPresentationDisplays());
+    mDefaultAudioVideo.updatePresentationDisplay();
     addRouteStatic(mDefaultAudioVideo);
     // This will select the active wifi display route if there is one.
     updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
@@ -20,27 +20,29 @@
         // route yet.
         updateAudioRoutes(newAudioRoutes);
     }
+    // Bind to the media router service.
+    rebindAsUser(UserHandle.myUserId());
     // appropriately with relevant system state.
     if (mSelectedRoute == null) {
-        selectRouteStatic(mDefaultAudioVideo.getSupportedTypes(), mDefaultAudioVideo);
+        selectDefaultRouteStatic();
     }
 }

Find a functionally equivalent code:android.appwidget.AppWidgetManager.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the AppWidgetManager instance to use for the supplied {@link android.content.Context
 * Context} object.
 */

@@ -1,18 +1,3 @@
 {
-    synchronized (sManagerCache) {
-        if (sService == null) {
-            IBinder b = ServiceManager.getService(Context.APPWIDGET_SERVICE);
-            sService = IAppWidgetService.Stub.asInterface(b);
-        }
-        WeakReference<AppWidgetManager> ref = sManagerCache.get(context);
-        AppWidgetManager result = null;
-        if (ref != null) {
-            result = ref.get();
-        }
-        if (result == null) {
-            result = new AppWidgetManager(context);
-            sManagerCache.put(context, new WeakReference<AppWidgetManager>(result));
-        }
-        return result;
-    }
+    return (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
 }

Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.onPostExecute:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

@@ -1,6 +1,6 @@
 {
     if (DEBUG)
-        Slog.v(TAG, this + " onPostExecute");
+        Log.v(TAG, this + " onPostExecute");
     try {
         AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
     } finally {

Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.interceptMediaKey:COMMENT
<com.android.keyguard.KeyguardViewBase: boolean interceptMediaKey(KeyEvent)>
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Allows the media keys to work when the keyguard is showing.
 * The media keys should be of no interest to the actual keyguard view(s),
 * so intercepting them here should not be of any harm.
 * @param event The key event
 * @return whether the event was consumed as a media key.
 */

@@ -39,45 +39,47 @@
                         }
                         // Volume buttons should only function for music (local or remote).
                         // TODO: Actually handle MUTE.
-                        mAudioManager.adjustLocalOrRemoteStreamVolume(AudioManager.STREAM_MUSIC, keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER);
+                        mAudioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER, /* direction */
+                        AudioManager.STREAM_MUSIC, /* stream */
+                        0);
                         // Don't execute default volume behavior
                         return true;
                     } else {

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */

@@ -4,8 +4,8 @@
         return null;
     }
     AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
-    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
+    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardFaceUnlockView.maybeStartBiometricUnlock:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the biometric unlock if it should be started based on a number of factors.  If it
 * should not be started, it either goes to the back up, or remains showing to prepare for
 * it being started later.
 */

@@ -4,16 +4,15 @@
     if (mBiometricUnlock != null) {
         KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);
         final boolean backupIsTimedOut = (monitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT);
-        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
-        boolean isShowing;
-        synchronized (mIsShowingLock) {
-            isShowing = mIsShowing;
+        boolean isBouncerVisibleToUser;
+        synchronized (mIsBouncerVisibleToUserLock) {
+            isBouncerVisibleToUser = mIsBouncerVisibleToUser;
         }
-        // showing.
-        if (!powerManager.isScreenOn() || !isShowing) {
+        // it here and ready for when the bouncer does show.
+        if (!isBouncerVisibleToUser) {
             // It shouldn't be running but calling this can't hurt.
             mBiometricUnlock.stop();
             return;

Find a functionally equivalent code:android.media.Ringtone.setUri:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set {@link Uri} to be used for ringtone playback. Attempts to open
 * locally, otherwise will delegate playback to remote
 * {@link IRingtonePlayer}.
 *
 * @hide
 */

@@ -9,15 +9,15 @@
     mLocalPlayer = new MediaPlayer();
     try {
         mLocalPlayer.setDataSource(mContext, mUri);
-        mLocalPlayer.setAudioStreamType(mStreamType);
+        mLocalPlayer.setAudioAttributes(mAudioAttributes);
         mLocalPlayer.prepare();
     } catch (SecurityException e) {
         destroyLocalPlayer();

Find a functionally equivalent code:android.os.Process.myTid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of the calling thread, which be used with
 * {@link #setThreadPriority(int, int)}.
 */

@@ -1,3 +1,3 @@
 {
-    return Libcore.os.gettid();
+    return Os.gettid();
 }

Find a functionally equivalent code:android.view.PointerIcon.load:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Loads the bitmap and hotspot information for a pointer icon, if it is not already loaded.
 * Returns a pointer icon (not necessarily the same instance) with the information filled in.
 *
 * @param context The context.
 * @return The loaded pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 * @see #isLoaded()
 * @hide
 */

@@ -7,12 +7,12 @@
     }
     PointerIcon result = new PointerIcon(mStyle);
     result.mSystemIconResourceId = mSystemIconResourceId;
-    result.loadResource(context.getResources(), mSystemIconResourceId);
+    result.loadResource(context, context.getResources(), mSystemIconResourceId);
     return result;
 }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerStart:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:android.content.res.TypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.transition.Transition.captureValues:COMMENT
Method Modifier: 
Comment:/**
 * Recursive method that captures values for the given view and the
 * hierarchy underneath it.
 * @param sceneRoot The root of the view hierarchy being captured
 * @param start true if this capture is happening before the scene change,
 * false otherwise
 */

@@ -1,60 +1,59 @@
 {
-    if (start) {
-        mStartValues.viewValues.clear();
-        mStartValues.idValues.clear();
-        mStartValues.itemIdValues.clear();
-    } else {
-        mEndValues.viewValues.clear();
-        mEndValues.idValues.clear();
-        mEndValues.itemIdValues.clear();
-    }
-    if (mTargetIds.size() > 0 || mTargets.size() > 0) {
-        if (mTargetIds.size() > 0) {
-            for (int i = 0; i < mTargetIds.size(); ++i) {
-                int id = mTargetIds.get(i);
-                View view = sceneRoot.findViewById(id);
-                if (view != null) {
-                    TransitionValues values = new TransitionValues();
-                    values.view = view;
-                    if (start) {
-                        captureStartValues(values);
-                    } else {
-                        captureEndValues(values);
-                    }
-                    if (start) {
-                        mStartValues.viewValues.put(view, values);
-                        if (id >= 0) {
-                            mStartValues.idValues.put(id, values);
-                        }
-                    } else {
-                        mEndValues.viewValues.put(view, values);
-                        if (id >= 0) {
-                            mEndValues.idValues.put(id, values);
-                        }
-                    }
+    clearValues(start);
+    if ((mTargetIds.size() > 0 || mTargets.size() > 0) && (mTargetNames == null || mTargetNames.isEmpty()) && (mTargetTypes == null || mTargetTypes.isEmpty())) {
+        for (int i = 0; i < mTargetIds.size(); ++i) {
+            int id = mTargetIds.get(i);
+            View view = sceneRoot.findViewById(id);
+            if (view != null) {
+                TransitionValues values = new TransitionValues();
+                values.view = view;
+                if (start) {
+                    captureStartValues(values);
+                } else {
+                    captureEndValues(values);
+                }
+                values.targetedTransitions.add(this);
+                capturePropagationValues(values);
+                if (start) {
+                    addViewValues(mStartValues, view, values);
+                } else {
+                    addViewValues(mEndValues, view, values);
                 }
             }
         }
-        if (mTargets.size() > 0) {
-            for (int i = 0; i < mTargets.size(); ++i) {
-                View view = mTargets.get(i);
-                if (view != null) {
-                    TransitionValues values = new TransitionValues();
-                    values.view = view;
-                    if (start) {
-                        captureStartValues(values);
-                    } else {
-                        captureEndValues(values);
-                    }
-                    if (start) {
-                        mStartValues.viewValues.put(view, values);
-                    } else {
-                        mEndValues.viewValues.put(view, values);
-                    }
-                }
+        for (int i = 0; i < mTargets.size(); ++i) {
+            View view = mTargets.get(i);
+            TransitionValues values = new TransitionValues();
+            values.view = view;
+            if (start) {
+                captureStartValues(values);
+            } else {
+                captureEndValues(values);
+            }
+            values.targetedTransitions.add(this);
+            capturePropagationValues(values);
+            if (start) {
+                addViewValues(mStartValues, view, values);
+            } else {
+                addViewValues(mEndValues, view, values);
             }
         }
     } else {
         captureHierarchy(sceneRoot, start);
     }
+    if (!start && mNameOverrides != null) {
+        int numOverrides = mNameOverrides.size();
+        ArrayList<View> overriddenViews = new ArrayList<View>(numOverrides);
+        for (int i = 0; i < numOverrides; i++) {
+            String fromName = mNameOverrides.keyAt(i);
+            overriddenViews.add(mStartValues.nameValues.remove(fromName));
+        }
+        for (int i = 0; i < numOverrides; i++) {
+            View view = overriddenViews.get(i);
+            if (view != null) {
+                String toName = mNameOverrides.valueAt(i);
+                mStartValues.nameValues.put(toName, view);
+            }
+        }
+    }
 }

Find a functionally equivalent code:android.graphics.Paint.setColorFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the paint's colorfilter, returning the parameter.
 *
 * @param filter May be null. The new filter to be installed in the paint
 * @return       filter
 */

@@ -1,5 +1,5 @@
 {
-    int filterNative = 0;
+    long filterNative = 0;
     if (filter != null)
         filterNative = filter.native_instance;
     native_setColorFilter(mNativePaint, filterNative);

Find a functionally equivalent code:com.android.systemui.SwipeHelper.dismissChild:COMMENT
Method Modifier: public      
Comment:/**
 * @param view The view to be dismissed
 * @param velocity The desired pixels/second speed at which the view should move
 */

@@ -1,35 +1,3 @@
 {
-    final View animView = mCallback.getChildContentView(view);
-    final boolean canAnimViewBeDismissed = mCallback.canChildBeDismissed(view);
-    float newPos;
-    if (velocity < 0 || (velocity == 0 && getTranslation(animView) < 0) || // if we use the Menu to dismiss an item in landscape, animate up
-    (velocity == 0 && getTranslation(animView) == 0 && mSwipeDirection == Y)) {
-        newPos = -getSize(animView);
-    } else {
-        newPos = getSize(animView);
-    }
-    int duration = MAX_ESCAPE_ANIMATION_DURATION;
-    if (velocity != 0) {
-        duration = Math.min(duration, (int) (Math.abs(newPos - getTranslation(animView)) * 1000f / Math.abs(velocity)));
-    } else {
-        duration = DEFAULT_ESCAPE_ANIMATION_DURATION;
-    }
-    animView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
-    ObjectAnimator anim = createTranslationAnimation(animView, newPos);
-    anim.setInterpolator(sLinearInterpolator);
-    anim.setDuration(duration);
-    anim.addListener(new AnimatorListenerAdapter() {
-
-        public void onAnimationEnd(Animator animation) {
-            mCallback.onChildDismissed(view);
-            animView.setLayerType(View.LAYER_TYPE_NONE, null);
-        }
-    });
-    anim.addUpdateListener(new AnimatorUpdateListener() {
-
-        public void onAnimationUpdate(ValueAnimator animation) {
-            updateAlphaFromOffset(animView, canAnimViewBeDismissed);
-        }
-    });
-    anim.start();
+    dismissChild(view, velocity, null, 0, false, 0);
 }

Find a functionally equivalent code:android.content.ContentResolver.setMasterSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param sync the master auto-sync setting that applies to all the providers and accounts
 */

@@ -1,8 +1,3 @@
 {
-    try {
-        getContentService().setMasterSyncAutomatically(sync);
-    } catch (RemoteException e) {
-    // exception ignored; if this is thrown then it means the runtime is in the midst of
-    // being restarted
-    }
+    setMasterSyncAutomaticallyAsUser(sync, UserHandle.myUserId());
 }

Find a functionally equivalent code:android.provider.DocumentsProvider.openFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */

@@ -1,3 +1,4 @@
 {
+    enforceTree(uri);
     return openDocument(getDocumentId(uri), mode, signal);
 }

Find a functionally equivalent code:android.os.Bundle.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */

@@ -1,25 +1,7 @@
 {
     final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
     try {
-        if (mParcelledData != null) {
-            int length = mParcelledData.dataSize();
-            parcel.writeInt(length);
-            parcel.writeInt(BUNDLE_MAGIC);
-            parcel.appendFrom(mParcelledData, 0, length);
-        } else {
-            int lengthPos = parcel.dataPosition();
-            // dummy, will hold length
-            parcel.writeInt(-1);
-            parcel.writeInt(BUNDLE_MAGIC);
-            int startPos = parcel.dataPosition();
-            parcel.writeArrayMapInternal(mMap);
-            int endPos = parcel.dataPosition();
-            // Backpatch length
-            parcel.setDataPosition(lengthPos);
-            int length = endPos - startPos;
-            parcel.writeInt(length);
-            parcel.setDataPosition(endPos);
-        }
+        super.writeToParcelInner(parcel, flags);
     } finally {
         parcel.restoreAllowFds(oldAllowFds);
     }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getChildCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of children.
 *
 * @return The child count.
 */

@@ -1,3 +1,3 @@
 {
-    return mChildNodeIds.size();
+    return mChildNodeIds == null ? 0 : mChildNodeIds.size();
 }

Find a functionally equivalent code:android.content.res.TypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.addNewDelegate:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a delegate to the manager and returns the native int used to identify it.
 * @param newDelegate the delegate to add
 * @return a unique native int to identify the delegate
 */

@@ -1,5 +1,5 @@
 {
-    int native_object = ++mDelegateCounter;
+    long native_object = ++mDelegateCounter;
     mDelegates.put(native_object, newDelegate);
     assert !mJavaReferences.contains(newDelegate);
     mJavaReferences.add(newDelegate);

Find a functionally equivalent code:com.android.systemui.usb.StorageNotification.setUsbStorageNotification:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the USB storage notification.
 */

@@ -26,32 +26,35 @@
             Intent intent = new Intent();
             pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
         }
+        mUsbStorageNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
         mUsbStorageNotification.setLatestEventInfo(mContext, title, message, pi);
+        mUsbStorageNotification.visibility = Notification.VISIBILITY_PUBLIC;
+        mUsbStorageNotification.category = Notification.CATEGORY_SYSTEM;
         final boolean adbOn = 1 == Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.ADB_ENABLED, 0);
         if (POP_UMS_ACTIVITY_ON_CONNECT && !adbOn) {
             // Pop up a full-screen alert to coach the user through enabling UMS. The average

Find a functionally equivalent code:android.util.ArrayMap.remove:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an existing key from the array map.
 * @param key The key of the mapping to remove.
 * @return Returns the value that was stored under the key, or null if there
 * was no such key.
 */

@@ -1,5 +1,5 @@
 {
-    int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
+    final int index = indexOfKey(key);
     if (index >= 0) {
         return removeAt(index);
     }

Find a functionally equivalent code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

@@ -12,17 +12,19 @@
             return "FLAG_REPORT_VIEW_IDS";
         case FLAG_REQUEST_FILTER_KEY_EVENTS:
             return "FLAG_REQUEST_FILTER_KEY_EVENTS";
+        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
+            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
         default:
             return null;
     }

Find a functionally equivalent code:android.os.FileUtils.getUid:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return owning UID of given path, otherwise -1.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return Libcore.os.stat(path).st_uid;
+        return Os.stat(path).st_uid;
     } catch (ErrnoException e) {
         return -1;
     }

Find a functionally equivalent code:android.app.Notification.BigTextStyle.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,4 +1,4 @@
 {
     super.addExtras(extras);
-    extras.putCharSequence(EXTRA_TEXT, mBigText);
+    extras.putCharSequence(EXTRA_BIG_TEXT, mBigText);
 }

Find a functionally equivalent code:android.transition.TransitionSet.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Setting a non-negative duration on a TransitionSet causes all of the child
 * transitions (current and future) to inherit this duration.
 *
 * @param duration The length of the animation, in milliseconds.
 * @return This transitionSet object.
 */

@@ -1,6 +1,6 @@
 {
     super.setDuration(duration);
-    if (mDuration >= 0) {
+    if (mDuration >= 0 && mTransitions != null) {
         int numTransitions = mTransitions.size();
         for (int i = 0; i < numTransitions; ++i) {
             mTransitions.get(i).setDuration(duration);

Find a functionally equivalent code:android.transition.TransitionSet.runAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,8 +1,14 @@
 {
+    if (mTransitions.isEmpty()) {
+        start();
+        end();
+        return;
+    }
     setupStartEndListeners();
+    int numTransitions = mTransitions.size();
     if (!mPlayTogether) {
         // TODO: Need to add listeners in such a way that we can remove them later if canceled
-        for (int i = 1; i < mTransitions.size(); ++i) {
+        for (int i = 1; i < numTransitions; ++i) {
             Transition previousTransition = mTransitions.get(i - 1);
             final Transition nextTransition = mTransitions.get(i);
             previousTransition.addListener(new TransitionListenerAdapter() {
@@ -19,26 +25,32 @@
             firstTransition.runAnimators();
         }
     } else {
-        for (Transition childTransition : mTransitions) {
-            childTransition.runAnimators();
+        for (int i = 0; i < numTransitions; ++i) {
+            mTransitions.get(i).runAnimators();
         }
     }
 }

Find a functionally equivalent code:com.android.systemui.statusbar.BaseStatusBar.visibilityChanged:COMMENT
Method Modifier: protected   
Comment:/**
 * The LEDs are turned o)ff when the notification panel is shown, even just a little bit.
 * This was added last-minute and is inconsistent with the way the rest of the notifications
 * are handled, because the notification isn't really cancelled.  The lights are just
 * turned off.  If any other notifications happen, the lights will turn back on.  Steve says
 * this is what he wants. (see bug 1131461)
 */

@@ -1,8 +1,15 @@
 {
     if (mPanelSlightlyVisible != visible) {
         mPanelSlightlyVisible = visible;
+        if (!visible) {
+            dismissPopups();
+        }
         try {
-            mBarService.onPanelRevealed();
+            if (visible) {
+                mBarService.onPanelRevealed();
+            } else {
+                mBarService.onPanelHidden();
+            }
         } catch (RemoteException ex) {
         // Won't fail unless the world has ended.
         }

Find a functionally equivalent code:android.widget.CalendarView.setSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the background color for the selected week.
 *
 * @param color The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

@@ -1,12 +1,3 @@
 {
-    if (mSelectedWeekBackgroundColor != color) {
-        mSelectedWeekBackgroundColor = color;
-        final int childCount = mListView.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            WeekView weekView = (WeekView) mListView.getChildAt(i);
-            if (weekView.mHasSelectedDay) {
-                weekView.invalidate();
-            }
-        }
-    }
+    mDelegate.setSelectedWeekBackgroundColor(color);
 }

Find a functionally equivalent code:android.appwidget.AppWidgetHostView.getRemoteContext:COMMENT
Method Modifier: private     
Comment:/**
 * Build a {@link Context} cloned into another package name, usually for the
 * purposes of reading remote resources.
 */

@@ -1,13 +1,9 @@
 {
-    // Bail if missing package name
-    final String packageName = views.getPackage();
-    if (packageName == null)
-        return mContext;
     try {
         // Return if cloned successfully, otherwise default
-        return mContext.createPackageContextAsUser(packageName, Context.CONTEXT_RESTRICTED, mUser);
+        return mContext.createApplicationContext(mInfo.providerInfo.applicationInfo, Context.CONTEXT_RESTRICTED);
     } catch (NameNotFoundException e) {
-        Log.e(TAG, "Package name " + packageName + " not found");
+        Log.e(TAG, "Package name " + mInfo.providerInfo.packageName + " not found");
         return mContext;
     }
 }

Find a functionally equivalent code:android.graphics.Rect.unflattenFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a Rect from a string of the form returned by {@link #flattenToString},
 * or null if the string is not of that form.
 */

@@ -1,5 +1,5 @@
 {
-    Matcher matcher = FLATTENED_PATTERN.matcher(str);
+    Matcher matcher = UnflattenHelper.getMatcher(str);
     if (!matcher.matches()) {
         return null;
     }

Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Stop listening to changes for this AppWidget.
 */

@@ -2,8 +2,8 @@
     synchronized (mViews) {
         mViews.remove(appWidgetId);
         try {
-            sService.deleteAppWidgetId(appWidgetId, mContext.getUserId());
+            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
         } catch (RemoteException e) {
             throw new RuntimeException("system server dead?", e);
         }

Find a functionally equivalent code:android.provider.MediaStore.InternalThumbnails.getThumbnail:COMMENT
Method Modifier: default     static      
Comment:/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */

@@ -46,51 +46,52 @@
                 if (sThumbBuf == null) {
                     sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                 }
+                Arrays.fill(sThumbBuf, (byte) 0);
                 if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                     bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                     if (bitmap == null) {

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

@@ -1,18 +1,12 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
+    if (!hasValue(index)) {
         return null;
     }
-    if (mResourceData[index] == null) {
-        return null;
-    }
     ResourceValue resValue = mResourceData[index];
     String value = resValue.getValue();
     if (value == null) {
         return null;
     }
-    if (RenderResources.REFERENCE_NULL.equals(value)) {
-        return null;
-    }
     // let the framework inflate the ColorStateList from the XML file.
     File f = new File(value);
     if (f.isFile()) {

Find a functionally equivalent code:android.media.AudioTrack.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mDataLoadMode is valid

@@ -1,11 +1,6 @@
 {
-    // stream type
-    if ((streamType != AudioManager.STREAM_ALARM) && (streamType != AudioManager.STREAM_MUSIC) && (streamType != AudioManager.STREAM_RING) && (streamType != AudioManager.STREAM_SYSTEM) && (streamType != AudioManager.STREAM_VOICE_CALL) && (streamType != AudioManager.STREAM_NOTIFICATION) && (streamType != AudioManager.STREAM_BLUETOOTH_SCO) && (streamType != AudioManager.STREAM_DTMF)) {
-        throw new IllegalArgumentException("Invalid stream type.");
-    }
-    mStreamType = streamType;
     // sample rate, note these values are subject to change
-    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
+    if (sampleRateInHz < SAMPLE_RATE_HZ_MIN || sampleRateInHz > SAMPLE_RATE_HZ_MAX) {
         throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
     }
     mSampleRate = sampleRateInHz;
@@ -34,52 +29,43 @@
             mChannelCount = Integer.bitCount(channelConfig);
     }
     // audio format
-    switch(audioFormat) {
-        case AudioFormat.ENCODING_DEFAULT:
-            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
-            break;
-        case AudioFormat.ENCODING_PCM_16BIT:
-        case AudioFormat.ENCODING_PCM_8BIT:
-            mAudioFormat = audioFormat;
-            break;
-        default:
-            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
+    if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
+        audioFormat = AudioFormat.ENCODING_PCM_16BIT;
+    }
+    if (!AudioFormat.isValidEncoding(audioFormat)) {
+        throw new IllegalArgumentException("Unsupported audio encoding.");
     }
+    mAudioFormat = audioFormat;
     // audio load mode
-    if ((mode != MODE_STREAM) && (mode != MODE_STATIC)) {
+    if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
         throw new IllegalArgumentException("Invalid mode.");
     }
     mDataLoadMode = mode;

Find a functionally equivalent code:android.view.ViewGroup.invalidateChildInParent:COMMENT
Method Modifier: public      
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */

@@ -17,23 +17,22 @@
             location[CHILD_TOP_INDEX] = top;
             if (mLayerType != LAYER_TYPE_NONE) {
                 mPrivateFlags |= PFLAG_INVALIDATED;
-                mLocalDirtyRect.union(dirty);
             }
             return mParent;
         } else {
@@ -32,38 +31,36 @@
             }
             if (mLayerType != LAYER_TYPE_NONE) {
                 mPrivateFlags |= PFLAG_INVALIDATED;
-                mLocalDirtyRect.union(dirty);
             }
             return mParent;
         }

Find a functionally equivalent code:android.app.AlertDialog.Builder.setView:COMMENT
Method Modifier: public      
Comment:/**
 * Set a custom view to be the contents of the Dialog. If the supplied view is an instance
 * of a {@link ListView} the light background will be used.
 *
 * @param view The view to use as the contents of the Dialog.
 *
 * @return This Builder object to allow for chaining of calls to set methods
 */

@@ -1,5 +1,6 @@
 {
     P.mView = view;
+    P.mViewLayoutResId = 0;
     P.mViewSpacingSpecified = false;
     return this;
 }

Find a functionally equivalent code:android.media.MediaRecorder.setCaptureRate:COMMENT
Method Modifier: public      
Comment:/**
 * Set video frame capture rate. This can be used to set a different video frame capture
 * rate than the recorded video's playback rate. This method also sets the recording mode
 * to time lapse. In time lapse video recording, only video is recorded. Audio related
 * parameters are ignored when a time lapse recording session starts, if an application
 * sets them.
 *
 * @param fps Rate at which frames should be captured in frames per second.
 * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
 * For resolutions that can be captured by the video camera, the fastest fps can be computed using
 * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
 * resolutions the fastest fps may be more restrictive.
 * Note that the recorder cannot guarantee that frames will be captured at the
 * given rate due to camera/encoder limitations. However it tries to be as close as
 * possible.
 */

@@ -2,7 +2,7 @@
     // Make sure that time lapse is enabled when this method is called.
     setParameter("time-lapse-enable=1");
     double timeBetweenFrameCapture = 1 / fps;
-    int timeBetweenFrameCaptureMs = (int) (1000 * timeBetweenFrameCapture);
-    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureMs);
+    long timeBetweenFrameCaptureUs = (long) (1000000 * timeBetweenFrameCapture);
+    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureUs);
 }

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

@@ -1,19 +1,7 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return null;
-    }
-    if (mResourceData[index] == null) {
-        return null;
-    }
-    String value = mResourceData[index].getValue();
+    String value = getString(index);
     if (value != null) {
-        if (RenderResources.REFERENCE_NULL.equals(value)) {
-            return null;
-        }
         return new CharSequence[] { value };
     }
-    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format(// DEBUG
-    String.format(// DEBUG
-    "Unknown value for getTextArray(%d) => %s", index, mResourceData[index].getName())), null);
     return null;
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getActivePasswordQuality:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Used by device policy manager to validate the current password
 * information it has.
 */

@@ -19,24 +19,29 @@
                 activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
             }
             break;
+        case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX:
+            if (isLockPasswordEnabled()) {
+                activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;
+            }
+            break;
         case DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:
             if (isLockPasswordEnabled()) {
                 activePasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;

Find a functionally equivalent code:android.app.SearchManager.startSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */


Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callGet:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link OuterClass#get} or {@link InnerClass#get}via reflection.
 */

@@ -1,5 +1,5 @@
 {
-    Method m = instance.getClass().getMethod("get", new Class<?>[] { int.class, long.class });
-    Object result = m.invoke(instance, new Object[] { a, b });
-    return ((Integer) result).intValue();
+    Method m = instance.getClass().getMethod("get", int.class, long.class);
+    Object result = m.invoke(instance, a, b);
+    return (Integer) result;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyUpPanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Called when the panel key is released.
 * @param featureId The feature ID of the relevant panel (defaults to FEATURE_OPTIONS_PANEL}.
 * @param event The key event.
 */

@@ -7,21 +7,19 @@
         }
         boolean playSoundEffect = false;
         final PanelFeatureState st = getPanelState(featureId, true);
-        if (featureId == FEATURE_OPTIONS_PANEL && mActionBar != null && mActionBar.isOverflowReserved() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
-            if (mActionBar.getVisibility() == View.VISIBLE) {
-                if (!mActionBar.isOverflowMenuShowing()) {
-                    if (!isDestroyed() && preparePanel(st, event)) {
-                        playSoundEffect = mActionBar.showOverflowMenu();
-                    }
-                } else {
-                    playSoundEffect = mActionBar.hideOverflowMenu();
+        if (featureId == FEATURE_OPTIONS_PANEL && mDecorContentParent != null && mDecorContentParent.canShowOverflowMenu() && !ViewConfiguration.get(getContext()).hasPermanentMenuKey()) {
+            if (!mDecorContentParent.isOverflowMenuShowing()) {
+                if (!isDestroyed() && preparePanel(st, event)) {
+                    playSoundEffect = mDecorContentParent.showOverflowMenu();
                 }
+            } else {
+                playSoundEffect = mDecorContentParent.hideOverflowMenu();
             }
         } else {
             if (st.isOpen || st.isHandled) {

Find a functionally equivalent code:android.os.BatteryStats.getPhoneSignalStrengthTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been running with
 * the given signal strength.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.transition.TransitionInflater.from:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtains the TransitionInflater from the given context.
 */

@@ -1,9 +1,3 @@
 {
-    TransitionInflater inflater = sInflaterMap.get(context);
-    if (inflater != null) {
-        return inflater;
-    }
-    inflater = new TransitionInflater(context);
-    sInflaterMap.put(context, inflater);
-    return inflater;
+    return new TransitionInflater(context);
 }

Find a functionally equivalent code:android.graphics.Path.isInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the filltype is one of the INVERSE variants
 *
 * @return true if the filltype is one of the INVERSE variants
 */

@@ -1,4 +1,4 @@
 {
     final int ft = native_getFillType(mNativePath);
-    return (ft & 2) != 0;
+    return (ft & FillType.INVERSE_WINDING.nativeInt) != 0;
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.CollectionInfo.obtain:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtains a pooled instance.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 */

@@ -1,4 +1,3 @@
 {
-    CollectionInfo info = sPool.acquire();
-    return (info != null) ? info : new CollectionInfo(rowCount, columnCount, hierarchical);
+    return obtain(rowCount, columnCount, hierarchical, SELECTION_MODE_NONE);
 }

Find a functionally equivalent code:android.media.AudioService.checkSendBecomingNoisyIntent:COMMENT
Method Modifier: private     
Comment:// must be called before removing the device from mConnectedDevices

@@ -3,9 +3,9 @@
     if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
         int devices = 0;
         for (int dev : mConnectedDevices.keySet()) {
-            if ((dev & mBecomingNoisyIntentDevices) != 0) {
+            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                 devices |= dev;
             }
         }
@@ -12,18 +12,18 @@
             delay = 1000;
         }
     }
-    if (mAudioHandler.hasMessages(MSG_SET_A2DP_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
+    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
         delay = 1000;
     }
     return delay;

Find a functionally equivalent code:android.widget.TextView.getTextColors:COMMENT
Method Modifier: public      final       
Comment:/**
 * Gets the text colors for the different states (normal, selected, focused) of the TextView.
 *
 * @see #setTextColor(ColorStateList)
 * @see #setTextColor(int)
 *
 * @attr ref android.R.styleable#TextView_textColor
 */


Find a functionally equivalent code:android.content.pm.Signature.areExactMatch:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Test if given {@link Signature} sets are exactly equal.
 *
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
+    return (a.length == b.length) && ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
 }

Find a functionally equivalent code:android.os.storage.IMountService.encryptStorage:COMMENT
Method Modifier: public      
Comment:/**
 * Encrypts storage.
 */


Find a functionally equivalent code:android.content.RestrictionEntry.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the type for this restriction.
 * @param type the type for this restriction.
 */

@@ -1,3 +1,3 @@
 {
-    this.type = type;
+    this.mType = type;
 }

Find a functionally equivalent code:android.animation.AnimatorSet.Builder.before:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */

@@ -1,4 +1,5 @@
 {
+    mReversible = false;
     Node node = mNodeMap.get(anim);
     if (node == null) {
         node = new Node(anim);

Find a functionally equivalent code:android.os.Bundle.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */

@@ -1,6 +1,3 @@
 {
-    unparcel();
-    if (DEBUG)
-        Log.d(TAG, "Getting boolean in " + Integer.toHexString(System.identityHashCode(this)));
-    return getBoolean(key, false);
+    return super.getBoolean(key);
 }

Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.stop:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Stops the animation. This method has no effect if the animation is
 * not running.</p>
 *
 * @see #isRunning()
 * @see #start()
 */

@@ -1,4 +1,5 @@
 {
+    mAnimating = false;
     if (isRunning()) {
         unscheduleSelf(this);
     }

Find a functionally equivalent code:android.widget.AbsListView.onLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * Subclasses should NOT override this method but
 * {@link #layoutChildren()} instead.
 */

@@ -1,17 +1,18 @@
 {
     super.onLayout(changed, l, t, r, b);
     mInLayout = true;
+    final int childCount = getChildCount();
     if (changed) {
-        int childCount = getChildCount();
         for (int i = 0; i < childCount; i++) {
             getChildAt(i).forceLayout();
         }
         mRecycler.markChildrenDirty();
     }
-    if (mFastScroller != null && (mItemCount != mOldItemCount || mDataChanged)) {
-        mFastScroller.onItemCountChanged(mItemCount);
-    }
     layoutChildren();
     mInLayout = false;
     mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
+    // TODO: Move somewhere sane. This doesn't belong in onLayout().
+    if (mFastScroll != null) {
+        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
+    }
 }

Find a functionally equivalent code:android.widget.CalendarView.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

@@ -1,3 +1,3 @@
 {
-    return mMinDate.getTimeInMillis();
+    return mDelegate.getMinDate();
 }

Find a functionally equivalent code:android.widget.TextView.handleTextChanged:COMMENT
Method Modifier: 
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

@@ -14,19 +14,20 @@
         }
         ims.mChangedDelta += after - before;
     }
+    resetErrorChangedFlag();
     sendOnTextChanged(buffer, start, before, after);
     onTextChanged(buffer, start, before, after);
 }

Find a functionally equivalent code:android.print.PrintJobInfo.Builder.putAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Puts an advanced (printer specific) option.
 *
 * @param key The option key.
 * @param value The option value.
 */

@@ -1,2 +1,6 @@
 {
+    if (mPrototype.mAdvancedOptions == null) {
+        mPrototype.mAdvancedOptions = new Bundle();
+    }
+    mPrototype.mAdvancedOptions.putInt(key, value);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.saveHierarchyState:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -23,31 +23,31 @@
     if (panelStates.size() > 0) {
         outState.putSparseParcelableArray(PANELS_TAG, panelStates);
     }
-    if (mActionBar != null) {
+    if (mDecorContentParent != null) {
         SparseArray<Parcelable> actionBarStates = new SparseArray<Parcelable>();
-        mActionBar.saveHierarchyState(actionBarStates);
+        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);
         outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
     }
     return outState;

Find a functionally equivalent code:android.media.RemoteController.seekTo:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the new playback position.
 * This method can only be called on a registered RemoteController.
 * @param timeMs a 0 or positive value for the new playback position, expressed in ms.
 * @return true if the command to set the playback position was successfully sent.
 * @throws IllegalArgumentException
 */

@@ -6,15 +6,15 @@
     if (timeMs < 0) {
         throw new IllegalArgumentException("illegal negative time value");
     }
-    final int genId;
-    synchronized (mGenLock) {
-        genId = mClientGenerationIdCurrent;
+    synchronized (mInfoLock) {
+        if (mCurrentSession != null) {
+            mCurrentSession.getTransportControls().seekTo(timeMs);
+        }
     }
-    mAudioManager.setRemoteControlClientPlaybackPosition(genId, timeMs);
     return true;
 }

Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.doInBackground:COMMENT
Method Modifier: protected   
Comment:/* Runs on a worker thread */

@@ -1,10 +1,10 @@
 {
     if (DEBUG)
-        Slog.v(TAG, this + " >>> doInBackground");
+        Log.v(TAG, this + " >>> doInBackground");
     try {
         D data = AsyncTaskLoader.this.onLoadInBackground();
         if (DEBUG)
-            Slog.v(TAG, this + "  <<< doInBackground");
+            Log.v(TAG, this + "  <<< doInBackground");
         return data;
     } catch (OperationCanceledException ex) {
         if (!isCancelled()) {
@@ -12,18 +12,18 @@
             throw ex;
         }
         if (DEBUG)
-            Slog.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
+            Log.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
         return null;
     }
 }

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runLargeDownloadOverWiFi:COMMENT
Method Modifier: public      
Comment:/**
 * Tests downloading a large file over WiFi (~10 Mb).
 *
 * @throws Exception if unsuccessful
 */

@@ -1,6 +1,6 @@
 {
-    String filename = DOWNLOAD_10MB_FILENAME;
-    long filesize = DOWNLOAD_10MB_FILESIZE;
+    String filename = DOWNLOAD_FILENAME;
+    long filesize = DOWNLOAD_FILESIZE;
     long dlRequest = -1;
     doCommonDownloadSetup();
     // Make sure there are no pending downloads currently going on
@@ -10,16 +10,16 @@
     request.setMimeType("application/vnd.android.package-archive");
     dlRequest = mDownloadManager.enqueue(request);
     // Rather large file, so wait up to 15 mins...
-    waitForDownloadOrTimeout(dlRequest, WAIT_FOR_DOWNLOAD_POLL_TIME, 15 * 60 * 1000);
+    assertTrue("download not finished", waitForDownload(dlRequest, 15 * 60 * 1000));
     Cursor cursor = getCursor(dlRequest);
     ParcelFileDescriptor pfd = null;
     try {

Find a functionally equivalent code:android.view.ScaleGestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */

@@ -16,21 +16,25 @@
             mInProgress = false;
             mInitialSpan = 0;
             mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
+        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
+            mInProgress = false;
+            mInitialSpan = 0;
+            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
         }
         if (streamComplete) {
             clearTouchHistory();

Find a functionally equivalent code:android.os.Bundle.putByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a byte array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putByteArray(key, value);
 }

Find a functionally equivalent code:android.view.HardwareRenderer.setupDiskCache:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Sets the directory to use as a persistent storage for hardware rendering
 * resources.
 *
 * @param cacheDir A directory the current process can write to
 *
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    nSetupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
+    ThreadedRenderer.setupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
 }

Find a functionally equivalent code:android.util.TimeUtils.getTimeZone:COMMENT
Method Modifier: public      static      
Comment:/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */

@@ -1,8 +1,6 @@
 {
     TimeZone best = null;
-    Resources r = Resources.getSystem();
-    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
-    Date d = new Date(when);
+    final Date d = new Date(when);
     TimeZone current = TimeZone.getDefault();
     String currentName = current.getID();
     int currentOffset = current.getOffset(when);

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.launchDefaultSearch:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Helper method for adding launch-search to most applications. Opens the
 * search window using default settings.
 *
 * @return true if search window opened
 */

@@ -1,9 +1,15 @@
 {
+    boolean result;
     final Callback cb = getCallback();
     if (cb == null || isDestroyed()) {
-        return false;
+        result = false;
     } else {
         sendCloseSystemWindows("search");
-        return cb.onSearchRequested();
+        result = cb.onSearchRequested();
     }
+    if (!result && (getContext().getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_TELEVISION) {
+        // On TVs, if the app doesn't implement search, we want to launch assist.
+        return ((SearchManager) getContext().getSystemService(Context.SEARCH_SERVICE)).launchAssistAction(0, null, UserHandle.myUserId());
+    }
+    return result;
 }

Find a functionally equivalent code:android.util.ArrayMap.containsKey:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether a key exists in the array.
 *
 * @param key The key to search for.
 * @return Returns true if the key exists, else false.
 */

@@ -1,3 +1,3 @@
 {
-    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
+    return indexOfKey(key) >= 0;
 }

Find a functionally equivalent code:android.printservice.PrintJob.hasAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether this job has a given advanced (printer specific) print
 * option.
 *
 * @param key The option key.
 * @return Whether the option is present.
 */

@@ -1,4 +1,4 @@
 {
     PrintService.throwIfNotCalledOnMainThread();
-    return false;
+    return getInfo().hasAdvancedOption(key);
 }

Find a functionally equivalent code:android.view.textservice.TextServicesManager.newSpellCheckerSession:COMMENT
Method Modifier: public      
Comment:/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. "en"), the specified locale in Settings (e.g. "en_US") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */

@@ -25,32 +25,32 @@
         }
         if (locale != null) {
             final String subtypeLocale = subtypeInUse.getLocale();
-            final String inputLocale = locale.toString();
-            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
+            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
+            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                 return null;
             }
         }
@@ -35,44 +35,45 @@
         for (int i = 0; i < sci.getSubtypeCount(); ++i) {
             final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
             final String tempSubtypeLocale = subtype.getLocale();
+            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
             if (tempSubtypeLocale.equals(localeStr)) {
                 subtypeInUse = subtype;
                 break;
-            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
+            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                 subtypeInUse = subtype;
             }
         }

Find a functionally equivalent code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

@@ -4,9 +4,12 @@
     dest.writeInt(disableReason);
     dest.writeString(SSID);
     dest.writeString(BSSID);
+    dest.writeString(autoJoinBSSID);
+    dest.writeString(FQDN);
+    dest.writeString(naiRealm);
     dest.writeString(preSharedKey);
     for (String wepKey : wepKeys) {
         dest.writeString(wepKey);
@@ -11,23 +14,52 @@
     dest.writeInt(wepTxKeyIndex);
     dest.writeInt(priority);
     dest.writeInt(hiddenSSID ? 1 : 0);
+    dest.writeInt(requirePMF ? 1 : 0);
+    dest.writeString(updateIdentifier);
     writeBitSet(dest, allowedKeyManagement);
     writeBitSet(dest, allowedProtocols);
     writeBitSet(dest, allowedAuthAlgorithms);
     writeBitSet(dest, allowedPairwiseCiphers);
     writeBitSet(dest, allowedGroupCiphers);
     dest.writeParcelable(enterpriseConfig, flags);
-    dest.writeString(ipAssignment.name());
-    dest.writeString(proxySettings.name());
-    dest.writeParcelable(linkProperties, flags);
+    dest.writeParcelable(mIpConfiguration, flags);
+    dest.writeString(dhcpServer);
+    dest.writeString(defaultGwMacAddress);
+    dest.writeInt(autoJoinStatus);
+    dest.writeInt(selfAdded ? 1 : 0);
+    dest.writeInt(didSelfAdd ? 1 : 0);
+    dest.writeInt(noInternetAccess ? 1 : 0);
+    dest.writeInt(creatorUid);
+    dest.writeInt(lastConnectUid);
+    dest.writeInt(lastUpdateUid);
+    dest.writeLong(blackListTimestamp);
+    dest.writeLong(lastConnectionFailure);
+    dest.writeInt(numConnectionFailures);
+    dest.writeInt(numIpConfigFailures);
+    dest.writeInt(numAuthFailures);
+    dest.writeInt(numScorerOverride);
+    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
+    dest.writeInt(numAssociation);
+    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
+    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
+    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
+    dest.writeInt(numTicksAtLowRSSI);
+    dest.writeInt(numTicksAtBadRSSI);
+    dest.writeInt(numTicksAtNotHighRSSI);
+    dest.writeInt(numUserTriggeredJoinAttempts);
+    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
+    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
 }

Find a functionally equivalent code:android.widget.AutoCompleteTextView.setDropDownBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the background of the auto-complete drop-down list.</p>
 *
 * @param id the id of the drawable to set as the background
 *
 * @attr ref android.R.styleable#PopupWindow_popupBackground
 */

@@ -1,3 +1,3 @@
 {
-    mPopup.setBackgroundDrawable(getResources().getDrawable(id));
+    mPopup.setBackgroundDrawable(getContext().getDrawable(id));
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */

@@ -4,8 +4,8 @@
         return null;
     }
     AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
-    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
+    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
 }

Find a functionally equivalent code:com.android.systemui.statusbar.SignalClusterView.apply:COMMENT
Method Modifier: private     
Comment:// Run after each indicator change.

@@ -1,6 +1,9 @@
 {
     if (mWifiGroup == null)
         return;
+    mVpn.setVisibility(mVpnVisible ? View.VISIBLE : View.GONE);
+    if (DEBUG)
+        Log.d(TAG, String.format("vpn: %s", mVpnVisible ? "VISIBLE" : "GONE"));
     if (mWifiVisible) {
         mWifi.setImageResource(mWifiStrengthId);
         mWifiGroup.setContentDescription(mWifiDescription);
@@ -24,35 +27,44 @@
     } else {
         mAirplane.setVisibility(View.GONE);
     }
-    if (mMobileVisible && mWifiVisible && mIsAirplaneMode) {
-        mSpacer.setVisibility(View.INVISIBLE);
+    if (mIsAirplaneMode && mWifiVisible) {
+        mWifiAirplaneSpacer.setVisibility(View.VISIBLE);
+    } else {
+        mWifiAirplaneSpacer.setVisibility(View.GONE);
+    }
+    if (mRoaming && mMobileVisible && mWifiVisible) {
+        mWifiSignalSpacer.setVisibility(View.VISIBLE);
     } else {
-        mSpacer.setVisibility(View.GONE);
+        mWifiSignalSpacer.setVisibility(View.GONE);
     }
+    mMobile.setPaddingRelative(mIsMobileTypeIconWide ? mWideTypeIconStartPadding : 0, 0, 0, 0);
     if (DEBUG)
         Log.d(TAG, String.format("mobile: %s sig=%d typ=%d", (mMobileVisible ? "VISIBLE" : "GONE"), mMobileStrengthId, mMobileTypeId));
-    mMobileType.setVisibility(!mWifiVisible ? View.VISIBLE : View.GONE);
+    mMobileType.setVisibility((mRoaming || mMobileTypeId != 0) ? View.VISIBLE : View.GONE);
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockPasswordEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether the lock password is enabled, or if it is set as a backup for biometric weak
 */

@@ -1,7 +1,7 @@
 {
     long mode = getLong(PASSWORD_TYPE_KEY, 0);
     long backupMode = getLong(PASSWORD_TYPE_ALTERNATE_KEY, 0);
-    final boolean passwordEnabled = mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
-    final boolean backupEnabled = backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
+    final boolean passwordEnabled = mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
+    final boolean backupEnabled = backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX || backupMode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC || backupMode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX;
     return savedPasswordExists() && (passwordEnabled || (usingBiometricWeak() && backupEnabled));
 }

Find a functionally equivalent code:android.view.MotionEvent.PointerCoords.getAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

@@ -24,34 +24,34 @@
                     throw new IllegalArgumentException("Axis out of range.");
                 }
                 final long bits = mPackedAxisBits;
-                final long axisBit = 1L << axis;
+                final long axisBit = 0x8000000000000000L >>> axis;
                 if ((bits & axisBit) == 0) {
                     return 0;
                 }
-                final int index = Long.bitCount(bits & (axisBit - 1L));
+                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                 return mPackedAxisValues[index];
             }
     }

Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

@@ -1,5 +1,5 @@
 {
-    if (false)
+    if (DEBUG)
         Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
     int type = request.type;
     if (type == CHUNK_MPRS) {
@@ -9,21 +9,21 @@
     } else if (type == CHUNK_MPSS) {
         return handleMPSS(request);
     } else if (type == CHUNK_MPSE) {
-        return handleMPSE(request);
+        return handleMPSEOrSPSE(request, "Method");
     } else if (type == CHUNK_MPRQ) {
         return handleMPRQ(request);
     } else if (type == CHUNK_SPSS) {
         return handleSPSS(request);
     } else if (type == CHUNK_SPSE) {
-        return handleSPSE(request);
+        return handleMPSEOrSPSE(request, "Sample");
     } else {
         throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
     }

Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.test3GToWifiNotification:COMMENT
Method Modifier: public      
Comment:// event should be expected.

@@ -1,37 +1,24 @@
 {
     if (mWifiOnlyFlag) {
-        Log.v(TAG, this.getName() + " is excluded for wifi-only test");
+        logv(getName() + " is excluded for wifi-only test");
         return;
     }
-    // Enable Wi-Fi to avoid initial UNKNOWN state
-    enableWifi();
-    sleep(2 * SHORT_TIMEOUT);
-    // Wi-Fi is disabled
-    disableWifi();
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, LONG_TIMEOUT));
-    // Wait for 10 seconds for broadcasts to be sent out
-    sleep(10 * 1000);
-    // As Wifi stays in DISCONNETED, Mobile statys in CONNECTED,
-    // the connectivity manager will not broadcast any network connectivity event for Wifi
-    NetworkInfo networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
-    setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE, networkInfo.getState(), NetworkState.DO_NOTHING, State.CONNECTED);
-    networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.DO_NOTHING, State.DISCONNECTED);
-    // Eanble Wifi without associating with any AP
-    enableWifi();
-    sleep(2 * SHORT_TIMEOUT);
-    // validate state and broadcast
-    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
-        log("the state for WIFI is changed");
-        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
-        assertTrue("state validation fail", false);
-    }
-    if (!validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
-        log("the state for MOBILE is changed");
-        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
-        assertTrue("state validation fail", false);
-    }
-    // Verify that the device is still connected to MOBILE
+    // disable WiFi
+    assertTrue("failed to disable WiFi", disableWifi());
+    // wait for mobile
+    assertTrue("failed to wait for mobile connection", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, LONG_TIMEOUT));
+    // assert that we are indeed using mobile
+    NetworkInfo ni = mCm.getActiveNetworkInfo();
+    assertEquals("active network is not mobile", ConnectivityManager.TYPE_MOBILE, ni.getType());
+    long timestamp = SystemClock.uptimeMillis();
+    // now enable WiFi
+    assertTrue("failed to enable WiFi", enableWifi());
+    // assert that WiFi state settles at disconnected since no AP should be configured
+    assertTrue("WiFi state is not DISCONNECTED after enabling", waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
+    // assert that no connectivity change broadcast was sent since we enable wifi
+    assertTrue("connectivity has changed since wifi enable", timestamp > getLastConnectivityChangeTime());
+    // verify that the device is still connected to MOBILE
     verifyCellularConnection();
+    // verify that connection actually works
+    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.dispatchBootCompleted:COMMENT
<com.android.keyguard.KeyguardUpdateMonitor: void dispatchBootCompleted()>
Method Modifier: public      protected   
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * This is exposed since {@link Intent#ACTION_BOOT_COMPLETED} is not sticky. If
 * keyguard crashes sometime after boot, then it will never receive this
 * broadcast and hence not handle the event. This method is ultimately called by
 * PhoneWindowManager in this case.
 */


Find a functionally equivalent code:android.graphics.Canvas.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a bitmap for the canvas to draw into. All canvas state such as
 * layers, filters, and the save/restore stack are reset with the exception
 * of the current matrix and clip stack. Additionally, as a side-effect
 * the canvas' target density is updated to match that of the bitmap.
 *
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */

@@ -1,16 +1,16 @@
 {
     if (isHardwareAccelerated()) {
-        throw new RuntimeException("Can't set a bitmap device on a GL canvas");
+        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
     }
     if (bitmap == null) {
-        safeCanvasSwap(initRaster(0), false);
+        native_setBitmap(mNativeCanvasWrapper, 0, false);
         mDensity = Bitmap.DENSITY_NONE;
     } else {
         if (!bitmap.isMutable()) {
             throw new IllegalStateException();
         }
         throwIfCannotDraw(bitmap);
-        safeCanvasSwap(initRaster(bitmap.ni()), true);
+        native_setBitmap(mNativeCanvasWrapper, bitmap.ni(), true);
         mDensity = bitmap.mDensity;
     }
     mBitmap = bitmap;

Find a functionally equivalent code:android.bluetooth.BluetoothSocket.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */

@@ -32,36 +32,37 @@
         }
     } catch (RemoteException e) {
         Log.e(TAG, Log.getStackTraceString(new Throwable()));
+        throw new IOException("unable to send RPC: " + e.getMessage());
     }
 }

Find a functionally equivalent code:com.android.externalstorage.ExternalStorageProvider.removeExtension:COMMENT
Method Modifier: private     static      
Comment:/**
 * Remove file extension from name, but only if exact MIME type mapping
 * exists. This means we can reapply the extension later.
 */

@@ -1,7 +1,7 @@
 {
     final int lastDot = name.lastIndexOf('.');
     if (lastDot >= 0) {
-        final String extension = name.substring(lastDot + 1);
+        final String extension = name.substring(lastDot + 1).toLowerCase();
         final String nameMime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
         if (mimeType.equals(nameMime)) {
             return name.substring(0, lastDot);

Find a functionally equivalent code:android.graphics.Paint.setClassVariablesFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Set all class variables using current values from the given
 * {@link Paint}.
 */

@@ -9,23 +9,20 @@
         mShader = null;
     }
     mTypeface = paint.mTypeface;
+    mNativeTypeface = paint.mNativeTypeface;
     mXfermode = paint.mXfermode;
     mHasCompatScaling = paint.mHasCompatScaling;
     mCompatScaling = paint.mCompatScaling;
     mInvCompatScaling = paint.mInvCompatScaling;
-    hasShadow = paint.hasShadow;
-    shadowDx = paint.shadowDx;
-    shadowDy = paint.shadowDy;
-    shadowRadius = paint.shadowRadius;
-    shadowColor = paint.shadowColor;
     mBidiFlags = paint.mBidiFlags;
     mLocale = paint.mLocale;
+    mFontFeatureSettings = paint.mFontFeatureSettings;
 }

Find a functionally equivalent code:android.widget.EdgeEffect.setSize:COMMENT
Method Modifier: public      
Comment:/**
 * Set the size of this edge effect in pixels.
 *
 * @param width Effect width in pixels
 * @param height Effect height in pixels
 */

@@ -1,4 +1,11 @@
 {
-    mWidth = width;
-    mHeight = height;
+    final float r = width * 0.75f / SIN;
+    final float y = COS * r;
+    final float h = r - y;
+    final float or = height * 0.75f / SIN;
+    final float oy = COS * or;
+    final float oh = or - oy;
+    mRadius = r;
+    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
+    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
 }

Find a functionally equivalent code:android.media.MediaRecorder.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Prepares the recorder to begin capturing and encoding data. This method
 * must be called after setting up the desired audio and video sources,
 * encoders, file format, etc., but before start().
 *
 * @throws IllegalStateException if it is called after
 * start() or before setOutputFormat().
 * @throws IOException if prepare fails otherwise.
 */

@@ -1,10 +1,10 @@
 {
     if (mPath != null) {
-        FileOutputStream fos = new FileOutputStream(mPath);
+        RandomAccessFile file = new RandomAccessFile(mPath, "rws");
         try {
-            _setOutputFile(fos.getFD(), 0, 0);
+            _setOutputFile(file.getFD(), 0, 0);
         } finally {
-            fos.close();
+            file.close();
         }
     } else if (mFd != null) {
         _setOutputFile(mFd, 0, 0);

Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.updateMode:COMMENT
Method Modifier: private     
Comment:/**
 * Fetch the brightness mode from the system settings and update the icon
 */

@@ -1,13 +1,9 @@
 {
     if (mAutomaticAvailable) {
         int automatic;
-        try {
-            automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
-        } catch (SettingNotFoundException snfe) {
-            automatic = 0;
-        }
-        mControl.setChecked(automatic != 0);
-        updateIcon(automatic != 0);
+        automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT);
+        mAutomatic = automatic != Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
+        updateIcon(mAutomatic);
     } else {
         mControl.setChecked(false);
         updateIcon(false);

Find a functionally equivalent code:android.app.admin.DevicePolicyManager.getActiveAdmins:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */

@@ -1,10 +1,3 @@
 {
-    if (mService != null) {
-        try {
-            return mService.getActiveAdmins(UserHandle.myUserId());
-        } catch (RemoteException e) {
-            Log.w(TAG, "Failed talking with device policy service", e);
-        }
-    }
-    return null;
+    return getActiveAdminsAsUser(UserHandle.myUserId());
 }

Find a functionally equivalent code:android.widget.TimePicker.setOnTimeChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Set the callback that indicates the time has been adjusted by the user.
 *
 * @param onTimeChangedListener the callback, should not be null.
 */

@@ -1,3 +1,3 @@
 {
-    mOnTimeChangedListener = onTimeChangedListener;
+    mDelegate.setOnTimeChangedListener(onTimeChangedListener);
 }

Find a functionally equivalent code:android.graphics.Bitmap.setHasAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the bitmap if all of the pixels are known to be opaque (false)
 * or if some of the pixels may contain non-opaque alpha values (true).
 * Note, for some configs (e.g. RGB_565) this call is ignored, since it
 * does not support per-pixel alpha values.
 *
 * This is meant as a drawing hint, as in some cases a bitmap that is known
 * to be opaque can take a faster drawing case than one that may have
 * non-opaque per-pixel alpha values.
 */

@@ -1,3 +1,3 @@
 {
-    nativeSetHasAlpha(mNativeBitmap, hasAlpha);
+    nativeSetHasAlpha(mNativeBitmap, hasAlpha, mRequestPremultiplied);
 }

Find a functionally equivalent code:android.app.Activity.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Implement to provide correct calling token.
 */


Find a functionally equivalent code:android.app.UiAutomation.takeScreenshot:COMMENT
Method Modifier: public      
Comment:/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */

@@ -61,66 +61,67 @@
         canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
         canvas.drawBitmap(screenShot, 0, 0, null);
         canvas.setBitmap(null);
+        screenShot.recycle();
         screenShot = unrotatedScreenShot;
     }
     // Optimization

Find a functionally equivalent code:android.graphics.drawable.DrawableContainer.DrawableContainerState.ConstantStateFuture.get:COMMENT
Method Modifier: public      
Comment:/**
 * Obtains and prepares the Drawable represented by this future.
 *
 * @param state the container into which this future will be placed
 * @return a prepared Drawable
 */

@@ -1,5 +1,12 @@
 {
-    final Drawable result = (state.mRes == null) ? mConstantState.newDrawable() : mConstantState.newDrawable(state.mRes);
+    final Drawable result;
+    if (state.mRes == null) {
+        result = mConstantState.newDrawable();
+    } else if (state.mTheme == null) {
+        result = mConstantState.newDrawable(state.mRes);
+    } else {
+        result = mConstantState.newDrawable(state.mRes, state.mTheme);
+    }
     result.setLayoutDirection(state.mLayoutDirection);
     result.setCallback(state.mOwner);
     if (state.mMutated) {

Find a functionally equivalent code:android.media.AudioManager.registerMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * no-op if (pi == null) or (eventReceiver == null)
 */

@@ -3,13 +3,8 @@
         Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
         return;
     }
-    IAudioService service = getService();
-    try {
-        // pi != null
-        service.registerMediaButtonIntent(pi, eventReceiver, eventReceiver == null ? mToken : null);
-    } catch (RemoteException e) {
-        Log.e(TAG, "Dead object in registerMediaButtonIntent" + e);
-    }
+    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
+    helper.addMediaButtonListener(pi, eventReceiver, mContext);
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setParent:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the parent to be a virtual descendant of the given <code>root</code>.
 * If <code>virtualDescendantId</code> equals to {@link View#NO_ID} the root
 * is set as the parent.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report them selves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 */

@@ -1,5 +1,5 @@
 {
     enforceNotSealed();
-    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
+    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
     mParentNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testConnectToWifi:COMMENT
Method Modifier: public      
Comment:// Test case 2: test connection to a given AP

@@ -1,32 +1,17 @@
 {
-    assertNotNull("SSID is null", mTestAccessPoint);
-    NetworkInfo networkInfo;
-    if (!mWifiOnlyFlag) {
-        // Prepare for connectivity verification
-        networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
-        setStateTransitionCriteria(ConnectivityManager.TYPE_MOBILE, networkInfo.getState(), NetworkState.TO_DISCONNECTION, State.DISCONNECTED);
-    }
-    networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.TO_CONNECTION, State.CONNECTED);
-    // Enable Wifi and connect to a test access point
-    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
-    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
-    log("wifi state is enabled");
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
-    if (!mWifiOnlyFlag) {
-        assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
-    }
-    // validate states
-    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
-        log("Wifi state transition validation failed.");
-        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
-        assertTrue(false);
-    }
-    if (!mWifiOnlyFlag) {
-        if (!validateNetworkStates(ConnectivityManager.TYPE_MOBILE)) {
-            log("Mobile state transition validation failed.");
-            log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_MOBILE));
-            assertTrue(false);
-        }
-    }
+    assertNotNull("SSID is null", mSsid);
+    // assert that we are able to connect to the ap
+    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
+    // assert that WifiManager reports correct state
+    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
+    // assert that ConnectivityManager reports correct state for Wifi
+    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
+    // below check disbabled since we have bug in what ConnectivityManager returns
+    // if (!mWifiOnlyFlag) {
+    // // assert that ConnectivityManager reports correct state for mobile
+    // assertTrue("mobile not disconnected", waitForNetworkState(
+    // ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
+    // }
+    // verify that connection actually works
+    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
 }

Find a functionally equivalent code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

@@ -12,15 +12,32 @@
     dest.writeLong(timestamp);
     dest.writeInt(distanceCm);
     dest.writeInt(distanceSdCm);
+    dest.writeLong(seen);
+    dest.writeInt(autoJoinStatus);
+    dest.writeInt(untrusted ? 1 : 0);
+    dest.writeInt(numConnection);
+    dest.writeInt(numUsage);
+    dest.writeInt(numIpConfigFailures);
+    dest.writeInt(isAutoJoinCandidate);
+    if (informationElements != null) {
+        dest.writeInt(informationElements.length);
+        for (int i = 0; i < informationElements.length; i++) {
+            dest.writeInt(informationElements[i].id);
+            dest.writeInt(informationElements[i].bytes.length);
+            dest.writeByteArray(informationElements[i].bytes);
+        }
+    } else {
+        dest.writeInt(0);
+    }
 }

Find a functionally equivalent code:android.transition.TransitionSet.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,7 +1,7 @@
 {
-    super.pause();
+    super.pause(sceneRoot);
     int numTransitions = mTransitions.size();
     for (int i = 0; i < numTransitions; ++i) {
-        mTransitions.get(i).pause();
+        mTransitions.get(i).pause(sceneRoot);
     }
 }

Find a functionally equivalent code:android.media.Ringtone.isPlaying:COMMENT
Method Modifier: public      
Comment:/**
 * Whether this ringtone is currently playing.
 *
 * @return True if playing, false otherwise.
 */

@@ -1,7 +1,7 @@
 {
     if (mLocalPlayer != null) {
         return mLocalPlayer.isPlaying();
-    } else if (mAllowRemote) {
+    } else if (mAllowRemote && (mRemotePlayer != null)) {
         try {
             return mRemotePlayer.isPlaying(mRemoteToken);
         } catch (RemoteException e) {

Find a functionally equivalent code:android.widget.AbsListView.obtainView:COMMENT
Method Modifier: 
Comment:/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */

@@ -1,52 +1,42 @@
 {
     Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");
     isScrap[0] = false;
-    View scrapView;
-    scrapView = mRecycler.getTransientStateView(position);
-    if (scrapView == null) {
-        scrapView = mRecycler.getScrapView(position);
+    // Check whether we have a transient state view. Attempt to re-bind the
+    // data and discard the view if we fail.
+    final View transientView = mRecycler.getTransientStateView(position);
+    if (transientView != null) {
+        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
+        // If the view type hasn't changed, attempt to re-bind the data.
+        if (params.viewType == mAdapter.getItemViewType(position)) {
+            final View updatedView = mAdapter.getView(position, transientView, this);
+            // If we failed to re-bind the data, scrap the obtained view.
+            if (updatedView != transientView) {
+                setItemViewLayoutParams(updatedView, position);
+                mRecycler.addScrapView(updatedView, position);
+            }
+        }
+        // Scrap view implies temporary detachment.
+        isScrap[0] = true;
+        return transientView;
     }
-    View child;
+    final View scrapView = mRecycler.getScrapView(position);
+    final View child = mAdapter.getView(position, scrapView, this);
     if (scrapView != null) {
-        child = mAdapter.getView(position, scrapView, this);
-        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
-            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
-        }
         if (child != scrapView) {
+            // Failed to re-bind the data, return scrap to the heap.
             mRecycler.addScrapView(scrapView, position);
-            if (mCacheColorHint != 0) {
-                child.setDrawingCacheBackgroundColor(mCacheColorHint);
-            }
         } else {
             isScrap[0] = true;
-            // recycle this view and bind it to different data.
-            if (child.isAccessibilityFocused()) {
-                child.clearAccessibilityFocus();
-            }
             child.dispatchFinishTemporaryDetach();
         }
-    } else {
-        child = mAdapter.getView(position, null, this);
-        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
-            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
-        }
-        if (mCacheColorHint != 0) {
-            child.setDrawingCacheBackgroundColor(mCacheColorHint);
-        }
     }
-    if (mAdapterHasStableIds) {
-        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
-        LayoutParams lp;
-        if (vlp == null) {
-            lp = (LayoutParams) generateDefaultLayoutParams();
-        } else if (!checkLayoutParams(vlp)) {
-            lp = (LayoutParams) generateLayoutParams(vlp);
-        } else {
-            lp = (LayoutParams) vlp;
-        }
-        lp.itemId = mAdapter.getItemId(position);
-        child.setLayoutParams(lp);
+    if (mCacheColorHint != 0) {
+        child.setDrawingCacheBackgroundColor(mCacheColorHint);
+    }
+    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
     }
+    setItemViewLayoutParams(child, position);
     if (AccessibilityManager.getInstance(mContext).isEnabled()) {
         if (mAccessibilityDelegate == null) {
             mAccessibilityDelegate = new ListItemAccessibilityDelegate();

Find a functionally equivalent code:android.content.res.TypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.app.Dialog.show:COMMENT
Method Modifier: public      
Comment:/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */

@@ -18,24 +18,24 @@
         final ApplicationInfo info = mContext.getApplicationInfo();
         mWindow.setDefaultIcon(info.icon);
         mWindow.setDefaultLogo(info.logo);
-        mActionBar = new ActionBarImpl(this);
+        mActionBar = new WindowDecorActionBar(this);
     }
     WindowManager.LayoutParams l = mWindow.getAttributes();
     if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {

Find a functionally equivalent code:android.service.dreams.DreamService.getWindowManager:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the current {@link android.view.WindowManager} for the dream.
 * Behaves similarly to {@link android.app.Activity#getWindowManager()}.
 *
 * @return The current window manager, or null if the dream is not started.
 */

@@ -1,3 +1,3 @@
 {
-    return mWindowManager;
+    return mWindow != null ? mWindow.getWindowManager() : null;
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getNextAlarm:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return A formatted string of the next alarm (for showing on the lock screen),
 * or null if there is no next alarm.
 */

@@ -1,7 +1,4 @@
 {
-    String nextAlarm = Settings.System.getStringForUser(mContentResolver, Settings.System.NEXT_ALARM_FORMATTED, UserHandle.USER_CURRENT);
-    if (nextAlarm == null || TextUtils.isEmpty(nextAlarm)) {
-        return null;
-    }
-    return nextAlarm;
+    AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+    return alarmManager.getNextAlarmClock(UserHandle.USER_CURRENT);
 }

Find a functionally equivalent code:android.media.MediaDrm.provideProvisionResponse:COMMENT
<android.media.MediaDrm: void provideProvisionResponse(byte[])>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * After a provision response is received by the app, it is provided to the DRM
 * engine plugin using this method.
 *
 * @param response the opaque provisioning response byte array to provide to the
 * DRM engine plugin.
 *
 * @throws DeniedByServerException if the response indicates that the
 * server rejected the request
 */

@@ -1 +1,3 @@
-
+{
+    provideProvisionResponseNative(response);
+}

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRefreshBatteryInfo:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshBatteryInfo(BatteryStatus)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the battery status changes, e.g. when plugged in or unplugged, charge
 * level, etc. changes.
 *
 * @param status current battery status
 */


Find a functionally equivalent code:android.bluetooth.BluetoothSocket.write:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -1,4 +1,6 @@
 {
+    if (mSocketOS == null)
+        throw new IOException("write is called on null OutputStream");
     if (VDBG)
         Log.d(TAG, "write: " + mSocketOS + " length: " + length);
     mSocketOS.write(b, offset, length);

Find a functionally equivalent code:android.view.ViewRootImpl.outputDisplayList:COMMENT
Method Modifier: hidden      
Comment:/**
 * @hide
 */

@@ -1,8 +1,6 @@
 {
-    if (mAttachInfo != null && mAttachInfo.mHardwareCanvas != null) {
-        DisplayList displayList = view.getDisplayList();
-        if (displayList != null) {
-            mAttachInfo.mHardwareCanvas.outputDisplayList(displayList);
-        }
+    RenderNode renderNode = view.getDisplayList();
+    if (renderNode != null) {
+        renderNode.output();
     }
 }

Find a functionally equivalent code:android.media.MediaMuxer.nativeSetup:COMMENT
Method Modifier: private     static      native      
Comment:// All the native functions are listed here.


Find a functionally equivalent code:android.view.ViewPropertyAnimator.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all property animations that are currently running or pending.
 */

@@ -7,11 +7,18 @@
         }
     }
     mPendingAnimations.clear();
+    mPendingSetupAction = null;
+    mPendingCleanupAction = null;
+    mPendingOnStartAction = null;
+    mPendingOnEndAction = null;
     mView.removeCallbacks(mAnimationStarter);
+    if (mRTBackend != null) {
+        mRTBackend.cancelAll();
+    }
 }

Find a functionally equivalent code:android.view.ViewGroup.dispatchGenericPointerEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

@@ -2,21 +2,26 @@
     // Send the event to the child under the pointer.
     final int childrenCount = mChildrenCount;
     if (childrenCount != 0) {
-        final View[] children = mChildren;
         final float x = event.getX();
         final float y = event.getY();
-        final boolean customOrder = isChildrenDrawingOrderEnabled();
+        final ArrayList<View> preorderedList = buildOrderedChildList();
+        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
+        final View[] children = mChildren;
         for (int i = childrenCount - 1; i >= 0; i--) {
-            final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
-            final View child = children[childIndex];
+            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
+            final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
             if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                 continue;
             }
             if (dispatchTransformedGenericPointerEvent(event, child)) {
+                if (preorderedList != null)
+                    preorderedList.clear();
                 return true;
             }
         }
+        if (preorderedList != null)
+            preorderedList.clear();
     }
     // No child handled the event.  Send it to this view group.
     return super.dispatchGenericPointerEvent(event);

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.connectToWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean connectToWifi(String)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Associate the device to given SSID
 * If the device is already associated with a WiFi, disconnect and forget it,
 * We don't verify whether the connection is successful or not, leave this to the test
 */

@@ -1,6 +1,9 @@
 {
-    WifiConfiguration config = new WifiConfiguration();
-    config.SSID = knownSSID;
-    config.allowedKeyManagement.set(KeyMgmt.NONE);
+    WifiConfiguration config;
+    if (password == null) {
+        config = WifiConfigurationHelper.createOpenConfig(ssid);
+    } else {
+        config = WifiConfigurationHelper.createPskConfig(ssid, password);
+    }
     return connectToWifiWithConfiguration(config);
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visitMethod:COMMENT
Method Modifier: public      
Comment:/* Visits a method. */

@@ -11,21 +11,16 @@
         }
     }
     String methodSignature = mClassName.replace('/', '.') + "#" + name;
-    // change access to public
-    if (Main.sOptions.generatePublicAccess) {
-        access &= ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);
-        access |= Opcodes.ACC_PUBLIC;
-    }
     // remove final
     access = access & ~Opcodes.ACC_FINAL;
     // and don't try to stub interfaces nor abstract non-native methods.

Find a functionally equivalent code:com.android.keyguard.KeyguardHostView.ensureTransportPresentOrRemoved:COMMENT
Method Modifier: private     
Comment:/**
 * Examines the current state and adds the transport to the widget pager when the state changes.
 *
 * Showing the initial transport and keeping it around is a bit tricky because the signals
 * coming from music players aren't always clear. Here's how the states are handled:
 *
 * {@link TRANSPORT_GONE} means we have no reason to show the transport - remove it if present.
 *
 * {@link TRANSPORT_INVISIBLE} means we have potential to show the transport because a music
 * player is registered but not currently playing music (or we don't know the state yet). The
 * code adds it conditionally on play state.
 *
 * {@link #TRANSPORT_VISIBLE} means a music player is active and transport should be showing.
 *
 * Once the transport is showing, we always show it until keyguard is dismissed. This state is
 * maintained by onSave/RestoreInstanceState(). This state is cleared in
 * {@link KeyguardViewManager#hide} when keyguard is dismissed, which causes the transport to be
 * gone when keyguard is restarted until we get an update with the current state.
 *
 * @param state
 */

@@ -3,10 +3,8 @@
     final boolean visible = state == TRANSPORT_VISIBLE;
     final boolean shouldBeVisible = state == TRANSPORT_INVISIBLE && isMusicPlaying(state);
     if (!showing && (visible || shouldBeVisible)) {
-        if (DEBUGXPORT)
-            Log.v(TAG, "add transport");
         // insert to left of camera if it exists, otherwise after right-most widget
         int lastWidget = mAppWidgetContainer.getChildCount() - 1;
         // handle no widget case
@@ -12,18 +10,19 @@
         if (lastWidget >= 0) {
             position = mAppWidgetContainer.isCameraPage(lastWidget) ? lastWidget : lastWidget + 1;
         }
+        if (DEBUGXPORT)
+            Log.v(TAG, "add transport at " + position);
         mAppWidgetContainer.addWidget(getOrCreateTransportControl(), position);
+        return true;
     } else if (showing && state == TRANSPORT_GONE) {
         if (DEBUGXPORT)
             Log.v(TAG, "remove transport");
@@ -20,23 +21,25 @@
         mTransportControl = null;
         KeyguardUpdateMonitor.getInstance(getContext()).dispatchSetBackground(null);
     }
+    return false;
 }

Find a functionally equivalent code:android.animation.ObjectAnimator.animateValue:COMMENT
Method Modifier: 
Comment:/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */

@@ -1,7 +1,13 @@
 {
+    final Object target = getTarget();
+    if (mTarget != null && target == null) {
+        // We lost the target reference, cancel and clean up.
+        cancel();
+        return;
+    }
     super.animateValue(fraction);
     int numValues = mValues.length;
     for (int i = 0; i < numValues; ++i) {
-        mValues[i].setAnimatedValue(mTarget);
+        mValues[i].setAnimatedValue(target);
     }
 }

Find a functionally equivalent code:android.print.PrintDocumentInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link PrintDocumentInfo} instance.
 *
 * @return The new instance.
 */

@@ -1,3 +1,7 @@
 {
+    // wiritten PDF file for the page count.
+    if (mPrototype.mPageCount == 0) {
+        mPrototype.mPageCount = PAGE_COUNT_UNKNOWN;
+    }
     return new PrintDocumentInfo(mPrototype);
 }

Find a functionally equivalent code:android.media.MediaFocusControl.removeFocusStackEntryForClient:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove focus listeners from the focus stack for a particular client when it has died.
 */

@@ -5,11 +5,11 @@
     // evaluated it, traversal order doesn't matter here)
     Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
     while (stackIterator.hasNext()) {
-        FocusRequester fr = (FocusRequester) stackIterator.next();
+        FocusRequester fr = stackIterator.next();
         if (fr.hasSameBinder(cb)) {
             Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + cb);
             stackIterator.remove();
@@ -16,24 +16,20 @@
         // we removed an entry at the top of the stack:
         // notify the new top of the stack it gained focus.
         notifyTopOfAudioFocusStack();
-        // there's a new top of the stack, let the remote control know
-        synchronized (mRCStack) {
-            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-        }
     }
 }

Find a functionally equivalent code:android.content.res.TypedArray.getPositionDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a message about the parser state suitable for printing error messages.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return mXml != null ? mXml.getPositionDescription() : "<internal>";
 }

Find a functionally equivalent code:android.text.PackedIntVector.growBuffer:COMMENT
Method Modifier: private     final       
Comment:/**
 * Grows the value and gap arrays to be large enough to store at least
 * one more than the current number of rows.
 */

@@ -1,8 +1,7 @@
 {
     final int columns = mColumns;
-    int newsize = size() + 1;
-    newsize = ArrayUtils.idealIntArraySize(newsize * columns) / columns;
-    int[] newvalues = new int[newsize * columns];
+    int[] newvalues = ArrayUtils.newUnpaddedIntArray(GrowingArrayUtils.growSize(size()) * columns);
+    int newsize = newvalues.length / columns;
     final int[] valuegap = mValueGap;
     final int rowgapstart = mRowGapStart;
     int after = mRows - (rowgapstart + mRowGapLength);

Find a functionally equivalent code:android.media.MediaFocusControl.remoteControlDisplayUsesBitmapSize:COMMENT
Method Modifier: protected   
Comment:/**
 * Update the size of the artwork used by an IRemoteControlDisplay.
 * @see android.media.IAudioService#remoteControlDisplayUsesBitmapSize(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay with the new artwork size requirement
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 */

@@ -1,9 +1,9 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
         boolean artworkSizeUpdate = false;
         while (displayIterator.hasNext() && !artworkSizeUpdate) {
-            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
+            final DisplayInfoForServer di = displayIterator.next();
             if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                 if ((di.mArtworkExpectedWidth != w) || (di.mArtworkExpectedHeight != h)) {
                     di.mArtworkExpectedWidth = w;
@@ -15,26 +15,26 @@
         if (artworkSizeUpdate) {
             // RCD is currently plugged in and its artwork size has changed, notify all RCCs,
             // stack traversal order doesn't matter
-            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
             while (stackIterator.hasNext()) {
-                final RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRcClient != null) {
+                final PlayerRecord prse = stackIterator.next();
+                if (prse.getRcc() != null) {
                     try {
-                        rcse.mRcClient.setBitmapSizeForDisplay(rcd, w, h);
+                        prse.getRcc().setBitmapSizeForDisplay(rcd, w, h);
                     } catch (RemoteException e) {
                         Log.e(TAG, "Error setting bitmap size for RCD on RCC: ", e);
                     }

Find a functionally equivalent code:com.android.keyguard.KeyguardMessageArea.update:COMMENT
Method Modifier: 
Comment:/**
 * Update the status lines based on these rules:
 * AlarmStatus: Alarm state always gets it's own line.
 * Status1 is shared between help, battery status and generic unlock instructions,
 * prioritized in that order.
 * @param showStatusLines status lines are shown if true
 */

@@ -1,6 +1,6 @@
 {
     MutableInt icon = new MutableInt(0);
-    CharSequence status = concat(getChargeInfo(icon), getOwnerInfo(), getCurrentMessage());
+    CharSequence status = getCurrentMessage();
     setCompoundDrawablesWithIntrinsicBounds(icon.value, 0, 0, 0);
     setText(status);
 }

Find a functionally equivalent code:android.os.storage.IMountService.Stub.Proxy.mountSecureContainer:COMMENT
Method Modifier: public      
Comment:/*
             * Mount a secure container with the specified key and owner UID.
             * Returns an int consistent with MountServiceResultCode
             */

@@ -7,12 +7,13 @@
         _data.writeString(id);
         _data.writeString(key);
         _data.writeInt(ownerUid);
+        _data.writeInt(readOnly ? 1 : 0);
         mRemote.transact(Stub.TRANSACTION_mountSecureContainer, _data, _reply, 0);
         _reply.readException();
         _result = _reply.readInt();

Find a functionally equivalent code:com.android.documentsui.RootsCache.updatePackageAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Gather roots from storage providers belonging to given package name.
 */

@@ -1,6 +1,3 @@
 {
-    // Need at least first load, since we're going to be using previously
-    // cached values for non-matching packages.
-    waitForFirstLoad();
     new UpdateTask(packageName).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
 }

Find a functionally equivalent code:android.widget.CalendarView.setWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the week day abbreviation of the calendar header.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

@@ -1,6 +1,3 @@
 {
-    if (mWeekDayTextAppearanceResId != resourceId) {
-        mWeekDayTextAppearanceResId = resourceId;
-        setUpHeader();
-    }
+    mDelegate.setWeekDayTextAppearance(resourceId);
 }

Find a functionally equivalent code:android.inputmethodservice.SoftInputWindow.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set which boundary of the screen the DockWindow sticks to.
 *
 * @param gravity The boundary of the screen to stick. See {#link
 * android.view.Gravity.LEFT}, {#link android.view.Gravity.TOP},
 * {#link android.view.Gravity.BOTTOM}, {#link
 * android.view.Gravity.RIGHT}.
 */

@@ -1,12 +1,6 @@
 {
     WindowManager.LayoutParams lp = getWindow().getAttributes();
-    boolean oldIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
     lp.gravity = gravity;
-    boolean newIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
-    if (oldIsVertical != newIsVertical) {
-        int tmp = lp.width;
-        lp.width = lp.height;
-        lp.height = tmp;
-        getWindow().setAttributes(lp);
-    }
+    updateWidthHeight(lp);
+    getWindow().setAttributes(lp);
 }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarSetupVocabulary:COMMENT
Method Modifier: private     static      native      
Comment:// const struct SR_Nametag_t* nametag, int weight, String tag);


Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream
 */

@@ -1,7 +1,7 @@
 {
     Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
     try {
-        return createFromResourceStream(null, null, is, srcName, null);
+        return createFromResourceStream(null, null, is, srcName);
     } finally {
         Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
     }

Find a functionally equivalent code:android.media.MediaPlayer.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the MediaPlayer to its uninitialized state. After calling
 * this method, you will have to initialize it again by setting the
 * data source and calling prepare().
 */

@@ -24,28 +24,27 @@
     if (mEventHandler != null) {
         mEventHandler.removeCallbacksAndMessages(null);
     }
-    disableProxyListener();
 }

Find a functionally equivalent code:android.media.SubtitleTrack.hide:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -5,10 +5,13 @@
     if (mTimeProvider != null) {
         mTimeProvider.cancelNotifications(this);
     }
-    getRenderingWidget().setVisible(false);
+    RenderingWidget renderingWidget = getRenderingWidget();
+    if (renderingWidget != null) {
+        renderingWidget.setVisible(false);
+    }
     mVisible = false;
 }

Find a functionally equivalent code:android.widget.FastScroller.setEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * @param enabled Whether the fast scroll thumb is enabled.
 */

@@ -1,6 +1,6 @@
 {
     if (mEnabled != enabled) {
         mEnabled = enabled;
-        onStateDependencyChanged();
+        onStateDependencyChanged(true);
     }
 }

Find a functionally equivalent code:android.content.res.TypedArray.getIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Return an index in the array that has data.
 *
 * @param at The index you would like to returned, ranging from 0 to
 * {@link #getIndexCount()}.
 *
 * @return The index at the given offset, which can be used with
 * {@link #getValue} and related APIs.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return mIndices[1 + at];
 }

Find a functionally equivalent code:android.os.ParcelFileDescriptor.createSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */

@@ -2,8 +2,8 @@
     try {
         final FileDescriptor fd0 = new FileDescriptor();
         final FileDescriptor fd1 = new FileDescriptor();
-        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
+        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
         return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
     } catch (ErrnoException e) {
         throw e.rethrowAsIOException();

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisListXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read an ArrayList object from an XmlPullParser.  The XML data could
 * previously have been generated by writeListXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the list.
 *
 * @param parser The XmlPullParser from which to read the list data.
 * @param endTag Name of the tag that will end the list, usually "list".
 * @param name An array of one string, used to return the name attribute
 * of the list's tag.
 *
 * @return HashMap The newly generated list.
 *
 * @see #readListXml
 */

@@ -1,18 +1,3 @@
 {
-    ArrayList list = new ArrayList();
-    int eventType = parser.getEventType();
-    do {
-        if (eventType == parser.START_TAG) {
-            Object val = readThisValueXml(parser, name);
-            list.add(val);
-        // System.out.println("Adding to list: " + val);
-        } else if (eventType == parser.END_TAG) {
-            if (parser.getName().equals(endTag)) {
-                return list;
-            }
-            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-        }
-        eventType = parser.next();
-    } while (eventType != parser.END_DOCUMENT);
-    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    return readThisListXml(parser, endTag, name, null);
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */

@@ -4,8 +4,8 @@
         return null;
     }
     AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
-    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
+    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.GcSnapshot.createCustomGraphics:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new {@link Graphics2D} based on the {@link Paint} parameters.
 * <p/>The object must be disposed ({@link Graphics2D#dispose()}) after being used.
 */

@@ -5,59 +5,18 @@
         g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
     }
+    // set the shader first, as it'll replace the color if it can be used it.
     boolean customShader = false;
-    // get the shader first, as it'll replace the color if it can be used it.
-    if (compositeOnly == false) {
-        Shader_Delegate shaderDelegate = paint.getShader();
-        if (shaderDelegate != null) {
-            if (shaderDelegate.isSupported()) {
-                java.awt.Paint shaderPaint = shaderDelegate.getJavaPaint();
-                assert shaderPaint != null;
-                if (shaderPaint != null) {
-                    g.setPaint(shaderPaint);
-                    customShader = true;
-                }
-            } else {
-                Bridge.getLog().fidelityWarning(LayoutLog.TAG_SHADER, shaderDelegate.getSupportMessage(), null, /*throwable*/
-                null);
-            }
-        }
-        // if no shader, use the paint color
-        if (customShader == false) {
-            g.setColor(new Color(paint.getColor(), true));
-        }
+    if (!compositeOnly) {
+        customShader = setShader(g, paint);
         // set the stroke
         g.setStroke(paint.getJavaStroke());
     }
-    // the alpha for the composite. Always opaque if the normal paint color is used since
-    // it contains the alpha
-    int alpha = (compositeOnly || customShader) ? paint.getAlpha() : 0xFF;
-    if (forceSrcMode) {
-        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, (float) alpha / 255.f));
-    } else {
-        boolean customXfermode = false;
-        Xfermode_Delegate xfermodeDelegate = paint.getXfermode();
-        if (xfermodeDelegate != null) {
-            if (xfermodeDelegate.isSupported()) {
-                Composite composite = xfermodeDelegate.getComposite(alpha);
-                assert composite != null;
-                if (composite != null) {
-                    g.setComposite(composite);
-                    customXfermode = true;
-                }
-            } else {
-                Bridge.getLog().fidelityWarning(LayoutLog.TAG_XFERMODE, xfermodeDelegate.getSupportMessage(), null, /*throwable*/
-                null);
-            }
-        }
-        // that will handle the alpha.
-        if (customXfermode == false && alpha != 0xFF) {
-            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) alpha / 255.f));
-        }
-    }
+    // set the composite.
+    setComposite(g, paint, compositeOnly || customShader, forceMode);
     return g;
 }

Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onStopped:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -3,8 +3,10 @@
         if (DEBUG)
             Log.d(TAG, "onStopped");
         mPaused = true;
+        mStopped = true;
+        mSeeking = false;
         scheduleNotification(NOTIFY_STOP, 0);
     }
 }

Find a functionally equivalent code:android.bluetooth.BluetoothDevice.connectGatt:COMMENT
Method Modifier: public      
Comment:/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */

@@ -1,19 +1,3 @@
 {
-    // TODO(Bluetooth) check whether platform support BLE
-    // Do the check here or in GattServer?
-    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-    IBluetoothManager managerService = adapter.getBluetoothManager();
-    try {
-        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
-        if (iGatt == null) {
-            // BLE is not supported
-            return null;
-        }
-        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this);
-        gatt.connect(autoConnect, callback);
-        return gatt;
-    } catch (RemoteException e) {
-        Log.e(TAG, "", e);
-    }
-    return null;
+    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
 }

Find a functionally equivalent code:android.view.DisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

@@ -31,37 +31,39 @@
     sb.append(smallestNominalAppHeight);
     sb.append(", ");
     sb.append(refreshRate);
-    sb.append(" fps, rotation");
+    sb.append(" fps, supportedRefreshRates ");
+    sb.append(Arrays.toString(supportedRefreshRates));
+    sb.append(", rotation ");
     sb.append(rotation);
     sb.append(", density ");
     sb.append(logicalDensityDpi);
@@ -41,51 +43,59 @@
     sb.append(physicalYDpi);
     sb.append(") dpi, layerStack ");
     sb.append(layerStack);
+    sb.append(", appVsyncOff ");
+    sb.append(appVsyncOffsetNanos);
+    sb.append(", presDeadline ");
+    sb.append(presentationDeadlineNanos);
     sb.append(", type ");
     sb.append(Display.typeToString(type));
     if (address != null) {
         sb.append(", address ").append(address);
     }
+    sb.append(", state ");
+    sb.append(Display.stateToString(state));
     if (ownerUid != 0 || ownerPackageName != null) {
         sb.append(", owner ").append(ownerPackageName);
         sb.append(" (uid ").append(ownerUid).append(")");

Find a functionally equivalent code:android.app.backup.BackupManager.beginRestoreSession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Begin the process of restoring data from backup.  See the
 * {@link android.app.backup.RestoreSession} class for documentation on that process.
 * @hide
 */

@@ -9,15 +9,15 @@
                 session = new RestoreSession(mContext, binder);
             }
         } catch (RemoteException e) {
-            Log.w(TAG, "beginRestoreSession() couldn't connect");
+            Log.e(TAG, "beginRestoreSession() couldn't connect");
         }
     }
     return session;

Find a functionally equivalent code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function should be called from checkAndProcessPlusCode only
 * And it is used for test purpose also.
 *
 * It checks the dial string by looping through the network portion,
 * post dial portion 1, post dial porting 2, etc. If there is any
 * plus sign, then process the plus sign.
 * Currently, this function supports the plus sign conversion within NANP only.
 * Specifically, it handles the plus sign in the following ways:
 * 1)+1NANP,remove +, e.g.
 * +18475797000 is converted to 18475797000,
 * 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g,
 * +8475797000 is converted to 0118475797000,
 * +11875767800 is converted to 01111875767800
 * 3)+1NANP in post dial string(s), e.g.
 * 8475797000;+18475231753 is converted to 8475797000;18475231753
 *
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,
 * and if there is the "+" in the original dial string. Otherwise, the original dial
 * string returns.
 *
 * @hide
 */

@@ -1,61 +1,58 @@
 {
     String retStr = dialStr;
+    boolean useNanp = (currFormat == defaultFormat) && (currFormat == FORMAT_NANP);
     // Checks if the plus sign character is in the passed-in dial string
     if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
-        // and the current country the phone is camped on.
-        if ((currFormat == defaultFormat) && (currFormat == FORMAT_NANP)) {
-            // Handle case where default and current telephone numbering plans are NANP.
-            String postDialStr = null;
-            String tempDialStr = dialStr;
-            // Sets the retStr to null since the conversion will be performed below.
-            retStr = null;
-            if (DBG)
-                log("checkAndProcessPlusCode,dialStr=" + dialStr);
-            // applied
-            do {
-                String networkDialStr;
+        // Handle case where default and current telephone numbering plans are NANP.
+        String postDialStr = null;
+        String tempDialStr = dialStr;
+        // Sets the retStr to null since the conversion will be performed below.
+        retStr = null;
+        if (DBG)
+            log("checkAndProcessPlusCode,dialStr=" + dialStr);
+        // applied
+        do {
+            String networkDialStr;
+            // and the current country the phone is camped
+            if (useNanp) {
                 networkDialStr = extractNetworkPortion(tempDialStr);
-                // Handles the conversion within NANP
-                networkDialStr = processPlusCodeWithinNanp(networkDialStr);
-                // Concatenates the string that is converted from network portion
-                if (!TextUtils.isEmpty(networkDialStr)) {
-                    if (retStr == null) {
-                        retStr = networkDialStr;
-                    } else {
-                        retStr = retStr.concat(networkDialStr);
-                    }
+            } else {
+                networkDialStr = extractNetworkPortionAlt(tempDialStr);
+            }
+            networkDialStr = processPlusCode(networkDialStr, useNanp);
+            // Concatenates the string that is converted from network portion
+            if (!TextUtils.isEmpty(networkDialStr)) {
+                if (retStr == null) {
+                    retStr = networkDialStr;
                 } else {
-                    // This should never happen since we checked the if dialStr is null
-                    // and if it contains the plus sign in the beginning of this function.
-                    // The plus sign is part of the network portion.
-                    Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
-                    return dialStr;
+                    retStr = retStr.concat(networkDialStr);
                 }
-                postDialStr = extractPostDialPortion(tempDialStr);
-                if (!TextUtils.isEmpty(postDialStr)) {
-                    int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
-                    // dialableIndex should always be greater than 0
-                    if (dialableIndex >= 1) {
-                        retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
-                        // Skips the P/W character, extracts the dialable portion
-                        tempDialStr = postDialStr.substring(dialableIndex);
-                    } else {
-                        // Set the postDialStr to "" to break out of the loop
-                        if (dialableIndex < 0) {
-                            postDialStr = "";
-                        }
-                        Rlog.e("wrong postDialStr=", postDialStr);
+            } else {
+                // This should never happen since we checked the if dialStr is null
+                // and if it contains the plus sign in the beginning of this function.
+                // The plus sign is part of the network portion.
+                Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
+                return dialStr;
+            }
+            postDialStr = extractPostDialPortion(tempDialStr);
+            if (!TextUtils.isEmpty(postDialStr)) {
+                int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
+                // dialableIndex should always be greater than 0
+                if (dialableIndex >= 1) {
+                    retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
+                    // Skips the P/W character, extracts the dialable portion
+                    tempDialStr = postDialStr.substring(dialableIndex);
+                } else {
+                    // Set the postDialStr to "" to break out of the loop
+                    if (dialableIndex < 0) {
+                        postDialStr = "";
                     }
+                    Rlog.e("wrong postDialStr=", postDialStr);
                 }
-                if (DBG)
-                    log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
-            } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
-        } else {
-            // TODO: Support NANP international conversion and other telephone numbering plans.
-            // Currently the phone is never used in non-NANP system, so return the original
-            // dial string.
-            Rlog.e("checkAndProcessPlusCode:non-NANP not supported", dialStr);
-        }
+            }
+            if (DBG)
+                log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
+        } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
     }
     return retStr;
 }

Find a functionally equivalent code:android.graphics.Bitmap.nativeExtractAlpha:COMMENT
Method Modifier: private     static      native      
Comment:// returns a new bitmap built from the native bitmap's alpha, and the paint


Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateGroupCapability:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateGroupCapability(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * @hide
 */


Find a functionally equivalent code:android.os.Bundle.putByte:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a byte
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putByte(key, value);
 }

Find a functionally equivalent code:android.os.Bundle.putFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a float
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putFloat(key, value);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.systemReady:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,8 +1,8 @@
 {
-    if (!mHeadless) {
-        mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);
-        mKeyguardDelegate.onSystemReady();
-    }
+    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, null);
+    mKeyguardDelegate.onSystemReady();
+    readCameraLensCoverState();
+    updateUiMode();
     synchronized (mLock) {
         updateOrientationListenerLp();
         mSystemReady = true;

Find a functionally equivalent code:android.view.PointerIcon.getSystemIcon:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets a system pointer icon for the given style.
 * If style is not recognized, returns the default pointer icon.
 *
 * @param context The context.
 * @param style The pointer icon style.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 */

@@ -20,26 +20,26 @@
     if ((resourceId & 0xff000000) == 0x01000000) {
         icon.mSystemIconResourceId = resourceId;
     } else {
-        icon.loadResource(context.getResources(), resourceId);
+        icon.loadResource(context, context.getResources(), resourceId);
     }
     return icon;
 }

Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.allocate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Method to create a new CallerInfoAsyncQueryHandler object, ensuring correct
 * state of context and uri.
 */

@@ -3,8 +3,7 @@
         throw new QueryPoolException("Bad context or query uri.");
     }
     mHandler = new CallerInfoAsyncQueryHandler(context);
-    mHandler.mQueryContext = context;
     mHandler.mQueryUri = contactRef;
 }

Find a functionally equivalent code:android.os.CountDownTimer.start:COMMENT
Method Modifier: public      final       
Comment:/**
 * Start the countdown.
 */

@@ -1,4 +1,5 @@
 {
+    mCancelled = false;
     if (mMillisInFuture <= 0) {
         onFinish();
         return this;

Find a functionally equivalent code:android.content.RestrictionEntry.getChoiceValues:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of possible string values set earlier.
 * @return the list of possible values.
 */

@@ -1,3 +1,3 @@
 {
-    return values;
+    return mChoiceValues;
 }

Find a functionally equivalent code:android.graphics.Canvas.drawRoundRect:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified round-rect using the specified paint. The roundrect
 * will be filled or framed based on the Style in the paint.
 *
 * @param rect  The rectangular bounds of the roundRect to be drawn
 * @param rx    The x-radius of the oval used to round the corners
 * @param ry    The y-radius of the oval used to round the corners
 * @param paint The paint used to draw the roundRect
 */

@@ -1,6 +1,3 @@
 {
-    if (rect == null) {
-        throw new NullPointerException();
-    }
-    native_drawRoundRect(mNativeCanvas, rect, rx, ry, paint.mNativePaint);
+    drawRoundRect(rect.left, rect.top, rect.right, rect.bottom, rx, ry, paint);
 }

Find a functionally equivalent code:android.media.MediaFocusControl.unregisterMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterMediaButtonEventReceiverForCalls()
 */

@@ -3,9 +3,9 @@
         Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
         return;
     }
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         mMediaReceiverForCalls = null;
     }
 }

Find a functionally equivalent code:android.media.MediaRouter.removeUserRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an app-specified route for media from the MediaRouter.
 *
 * @param info Definition of the route to remove
 * @see #addUserRoute(UserRouteInfo)
 */

@@ -1,3 +1,3 @@
 {
-    removeRoute(info);
+    removeRouteStatic(info);
 }

Find a functionally equivalent code:android.text.TextLine.handleText:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function for measuring and rendering text.  The text must
 * not include a tab or emoji.
 *
 * @param wp the working paint
 * @param start the start of the text
 * @param end the end of the text
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null if rendering is not needed
 * @param x the edge of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width of the run is needed
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

@@ -11,22 +11,21 @@
     float ret = 0;
     int contextLen = contextEnd - contextStart;
     if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
-        int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
         if (mCharsValid) {
-            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, flags, null, 0);
+            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, runIsRtl, null, 0);
         } else {
             int delta = mStart;
-            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, flags, null, 0);
+            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, null, 0);
         }
     }
     if (c != null) {

Find a functionally equivalent code:android.hardware.location.GeofenceHardwareImpl.reportGeofenceMonitorStatus:COMMENT
Method Modifier: public      
Comment:/**
 * Used to report Monitor status changes.
 */

@@ -1,9 +1,7 @@
 {
-    // TODO: use the source if needed in the future
     setMonitorAvailability(monitoringType, monitoringStatus);
     acquireWakeLock();
-    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, location);
-    message.arg1 = monitoringStatus;
-    message.arg2 = monitoringType;
+    GeofenceHardwareMonitorEvent event = new GeofenceHardwareMonitorEvent(monitoringType, monitoringStatus, source, location);
+    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, event);
     message.sendToTarget();
 }

Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.requestSetVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request a volume change for this route.
 * @param volume value between 0 and getVolumeMax
 */

@@ -6,11 +6,11 @@
             Log.e(TAG, "Error setting local stream volume", e);
         }
     } else {
-        Log.e(TAG, getClass().getSimpleName() + ".requestSetVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
+        sStatic.requestSetVolume(this, volume);
     }
 }

Find a functionally equivalent code:android.content.res.AssetManager.addAssetPath:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Add an additional set of assets to the asset manager.  This can be
 * either a directory or ZIP file.  Not for use by applications.  Returns
 * the cookie of the added asset, or 0 on failure.
 * {@hide}
 */

@@ -1,4 +1,7 @@
 {
-    int res = addAssetPathNative(path);
-    return res;
+    synchronized (this) {
+        int res = addAssetPathNative(path);
+        makeStringBlocks(mStringBlocks);
+        return res;
+    }
 }

Find a functionally equivalent code:android.os.Bundle.getShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a short[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (short[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "short[]", e);
-        return null;
-    }
+    return super.getShortArray(key);
 }

Find a functionally equivalent code:android.graphics.drawable.LayerDrawable.setDrawableByLayerId:COMMENT
Method Modifier: public      
Comment:/**
 * Sets (or replaces) the {@link Drawable} for the layer with the given id.
 *
 * @param id The layer ID to search for.
 * @param drawable The replacement {@link Drawable}.
 * @return Whether the {@link Drawable} was replaced (could return false if
 * the id was not found).
 */

@@ -1,18 +1,21 @@
 {
     final ChildDrawable[] layers = mLayerState.mChildren;
-    for (int i = mLayerState.mNum - 1; i >= 0; i--) {
-        if (layers[i].mId == id) {
-            if (layers[i].mDrawable != null) {
+    final int N = mLayerState.mNum;
+    for (int i = 0; i < N; i++) {
+        final ChildDrawable childDrawable = layers[i];
+        if (childDrawable.mId == id) {
+            if (childDrawable.mDrawable != null) {
                 if (drawable != null) {
-                    Rect bounds = layers[i].mDrawable.getBounds();
+                    final Rect bounds = childDrawable.mDrawable.getBounds();
                     drawable.setBounds(bounds);
                 }
-                layers[i].mDrawable.setCallback(null);
+                childDrawable.mDrawable.setCallback(null);
             }
             if (drawable != null) {
                 drawable.setCallback(this);
             }
-            layers[i].mDrawable = drawable;
+            childDrawable.mDrawable = drawable;
+            mLayerState.invalidateCache();
             return true;
         }
     }

Find a functionally equivalent code:android.media.MediaFocusControl.checkUpdateRemoteStateIfActive:COMMENT
Method Modifier: protected   
Comment:/**
 * Checks if a remote client is active on the supplied stream type. Update the remote stream
 * volume state if found and playing
 * @param streamType
 * @return false if no remote playing is currently playing
 */

@@ -1,17 +1,17 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         // iterating from top of stack as active playback is more likely on entries at the top
         try {
-            for (int index = mRCStack.size() - 1; index >= 0; index--) {
-                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
-                if ((rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(rcse.mPlaybackState.mState) && (rcse.mPlaybackStream == streamType)) {
+            for (int index = mPRStack.size() - 1; index >= 0; index--) {
+                final PlayerRecord prse = mPRStack.elementAt(index);
+                if ((prse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(prse.mPlaybackState.mState) && (prse.mPlaybackStream == streamType)) {
                     if (DEBUG_RC)
-                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + rcse.mPlaybackVolume);
+                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + prse.mPlaybackVolume);
                     synchronized (mMainRemote) {
-                        mMainRemote.mRccId = rcse.mRccId;
-                        mMainRemote.mVolume = rcse.mPlaybackVolume;
-                        mMainRemote.mVolumeMax = rcse.mPlaybackVolumeMax;
-                        mMainRemote.mVolumeHandling = rcse.mPlaybackVolumeHandling;
+                        mMainRemote.mRccId = prse.getRccId();
+                        mMainRemote.mVolume = prse.mPlaybackVolume;
+                        mMainRemote.mVolumeMax = prse.mPlaybackVolumeMax;
+                        mMainRemote.mVolumeHandling = prse.mPlaybackVolumeHandling;
                         mMainRemoteIsActive = true;
                     }
                     return true;

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.setupTabHost:COMMENT
Method Modifier: private     
Comment:/**
 * Sets up a {@link TabHost} object.
 * @param tabHost the TabHost to setup.
 * @param projectCallback The project callback object to access the project R class.
 * @throws PostInflateException
 */

@@ -4,22 +4,23 @@
     if (v == null) {
         throw new PostInflateException("TabHost requires a TabWidget with id \"android:id/tabs\".\n");
     }
-    if ((v instanceof TabWidget) == false) {
+    if (!(v instanceof TabWidget)) {
         throw new PostInflateException(String.format("TabHost requires a TabWidget with id \"android:id/tabs\".\n" + "View found with id 'tabs' is '%s'", v.getClass().getCanonicalName()));
     }
     v = tabHost.findViewById(android.R.id.tabcontent);
     if (v == null) {
-        // TODO: see if we can fake tabs even without the FrameLayout (same below when the framelayout is empty)
+        // noinspection SpellCheckingInspection
         throw new PostInflateException("TabHost requires a FrameLayout with id \"android:id/tabcontent\".");
     }
-    if ((v instanceof FrameLayout) == false) {
+    if (!(v instanceof FrameLayout)) {
+        // noinspection SpellCheckingInspection
         throw new PostInflateException(String.format("TabHost requires a FrameLayout with id \"android:id/tabcontent\".\n" + "View found with id 'tabcontent' is '%s'", v.getClass().getCanonicalName()));
     }
     FrameLayout content = (FrameLayout) v;
-    // now process the content of the framelayout and dynamically create tabs for it.
+    // now process the content of the frameLayout and dynamically create tabs for it.
     final int count = content.getChildCount();
     // this must be called before addTab() so that the TabHost searches its TabWidget
     // and FrameLayout.
@@ -31,44 +32,44 @@
             }
         });
         tabHost.addTab(spec);
-        return;
     } else {
-        // for each child of the framelayout, add a new TabSpec
+        // for each child of the frameLayout, add a new TabSpec
         for (int i = 0; i < count; i++) {
             View child = content.getChildAt(i);
             String tabSpec = String.format("tab_spec%d", i + 1);
             int id = child.getId();
-            Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
+            @SuppressWarnings("deprecation") Pair<ResourceType, String> resource = projectCallback.resolveResourceId(id);
             String name;
             if (resource != null) {
                 name = resource.getSecond();

Find a functionally equivalent code:android.widget.ListPopupWindow.DropDownListView.onForwardedEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Handles forwarded events.
 *
 * @param activePointerId id of the pointer that activated forwarding
 * @return whether the event was handled
 */

@@ -23,29 +23,29 @@
                 break;
             }
             final View child = getChildAt(position - getFirstVisiblePosition());
-            setPressedItem(child, position);
+            setPressedItem(child, position, x, y);
             handledEvent = true;
             if (actionMasked == MotionEvent.ACTION_UP) {
                 clickPressedItem(child, position);

Find a functionally equivalent code:android.test.TouchUtils.scrollToBottom:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Scroll a ViewGroup to the bottom by repeatedly calling
 * {@link #dragQuarterScreenUp(InstrumentationTestCase, Activity)}
 *
 * @param test The test case that is being run
 * @param v The ViewGroup that should be dragged
 *
 * @deprecated {@link android.test.ActivityInstrumentationTestCase} is deprecated in favor of
 * {@link android.test.ActivityInstrumentationTestCase2}, which provides more options for
 * configuring the Activity under test
 */


Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callCallNativeInstance:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link ClassWithNative#callNativeInstance(int, double, Object[])}
 * via reflection.
 */

@@ -1,5 +1,5 @@
 {
-    Method m = instance.getClass().getMethod("callNativeInstance", new Class<?>[] { int.class, double.class, Object[].class });
-    Object result = m.invoke(instance, new Object[] { a, d, o });
-    return ((Integer) result).intValue();
+    Method m = instance.getClass().getMethod("callNativeInstance", int.class, double.class, Object[].class);
+    Object result = m.invoke(instance, a, d, o);
+    return (Integer) result;
 }

Find a functionally equivalent code:android.net.LocalSocketImpl.close:COMMENT
Method Modifier: public      
Comment:/**
 * Closes the socket.
 *
 * @throws IOException
 */

@@ -5,11 +5,11 @@
             return;
         }
         try {
-            Libcore.os.close(fd);
+            Os.close(fd);
         } catch (ErrnoException e) {
             e.rethrowAsIOException();
         }

Find a functionally equivalent code:com.android.systemui.settings.BrightnessController.unregisterCallbacks:COMMENT
Method Modifier: public      
Comment:/**
 * Unregister all call backs, both to and from the controller
 */

@@ -1,5 +1,9 @@
 {
+    if (!mListening) {
+        return;
+    }
     mBrightnessObserver.stopObserving();
-    mChangeCallbacks.clear();
     mUserTracker.stopTracking();
+    mControl.setOnChangedListener(null);
+    mListening = false;
 }

Find a functionally equivalent code:android.app.WallpaperManager.suggestDesiredDimensions:COMMENT
Method Modifier: public      
Comment:/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */

@@ -1,5 +1,31 @@
 {
     try {
+        /**
+         * The framework makes no attempt to limit the window size
+         * to the maximum texture size. Any window larger than this
+         * cannot be composited.
+         *
+         * Read maximum texture size from system property and scale down
+         * minimumWidth and minimumHeight accordingly.
+         */
+        int maximumTextureSize;
+        try {
+            maximumTextureSize = SystemProperties.getInt("sys.max_texture_size", 0);
+        } catch (Exception e) {
+            maximumTextureSize = 0;
+        }
+        if (maximumTextureSize > 0) {
+            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
+                float aspect = (float) minimumHeight / (float) minimumWidth;
+                if (minimumWidth > minimumHeight) {
+                    minimumWidth = maximumTextureSize;
+                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
+                } else {
+                    minimumHeight = maximumTextureSize;
+                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
+                }
+            }
+        }
         if (sGlobals.mService == null) {
             Log.w(TAG, "WallpaperService not running");
         } else {

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleCancel:COMMENT
Method Modifier: 
Comment:/**
 * Stops the Face Unlock service and goes to the backup lock.
 */

@@ -6,10 +6,10 @@
     KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
     mKeyguardScreenCallback.showBackupSecurity();
     stop();
-    mKeyguardScreenCallback.userActivity(BACKUP_LOCK_TIMEOUT);
+    mKeyguardScreenCallback.userActivity();
 }

Find a functionally equivalent code:android.content.RestrictionEntry.getTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the user-visible title for the entry, if any.
 * @return the user-visible title for the entry, null if none was set earlier.
 */

@@ -1,3 +1,3 @@
 {
-    return title;
+    return mTitle;
 }

Find a functionally equivalent code:android.graphics.Path.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Rewinds the path: clears any lines and curves from the path but
 * keeps the internal data structure for faster reuse.
 */

@@ -1,9 +1,7 @@
 {
     isSimplePath = true;
-    if (mDetectSimplePaths) {
-        mLastDirection = null;
-        if (rects != null)
-            rects.setEmpty();
-    }
+    mLastDirection = null;
+    if (rects != null)
+        rects.setEmpty();
     native_rewind(mNativePath);
 }

Find a functionally equivalent code:android.view.GLES20Canvas.getRenderer:COMMENT
Method Modifier: 
Comment:/**
 * Returns the native OpenGLRenderer object.
 */


Find a functionally equivalent code:android.widget.SuggestionsAdapter.getDrawable:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a drawable by URI, without using the cache.
 *
 * @return A drawable, or {@code null} if the drawable could not be loaded.
 */

@@ -5,11 +5,11 @@
             // Load drawables through Resources, to get the source density information
             OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
             try {
-                return r.r.getDrawable(r.id);
+                return r.r.getDrawable(r.id, mContext.getTheme());
             } catch (Resources.NotFoundException ex) {
                 throw new FileNotFoundException("Resource does not exist: " + uri);
             }

Find a functionally equivalent code:android.view.InputQueue.sendInputEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     ActiveInputEvent event = obtainActiveInputEvent(token, callback);
-    int id;
+    long id;
     if (e instanceof KeyEvent) {
         id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
     } else {

Find a functionally equivalent code:android.preference.Preference.setIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the icon for this Preference with a Drawable.
 * This icon will be placed into the ID
 * {@link android.R.id#icon} within the View created by
 * {@link #onCreateView(ViewGroup)}.
 *
 * @param icon The optional icon for this Preference.
 */


Find a functionally equivalent code:android.net.Proxy.getProxy:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Return the proxy object to be used for the URL given as parameter.
 * @param ctx A Context used to get the settings for the proxy host.
 * @param url A URL to be accessed. Used to evaluate exclusion list.
 * @return Proxy (java.net) object containing the host name. If the
 * user did not set a hostname it returns the default host.
 * A null value means that no host is to be used.
 * {@hide}
 */

@@ -1,20 +1,11 @@
 {
     String host = "";
-    if (url != null) {
+    if ((url != null) && !isLocalHost(host)) {
         URI uri = URI.create(url);
-        host = uri.getHost();
-    }
-    if (!isLocalHost(host)) {
-        if (sConnectivityManager == null) {
-            sConnectivityManager = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
-        }
-        if (sConnectivityManager == null)
-            return java.net.Proxy.NO_PROXY;
-        ProxyProperties proxyProperties = sConnectivityManager.getProxy();
-        if (proxyProperties != null) {
-            if (!proxyProperties.isExcluded(host)) {
-                return proxyProperties.makeProxy();
-            }
+        ProxySelector proxySelector = ProxySelector.getDefault();
+        List<java.net.Proxy> proxyList = proxySelector.select(uri);
+        if (proxyList.size() > 0) {
+            return proxyList.get(0);
         }
     }
     return java.net.Proxy.NO_PROXY;

Find a functionally equivalent code:android.os.Process.myUid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process's uid.  This is the kernel uid
 * that the process is running under, which is the identity of its
 * app-specific sandbox.  It is different from {@link #myUserHandle} in that
 * a uid identifies a specific app sandbox in a specific user.
 */

@@ -1,3 +1,3 @@
 {
-    return Libcore.os.getuid();
+    return Os.getuid();
 }

Find a functionally equivalent code:android.widget.Scroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */

@@ -6,16 +6,12 @@
     if (timePassed < mDuration) {
         switch(mMode) {
             case SCROLL_MODE:
-                float x = timePassed * mDurationReciprocal;
-                if (mInterpolator == null)
-                    x = viscousFluid(x);
-                else
-                    x = mInterpolator.getInterpolation(x);
+                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                 mCurrX = mStartX + Math.round(x * mDeltaX);
                 mCurrY = mStartY + Math.round(x * mDeltaY);
                 break;

Find a functionally equivalent code:android.os.Bundle.putIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<Integer> object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putIntegerArrayList(key, value);
 }

Find a functionally equivalent code:android.animation.ValueAnimator.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */

@@ -3,8 +3,8 @@
         throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
     }
     mUnscaledDuration = duration;
-    mDuration = (long) (duration * sDurationScale);
+    updateScaledDuration();
     return this;
 }

Find a functionally equivalent code:android.text.GraphicsOperations.drawTextRun:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Canvas#drawTextRun}.
 * {@hide}
 */


Find a functionally equivalent code:android.net.NetworkStats.findIndexHinted:COMMENT
Method Modifier: public      
Comment:/**
 * Find first stats index that matches the requested parameters, starting
 * search around the hinted index as an optimization.
 */

@@ -8,14 +8,14 @@
         } else {
             i = (size + hintIndex - halfOffset - 1) % size;
         }
-        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
+        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
             return i;
         }
     }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.setVisiblePatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Set whether the visible pattern is enabled.
 */

@@ -1,3 +1,19 @@
 {
     setBoolean(Settings.Secure.LOCK_PATTERN_VISIBLE, enabled);
+    // Update for crypto if owner
+    int userId = getCurrentOrCallingUserId();
+    if (userId != UserHandle.USER_OWNER) {
+        return;
+    }
+    IBinder service = ServiceManager.getService("mount");
+    if (service == null) {
+        Log.e(TAG, "Could not find the mount service to update the user info");
+        return;
+    }
+    IMountService mountService = IMountService.Stub.asInterface(service);
+    try {
+        mountService.setField(StorageManager.PATTERN_VISIBLE_KEY, enabled ? "1" : "0");
+    } catch (RemoteException e) {
+        Log.e(TAG, "Error changing pattern visible state", e);
+    }
 }

Find a functionally equivalent code:android.view.ViewGroup.focusableViewAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,6 +1,6 @@
 {
     if (mParent != null && // getting focus
-    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && // an ancestor of v; this will get checked for at ViewAncestor
+    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen()) && // an ancestor of v; this will get checked for at ViewAncestor
     !(isFocused() && getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) {
         mParent.focusableViewAvailable(v);
     }

Find a functionally equivalent code:android.webkit.WebSyncManager.resetSync:COMMENT
Method Modifier: public      
Comment:/**
 * resetSync() resets sync manager's timer
 */

@@ -1,11 +1,2 @@
 {
-    if (DebugFlags.WEB_SYNC_MANAGER) {
-        Log.v(LOGTAG, "*** WebSyncManager resetSync ***");
-    }
-    if (mHandler == null) {
-        return;
-    }
-    mHandler.removeMessages(SYNC_MESSAGE);
-    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
-    mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
 }

Find a functionally equivalent code:android.media.MediaPlayer.getTrackInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an array of track information.
 *
 * @return Array of track info. The total number of tracks is the array length.
 * Must be called again if an external timed text source has been added after any of the
 * addTimedTextSource methods are called.
 * @throws IllegalStateException if it is called in an invalid state.
 */

@@ -5,11 +5,12 @@
     System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
     int i = trackInfo.length;
     for (SubtitleTrack track : mOutOfBandSubtitleTracks) {
-        allTrackInfo[i] = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, track.getFormat());
+        int type = track.isTimedText() ? TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT : TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE;
+        allTrackInfo[i] = new TrackInfo(type, track.getFormat());
         ++i;
     }
     return allTrackInfo;

Find a functionally equivalent code:android.view.accessibility.CaptioningManager.CaptionStyle.getCustomStyle:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -4,12 +4,13 @@
     final int backgroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR, defStyle.backgroundColor);
     final int edgeType = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE, defStyle.edgeType);
     final int edgeColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR, defStyle.edgeColor);
+    final int windowColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR, defStyle.windowColor);
     String rawTypeface = Secure.getString(cr, Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
     if (rawTypeface == null) {
         rawTypeface = defStyle.mRawTypeface;
     }
-    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, rawTypeface);
+    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, windowColor, rawTypeface);
 }

Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onPaused:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -4,13 +4,16 @@
             Log.d(TAG, "onPaused: " + paused);
         if (mStopped) {
             // handle as seek if we were stopped
+            mStopped = false;
+            mSeeking = true;
             scheduleNotification(NOTIFY_SEEK, 0);
         } else {
             // special handling if player disappeared
             mPausing = paused;
+            mSeeking = false;
             scheduleNotification(REFRESH_AND_NOTIFY_TIME, 0);
         }
     }

Find a functionally equivalent code:android.view.Window.setWindowAnimations:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom animations to use for the window, as per
 * {@link WindowManager.LayoutParams#windowAnimations
 * WindowManager.LayoutParams.windowAnimations}.  Providing anything besides
 * 0 here will override the animations the window would
 * normally retrieve from its theme.
 */

@@ -1,7 +1,5 @@
 {
     final WindowManager.LayoutParams attrs = getAttributes();
     attrs.windowAnimations = resId;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.app.ActivityThread.performStopActivityInner:COMMENT
Method Modifier: private     
Comment:/**
 * Core implementation of stopping an activity.  Note this is a little
 * tricky because the server's meaning of stop is slightly different
 * than our client -- for the server, stop means to save state and give
 * it the result when it is done, but the window may still be visible.
 * For the client, we want to call onStop()/onStart() to indicate when
 * the activity's UI visibillity changes.
 */

@@ -1,7 +1,6 @@
 {
     if (localLOGV)
         Slog.v(TAG, "Performing stop of " + r);
-    Bundle state = null;
     if (r != null) {
         if (!keepShown && r.stopped) {
             if (r.activity.mFinished) {
@@ -16,23 +15,20 @@
                 // First create a thumbnail for the activity...
                 // For now, don't create the thumbnail here; we are
                 // doing that by doing a screen snapshot.
-                // createThumbnailBitmap(r);
-                info.thumbnail = null;
                 info.description = r.activity.onCreateDescription();
             } catch (Exception e) {
                 if (!mInstrumentation.onException(r.activity, e)) {
@@ -28,39 +25,31 @@
         // Next have the activity save its current state and managed dialogs...
         if (!r.activity.mFinished && saveState) {
             if (r.state == null) {
-                state = new Bundle();
-                state.setAllowFds(false);
-                mInstrumentation.callActivityOnSaveInstanceState(r.activity, state);
-                r.state = state;
-            } else {
-                state = r.state;
+                callCallActivityOnSaveInstanceState(r);
             }
         }
         if (!keepShown) {

Find a functionally equivalent code:android.hardware.SensorManager.getRotationMatrixFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a rotation matrix.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
 * 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
 * If R.length == 9, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   \
 * |  R[ 3]   R[ 4]   R[ 5]   |
 * \  R[ 6]   R[ 7]   R[ 8]   /
 * </pre>
 * If R.length == 16, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   0  \
 * |  R[ 4]   R[ 5]   R[ 6]   0  |
 * |  R[ 8]   R[ 9]   R[10]   0  |
 * \  0       0       0       1  /
 * </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */

@@ -3,9 +3,9 @@
     float q1 = rotationVector[0];
     float q2 = rotationVector[1];
     float q3 = rotationVector[2];
-    if (rotationVector.length == 4) {
+    if (rotationVector.length >= 4) {
         q0 = rotationVector[3];
     } else {
         q0 = 1 - q1 * q1 - q2 * q2 - q3 * q3;

Find a functionally equivalent code:android.os.Bundle.hasFileDescriptors:COMMENT
Method Modifier: public      
Comment:/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */

@@ -26,32 +26,32 @@
                 } else if (obj instanceof SparseArray) {
                     SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                     for (int n = array.size() - 1; n >= 0; n--) {
-                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
+                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                             fdFound = true;
                             break;
                         }
@@ -34,40 +34,40 @@
                 } else if (obj instanceof ArrayList) {
                     ArrayList array = (ArrayList) obj;
                     // Parcelables; only look inside for Parcelables
-                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
+                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                         for (int n = array.size() - 1; n >= 0; n--) {
                             Parcelable p = (Parcelable) array.get(n);
                             if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {

Find a functionally equivalent code:android.os.storage.IMountService.mountSecureContainer:COMMENT
Method Modifier: public      
Comment:/*
     * Mount a secure container with the specified key and owner UID. Returns an
     * int consistent with MountServiceResultCode
     */


Find a functionally equivalent code:android.os.ParcelFileDescriptor.getStatSize:COMMENT
Method Modifier: public      
Comment:/**
 * Return the total size of the file representing this fd, as determined by
 * {@code stat()}. Returns -1 if the fd is not a file.
 */

@@ -3,9 +3,9 @@
         return mWrapped.getStatSize();
     } else {
         try {
-            final StructStat st = Libcore.os.fstat(mFd);
+            final StructStat st = Os.fstat(mFd);
             if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                 return st.st_size;
             } else {

Find a functionally equivalent code:android.view.Surface.unlockCanvasAndPost:COMMENT
Method Modifier: public      
Comment:/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */

@@ -5,17 +5,20 @@
     synchronized (mLock) {
         checkNotReleasedLocked();
         if (mNativeObject != mLockedObject) {
-            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Integer.toHexString(mNativeObject) + ") != mLockedObject (0x" + Integer.toHexString(mLockedObject) + ")");
+            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Long.toHexString(mNativeObject) + ") != mLockedObject (0x" + Long.toHexString(mLockedObject) + ")");
         }
         if (mLockedObject == 0) {
             throw new IllegalStateException("Surface was not locked");
         }
-        nativeUnlockCanvasAndPost(mLockedObject, canvas);
-        nativeRelease(mLockedObject);
-        mLockedObject = 0;
+        try {
+            nativeUnlockCanvasAndPost(mLockedObject, canvas);
+        } finally {
+            nativeRelease(mLockedObject);
+            mLockedObject = 0;
+        }
     }
 }

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.start:COMMENT
Method Modifier: public      
Comment:/**
 * Binds to the Face Unlock service.  Face Unlock will be started when the bind completes.  The
 * Face Unlock view is displayed to hide the backup lock while the service is starting up.
 * Called on the UI thread.
 */

@@ -9,15 +9,15 @@
     }
     if (!mBoundToService) {
         Log.d(TAG, "Binding to Face Unlock service for user=" + mLockPatternUtils.getCurrentUser());
-        mContext.bindServiceAsUser(new Intent(IFaceLockInterface.class.getName()), mConnection, Context.BIND_AUTO_CREATE, new UserHandle(mLockPatternUtils.getCurrentUser()));
+        mContext.bindServiceAsUser(new Intent(IFaceLockInterface.class.getName()).setPackage(FACE_LOCK_PACKAGE), mConnection, Context.BIND_AUTO_CREATE, new UserHandle(mLockPatternUtils.getCurrentUser()));
         mBoundToService = true;
     } else {
         Log.w(TAG, "Attempt to bind to Face Unlock when already bound");

Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visit:COMMENT
Method Modifier: public      
Comment:/* Visits the class header. */

@@ -1,11 +1,6 @@
 {
     // This class might be being renamed.
     name = mClassName;
-    // remove protected or private and set as public
-    if (Main.sOptions.generatePublicAccess) {
-        access = access & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED);
-        access |= Opcodes.ACC_PUBLIC;
-    }
     // remove final
     access = access & ~Opcodes.ACC_FINAL;
     // note: leave abstract classes as such

Find a functionally equivalent code:android.view.MotionEvent.axisFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets an axis by its symbolic name such as "AXIS_X" or an
 * equivalent numeric constant such as "42".
 *
 * @param symbolicName The symbolic name of the axis.
 * @return The axis or -1 if not found.
 * @see KeyEvent#keyCodeToString(int)
 */

@@ -1,11 +1,9 @@
 {
-    if (symbolicName == null) {
-        throw new IllegalArgumentException("symbolicName must not be null");
-    }
-    final int count = AXIS_SYMBOLIC_NAMES.size();
-    for (int i = 0; i < count; i++) {
-        if (symbolicName.equals(AXIS_SYMBOLIC_NAMES.valueAt(i))) {
-            return i;
+    if (symbolicName.startsWith(LABEL_PREFIX)) {
+        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
+        int axis = nativeAxisFromString(symbolicName);
+        if (axis >= 0) {
+            return axis;
         }
     }
     try {

Find a functionally equivalent code:android.webkit.WebSyncManager.sync:COMMENT
Method Modifier: public      
Comment:/**
 * sync() forces sync manager to sync now
 */

@@ -1,11 +1,2 @@
 {
-    if (DebugFlags.WEB_SYNC_MANAGER) {
-        Log.v(LOGTAG, "*** WebSyncManager sync ***");
-    }
-    if (mHandler == null) {
-        return;
-    }
-    mHandler.removeMessages(SYNC_MESSAGE);
-    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
-    mHandler.sendMessageDelayed(msg, SYNC_NOW_INTERVAL);
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.getPropertyFunction:COMMENT
Method Modifier: private     
Comment:/**
 * Determine the setter or getter function using the JavaBeans convention of setFoo or
 * getFoo for a property named 'foo'. This function figures out what the name of the
 * function should be and uses reflection to find the Method with that name on the
 * target object.
 *
 * @param targetClass The class to search for the method
 * @param prefix "set" or "get", depending on whether we need a setter or getter.
 * @param valueType The type of the parameter (in the case of a setter). This type
 * is derived from the values set on this PropertyValuesHolder. This type is used as
 * a first guess at the parameter type, but we check for methods with several different
 * types to avoid problems with slight mis-matches between supplied values and actual
 * value types used on the setter.
 * @return Method the method associated with mPropertyName.
 */

@@ -12,33 +12,35 @@
     } else {
         args = new Class[1];
         Class[] typeVariants;
-        if (mValueType.equals(Float.class)) {
+        if (valueType.equals(Float.class)) {
             typeVariants = FLOAT_VARIANTS;
-        } else if (mValueType.equals(Integer.class)) {
+        } else if (valueType.equals(Integer.class)) {
             typeVariants = INTEGER_VARIANTS;
-        } else if (mValueType.equals(Double.class)) {
+        } else if (valueType.equals(Double.class)) {
             typeVariants = DOUBLE_VARIANTS;
         } else {
             typeVariants = new Class[1];
-            typeVariants[0] = mValueType;
+            typeVariants[0] = valueType;
         }
         for (Class typeVariant : typeVariants) {
             args[0] = typeVariant;
             try {
                 returnVal = targetClass.getMethod(methodName, args);
-                // change the value type to suit
-                mValueType = typeVariant;
+                if (mConverter == null) {
+                    // change the value type to suit
+                    mValueType = typeVariant;
+                }
                 return returnVal;
             } catch (NoSuchMethodException e) {
             // Swallow the error and keep trying other variants
@@ -36,42 +38,44 @@
     // If we got here, then no appropriate function was found
     }
     if (returnVal == null) {
-        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + mValueType + " not found on target class " + targetClass);
+        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + valueType + " not found on target class " + targetClass);
     }
     return returnVal;
 }

Find a functionally equivalent code:android.media.SubtitleTrack.show:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -3,9 +3,12 @@
         return;
     }
     mVisible = true;
-    getRenderingWidget().setVisible(true);
+    RenderingWidget renderingWidget = getRenderingWidget();
+    if (renderingWidget != null) {
+        renderingWidget.setVisible(true);
+    }
     if (mTimeProvider != null) {
         mTimeProvider.scheduleUpdate(this);
     }

Find a functionally equivalent code:android.hardware.Camera.setPreviewDisplay:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets the {@link Surface} to be used for live preview.
 * Either a surface or surface texture is necessary for preview, and
 * preview is necessary to take pictures.  The same surface can be re-set
 * without harm.  Setting a preview surface will un-set any preview surface
 * texture that was set via {@link #setPreviewTexture}.
 *
 * <p>The {@link SurfaceHolder} must already contain a surface when this
 * method is called.  If you are using {@link android.view.SurfaceView},
 * you will need to register a {@link SurfaceHolder.Callback} with
 * {@link SurfaceHolder#addCallback(SurfaceHolder.Callback)} and wait for
 * {@link SurfaceHolder.Callback#surfaceCreated(SurfaceHolder)} before
 * calling setPreviewDisplay() or starting preview.
 *
 * <p>This method must be called before {@link #startPreview()}.  The
 * one exception is that if the preview surface is not set (or set to null)
 * before startPreview() is called, then this method may be called once
 * with a non-null parameter to set the preview surface.  (This allows
 * camera setup and surface creation to happen in parallel, saving time.)
 * The preview surface may not otherwise change while preview is running.
 *
 * @param holder containing the Surface on which to place the preview,
 * or null to remove the preview surface
 * @throws IOException if the method fails (for example, if the surface
 * is unavailable or unsuitable).
 */

@@ -1,7 +1,7 @@
 {
     if (holder != null) {
-        setPreviewDisplay(holder.getSurface());
+        setPreviewSurface(holder.getSurface());
     } else {
-        setPreviewDisplay((Surface) null);
+        setPreviewSurface((Surface) null);
     }
 }

Find a functionally equivalent code:android.widget.CalendarView.getSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the background color for the selected week.
 *
 * @return The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

@@ -1,3 +1,3 @@
 {
-    return mSelectedWeekBackgroundColor;
+    return mDelegate.getSelectedWeekBackgroundColor();
 }

Find a functionally equivalent code:android.util.Patterns.concatGroups:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Convenience method to take all of the non-null matching groups in a
 * regex Matcher and return them as a concatenated string.
 *
 * @param matcher      The Matcher object from which grouped text will
 * be extracted
 *
 * @return             A String comprising all of the non-null matched
 * groups concatenated together
 */

@@ -3,9 +3,8 @@
     final int numGroups = matcher.groupCount();
     for (int i = 1; i <= numGroups; i++) {
         String s = matcher.group(i);
-        System.err.println("Group(" + i + ") : " + s);
         if (s != null) {
             b.append(s);
         }

Find a functionally equivalent code:android.os.PowerManager.WakeLock.setWorkSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */

@@ -18,24 +18,24 @@
         }
         if (changed && mHeld) {
             try {
-                mService.updateWakeLockWorkSource(mToken, mWorkSource);
+                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
             } catch (RemoteException e) {
             }
         }

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.setSealed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets if this instance is sealed.
 *
 * @param sealed Whether is sealed.
 *
 * @hide
 */

@@ -1,9 +1,11 @@
 {
     super.setSealed(sealed);
-    List<AccessibilityRecord> records = mRecords;
-    final int recordCount = records.size();
-    for (int i = 0; i < recordCount; i++) {
-        AccessibilityRecord record = records.get(i);
-        record.setSealed(sealed);
+    final List<AccessibilityRecord> records = mRecords;
+    if (records != null) {
+        final int recordCount = records.size();
+        for (int i = 0; i < recordCount; i++) {
+            AccessibilityRecord record = records.get(i);
+            record.setSealed(sealed);
+        }
     }
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.preloadClasses:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Performs Zygote process initialization. Loads and initializes
 * commonly used classes.
 *
 * Most classes only cause a few hundred bytes to be allocated, but
 * a few will allocate a dozen Kbytes (in one case, 500+K).
 */

@@ -43,48 +43,50 @@
                     count++;
                 } catch (ClassNotFoundException e) {
                     Log.w(TAG, "Class not found for preloading: " + line);
+                } catch (UnsatisfiedLinkError e) {
+                    Log.w(TAG, "Problem preloading " + line + ": " + e);
                 } catch (Throwable t) {
                     Log.e(TAG, "Error preloading " + line + ".", t);
                     if (t instanceof Error) {

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientRadius:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the radius of the gradient. The radius is honored only when the
 * gradient type is set to {@link #RADIAL_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradientRadius The radius of the gradient in pixels
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

@@ -1,5 +1,5 @@
 {
-    mGradientState.setGradientRadius(gradientRadius);
-    mRectIsDirty = true;
+    mGradientState.setGradientRadius(gradientRadius, TypedValue.COMPLEX_UNIT_PX);
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.graphics.Matrix.preConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified matrix.
 * M' = M * other
 */

@@ -1,3 +1,4 @@
 {
-    return native_preConcat(native_instance, other.native_instance);
+    native_preConcat(native_instance, other.native_instance);
+    return true;
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the state of this instance.
 */

@@ -4,24 +4,30 @@
     mParentNodeId = ROOT_NODE_ID;
     mLabelForId = ROOT_NODE_ID;
     mLabeledById = ROOT_NODE_ID;
-    mWindowId = UNDEFINED;
-    mConnectionId = UNDEFINED;
+    mWindowId = UNDEFINED_ITEM_ID;
+    mConnectionId = UNDEFINED_CONNECTION_ID;
+    mMaxTextLength = -1;
     mMovementGranularities = 0;
-    mChildNodeIds.clear();
+    if (mChildNodeIds != null) {
+        mChildNodeIds.clear();
+    }
     mBoundsInParent.set(0, 0, 0, 0);
     mBoundsInScreen.set(0, 0, 0, 0);
     mBooleanProperties = 0;
     mPackageName = null;
     mClassName = null;
     mText = null;
+    mError = null;
     mContentDescription = null;
     mViewIdResourceName = null;
-    mActions = 0;
-    mTextSelectionStart = UNDEFINED;
-    mTextSelectionEnd = UNDEFINED;
+    if (mActions != null) {
+        mActions.clear();
+    }
+    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
+    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
     mInputType = InputType.TYPE_NULL;
     mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
     if (mExtras != null) {

Find a functionally equivalent code:android.content.pm.ApplicationInfo.loadDefaultIcon:COMMENT
<android.content.pm.ApplicationInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */


Find a functionally equivalent code:android.text.Layout.getLineMax:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent, but excluding trailing whitespace.
 */

@@ -1,5 +1,5 @@
 {
     float margin = getParagraphLeadingMargin(line);
     float signedExtent = getLineExtent(line, false);
-    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
+    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
 }

Find a functionally equivalent code:android.net.wifi.WifiManager.requestBatchedScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Request a batched scan for access points.  To end your requested batched scan,
 * call stopBatchedScan with the same Settings.
 *
 * If there are mulitple requests for batched scans, the more demanding settings will
 * take precidence.
 *
 * @param requested {@link BatchedScanSettings} the scan settings requested.
 * @return false on known error
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return mService.requestBatchedScan(requested, new Binder());
+        return mService.requestBatchedScan(requested, new Binder(), null);
     } catch (RemoteException e) {
         return false;
     }

Find a functionally equivalent code:android.graphics.ColorMatrix.setConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Set this colormatrix to the concatenation of the two specified
 * colormatrices, such that the resulting colormatrix has the same effect
 * as applying matB and then applying matA. It is legal for either matA or
 * matB to be the same colormatrix as this.
 */

@@ -1,5 +1,5 @@
 {
-    float[] tmp = null;
+    float[] tmp;
     if (matA == this || matB == this) {
         tmp = new float[20];
     } else {

Find a functionally equivalent code:android.os.Parcel.writeArrayMapInternal:COMMENT
Method Modifier: 
Comment:/* package */

@@ -10,19 +10,22 @@
         here.fillInStackTrace();
         Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
     }
+    int startPos;
     for (int i = 0; i < N; i++) {
         if (DEBUG_ARRAY_MAP)
-            Log.d(TAG, "  Write #" + i + ": key=0x" + (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
-        writeValue(val.keyAt(i));
+            startPos = dataPosition();
+        writeString(val.keyAt(i));
         writeValue(val.valueAt(i));
+        if (DEBUG_ARRAY_MAP)
+            Log.d(TAG, "  Write #" + i + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
     }
 }

Find a functionally equivalent code:android.view.ViewGroup.dispatchDraw:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

@@ -1,15 +1,16 @@
 {
-    final int count = mChildrenCount;
+    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
+    final int childrenCount = mChildrenCount;
     final View[] children = mChildren;
     int flags = mGroupFlags;
     if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
         final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
         final boolean buildCache = !isHardwareAccelerated();
-        for (int i = 0; i < count; i++) {
+        for (int i = 0; i < childrenCount; i++) {
             final View child = children[i];
             if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                 final LayoutParams params = child.getLayoutParams();
-                attachLayoutAnimationParameters(child, params, i, count);
+                attachLayoutAnimationParameters(child, params, i, childrenCount);
                 bindLayoutAnimation(child);
                 if (cache) {
                     child.setDrawingCacheEnabled(true);
@@ -33,42 +34,43 @@
             mAnimationListener.onAnimationStart(controller.getAnimation());
         }
     }
-    int saveCount = 0;
+    int clipSaveCount = 0;
     final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
     if (clipToPadding) {
-        saveCount = canvas.save();
+        clipSaveCount = canvas.save();
         canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
     }
     // We will draw our child's animation, let's reset the flag
@@ -44,64 +45,65 @@
     mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
     boolean more = false;
     final long drawingTime = getDrawingTime();
-    if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
-        for (int i = 0; i < count; i++) {
-            final View child = children[i];
-            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
-                more |= drawChild(canvas, child, drawingTime);
-            }
-        }
-    } else {
-        for (int i = 0; i < count; i++) {
-            final View child = children[getChildDrawingOrder(count, i)];
-            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
-                more |= drawChild(canvas, child, drawingTime);
-            }
+    if (usingRenderNodeProperties)
+        canvas.insertReorderBarrier();
+    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
+    // draw reordering internally
+    final ArrayList<View> preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList();
+    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
+    for (int i = 0; i < childrenCount; i++) {
+        int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
+        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
+        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
+            more |= drawChild(canvas, child, drawingTime);
         }
     }
+    if (preorderedList != null)
+        preorderedList.clear();
     // Draw any disappearing views that have animations
     if (mDisappearingChildren != null) {
         final ArrayList<View> disappearingChildren = mDisappearingChildren;
@@ -69,79 +70,82 @@
             more |= drawChild(canvas, child, drawingTime);
         }
     }
+    if (usingRenderNodeProperties)
+        canvas.insertInorderBarrier();
     if (debugDraw()) {
         onDebugDraw(canvas);
     }
     if (clipToPadding) {
-        canvas.restoreToCount(saveCount);
+        canvas.restoreToCount(clipSaveCount);
     }
     // mGroupFlags might have been updated by drawChild()
     flags = mGroupFlags;

Find a functionally equivalent code:android.media.AmrInputStream.GsmAmrEncoderNew:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:android.hardware.SystemSensorManager.requestTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,7 +1,7 @@
 {
     if (sensor == null)
         throw new IllegalArgumentException("sensor cannot be null");
-    if (Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT)
+    if (sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT)
         return false;
     synchronized (mTriggerListeners) {
         TriggerEventQueue queue = mTriggerListeners.get(listener);

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readMapXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashMap from an InputStream containing XML.  The stream can
 * previously have been written by writeMapXml().
 *
 * @param in The InputStream from which to read.
 *
 * @return HashMap The resulting map.
 *
 * @see #readListXml
 * @see #readValueXml
 * @see #readThisMapXml
 * #see #writeMapXml
 */

@@ -1,5 +1,5 @@
 {
     XmlPullParser parser = Xml.newPullParser();
     parser.setInput(in, null);
-    return (HashMap) readValueXml(parser, new String[1]);
+    return (HashMap<String, ?>) readValueXml(parser, new String[1]);
 }

Find a functionally equivalent code:android.view.Window.setSoftInputMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specify an explicit soft input mode to use for the window, as per
 * {@link WindowManager.LayoutParams#softInputMode
 * WindowManager.LayoutParams.softInputMode}.  Providing anything besides
 * "unspecified" here will override the input mode the window would
 * normally retrieve from its theme.
 */

@@ -6,12 +6,10 @@
     } else {
         mHasSoftInputMode = false;
     }
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.transition.TransitionSet.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,7 +1,7 @@
 {
-    super.resume();
+    super.resume(sceneRoot);
     int numTransitions = mTransitions.size();
     for (int i = 0; i < numTransitions; ++i) {
-        mTransitions.get(i).resume();
+        mTransitions.get(i).resume(sceneRoot);
     }
 }

Find a functionally equivalent code:android.print.PrintManager.addPrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds a listener for observing the state of print jobs.
 *
 * @param listener The listener to add.
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return;
+    }
     if (mPrintJobStateChangeListeners == null) {
         mPrintJobStateChangeListeners = new ArrayMap<PrintJobStateChangeListener, PrintJobStateChangeListenerWrapper>();
     }

Find a functionally equivalent code:android.widget.TextView.onPreDraw:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -35,41 +35,40 @@
     if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
         mEditor.startSelectionActionMode();
     }
-    getViewTreeObserver().removeOnPreDrawListener(this);
-    mPreDrawRegistered = false;
+    unregisterForPreDraw();
     return true;
 }

Find a functionally equivalent code:androidx.media.filterfw.decoder.CpuVideoTrackDecoder.findDecoderCodec:COMMENT
Method Modifier: private     static      
Comment:/**
 * Looks for a codec with the specified requirements.
 *
 * The set of codecs will be filtered down to those that meet the following requirements:
 * <ol>
 * <li>The codec is a decoder.</li>
 * <li>The codec can decode a video of the specified format.</li>
 * <li>The codec can decode to one of the specified color formats.</li>
 * </ol>
 * If multiple codecs are found, the one with the preferred color-format is taken. Color format
 * preference is determined by the order of their appearance in the color format array.
 *
 * @param format The format the codec must decode.
 * @param requiredColorFormats Array of target color spaces ordered by preference.
 * @return A codec that meets the requirements, or null if no such codec was found.
 */

@@ -28,33 +28,37 @@
         return null;
     } else {
         String bestCodec = candidateCodecs.firstEntry().getValue();
-        return MediaCodec.createByCodecName(bestCodec);
+        try {
+            return MediaCodec.createByCodecName(bestCodec);
+        } catch (IOException e) {
+            throw new RuntimeException("failed to create codec for " + bestCodec, e);
+        }
     }
 }

Find a functionally equivalent code:android.appwidget.AppWidgetManager.getInstalledProviders:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of the AppWidget providers that are currently installed.
 */

@@ -1,3 +1,6 @@
 {
-    return getInstalledProviders(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);
+    if (mService == null) {
+        return Collections.emptyList();
+    }
+    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null);
 }

Find a functionally equivalent code:android.widget.DatePicker.getYear:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected year.
 */

@@ -1,3 +1,3 @@
 {
-    return mCurrentDate.get(Calendar.YEAR);
+    return mDelegate.getYear();
 }

Find a functionally equivalent code:android.os.Parcel.writeValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class="caution">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */

@@ -61,69 +61,66 @@
     } else if (v instanceof Parcelable[]) {
         writeInt(VAL_PARCELABLEARRAY);
         writeParcelableArray((Parcelable[]) v, 0);
-    } else if (v instanceof Object[]) {
-        writeInt(VAL_OBJECTARRAY);
-        writeArray((Object[]) v);
     } else if (v instanceof int[]) {
         writeInt(VAL_INTARRAY);
         writeIntArray((int[]) v);
@@ -73,83 +70,97 @@
     } else if (v instanceof Byte) {
         writeInt(VAL_BYTE);
         writeInt((Byte) v);
-    } else if (v instanceof Serializable) {
-        // Must be last
-        writeInt(VAL_SERIALIZABLE);
-        writeSerializable((Serializable) v);
+    } else if (v instanceof PersistableBundle) {
+        writeInt(VAL_PERSISTABLEBUNDLE);
+        writePersistableBundle((PersistableBundle) v);
+    } else if (v instanceof Size) {
+        writeInt(VAL_SIZE);
+        writeSize((Size) v);
+    } else if (v instanceof SizeF) {
+        writeInt(VAL_SIZEF);
+        writeSizeF((SizeF) v);
     } else {
-        throw new RuntimeException("Parcel: unable to marshal value " + v);
+        Class<?> clazz = v.getClass();
+        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
+            // Only pure Object[] are written here, Other arrays of non-primitive types are
+            // handled by serialization as this does not record the component type.
+            writeInt(VAL_OBJECTARRAY);
+            writeArray((Object[]) v);
+        } else if (v instanceof Serializable) {
+            // Must be last
+            writeInt(VAL_SERIALIZABLE);
+            writeSerializable((Serializable) v);
+        } else {
+            throw new RuntimeException("Parcel: unable to marshal value " + v);
+        }
     }
 }

Find a functionally equivalent code:android.media.MediaCodecInfo.getCapabilitiesForType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Enumerates the capabilities of the codec component. Since a single
 * component can support data of a variety of types, the type has to be
 * specified to yield a meaningful result.
 * @param type The MIME type to query
 */

@@ -1,3 +1,8 @@
 {
-    return MediaCodecList.getCodecCapabilities(mIndex, type);
+    CodecCapabilities caps = mCaps.get(type);
+    if (caps == null) {
+        throw new IllegalArgumentException("codec does not support type");
+    }
+    // clone writable object
+    return caps.dup();
 }

Find a functionally equivalent code:android.hardware.SystemSensorManager.SensorEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

@@ -1,8 +1,11 @@
 {
     final Sensor sensor = sHandleToSensor.get(handle);
-    SensorEvent t = mSensorsEvents.get(handle);
+    SensorEvent t = null;
+    synchronized (mSensorsEvents) {
+        t = mSensorsEvents.get(handle);
+    }
     if (t == null) {
-        Log.e(TAG, "Error: Sensor Event is null for Sensor: " + sensor);
+        // the queue waiting to be delivered. Ignore.
         return;
     }
     // Copy from the values array.
@@ -10,33 +13,23 @@
     t.timestamp = timestamp;
     t.accuracy = inAccuracy;
     t.sensor = sensor;
-    switch(t.sensor.getType()) {
-        // Only report accuracy for sensors that support it.
-        case Sensor.TYPE_MAGNETIC_FIELD:
-        case Sensor.TYPE_ORIENTATION:
-            // call onAccuracyChanged() only if the value changes
-            final int accuracy = mSensorAccuracies.get(handle);
-            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
-                mSensorAccuracies.put(handle, t.accuracy);
-                mListener.onAccuracyChanged(t.sensor, t.accuracy);
-            }
-            break;
-        default:
-            // For other sensors, just report the accuracy once
-            if (mFirstEvent.get(handle) == false) {
-                mFirstEvent.put(handle, true);
-                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
-            }
-            break;
+    // call onAccuracyChanged() only if the value changes
+    final int accuracy = mSensorAccuracies.get(handle);
+    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
+        mSensorAccuracies.put(handle, t.accuracy);
+        mListener.onAccuracyChanged(t.sensor, t.accuracy);
     }
     mListener.onSensorChanged(t);
 }

Find a functionally equivalent code:android.util.Spline.createMonotoneCubicSpline:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a monotone cubic spline from a given set of control points.
 *
 * The spline is guaranteed to pass through each control point exactly.
 * Moreover, assuming the control points are monotonic (Y is non-decreasing or
 * non-increasing) then the interpolated values will also be monotonic.
 *
 * This function uses the Fritsch-Carlson method for computing the spline parameters.
 * http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 *
 * @param x The X component of the control points, strictly increasing.
 * @param y The Y component of the control points, monotonic.
 * @return
 *
 * @throws IllegalArgumentException if the X or Y arrays are null, have
 * different lengths or have fewer than 2 values.
 * @throws IllegalArgumentException if the control points are not monotonic.
 */

@@ -1,44 +1,3 @@
 {
-    if (x == null || y == null || x.length != y.length || x.length < 2) {
-        throw new IllegalArgumentException("There must be at least two control " + "points and the arrays must be of equal length.");
-    }
-    final int n = x.length;
-    // could optimize this out
-    float[] d = new float[n - 1];
-    float[] m = new float[n];
-    // Compute slopes of secant lines between successive points.
-    for (int i = 0; i < n - 1; i++) {
-        float h = x[i + 1] - x[i];
-        if (h <= 0f) {
-            throw new IllegalArgumentException("The control points must all " + "have strictly increasing X values.");
-        }
-        d[i] = (y[i + 1] - y[i]) / h;
-    }
-    // Initialize the tangents as the average of the secants.
-    m[0] = d[0];
-    for (int i = 1; i < n - 1; i++) {
-        m[i] = (d[i - 1] + d[i]) * 0.5f;
-    }
-    m[n - 1] = d[n - 2];
-    // Update the tangents to preserve monotonicity.
-    for (int i = 0; i < n - 1; i++) {
-        if (d[i] == 0f) {
-            // successive Y values are equal
-            m[i] = 0f;
-            m[i + 1] = 0f;
-        } else {
-            float a = m[i] / d[i];
-            float b = m[i + 1] / d[i];
-            if (a < 0f || b < 0f) {
-                throw new IllegalArgumentException("The control points must have " + "monotonic Y values.");
-            }
-            float h = FloatMath.hypot(a, b);
-            if (h > 9f) {
-                float t = 3f / h;
-                m[i] = t * a * d[i];
-                m[i + 1] = t * b * d[i];
-            }
-        }
-    }
-    return new Spline(x, y, m);
+    return new MonotoneCubicSpline(x, y);
 }

Find a functionally equivalent code:android.content.res.XmlBlock.nativeGetName:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:android.animation.PropertyValuesHolder.setKeyframes:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Keyframes.
 *
 * @param values One or more values that the animation will animate between.
 */

@@ -5,9 +5,9 @@
     for (int i = 0; i < numKeyframes; ++i) {
         keyframes[i] = (Keyframe) values[i];
     }
-    mKeyframeSet = new KeyframeSet(keyframes);
+    mKeyframes = new KeyframeSet(keyframes);
 }

Find a functionally equivalent code:android.view.textservice.TextInfo.getText:COMMENT
Method Modifier: public      
Comment:/**
 * @return the text which is an input of a text service
 */

@@ -1,3 +1,6 @@
 {
-    return mText;
+    if (mCharSequence == null) {
+        return null;
+    }
+    return mCharSequence.toString();
 }

Find a functionally equivalent code:android.widget.DatePicker.getCalendarView:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link CalendarView}.
 *
 * @return The calendar view.
 * @see #getCalendarViewShown()
 */

@@ -1,3 +1,3 @@
 {
-    return mCalendarView;
+    return mDelegate.getCalendarView();
 }

Find a functionally equivalent code:android.app.WallpaperManager.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Remove any currently set wallpaper, reverting to the system's built-in
 * wallpaper. On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

@@ -1,3 +1,3 @@
 {
-    setResource(com.android.internal.R.drawable.default_wallpaper);
+    setStream(openDefaultWallpaper(mContext));
 }

Find a functionally equivalent code:android.app.Instrumentation.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Terminate instrumentation of the application.  This will cause the
 * application process to exit, removing this instrumentation from the next
 * time the application is started.
 *
 * @param resultCode Overall success/failure of instrumentation.
 * @param results Any results to send back to the code that started the
 * instrumentation.
 */

@@ -3,8 +3,11 @@
         endPerformanceSnapshot();
     }
     if (mPerfMetrics != null) {
+        if (results == null) {
+            results = new Bundle();
+        }
         results.putAll(mPerfMetrics);
     }
     if (mUiAutomation != null) {

Find a functionally equivalent code:android.service.dreams.DreamService.setLowProfile:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets View.SYSTEM_UI_FLAG_LOW_PROFILE on the content view.
 *
 * @param lowProfile True to set View.SYSTEM_UI_FLAG_LOW_PROFILE
 * @hide There is no reason to have this -- dreams can set this flag
 * on their own content view, and from there can actually do the
 * correct interactions with it (seeing when it is cleared etc).
 */

@@ -1,5 +1,7 @@
 {
-    mLowProfile = lowProfile;
-    int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
-    applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
+    if (mLowProfile != lowProfile) {
+        mLowProfile = lowProfile;
+        int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
+        applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
+    }
 }

Find a functionally equivalent code:android.os.StrictMode.conditionallyCheckInstanceCounts:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -3,9 +3,11 @@
     if (policy.classInstanceLimit.size() == 0) {
         return;
     }
-    Runtime.getRuntime().gc();
+    System.gc();
+    System.runFinalization();
+    System.gc();
     // Note: classInstanceLimit is immutable, so this is lock-free
     for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
         Class klass = entry.getKey();

Find a functionally equivalent code:android.graphics.Canvas.drawRect:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified Rect using the specified paint. The rectangle will
 * be filled or framed based on the Style in the paint.
 *
 * @param left   The left side of the rectangle to be drawn
 * @param top    The top side of the rectangle to be drawn
 * @param right  The right side of the rectangle to be drawn
 * @param bottom The bottom side of the rectangle to be drawn
 * @param paint  The paint used to draw the rect
 */

@@ -1,3 +1,3 @@
 {
-    native_drawRect(mNativeCanvas, left, top, right, bottom, paint.mNativePaint);
+    native_drawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.mNativePaint);
 }

Find a functionally equivalent code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

@@ -7,11 +7,14 @@
     if (quality < 0 || quality > 100) {
         throw new IllegalArgumentException("quality must be 0..100");
     }
-    return nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
+    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
+    boolean result = nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
+    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
+    return result;
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRingerModeChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRingerModeChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the ringer mode changes.
 * @param state the current ringer state, as defined in
 * {@link AudioManager#RINGER_MODE_CHANGED_ACTION}
 */


Find a functionally equivalent code:android.util.ArrayMap.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

@@ -5,12 +5,12 @@
         if (DEBUG)
             Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
         freeArrays(mHashes, mArray, mSize);
-        mHashes = ContainerHelpers.EMPTY_INTS;
-        mArray = ContainerHelpers.EMPTY_OBJECTS;
+        mHashes = EmptyArray.INT;
+        mArray = EmptyArray.OBJECT;
         mSize = 0;
     } else {
         if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {

Find a functionally equivalent code:android.hardware.location.GeofenceHardware.addGeofence:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a circular geofence which is monitored by subsystems in the hardware.
 *
 * <p> When the device detects that is has entered, exited or is uncertain
 * about the area specified by the geofence, the given callback will be called.
 *
 * <p> If this call returns true, it means that the geofence has been sent to the hardware.
 * {@link GeofenceHardwareCallback#onGeofenceAdd} will be called with the result of the
 * add call from the hardware. The {@link GeofenceHardwareCallback#onGeofenceAdd} will be
 * called with the following parameters when a transition event occurs.
 * <ul>
 * <li> The geofence Id
 * <li> The location object indicating the last known location.
 * <li> The transition associated with the geofence. One of
 * {@link #GEOFENCE_ENTERED}, {@link #GEOFENCE_EXITED}, {@link #GEOFENCE_UNCERTAIN}
 * <li> The timestamp when the geofence transition occured.
 * <li> The monitoring type ({@link #MONITORING_TYPE_GPS_HARDWARE} is one such example)
 * that was used.
 * </ul>
 *
 * <p> The geofence will be monitored by the subsystem specified by monitoring_type parameter.
 * The application does not need to hold a wakelock when the monitoring
 * is being done by the underlying hardware subsystem. If the same geofence Id is being
 * monitored by two different monitoring systems, the same id can be used for both calls, as
 * long as the same callback object is used.
 *
 * <p> Requires {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission when
 * {@link #MONITORING_TYPE_GPS_HARDWARE} is used.
 *
 * <p> Requires {@link android.Manifest.permission#LOCATION_HARDWARE} permission to access
 * geofencing in hardware.
 *
 * <p>This API should not be called directly by the app developers. A higher level api
 * which abstracts the hardware should be used instead. All the checks are done by the higher
 * level public API. Any needed locking should be handled by the higher level API.
 *
 * <p> Create a geofence request object using the methods in {@link GeofenceHardwareRequest} to
 * set all the characteristics of the geofence. Use the created GeofenceHardwareRequest object
 * in this call.
 *
 * @param geofenceId The id associated with the geofence.
 * @param monitoringType The type of the hardware subsystem that should be used
 * to monitor the geofence.
 * @param geofenceRequest The {@link GeofenceHardwareRequest} object associated with the
 * geofence.
 * @param callback {@link GeofenceHardwareCallback} that will be use to notify the
 * transition.
 * @return true when the geofence is successfully sent to the hardware for addition.
 * @throws IllegalArgumentException when the geofence request type is not supported.
 */

@@ -1,7 +1,7 @@
 {
     try {
         if (geofenceRequest.getType() == GeofenceHardwareRequest.GEOFENCE_TYPE_CIRCLE) {
-            return mService.addCircularFence(geofenceId, monitoringType, geofenceRequest.getLatitude(), geofenceRequest.getLongitude(), geofenceRequest.getRadius(), geofenceRequest.getLastTransition(), geofenceRequest.getMonitorTransitions(), geofenceRequest.getNotificationResponsiveness(), geofenceRequest.getUnknownTimer(), getCallbackWrapper(callback));
+            return mService.addCircularFence(monitoringType, new GeofenceHardwareRequestParcelable(geofenceId, geofenceRequest), getCallbackWrapper(callback));
         } else {
             throw new IllegalArgumentException("Geofence Request type not supported");
         }

Find a functionally equivalent code:android.media.MediaFocusControl.discardAudioFocusOwner:COMMENT
Method Modifier: protected   
Comment:/**
 * Discard the current audio focus owner.
 * Notify top of audio focus stack that it lost focus (regardless of possibility to reassign
 * focus), remove it from the stack, and clear the remote control display.
 */

@@ -5,14 +5,10 @@
             final FocusRequester exFocusOwner = mFocusStack.pop();
             exFocusOwner.handleFocusLoss(AudioManager.AUDIOFOCUS_LOSS);
             exFocusOwner.release();
-            // clear RCD
-            synchronized (mRCStack) {
-                clearRemoteControlDisplay_syncAfRcs();
-            }
         }
     }
 }

Find a functionally equivalent code:android.animation.AnimatorSet.Builder.after:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to start when the animation supplied in this method call ends.
 *
 * @param anim The animation whose end will cause the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method to play.
 */

@@ -1,4 +1,5 @@
 {
+    mReversible = false;
     Node node = mNodeMap.get(anim);
     if (node == null) {
         node = new Node(anim);

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.MyMethodVisitor.visitMethodInsn:COMMENT
Method Modifier: public      
Comment:// instruction that invokes a method

@@ -3,6 +3,10 @@
     considerName(owner);
     // desc is the method's descriptor (see Type).
     considerDesc(desc);
+    // Check if method needs to replaced by a call to a different method.
+    if (ReplaceMethodCallsAdapter.isReplacementNeeded(owner, name, desc)) {
+        mReplaceMethodCallClasses.add(mOwnerClass);
+    }
 }

Find a functionally equivalent code:android.provider.Settings.Secure.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (LOCATION_MODE.equals(name)) {
+        // TODO: once b/10491283 fixed, remove this hack
+        return setLocationModeForUser(resolver, Integer.parseInt(value), userHandle);
+    }
     if (MOVED_TO_GLOBAL.contains(name)) {
         Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System" + " to android.provider.Settings.Global");
         return Global.putStringForUser(resolver, name, value, userHandle);

Find a functionally equivalent code:android.app.NotificationManager.notifyAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -10,17 +10,19 @@
     }
     if (localLOGV)
         Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
+    Notification stripped = notification.clone();
+    Builder.stripForDelivery(stripped);
     try {
-        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, user.getIdentifier());
+        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, user.getIdentifier());
         if (id != idOut[0]) {
             Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
         }

Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setPlaybackType:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether playback associated with this route is "local"
 * ({@link RouteInfo#PLAYBACK_TYPE_LOCAL}) or "remote"
 * ({@link RouteInfo#PLAYBACK_TYPE_REMOTE}).
 * @param type
 */

@@ -1,6 +1,6 @@
 {
     if (mPlaybackType != type) {
         mPlaybackType = type;
-        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE, type);
+        configureSessionVolume();
     }
 }

Find a functionally equivalent code:android.widget.DatePicker.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 */

@@ -1,3 +1,3 @@
 {
-    return mCalendarView.getMinDate();
+    return mDelegate.getMinDate().getTimeInMillis();
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setObjectValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Objects.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

@@ -1,4 +1,7 @@
 {
     mValueType = values[0].getClass();
-    mKeyframeSet = KeyframeSet.ofObject(values);
+    mKeyframes = KeyframeSet.ofObject(values);
+    if (mEvaluator != null) {
+        mKeyframes.setEvaluator(mEvaluator);
+    }
 }

Find a functionally equivalent code:android.graphics.Canvas.restoreToCount:COMMENT
<android.graphics.Canvas: void restoreToCount(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Efficient way to pop any calls to save() that happened after the save
 * count reached saveCount. It is an error for saveCount to be less than 1.
 *
 * Example:
 * int count = canvas.save();
 * ... // more calls potentially to save()
 * canvas.restoreToCount(count);
 * // now the canvas is back in the same state it was before the initial
 * // call to save().
 *
 * @param saveCount The save level to restore to.
 */

@@ -1 +1,3 @@
-
+{
+    native_restoreToCount(mNativeCanvasWrapper, saveCount);
+}

Find a functionally equivalent code:android.bluetooth.BluetoothSocket.flush:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -1,4 +1,6 @@
 {
+    if (mSocketOS == null)
+        throw new IOException("flush is called on null OutputStream");
     if (VDBG)
         Log.d(TAG, "flush: " + mSocketOS);
     mSocketOS.flush();

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmGenerator.generate:COMMENT
Method Modifier: public      
Comment:/**
 * Generates the final JAR
 */

@@ -20,25 +20,33 @@
         String name = classNameToEntryPath(transformName(cr.getClassName()));
         all.put(name, b);
     }
+    for (Entry<String, InputStream> entry : mCopyFiles.entrySet()) {
+        try {
+            byte[] b = inputStreamToByteArray(entry.getValue());
+            all.put(entry.getKey(), b);
+        } catch (IOException e) {
+        // Ignore.
+        }
+    }
     mLog.info("# deps classes: %d", mDeps.size());
     mLog.info("# keep classes: %d", mKeep.size());
     mLog.info("# renamed     : %d", mRenameCount);

Find a functionally equivalent code:android.media.AudioManager.querySoundEffectsEnabled:COMMENT
Method Modifier: private     
Comment:/**
 * Settings has an in memory cache, so this is fast.
 */

@@ -1,3 +1,3 @@
 {
-    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
+    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
 }

Find a functionally equivalent code:android.service.dreams.DreamService.dispatchGenericMotionEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,8 +1,8 @@
 {
     if (!mInteractive) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on genericMotionEvent");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on genericMotionEvent");
+        wakeUp();
         return true;
     }
     return mWindow.superDispatchGenericMotionEvent(event);

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.appendRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Appends an {@link AccessibilityRecord} to the end of event records.
 *
 * @param record The record to append.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */

@@ -1,4 +1,7 @@
 {
     enforceNotSealed();
+    if (mRecords == null) {
+        mRecords = new ArrayList<AccessibilityRecord>();
+    }
     mRecords.add(record);
 }

Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.release:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Releases the relevant data.
 */

@@ -1,5 +1,5 @@
 {
-    mHandler.mQueryContext = null;
+    mHandler.mContext = null;
     mHandler.mQueryUri = null;
     mHandler.mCallerInfo = null;
     mHandler = null;

Find a functionally equivalent code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

@@ -1,29 +1,44 @@
 {
+    if (mAnimationType == ANIM_DEFAULT) {
+        return null;
+    }
     Bundle b = new Bundle();
     if (mPackageName != null) {
         b.putString(KEY_PACKAGE_NAME, mPackageName);
     }
+    b.putInt(KEY_ANIM_TYPE, mAnimationType);
     switch(mAnimationType) {
         case ANIM_CUSTOM:
-            b.putInt(KEY_ANIM_TYPE, mAnimationType);
             b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
             b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
-            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
+            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
             break;
         case ANIM_SCALE_UP:
-            b.putInt(KEY_ANIM_TYPE, mAnimationType);
             b.putInt(KEY_ANIM_START_X, mStartX);
             b.putInt(KEY_ANIM_START_Y, mStartY);
-            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
-            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
+            b.putInt(KEY_ANIM_WIDTH, mWidth);
+            b.putInt(KEY_ANIM_HEIGHT, mHeight);
             break;
         case ANIM_THUMBNAIL_SCALE_UP:
         case ANIM_THUMBNAIL_SCALE_DOWN:
-            b.putInt(KEY_ANIM_TYPE, mAnimationType);
+        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
+        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
             b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
             b.putInt(KEY_ANIM_START_X, mStartX);
             b.putInt(KEY_ANIM_START_Y, mStartY);
-            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
+            b.putInt(KEY_ANIM_WIDTH, mWidth);
+            b.putInt(KEY_ANIM_HEIGHT, mHeight);
+            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
+            break;
+        case ANIM_SCENE_TRANSITION:
+            if (mTransitionReceiver != null) {
+                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
+            }
+            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
+            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
+            b.putParcelable(KEY_RESULT_DATA, mResultData);
+            b.putInt(KEY_RESULT_CODE, mResultCode);
+            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
             break;
     }
     return b;

Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPurgeActiveSync:COMMENT
Method Modifier: public      
Comment:// @SmallTest

@@ -4,11 +4,12 @@
     MockContentResolver mockResolver = new MockContentResolver();
     SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
     long time0 = 1000;
-    long historyId = engine.insertStartSyncEvent(account, 0, SyncOperation.REASON_PERIODIC, authority, time0, SyncStorageEngine.SOURCE_LOCAL, false, /* initialization */
-    null);
+    SyncOperation op = new SyncOperation(account, 0, SyncOperation.REASON_PERIODIC, SyncStorageEngine.SOURCE_LOCAL, authority, Bundle.EMPTY, time0, 0, /* flex*/
+    0, 0, true);
+    long historyId = engine.insertStartSyncEvent(op, time0);
     long time1 = time0 + SyncStorageEngine.MILLIS_IN_4WEEKS * 2;
     engine.stopSyncEvent(historyId, time1 - time0, "yay", 0, 0);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.prepareAddWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Preflight adding a window to the system.
 *
 * Currently enforces that three window types are singletons:
 * <ul>
 * <li>STATUS_BAR_TYPE</li>
 * <li>KEYGUARD_TYPE</li>
 * </ul>
 *
 * @param win The window to be added
 * @param attrs Information about the window to be added
 *
 * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons,
 * WindowManagerImpl.ADD_MULTIPLE_SINGLETON
 */

@@ -9,14 +9,15 @@
             }
             mStatusBar = win;
             mStatusBarController.setWindow(win);
+            mKeyguardDelegate.hideScrim();
             break;
         case TYPE_NAVIGATION_BAR:
             mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
@@ -31,42 +32,37 @@
         case TYPE_STATUS_BAR_SUB_PANEL:
             mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE, "PhoneWindowManager");
             break;
-        case TYPE_KEYGUARD:
-            if (mKeyguard != null) {
-                return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;
-            }
-            mKeyguard = win;
-            break;
         case TYPE_KEYGUARD_SCRIM:
             if (mKeyguardScrim != null) {
                 return WindowManagerGlobal.ADD_MULTIPLE_SINGLETON;

Find a functionally equivalent code:android.view.ViewPropertyAnimator.setValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method handles setting the property values directly in the View object's fields.
 * propertyConstant tells it which property should be set, value is the value to set
 * the property to.
 *
 * @param propertyConstant The property to be set
 * @param value The value to set the property to
 */

@@ -1,56 +1,43 @@
 {
     final View.TransformationInfo info = mView.mTransformationInfo;
-    final DisplayList displayList = mView.mDisplayList;
+    final RenderNode renderNode = mView.mRenderNode;
     switch(propertyConstant) {
         case TRANSLATION_X:
-            info.mTranslationX = value;
-            if (displayList != null)
-                displayList.setTranslationX(value);
+            renderNode.setTranslationX(value);
             break;
         case TRANSLATION_Y:
-            info.mTranslationY = value;
-            if (displayList != null)
-                displayList.setTranslationY(value);
+            renderNode.setTranslationY(value);
             break;
+        case TRANSLATION_Z:
+            renderNode.setTranslationZ(value);
+            break;
         case ROTATION:
-            info.mRotation = value;
-            if (displayList != null)
-                displayList.setRotation(value);
+            renderNode.setRotation(value);
             break;
         case ROTATION_X:
-            info.mRotationX = value;
-            if (displayList != null)
-                displayList.setRotationX(value);
+            renderNode.setRotationX(value);
             break;
         case ROTATION_Y:
-            info.mRotationY = value;
-            if (displayList != null)
-                displayList.setRotationY(value);
+            renderNode.setRotationY(value);
             break;
         case SCALE_X:
-            info.mScaleX = value;
-            if (displayList != null)
-                displayList.setScaleX(value);
+            renderNode.setScaleX(value);
             break;
         case SCALE_Y:
-            info.mScaleY = value;
-            if (displayList != null)
-                displayList.setScaleY(value);
+            renderNode.setScaleY(value);
             break;
         case X:
-            info.mTranslationX = value - mView.mLeft;
-            if (displayList != null)
-                displayList.setTranslationX(value - mView.mLeft);
+            renderNode.setTranslationX(value - mView.mLeft);
             break;
         case Y:
-            info.mTranslationY = value - mView.mTop;
-            if (displayList != null)
-                displayList.setTranslationY(value - mView.mTop);
+            renderNode.setTranslationY(value - mView.mTop);
+            break;
+        case Z:
+            renderNode.setTranslationZ(value - renderNode.getElevation());
             break;
         case ALPHA:
             info.mAlpha = value;
-            if (displayList != null)
-                displayList.setAlpha(value);
+            renderNode.setAlpha(value);
             break;
     }
 }

Find a functionally equivalent code:android.content.RestrictionEntry.getSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current selected state for an entry of type {@link #TYPE_BOOLEAN}.
 * @return the current selected state of the entry.
 */

@@ -1,3 +1,3 @@
 {
-    return Boolean.parseBoolean(currentValue);
+    return Boolean.parseBoolean(mCurrentValue);
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findClassesDerivingFrom:COMMENT
Method Modifier: 
Comment:/**
 * Checks all the classes defined in the JarClassName instance and uses BCEL to
 * determine if they are derived from the given FQCN super class name.
 * Inserts the super class and all the class objects found in the map.
 */

@@ -1,4 +1,7 @@
 {
+    if (mExcludedClasses.contains(getOuterClassName(super_name))) {
+        return;
+    }
     findClass(super_name, zipClasses, inOutFound);
     for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
         String className = entry.getKey();

Find a functionally equivalent code:android.database.sqlite.SQLiteDatabase.deleteDatabase:COMMENT
Method Modifier: public      static      
Comment:/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */

@@ -10,24 +10,26 @@
     File dir = file.getParentFile();
     if (dir != null) {
         final String prefix = file.getName() + "-mj";
-        final FileFilter filter = new FileFilter() {
+        File[] files = dir.listFiles(new FileFilter() {
 
             @Override
             public boolean accept(File candidate) {
                 return candidate.getName().startsWith(prefix);
             }
-        };
-        for (File masterJournal : dir.listFiles(filter)) {
-            deleted |= masterJournal.delete();
+        });
+        if (files != null) {
+            for (File masterJournal : files) {
+                deleted |= masterJournal.delete();
+            }
         }
     }
     return deleted;

Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.getProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */

@@ -7,12 +7,18 @@
     } else if (profile == BluetoothProfile.A2DP) {
         BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
         return true;
+    } else if (profile == BluetoothProfile.A2DP_SINK) {
+        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
+        return true;
+    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
+        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
+        return true;
     } else if (profile == BluetoothProfile.INPUT_DEVICE) {
         BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
         return true;
@@ -19,24 +25,33 @@
     } else if (profile == BluetoothProfile.MAP) {
         BluetoothMap map = new BluetoothMap(context, listener);
         return true;
+    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
+        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
+        return true;
     } else {
         return false;
     }

Find a functionally equivalent code:android.os.BatteryStats.getScreenBrightnessTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the screen has been on with
 * the given brightness
 *
 * {@hide}
 */


Find a functionally equivalent code:android.graphics.Matrix.postConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified matrix.
 * M' = other * M
 */

@@ -1,3 +1,4 @@
 {
-    return native_postConcat(native_instance, other.native_instance);
+    native_postConcat(native_instance, other.native_instance);
+    return true;
 }

Find a functionally equivalent code:android.os.Bundle.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Removes all elements from the mapping of this Bundle.
 */

@@ -1,6 +1,5 @@
 {
-    unparcel();
-    mMap.clear();
+    super.clear();
     mHasFds = false;
     mFdsKnown = true;
 }

Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.processStillUp:COMMENT
Method Modifier: private     
Comment:/**
 * Determine if a given package is still running.
 *
 * @param packageName {@link String} package to look for
 * @return True if package is running, false otherwise.
 */

@@ -1,18 +1,18 @@
 {
-    try {
-        PackageInfo packageInfo = mPackageManager.getPackageInfo(packageName, 0);
-        String processName = packageInfo.applicationInfo.processName;
-        List<RunningAppProcessInfo> runningApps = mActivityManager.getRunningAppProcesses();
-        for (RunningAppProcessInfo app : runningApps) {
-            if (app.processName.equalsIgnoreCase(processName)) {
+    String processName = getProcessName(packageName);
+    List<RunningAppProcessInfo> runningApps = mActivityManager.getRunningAppProcesses();
+    for (RunningAppProcessInfo app : runningApps) {
+        if (app.processName.equalsIgnoreCase(processName)) {
+            Log.d(TAG, "Found process " + app.processName);
+            return true;
+        }
+        for (String relatedPackage : app.pkgList) {
+            if (relatedPackage.equalsIgnoreCase(processName)) {
                 Log.d(TAG, "Found process " + app.processName);
                 return true;
             }
         }
-        Log.d(TAG, "Failed to find process " + processName + " with package name " + packageName);
-    } catch (NameNotFoundException e) {
-        Log.w(TAG, "Failed to find package " + packageName);
-        return false;
     }
+    Log.d(TAG, "Failed to find process " + processName + " with package name " + packageName);
     return false;
 }

Find a functionally equivalent code:android.os.Bundle.getClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Return the ClassLoader currently associated with this Bundle.
 */

@@ -1,3 +1,3 @@
 {
-    return mClassLoader;
+    return super.getClassLoader();
 }

Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.getStatusCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return mStatusCode;
+    return mResolvedStatusCode;
 }

Find a functionally equivalent code:android.graphics.Typeface.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a typeface object that best matches the specified existing
 * typeface and the specified Style. Use this call if you want to pick a new
 * style from the same family of an existing typeface object. If family is
 * null, this selects from the default font's family.
 *
 * @param family May be null. The name of the existing type face.
 * @param style  The style (normal, bold, italic) of the typeface.
 * e.g. NORMAL, BOLD, ITALIC, BOLD_ITALIC
 * @return The best matching typeface.
 */

@@ -1,5 +1,8 @@
 {
-    int ni = 0;
+    if (style < 0 || style > 3) {
+        style = 0;
+    }
+    long ni = 0;
     if (family != null) {
         // Return early if we're asked for the same face/style
         if (family.mStyle == style) {

Find a functionally equivalent code:android.media.AudioManager.dispatchMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a simulated key event for a media button.
 * To simulate a key press, you must first send a KeyEvent built with a
 * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the current media key event consumer which registered with
 * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 */

@@ -1,8 +1,4 @@
 {
-    IAudioService service = getService();
-    try {
-        service.dispatchMediaKeyEvent(keyEvent);
-    } catch (RemoteException e) {
-        Log.e(TAG, "dispatchMediaKeyEvent threw exception ", e);
-    }
+    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
+    helper.sendMediaButtonEvent(keyEvent, false);
 }

Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Associates all the metadata that has been set since the MetadataEditor instance was
 * created with {@link RemoteControlClient#editMetadata(boolean)}, or since
 * {@link #clear()} was called, with the RemoteControlClient. Once "applied",
 * this MetadataEditor cannot be reused to edit the RemoteControlClient's metadata.
 */

@@ -4,9 +4,11 @@
         return;
     }
     synchronized (mCacheLock) {
+        // Still build the old metadata so when creating a new editor
+        // you get the expected values.
         // assign the edited data
         mMetadata = new Bundle(mEditorMetadata);
         // add the information about editable keys
@@ -13,27 +15,24 @@
         }
         mOriginalArtwork = mEditorArtwork;
         mEditorArtwork = null;
-        if (mMetadataChanged & mArtworkChanged) {
-            // send to remote control display if conditions are met
-            sendMetadataWithArtwork_syncCacheLock(null, 0, 0);
-        } else if (mMetadataChanged) {
-            // send to remote control display if conditions are met
-            sendMetadata_syncCacheLock(null);
-        } else if (mArtworkChanged) {
-            // send to remote control display if conditions are met
-            sendArtwork_syncCacheLock(null, 0, 0);
+        // USE_SESSIONS
+        if (mSession != null && mMetadataBuilder != null) {
+            mMediaMetadata = mMetadataBuilder.build();
+            mSession.setMetadata(mMediaMetadata);
         }
         mApplied = true;
     }

Find a functionally equivalent code:android.text.TextUtils.getLayoutDirectionFromLocale:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */

@@ -1,6 +1,6 @@
 {
     if (locale != null && !locale.equals(Locale.ROOT)) {
-        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
+        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
         if (scriptSubtag == null)
             return getLayoutDirectionFromFirstChar(locale);
         if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {

Find a functionally equivalent code:android.print.PrintManager.getEnabledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of enabled print services.
 *
 * @return The enabled service list or an empty list.
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return Collections.emptyList();
+    }
     try {
         List<PrintServiceInfo> enabledServices = mService.getEnabledPrintServices(mUserId);
         if (enabledServices != null) {

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.runSelectLoop:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Runs the zygote process's select loop. Accepts new connections as
 * they happen, and reads commands from connections one spawn-request's
 * worth at a time.
 *
 * @throws MethodAndArgsCaller in a child process when a main() should
 * be executed.
 */

@@ -31,39 +31,39 @@
         if (index < 0) {
             throw new RuntimeException("Error in select()");
         } else if (index == 0) {
-            ZygoteConnection newPeer = acceptCommandPeer();
+            ZygoteConnection newPeer = acceptCommandPeer(abiList);
             peers.add(newPeer);
-            fds.add(newPeer.getFileDesciptor());
+            fds.add(newPeer.getFileDescriptor());
         } else {
             boolean done;
             done = peers.get(index).runOnce();

Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.verifyUnlock:COMMENT
<com.android.keyguard.KeyguardViewBase: void verifyUnlock()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Verify that the user can get past the keyguard securely.  This is called,
 * for example, when the phone disables the keyguard but then wants to launch
 * something else that requires secure access.
 *
 * The result will be propogated back via {@link KeyguardViewCallback#keyguardDone(boolean)}
 */

@@ -1 +1,16 @@
-
+{
+    SecurityMode securityMode = mSecurityContainer.getSecurityMode();
+    if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
+        if (mViewMediatorCallback != null) {
+            mViewMediatorCallback.keyguardDone(true);
+        }
+    } else if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
+        // can only verify unlock when in pattern/password mode
+        if (mViewMediatorCallback != null) {
+            mViewMediatorCallback.keyguardDone(false);
+        }
+    } else {
+        // otherwise, go to the unlock screen, see if they can verify it
+        mSecurityContainer.verifyUnlock();
+    }
+}

Find a functionally equivalent code:android.widget.QuickContactBadge.setImageToDefault:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the contact photo to the default state.
 */

@@ -1,6 +1,6 @@
 {
     if (mDefaultAvatar == null) {
-        mDefaultAvatar = getResources().getDrawable(R.drawable.ic_contact_picture);
+        mDefaultAvatar = mContext.getDrawable(R.drawable.ic_contact_picture);
     }
     setImageDrawable(mDefaultAvatar);
 }

Find a functionally equivalent code:android.provider.Browser.requestAllIcons:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Request all icons from the database.  This call must either be called
 * in the main thread or have had Looper.prepare() invoked in the calling
 * thread.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param  cr The ContentResolver used to access the database.
 * @param  where Clause to be used to limit the query from the database.
 * Must be an allowable string to be passed into a database query.
 * @param  listener IconListener that gets the icons once they are
 * retrieved.
 */

@@ -1,3 +1,3 @@
 {
-    WebIconDatabase.getInstance().bulkRequestIconForPageUrl(cr, where, listener);
+// Do nothing: this is no longer used.
 }

Find a functionally equivalent code:android.media.AudioService.getMasterStreamType:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#getMasterStreamType()
 */

@@ -1,7 +1,3 @@
 {
-    if (mVoiceCapable) {
-        return AudioSystem.STREAM_RING;
-    } else {
-        return AudioSystem.STREAM_MUSIC;
-    }
+    return mStreamVolumeAlias[AudioSystem.STREAM_SYSTEM];
 }

Find a functionally equivalent code:android.provider.DocumentsProvider.openTypedAssetFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */

@@ -1,8 +1,9 @@
 {
-    if (opts != null && opts.containsKey(EXTRA_THUMBNAIL_SIZE)) {
-        final Point sizeHint = opts.getParcelable(EXTRA_THUMBNAIL_SIZE);
-        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
+    enforceTree(uri);
+    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
+        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
+        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
     } else {
-        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
+        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
     }
 }

Find a functionally equivalent code:android.widget.GridLayout.measureChildrenWithMargins:COMMENT
Method Modifier: private     
Comment:// Note: padding has already been removed from the supplied specs

@@ -6,11 +6,13 @@
         LayoutParams lp = getLayoutParams(c);
         if (firstPass) {
             measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
+            mHorizontalAxis.recordOriginalMeasurement(i);
+            mVerticalAxis.recordOriginalMeasurement(i);
         } else {
             boolean horizontal = (mOrientation == HORIZONTAL);
             Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;

Find a functionally equivalent code:android.graphics.Matrix.preSkew:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified skew.
 * M' = M * K(kx, ky, px, py)
 */

@@ -1,3 +1,4 @@
 {
-    return native_preSkew(native_instance, kx, ky, px, py);
+    native_preSkew(native_instance, kx, ky, px, py);
+    return true;
 }

Find a functionally equivalent code:android.util.LongSparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -6,23 +6,12 @@
     if (mGarbage && mSize >= mKeys.length) {
         gc();
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        int n = ArrayUtils.idealLongArraySize(pos + 1);
-        long[] nkeys = new long[n];
-        Object[] nvalues = new Object[n];
-        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-        mKeys = nkeys;
-        mValues = nvalues;
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:android.content.res.ColorStateList.createFromXml:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */

@@ -1,5 +1,5 @@
 {
-    AttributeSet attrs = Xml.asAttributeSet(parser);
+    final AttributeSet attrs = Xml.asAttributeSet(parser);
     int type;
     while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
     }

Find a functionally equivalent code:android.media.RemoteControlClient.setTransportControlFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the flags for the media transport control buttons that this client supports.
 * @param transportControlFlags A combination of the following flags:
 * {@link #FLAG_KEY_MEDIA_PREVIOUS},
 * {@link #FLAG_KEY_MEDIA_REWIND},
 * {@link #FLAG_KEY_MEDIA_PLAY},
 * {@link #FLAG_KEY_MEDIA_PLAY_PAUSE},
 * {@link #FLAG_KEY_MEDIA_PAUSE},
 * {@link #FLAG_KEY_MEDIA_STOP},
 * {@link #FLAG_KEY_MEDIA_FAST_FORWARD},
 * {@link #FLAG_KEY_MEDIA_NEXT},
 * {@link #FLAG_KEY_MEDIA_POSITION_UPDATE},
 * {@link #FLAG_KEY_MEDIA_RATING}.
 */

@@ -2,8 +2,13 @@
     synchronized (mCacheLock) {
         // store locally
         mTransportControlFlags = transportControlFlags;
-        // send to remote control display if conditions are met
-        sendTransportControlInfo_syncCacheLock(null);
+        // USE_SESSIONS
+        if (mSession != null) {
+            PlaybackState.Builder bob = new PlaybackState.Builder(mSessionPlaybackState);
+            bob.setActions(PlaybackState.getActionsFromRccControlFlags(transportControlFlags));
+            mSessionPlaybackState = bob.build();
+            mSession.setPlaybackState(mSessionPlaybackState);
+        }
     }
 }

Find a functionally equivalent code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

@@ -2,7 +2,8 @@
     NfcAdapter.CreateNdefMessageCallback ndefCallback;
     NfcAdapter.CreateBeamUrisCallback urisCallback;
     NdefMessage message;
+    Activity activity;
     Uri[] uris;
     int flags;
     synchronized (NfcActivityManager.this) {
@@ -13,18 +14,20 @@
         message = state.ndefMessage;
         uris = state.uris;
         flags = state.flags;
+        activity = state.activity;
     }
     // Make callbacks without lock
     if (ndefCallback != null) {
@@ -34,38 +36,46 @@
             }
         }
     }
+    if (uris != null && uris.length > 0) {
+        for (Uri uri : uris) {
+            // Grant the NFC process permission to read these URIs
+            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        }
+    }
     return new BeamShareData(message, uris, flags);
 }

Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.setSelection:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation changes the selection position in the
 * current editable text.
 */

@@ -5,11 +5,11 @@
     if (content == null)
         return false;
     int len = content.length();
-    if (start > len || end > len) {
+    if (start > len || end > len || start < 0 || end < 0) {
         // anyway.
         return true;
     }

Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.addInternal:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Adds an item to the menu.  The other add methods funnel to this.
 */

@@ -1,6 +1,6 @@
 {
     final int ordering = getOrdering(categoryOrder);
-    final MenuItemImpl item = new MenuItemImpl(this, group, id, categoryOrder, ordering, title, mDefaultShowAsAction);
+    final MenuItemImpl item = createNewMenuItem(group, id, categoryOrder, ordering, title, mDefaultShowAsAction);
     if (mCurrentMenuInfo != null) {
         // Pass along the current menu info
         item.setMenuInfo(mCurrentMenuInfo);

Find a functionally equivalent code:android.os.BatteryStats.getPhoneSignalScanningTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been trying to
 * acquire a signal.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.preference.PreferenceFragment.setPreferenceScreen:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the root of the preference hierarchy that this fragment is showing.
 *
 * @param preferenceScreen The root {@link PreferenceScreen} of the preference hierarchy.
 */

@@ -1,5 +1,6 @@
 {
     if (mPreferenceManager.setPreferences(preferenceScreen) && preferenceScreen != null) {
+        onUnbindPreferences();
         mHavePrefs = true;
         if (mInitDone) {
             postBindPreferences();

Find a functionally equivalent code:javax.obex.ObexHelper.createHeader:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates the header part of OBEX packet based on the header provided.
 * TODO: Could use getHeaderList() to get the array of headers to include
 * and then use the high two bits to determine the the type of the object
 * and construct the byte array from that. This will make the size smaller.
 * @param head the header used to construct the byte array
 * @param nullOut <code>true</code> if the header should be set to
 * <code>null</code> once it is added to the array or
 * <code>false</code> if it should not be nulled out
 * @return the header of an OBEX packet
 */

@@ -43,48 +43,53 @@
             if (nullOut) {
                 headImpl.setHeader(HeaderSet.NAME, null);
             }
+        } else if (headImpl.getEmptyNameHeader()) {
+            out.write((byte) HeaderSet.NAME);
+            lengthArray[0] = (byte) 0x00;
+            lengthArray[1] = (byte) 0x03;
+            out.write(lengthArray);
         }
         // Type Header
         stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);

Find a functionally equivalent code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
<android.os.SystemClock: boolean setCurrentTimeMillis(long)>
Method Modifier: public      static      native      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

@@ -1 +1,15 @@
-
+{
+    IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);
+    IAlarmManager mgr = IAlarmManager.Stub.asInterface(b);
+    if (mgr == null) {
+        return false;
+    }
+    try {
+        return mgr.setTime(millis);
+    } catch (RemoteException e) {
+        Slog.e(TAG, "Unable to set RTC", e);
+    } catch (SecurityException e) {
+        Slog.e(TAG, "Unable to set RTC", e);
+    }
+    return false;
+}

Find a functionally equivalent code:android.os.ParcelFileDescriptor.dup:COMMENT
Method Modifier: public      
Comment:/**
 * Create a new ParcelFileDescriptor that is a dup of the existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */


Find a functionally equivalent code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      
Comment:/**
 * We have one child
 */

@@ -2,7 +2,9 @@
     synchronized (this) {
         if (mView == null) {
             mView = view;
+            mAttachInfo.mDisplayState = mDisplay.getState();
+            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
             mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
             mFallbackEventHandler.setView(view);
             mWindowAttributes.copyFrom(attrs);
@@ -19,24 +21,30 @@
                     mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                 }
             }
+            // Compute surface insets required to draw at specified Z value.
+            // TODO: Use real shadow insets for a constant max Z.
+            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
+            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
             CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
             mTranslator = compatibilityInfo.getTranslator();
             mDisplayAdjustments.setActivityToken(attrs.token);
@@ -82,87 +88,94 @@
             }
             mPendingOverscanInsets.set(0, 0, 0, 0);
             mPendingContentInsets.set(mAttachInfo.mContentInsets);
+            mPendingStableInsets.set(mAttachInfo.mStableInsets);
             mPendingVisibleInsets.set(0, 0, 0, 0);
             if (DEBUG_LAYOUT)
                 Log.v(TAG, "Added window " + mWindow);
@@ -134,141 +141,148 @@
             }
             // Set up the input pipeline.
             CharSequence counterSuffix = attrs.getTitle();
-            InputStage syntheticInputStage = new SyntheticInputStage();
-            InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage);
+            mSyntheticInputStage = new SyntheticInputStage();
+            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
             InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
             InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
             InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);

Find a functionally equivalent code:android.media.AudioManager.unregisterMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,8 +1,4 @@
 {
-    IAudioService service = getService();
-    try {
-        service.unregisterMediaButtonIntent(pi);
-    } catch (RemoteException e) {
-        Log.e(TAG, "Dead object in unregisterMediaButtonIntent" + e);
-    }
+    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
+    helper.removeMediaButtonListener(pi);
 }

Find a functionally equivalent code:android.view.animation.Transformation.postCompose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #compose(Transformation)} but does this.postConcat(t) of
 * the transformation matrix.
 * @hide
 */

@@ -1,4 +1,7 @@
 {
     mAlpha *= t.getAlpha();
     mMatrix.postConcat(t.getMatrix());
+    if (t.mHasClipRect) {
+        setClipRect(t.getClipRect());
+    }
 }

Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onSeekComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,5 +1,7 @@
 {
     synchronized (this) {
+        mStopped = false;
+        mSeeking = true;
         scheduleNotification(NOTIFY_SEEK, 0);
     }
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserSwitchComplete:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitchComplete(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user change is complete.
 */


Find a functionally equivalent code:android.graphics.Paint.setMaskFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the maskfilter object.
 * <p />
 * Pass null to clear any previous maskfilter.
 * As a convenience, the parameter passed is also returned.
 *
 * @param maskfilter May be null. The maskfilter to be installed in the
 * paint
 * @return           maskfilter
 */

@@ -1,5 +1,5 @@
 {
-    int maskfilterNative = 0;
+    long maskfilterNative = 0;
     if (maskfilter != null) {
         maskfilterNative = maskfilter.native_instance;
     }

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.clear:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Clears the state of this instance.
 *
 * @hide
 */

@@ -6,13 +6,15 @@
     mContentChangeTypes = 0;
     mPackageName = null;
     mEventTime = 0;
-    while (!mRecords.isEmpty()) {
-        AccessibilityRecord record = mRecords.remove(0);
-        record.recycle();
+    if (mRecords != null) {
+        while (!mRecords.isEmpty()) {
+            AccessibilityRecord record = mRecords.remove(0);
+            record.recycle();
+        }
     }
 }

Find a functionally equivalent code:android.animation.ObjectAnimator.ofPropertyValuesHolder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Constructs and returns an ObjectAnimator that animates between the sets of values specified
 * in <code>PropertyValueHolder</code> objects. This variant should be used when animating
 * several properties at once with the same ObjectAnimator, since PropertyValuesHolder allows
 * you to associate a set of animation values with a property name.
 *
 * @param target The object whose property is to be animated. Depending on how the
 * PropertyValuesObjects were constructed, the target object should either have the {@link
 * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
 * PropertyValuesHOlder objects were created with property names) the target object should have
 * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
 * the property passed in as the <code>propertyName</code> parameter for each of the
 * PropertyValuesHolder objects.
 * @param values A set of PropertyValuesHolder objects whose values will be animated between
 * over time.
 * @return An ObjectAnimator object that is set up to animate between the given values.
 */

@@ -1,6 +1,6 @@
 {
     ObjectAnimator anim = new ObjectAnimator();
-    anim.mTarget = target;
+    anim.setTarget(target);
     anim.setValues(values);
     return anim;
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onTimeChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onTimeChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called once per minute or when the time changes.
 */


Find a functionally equivalent code:android.app.admin.DevicePolicyManager.isAdminActive:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */

@@ -1,10 +1,3 @@
 {
-    if (mService != null) {
-        try {
-            return mService.isAdminActive(who, UserHandle.myUserId());
-        } catch (RemoteException e) {
-            Log.w(TAG, "Failed talking with device policy service", e);
-        }
-    }
-    return false;
+    return isAdminActiveAsUser(who, UserHandle.myUserId());
 }

Find a functionally equivalent code:android.graphics.Bitmap.getPixel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Color} at the specified location. Throws an exception
 * if x or y are out of bounds (negative or >= to the width or height
 * respectively). The returned color is a non-premultiplied ARGB value.
 *
 * @param x    The x coordinate (0...width-1) of the pixel to return
 * @param y    The y coordinate (0...height-1) of the pixel to return
 * @return     The argb {@link Color} at the specified coordinate
 * @throws IllegalArgumentException if x, y exceed the bitmap's bounds
 */

@@ -1,5 +1,5 @@
 {
     checkRecycled("Can't call getPixel() on a recycled bitmap");
     checkPixelAccess(x, y);
-    return nativeGetPixel(mNativeBitmap, x, y, mIsPremultiplied);
+    return nativeGetPixel(mNativeBitmap, x, y);
 }

Find a functionally equivalent code:android.content.res.AssetManager.loadThemeAttributeValue:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:com.android.systemui.statusbar.StatusBarIconView.set:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the set succeeded.
 */

@@ -13,19 +13,19 @@
         setImageLevel(icon.iconLevel);
     }
     if (!numberEquals) {
-        if (icon.number > 0 && mContext.getResources().getBoolean(R.bool.config_statusBarShowNumber)) {
+        if (icon.number > 0 && getContext().getResources().getBoolean(R.bool.config_statusBarShowNumber)) {
             if (mNumberBackground == null) {
                 mNumberBackground = getContext().getResources().getDrawable(R.drawable.ic_notification_overlay);
             }

Find a functionally equivalent code:android.media.AudioTrack.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

@@ -1,7 +1,12 @@
 {
     // NB: this section is only valid with PCM data.
     // To update when supporting compressed formats
-    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
+    int frameSizeInBytes;
+    if (AudioFormat.isEncodingLinearPcm(mAudioFormat)) {
+        frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
+    } else {
+        frameSizeInBytes = 1;
+    }
     if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
         throw new IllegalArgumentException("Invalid audio buffer size.");
     }

Find a functionally equivalent code:android.net.NetworkStats.findIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Find first stats index that matches the requested parameters.
 */

@@ -1,6 +1,6 @@
 {
     for (int i = 0; i < size; i++) {
-        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
+        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
             return i;
         }
     }

Find a functionally equivalent code:android.view.Window.setFormat:COMMENT
Method Modifier: public      
Comment:/**
 * Set the format of window, as per the PixelFormat types.  This overrides
 * the default format that is selected by the Window based on its
 * window decorations.
 *
 * @param format The new window format (see PixelFormat).  Use
 * PixelFormat.UNKNOWN to allow the Window to select
 * the format.
 *
 * @see PixelFormat
 */

@@ -7,13 +7,11 @@
         attrs.format = mDefaultWindowFormat;
         mHaveWindowFormat = false;
     }
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.animation.ObjectAnimator.initAnimation:COMMENT
Method Modifier: 
Comment:/**
 * This function is called immediately before processing the first animation
 * frame of an animation. If there is a nonzero <code>startDelay</code>, the
 * function is called after that delay ends.
 * It takes care of the final initialization steps for the
 * animation. This includes setting mEvaluator, if the user has not yet
 * set it up, and the setter/getter methods, if the user did not supply
 * them.
 *
 * <p>Overriders of this method should call the superclass method to cause
 * internal mechanisms to be set up correctly.</p>
 */

@@ -2,10 +2,13 @@
     if (!mInitialized) {
         // mValueType may change due to setter/getter setup; do this before calling super.init(),
         // which uses mValueType to set up the default type evaluator.
-        int numValues = mValues.length;
-        for (int i = 0; i < numValues; ++i) {
-            mValues[i].setupSetterAndGetter(mTarget);
+        final Object target = getTarget();
+        if (target != null) {
+            final int numValues = mValues.length;
+            for (int i = 0; i < numValues; ++i) {
+                mValues[i].setupSetterAndGetter(target);
+            }
         }
         super.initAnimation();
     }

Find a functionally equivalent code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

@@ -11,37 +11,39 @@
                 BitmapFactory.decodeFile(STAGE_FILE, options);
                 if (DEBUG)
                     Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
-                // How much does the image differ from our preference?  The threshold
-                // here is set to accept any image larger than our target, because
-                // scaling down is acceptable; but to reject images that are deemed
-                // "too small" to scale up attractively.  The value 1.33 is just barely
-                // too low to pass Nexus 1 or Droid wallpapers for use on a Xoom, but
-                // will pass anything relatively larger.
-                double widthRatio = mDesiredMinWidth / options.outWidth;
-                double heightRatio = mDesiredMinHeight / options.outHeight;
-                if (widthRatio > 0 && widthRatio < 1.33 && heightRatio > 0 && heightRatio < 1.33) {
-                    // sufficiently close to our resolution; go ahead and use it
-                    if (DEBUG)
-                        Slog.d(TAG, "wallpaper dimension match; using");
-                    f.renameTo(new File(WALLPAPER_IMAGE));
+                if (REJECT_OUTSIZED_RESTORE) {
+                    // We accept any wallpaper that is at least as wide as our preference
+                    // (i.e. wide enough to fill the screen), and is within a comfortable
+                    // factor of the target height, to avoid significant clipping/scaling/
+                    // letterboxing.
+                    final double heightRatio = mDesiredMinHeight / options.outHeight;
+                    if (options.outWidth < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
+                        // Not wide enough for the screen, or too short/tall to be a good fit
+                        // for the height of the screen, broken image file, or the system's
+                        // desires for wallpaper size are in a bad state.  Probably one of the
+                        // first two.
+                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
+                        f.delete();
+                        return;
+                    }
+                }
+                // We passed the acceptable-dimensions test (if any), so we're going to
+                // use the restored image.
                 // TODO: spin a service to copy the restored image to sd/usb storage,
                 // since it does not exist anywhere other than the private wallpaper
                 // file.
-                } else {
-                    if (DEBUG)
-                        Slog.d(TAG, "dimensions too far off: wr=" + widthRatio + " hr=" + heightRatio);
-                    f.delete();
-                }
+                Slog.d(TAG, "Applying restored wallpaper image.");
+                f.renameTo(new File(WALLPAPER_IMAGE));
             }
         } else if (key.equals(WALLPAPER_INFO_KEY)) {
             // XML file containing wallpaper info

Find a functionally equivalent code:com.android.mediaframeworktest.functional.CodecTest.playMediaSamples:COMMENT
Method Modifier: public      static      
Comment:// For each media file, forward twice and backward once, then play to the end

@@ -34,40 +34,40 @@
         waittime = duration - mMediaPlayer.getCurrentPosition();
         synchronized (onCompletion) {
             try {
-                onCompletion.wait(waittime + 2000);
+                onCompletion.wait(waittime + buffertime);
             } catch (Exception e) {
                 Log.v(TAG, "playMediaSamples are interrupted");
                 return false;

Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.testNoOp:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that a class not being modified still works.
 */

@@ -40,48 +40,55 @@
                 }
                 // Check that the native method does NOT have the new annotation
                 Method[] m = clazz2.getDeclaredMethods();
-                assertEquals("native_instance", m[2].getName());
-                assertTrue(Modifier.isNative(m[2].getModifiers()));
-                Annotation[] a = m[2].getAnnotations();
+                Method nativeInstanceMethod = null;
+                for (Method method : m) {
+                    if ("native_instance".equals(method.getName())) {
+                        nativeInstanceMethod = method;
+                        break;
+                    }
+                }
+                assertNotNull(nativeInstanceMethod);
+                assertTrue(Modifier.isNative(nativeInstanceMethod.getModifiers()));
+                Annotation[] a = nativeInstanceMethod.getAnnotations();
                 assertEquals(0, a.length);
             }
         };

Find a functionally equivalent code:android.app.Activity.getMenuInflater:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link MenuInflater} with this context.
 */

@@ -1,7 +1,7 @@
 {
     // Make sure that action views can get an appropriate theme.
     if (mMenuInflater == null) {
-        initActionBar();
+        initWindowDecorActionBar();
         if (mActionBar != null) {
             mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
         } else {

Find a functionally equivalent code:com.android.internal.util.AsyncChannel.disconnect:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Disconnect
 */

@@ -1,6 +1,7 @@
 {
     if ((mConnection != null) && (mSrcContext != null)) {
         mSrcContext.unbindService(mConnection);
+        mConnection = null;
     }
     try {
         // Send the DISCONNECTED, although it may not be received
@@ -14,22 +15,25 @@
     // Tell source we're disconnected.
     if (mSrcHandler != null) {
         replyDisconnected(STATUS_SUCCESSFUL);
+        mSrcHandler = null;
     }
     // Unlink only when bindService isn't used
     if (mConnection == null && mDstMessenger != null && mDeathMonitor != null) {
         mDstMessenger.getBinder().unlinkToDeath(mDeathMonitor, 0);
+        mDeathMonitor = null;
     }
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */

@@ -6,16 +6,20 @@
     parcel.writeLong(mLabelForId);
     parcel.writeLong(mLabeledById);
     parcel.writeInt(mConnectionId);
-    SparseLongArray childIds = mChildNodeIds;
-    final int childIdsSize = childIds.size();
-    parcel.writeInt(childIdsSize);
-    for (int i = 0; i < childIdsSize; i++) {
-        parcel.writeLong(childIds.valueAt(i));
+    final LongArray childIds = mChildNodeIds;
+    if (childIds == null) {
+        parcel.writeInt(0);
+    } else {
+        final int childIdsSize = childIds.size();
+        parcel.writeInt(childIdsSize);
+        for (int i = 0; i < childIdsSize; i++) {
+            parcel.writeLong(childIds.get(i));
+        }
     }
     parcel.writeInt(mBoundsInParent.top);
     parcel.writeInt(mBoundsInParent.bottom);
@@ -20,31 +24,57 @@
     parcel.writeInt(mBoundsInScreen.bottom);
     parcel.writeInt(mBoundsInScreen.left);
     parcel.writeInt(mBoundsInScreen.right);
-    parcel.writeInt(mActions);
+    if (mActions != null && !mActions.isEmpty()) {
+        final int actionCount = mActions.size();
+        parcel.writeInt(actionCount);
+        int defaultLegacyStandardActions = 0;
+        for (int i = 0; i < actionCount; i++) {
+            AccessibilityAction action = mActions.get(i);
+            if (isDefaultLegacyStandardAction(action)) {
+                defaultLegacyStandardActions |= action.getId();
+            }
+        }
+        parcel.writeInt(defaultLegacyStandardActions);
+        for (int i = 0; i < actionCount; i++) {
+            AccessibilityAction action = mActions.get(i);
+            if (!isDefaultLegacyStandardAction(action)) {
+                parcel.writeInt(action.getId());
+                parcel.writeCharSequence(action.getLabel());
+            }
+        }
+    } else {
+        parcel.writeInt(0);
+    }
+    parcel.writeInt(mMaxTextLength);
     parcel.writeInt(mMovementGranularities);
     parcel.writeInt(mBooleanProperties);
     parcel.writeCharSequence(mPackageName);
     parcel.writeCharSequence(mClassName);
     parcel.writeCharSequence(mText);
+    parcel.writeCharSequence(mError);
     parcel.writeCharSequence(mContentDescription);
     parcel.writeString(mViewIdResourceName);
     parcel.writeInt(mTextSelectionStart);
@@ -52,57 +78,84 @@
         parcel.writeInt(mCollectionInfo.getRowCount());
         parcel.writeInt(mCollectionInfo.getColumnCount());
         parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
+        parcel.writeInt(mCollectionInfo.getSelectionMode());
     } else {
         parcel.writeInt(0);
     }
@@ -62,67 +89,95 @@
         parcel.writeInt(mCollectionItemInfo.getRowIndex());
         parcel.writeInt(mCollectionItemInfo.getRowSpan());
         parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
+        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
     } else {
         parcel.writeInt(0);
     }

Find a functionally equivalent code:android.content.res.AssetManager.applyStyle:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:android.widget.CalendarView.setUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of a not focused month.
 *
 * @param color A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

@@ -1,12 +1,3 @@
 {
-    if (mUnfocusedMonthDateColor != color) {
-        mUnfocusedMonthDateColor = color;
-        final int childCount = mListView.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            WeekView weekView = (WeekView) mListView.getChildAt(i);
-            if (weekView.mHasUnfocusedDay) {
-                weekView.invalidate();
-            }
-        }
-    }
+    mDelegate.setUnfocusedMonthDateColor(color);
 }

Find a functionally equivalent code:android.widget.CalendarView.getSelectedDateVerticalBar:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable for the vertical bar shown at the beginning and at
 * the end of the selected date.
 *
 * @return The vertical bar drawable.
 */

@@ -1,3 +1,3 @@
 {
-    return mSelectedDateVerticalBar;
+    return mDelegate.getSelectedDateVerticalBar();
 }

Find a functionally equivalent code:android.graphics.pdf.PdfDocument.finishPage:COMMENT
Method Modifier: public      
Comment:/**
 * Finishes a started page. You should always finish the last started page.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * You should not finish the same page more than once.
 * </p>
 *
 * @param page The page. Cannot be null.
 *
 * @see #startPage(PageInfo)
 */

@@ -11,16 +11,16 @@
     }
     mPages.add(page.getInfo());
     mCurrentPage = null;
-    nativeAppendPage(mNativeDocument, page.mCanvas.mNativeCanvas);
+    nativeFinishPage(mNativeDocument);
     page.finish();
 }

Find a functionally equivalent code:com.android.internal.telephony.GsmAlphabet.gsm8BitUnpackedToString:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Convert a GSM alphabet string that's stored in 8-bit unpacked
 * format (as it often appears in SIM records) into a String
 *
 * Field may be padded with trailing 0xff's. The decode stops
 * at the first 0xff encountered.
 *
 * Additionally, in some country(ex. Korea), there are non-ASCII or MBCS characters.
 * If a character set is given, characters in data are treat as MBCS.
 */

@@ -30,45 +30,53 @@
             }
         } else {
             if (prevWasEscape) {
-                char shiftChar = shiftTableToChar.charAt(c);
+                char shiftChar = c < shiftTableToChar.length() ? shiftTableToChar.charAt(c) : ' ';
                 if (shiftChar == ' ') {
                     // display character from main table if not present in shift table
-                    ret.append(languageTableToChar.charAt(c));
+                    if (c < languageTableToChar.length()) {
+                        ret.append(languageTableToChar.charAt(c));
+                    } else {
+                        ret.append(' ');
+                    }
                 } else {
                     ret.append(shiftChar);
                 }
             } else {
                 if (!isMbcs || c < 0x80 || i + 1 >= offset + length) {
-                    ret.append(languageTableToChar.charAt(c));
+                    if (c < languageTableToChar.length()) {
+                        ret.append(languageTableToChar.charAt(c));
+                    } else {
+                        ret.append(' ');
+                    }
                 } else {
                     // isMbcs must be true. So both mbcsBuffer and charset are initialized.
                     mbcsBuffer.clear();

Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.handleNiNotification:COMMENT
Method Modifier: public      internal    
Comment:// Handles NI events from HAL

@@ -1,22 +1,11 @@
 {
     if (DEBUG)
-        Log.d(TAG, "handleNiNotification" + " notificationId: " + notif.notificationId + " requestorId: " + notif.requestorId + " text: " + notif.text);
-    // Notify and verify with immediate pop-up
-    if (notif.needNotify && notif.needVerify && mPopupImmediately) {
-        // Popup the dialog box now
-        openNiDialog(notif);
+        Log.d(TAG, "in handleNiNotification () :" + " notificationId: " + notif.notificationId + " requestorId: " + notif.requestorId + " text: " + notif.text + " mIsSuplEsEnabled" + getSuplEsEnabled() + " mIsLocationEnabled" + getLocationEnabled());
+    if (getSuplEsEnabled()) {
+        handleNiInEs(notif);
+    } else {
+        handleNi(notif);
     }
-    // Notify only, or delayed pop-up (change mPopupImmediately to FALSE)
-    if (notif.needNotify && !notif.needVerify || notif.needNotify && notif.needVerify && !mPopupImmediately) {
-        // Show the notification
-        // if mPopupImmediately == FALSE and needVerify == TRUE, a dialog will be opened
-        // when the user opens the notification message
-        setNiNotification(notif);
-    }
-    // ACCEPT cases: 1. Notify, no verify; 2. no notify, no verify; 3. privacy override.
-    if (notif.needNotify && !notif.needVerify || !notif.needNotify && !notif.needVerify || notif.privacyOverride) {
-        mLocationManager.sendNiResponse(notif.notificationId, GPS_NI_RESPONSE_ACCEPT);
-    }
 // ////////////////////////////////////////////////////////////////////////
 // A note about timeout
 // According to the protocol, in the need_notify and need_verify case,

Find a functionally equivalent code:android.media.MediaPlayer.addSubtitleSource:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -27,33 +27,33 @@
             }
             scanner.close();
             mOutOfBandSubtitleTracks.add(track);
-            track.onData(contents, true, /* eos */
+            track.onData(contents.getBytes(), true, /* eos */
             ~0);
             return MEDIA_INFO_EXTERNAL_METADATA_UPDATE;
         }

Find a functionally equivalent code:android.net.ConnectivityManager.isNetworkTypeMobile:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given type uses the cellular data connection.
 * This should be replaced in the future by a network property.
 * @param networkType the type to check
 * @return a boolean - {@code true} if uses cellular network, else {@code false}
 * {@hide}
 */

@@ -9,14 +9,15 @@
         case TYPE_MOBILE_IMS:
         case TYPE_MOBILE_CBS:
         case TYPE_MOBILE_IA:
+        case TYPE_MOBILE_EMERGENCY:
             return true;
         default:
             return false;

Find a functionally equivalent code:com.android.smspush.WapPushManager.WapPushManDBHelper.queryLastApp:COMMENT
Method Modifier: protected   
Comment:/**
 * Query the latest receiver application info with supplied application ID and
 * content type.
 * @param app_id    application ID to look up
 * @param content_type    content type to look up
 */

@@ -1,8 +1,9 @@
 {
-    String sql = "select install_order, package_name, class_name, " + " app_type, need_signature, further_processing" + " from " + APPID_TABLE_NAME + " where x_wap_application=\'" + app_id + "\'" + " and content_type=\'" + content_type + "\'" + " order by install_order desc";
-    if (DEBUG_SQL)
-        Log.v(LOG_TAG, "sql: " + sql);
-    Cursor cur = db.rawQuery(sql, null);
+    if (LOCAL_LOGV)
+        Log.v(LOG_TAG, "queryLastApp app_id: " + app_id + " content_type: " + content_type);
+    Cursor cur = db.query(APPID_TABLE_NAME, new String[] { "install_order", "package_name", "class_name", "app_type", "need_signature", "further_processing" }, "x_wap_application=? and content_type=?", new String[] { app_id, content_type }, null, /* groupBy */
+    null, /* having */
+    "install_order desc");
     queryData ret = null;
     if (cur.moveToNext()) {
         ret = new queryData();

Find a functionally equivalent code:android.os.Parcel.readArrayMapSafelyInternal:COMMENT
Method Modifier: 
Comment:/* package */

@@ -5,11 +5,11 @@
         Log.d(TAG, "Reading safely " + N + " ArrayMap entries", here);
     }
     while (N > 0) {
-        Object key = readValue(loader);
+        String key = readString();
         if (DEBUG_ARRAY_MAP)
             Log.d(TAG, "  Read safe #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
         Object value = readValue(loader);

Find a functionally equivalent code:android.os.ParcelFileDescriptor.createReliableSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

@@ -1,9 +1,9 @@
 {
     try {
-        final FileDescriptor[] comm = createCommSocketPair(false);
+        final FileDescriptor[] comm = createCommSocketPair();
         final FileDescriptor fd0 = new FileDescriptor();
         final FileDescriptor fd1 = new FileDescriptor();
-        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
+        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
         return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
     } catch (ErrnoException e) {
         throw e.rethrowAsIOException();

Find a functionally equivalent code:android.media.MediaRouter.selectRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Select the specified route to use for output of the given media types.
 * <p class="note">
 * As API version 18, this function may be used to select any route.
 * In prior versions, this function could only be used to select user
 * routes and would ignore any attempt to select a system route.
 * </p>
 *
 * @param types type flags indicating which types this route should be used for.
 * The route must support at least a subset.
 * @param route Route to select
 */

@@ -1,3 +1,3 @@
 {
-    selectRouteStatic(types, route);
+    selectRouteStatic(types, route, true);
 }

Find a functionally equivalent code:android.transition.TransitionSet.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,5 +1,17 @@
 {
-    for (Transition childTransition : mTransitions) {
-        childTransition.createAnimators(sceneRoot, startValues, endValues);
+    long startDelay = getStartDelay();
+    int numTransitions = mTransitions.size();
+    for (int i = 0; i < numTransitions; i++) {
+        Transition childTransition = mTransitions.get(i);
+        // the transitions sequentially.
+        if (startDelay > 0 && (mPlayTogether || i == 0)) {
+            long childStartDelay = childTransition.getStartDelay();
+            if (childStartDelay > 0) {
+                childTransition.setStartDelay(startDelay + childStartDelay);
+            } else {
+                childTransition.setStartDelay(startDelay);
+            }
+        }
+        childTransition.createAnimators(sceneRoot, startValues, endValues, startValuesList, endValuesList);
     }
 }

Find a functionally equivalent code:android.media.MediaFocusControl.onRegisterVolumeObserverForRcc:COMMENT
Method Modifier: private     
Comment:// handler for MSG_RCC_NEW_VOLUME_OBS

@@ -1,11 +1,11 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         // start iterating from the top.
         try {
-            for (int index = mRCStack.size() - 1; index >= 0; index--) {
-                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
-                if (rcse.mRccId == rccId) {
-                    rcse.mRemoteVolumeObs = rvo;
+            for (int index = mPRStack.size() - 1; index >= 0; index--) {
+                final PlayerRecord prse = mPRStack.elementAt(index);
+                if (prse.getRccId() == rccId) {
+                    prse.mRemoteVolumeObs = rvo;
                     break;
                 }
             }

Find a functionally equivalent code:android.text.SpannableStringBuilder.getTextRunAdvances:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Paint to use internally.
 * {@hide}
 */

@@ -3,15 +3,15 @@
     int contextLen = contextEnd - contextStart;
     int len = end - start;
     if (end <= mGapStart) {
-        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, flags, advances, advancesPos);
+        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, isRtl, advances, advancesPos);
     } else if (start >= mGapStart) {
-        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, flags, advances, advancesPos);
+        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, isRtl, advances, advancesPos);
     } else {
         char[] buf = TextUtils.obtain(contextLen);
         getChars(contextStart, contextEnd, buf, 0);
-        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, flags, advances, advancesPos);
+        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, isRtl, advances, advancesPos);
         TextUtils.recycle(buf);
     }
     return ret;

Find a functionally equivalent code:android.widget.CalendarView.setDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the calendar dates.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

@@ -1,7 +1,3 @@
 {
-    if (mDateTextAppearanceResId != resourceId) {
-        mDateTextAppearanceResId = resourceId;
-        updateDateTextSize();
-        invalidateAllWeekViews();
-    }
+    mDelegate.setDateTextAppearance(resourceId);
 }

Find a functionally equivalent code:android.net.ConnectivityManager.setProvisioningNotificationVisible:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set sign in error notification to visible or in visible
 *
 * @param visible
 * @param networkType
 *
 * {@hide}
 */

@@ -1,6 +1,6 @@
 {
     try {
-        mService.setProvisioningNotificationVisible(visible, networkType, extraInfo, url);
+        mService.setProvisioningNotificationVisible(visible, networkType, action);
     } catch (RemoteException e) {
     }
 }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_VocabularyDestroy:COMMENT
Method Modifier: private     static      native      
Comment:// ESR_Locale* locale);


Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.finishPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,4 +1,12 @@
 {
+    if (mWinShowWhenLocked != null && mWinShowWhenLocked != mTopFullscreenOpaqueWindowState) {
+        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
+        // fullscreen window.
+        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
+        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
+        mTopFullscreenOpaqueWindowState.hideLw(false);
+        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
+    }
     int changes = 0;
     boolean topIsFullscreen = false;
     final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
@@ -15,26 +23,42 @@
             if (mStatusBarController.setBarShowingLw(true)) {
                 changes |= FINISH_LAYOUT_REDO_LAYOUT;
             }
+            // Maintain fullscreen layout until incoming animation is complete.
+            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
+            // Transient status bar on the lockscreen is not allowed
+            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
+                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
+                mLastSystemUiFlags, mLastSystemUiFlags);
+            }
         } else if (mTopFullscreenOpaqueWindowState != null) {
+            final int fl = PolicyControl.getWindowFlags(null, lp);
             if (localLOGV) {
                 Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
-                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(lp.flags));
+                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
             }
-            topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
+            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
             // case though.
             if (mStatusBarController.isTransientShowing()) {
                 if (mStatusBarController.setBarShowingLw(true)) {
@@ -44,56 +60,79 @@
             }
         }
     }
-    mTopIsFullscreen = topIsFullscreen;
+    if (mTopIsFullscreen != topIsFullscreen) {
+        if (!topIsFullscreen) {
+            // Force another layout when status bar becomes fully shown.
+            changes |= FINISH_LAYOUT_REDO_LAYOUT;
+        }
+        mTopIsFullscreen = topIsFullscreen;
+    }
     // displayed when the screen is locked.
-    if (mKeyguard != null) {
+    if (mKeyguardDelegate != null && mStatusBar != null) {
         if (localLOGV)
             Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
-        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardDelegate.isSecure()) {
-            if (mKeyguard.hideLw(true)) {
+        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !isKeyguardSecure()) {
+            mKeyguardHidden = true;
+            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                 changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
             }
             if (mKeyguardDelegate.isShowing()) {
@@ -63,82 +86,103 @@
                 });
             }
         } else if (mHideLockScreen) {
-            if (mKeyguard.hideLw(true)) {
+            mKeyguardHidden = true;
+            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(true))) {
                 changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
             }
-            if (!mShowingDream) {
-                mKeyguardDelegate.setHidden(true);
-            }
         } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
             // This is the case of keyguard isSecure() and not mHideLockScreen.
             if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                 // Only launch the next keyguard unlock window once per window.
-                if (mKeyguard.showLw(true)) {
+                mKeyguardHidden = false;
+                if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                     changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                 }
-                mKeyguardDelegate.setHidden(false);
                 mHandler.post(new Runnable() {
 
                     @Override
@@ -87,96 +108,117 @@
             }
         } else {
             mWinDismissingKeyguard = null;
-            if (mKeyguard.showLw(true)) {
+            mKeyguardHidden = false;
+            if (processKeyguardSetHiddenResultLw(mKeyguardDelegate.setOccluded(false))) {
                 changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
             }
-            mKeyguardDelegate.setHidden(false);
         }
     }
     if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {

Find a functionally equivalent code:android.net.wifi.WifiInfo.getHiddenSSID:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@code true} if this network does not broadcast its SSID, so an
 * SSID-specific probe request must be used for scans.
 */

@@ -1,3 +1,5 @@
 {
-    return mHiddenSSID;
+    if (mWifiSsid == null)
+        return false;
+    return mWifiSsid.isHidden();
 }

Find a functionally equivalent code:android.os.Parcel.writeException:COMMENT
Method Modifier: public      final       
Comment:/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */

@@ -12,17 +12,19 @@
         code = EX_ILLEGAL_STATE;
     } else if (e instanceof NetworkOnMainThreadException) {
         code = EX_NETWORK_MAIN_THREAD;
+    } else if (e instanceof UnsupportedOperationException) {
+        code = EX_UNSUPPORTED_OPERATION;
     }
     writeInt(code);
     StrictMode.clearGatheredViolations();

Find a functionally equivalent code:android.graphics.BidiRenderer.getScriptRuns:COMMENT
Method Modifier: default     static      
Comment:/* package */


Find a functionally equivalent code:android.content.res.BridgeTypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

@@ -1,10 +1,4 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return false;
-    }
-    if (mResourceData[index] == null) {
-        return false;
-    }
-    String s = mResourceData[index].getValue();
-    return ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
+    String s = getString(index);
+    return s != null && ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.updateOrientationListenerLp:COMMENT
Method Modifier: internal    
Comment:/*
     * Various use cases for invoking this function
     * screen turning off, should always disable listeners if already enabled
     * screen turned on and current app has sensor based orientation, enable listeners
     * if not already enabled
     * screen turned on and current app does not have sensor orientation, disable listeners if
     * already enabled
     * screen turning on and current app has sensor based orientation, enable listeners if needed
     * screen turning on and current app has nosensor based orientation, do nothing
     */

@@ -5,13 +5,13 @@
     }
     // change of the currently visible window's orientation
     if (localLOGV)
-        Slog.v(TAG, "Screen status=" + mScreenOnEarly + ", current orientation=" + mCurrentAppOrientation + ", SensorEnabled=" + mOrientationSensorEnabled);
+        Slog.v(TAG, "mScreenOnEarly=" + mScreenOnEarly + ", mAwake=" + mAwake + ", mCurrentAppOrientation=" + mCurrentAppOrientation + ", mOrientationSensorEnabled=" + mOrientationSensorEnabled);
     boolean disable = true;
-    if (mScreenOnEarly) {
+    if (mScreenOnEarly && mAwake) {
         if (needSensorRunningLp()) {
             disable = false;
             // enable listener if not already enabled

Find a functionally equivalent code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: 
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

@@ -10,15 +10,16 @@
     final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
     final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
     boolean matchWidth = false;
+    boolean skippedMeasure = false;
     final int baselineChildIndex = mBaselineAlignedChildIndex;
     final boolean useLargestChild = mUseLargestChild;
     int largestChildHeight = Integer.MIN_VALUE;
@@ -35,40 +36,42 @@
             // there is any leftover space.
             final int totalLength = mTotalLength;
             mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
+            skippedMeasure = true;
         } else {
             int oldHeight = Integer.MIN_VALUE;
             if (lp.height == 0 && lp.weight > 0) {
@@ -126,134 +128,137 @@
     int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
     heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
     // Either expand children with weight to take up available space or
-    // shrink them if they extend beyond our current bounds
+    // shrink them if they extend beyond our current bounds. If we skipped
+    // measurement on any children, we need to measure them now.
     int delta = heightSize - mTotalLength;
-    if (delta != 0 && totalWeight > 0.0f) {
+    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
         float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
         mTotalLength = 0;
         for (int i = 0; i < count; ++i) {

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.registerZygoteSocket:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Registers a server socket for zygote command connections
 *
 * @throws RuntimeException when open fails
 */

@@ -1,11 +1,12 @@
 {
     if (sServerSocket == null) {
         int fileDesc;
+        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
         try {
-            String env = System.getenv(ANDROID_SOCKET_ENV);
+            String env = System.getenv(fullSocketName);
             fileDesc = Integer.parseInt(env);
         } catch (RuntimeException ex) {
-            throw new RuntimeException(ANDROID_SOCKET_ENV + " unset or invalid", ex);
+            throw new RuntimeException(fullSocketName + " unset or invalid", ex);
         }
         try {
             sServerSocket = new LocalServerSocket(createFileDescriptor(fileDesc));

Find a functionally equivalent code:android.test.ServiceTestCase.shutdownService:COMMENT
Method Modifier: protected   
Comment:/**
 * Makes the necessary calls to stop (or unbind) the service under test, and
 * calls onDestroy().  Ordinarily this is called automatically (by {@link #tearDown}, but
 * you can call it directly from your test in order to check for proper shutdown behavior.
 */

@@ -8,12 +8,13 @@
     }
     if (mServiceCreated) {
         mService.onDestroy();
+        mServiceCreated = false;
     }
 }

Find a functionally equivalent code:android.graphics.Paint_Delegate.updateFontObject:COMMENT
Method Modifier: private     
Comment:/**
 * Update the {@link Font} object from the typeface, text size and scaling
 */

@@ -1,11 +1,17 @@
 {
     if (mTypeface != null) {
         // Get the fonts from the TypeFace object.
-        List<Font> fonts = mTypeface.getFonts();
+        List<Font> fonts = mTypeface.getFonts(mFontVariant);
         // create new font objects as well as FontMetrics, based on the current text size
         // and skew info.
         ArrayList<FontInfo> infoList = new ArrayList<FontInfo>(fonts.size());
         for (Font font : fonts) {
+            if (font == null) {
+                // If the font is null, add null to infoList. When rendering the text, if this
+                // null is reached, a warning will be logged.
+                infoList.add(null);
+                continue;
+            }
             FontInfo info = new FontInfo();
             info.mFont = font.deriveFont(mTextSize);
             if (mTextScaleX != 1.0 || mTextSkewX != 0) {

Find a functionally equivalent code:android.net.http.CertificateChainValidator.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * @return The singleton instance of the certificates chain validator
 */

@@ -1,3 +1,3 @@
 {
-    return sInstance;
+    return NoPreloadHolder.sInstance;
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.getDelegate:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the delegate from the given native int.
 * <p>
 * If the int is zero, then this will always return null.
 * <p>
 * If the int is non zero and the delegate is not found, this will throw an assert.
 *
 * @param native_object the native int.
 * @return the delegate or null if not found.
 */


Find a functionally equivalent code:android.widget.EdgeEffect.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */

@@ -1,29 +1,20 @@
 {
     update();
-    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
-    int glowBottom = (int) Math.min(mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f, mGlowHeight * MAX_GLOW_HEIGHT);
-    if (mWidth < mMinWidth) {
-        // Center the glow and clip it.
-        int glowLeft = (mWidth - mMinWidth) / 2;
-        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
-    } else {
-        // Stretch the glow to fit.
-        mGlow.setBounds(0, 0, mWidth, glowBottom);
-    }
-    mGlow.draw(canvas);
-    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
-    int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
-    if (mWidth < mMinWidth) {
-        // Center the edge and clip it.
-        int edgeLeft = (mWidth - mMinWidth) / 2;
-        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
-    } else {
-        // Stretch the edge to fit.
-        mEdge.setBounds(0, 0, mWidth, edgeBottom);
-    }
-    mEdge.draw(canvas);
-    if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
+    final int count = canvas.save();
+    final float centerX = mBounds.centerX();
+    final float centerY = mBounds.height() - mRadius;
+    canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
+    final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
+    float translateX = mBounds.width() * displacement / 2;
+    canvas.clipRect(mBounds);
+    canvas.translate(translateX, 0);
+    mPaint.setAlpha((int) (0xff * mGlowAlpha));
+    canvas.drawCircle(centerX, centerY, mRadius, mPaint);
+    canvas.restoreToCount(count);
+    boolean oneLastFrame = false;
+    if (mState == STATE_RECEDE && mGlowScaleY == 0) {
         mState = STATE_IDLE;
+        oneLastFrame = true;
     }
-    return mState != STATE_IDLE;
+    return mState != STATE_IDLE || oneLastFrame;
 }

Find a functionally equivalent code:android.graphics.Paint.setShader:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the shader object.
 * <p />
 * Pass null to clear any previous shader.
 * As a convenience, the parameter passed is also returned.
 *
 * @param shader May be null. the new shader to be installed in the paint
 * @return       shader
 */

@@ -1,7 +1,7 @@
 {
-    int shaderNative = 0;
+    long shaderNative = 0;
     if (shader != null)
-        shaderNative = shader.native_instance;
+        shaderNative = shader.getNativeInstance();
     native_setShader(mNativePaint, shaderNative);
     mShader = shader;
     return shader;

Find a functionally equivalent code:android.widget.CalendarView.getWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the week day abbreviation of the calendar header.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

@@ -1,3 +1,3 @@
 {
-    return mWeekDayTextAppearanceResId;
+    return mDelegate.getWeekDayTextAppearance();
 }

Find a functionally equivalent code:android.os.Binder.execTransact:COMMENT
Method Modifier: private     
Comment:// Entry point from android_util_Binder.cpp's onTransact

@@ -11,26 +11,28 @@
     } catch (RemoteException e) {
         if ((flags & FLAG_ONEWAY) != 0) {
             Log.w(TAG, "Binder call failed.", e);
+        } else {
+            reply.setDataPosition(0);
+            reply.writeException(e);
         }
-        reply.setDataPosition(0);
-        reply.writeException(e);
         res = true;
     } catch (RuntimeException e) {
         if ((flags & FLAG_ONEWAY) != 0) {
             Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
+        } else {
+            reply.setDataPosition(0);
+            reply.writeException(e);
         }
-        reply.setDataPosition(0);
-        reply.writeException(e);
         res = true;
     } catch (OutOfMemoryError e) {
         // Unconditionally log this, since this is generally unrecoverable.
@@ -30,36 +32,45 @@
         reply.writeException(re);
         res = true;
     }
+    checkParcel(this, code, reply, "Unreasonably large binder reply buffer");
     reply.recycle();
     data.recycle();
+    // Just in case -- we are done with the IPC, so there should be no more strict
+    // mode violations that have gathered for this thread.  Either they have been
+    // parceled and are now in transport off to the caller, or we are returning back
+    // to the main transaction loop to wait for another incoming transaction.  Either
+    // way, strict mode begone!
+    StrictMode.clearGatheredViolations();
     return res;
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.acceptCommandPeer:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Waits for and accepts a single command connection. Throws
 * RuntimeException on failure.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return new ZygoteConnection(sServerSocket.accept());
+        return new ZygoteConnection(sServerSocket.accept(), abiList);
     } catch (IOException ex) {
         throw new RuntimeException("IOException during accept()", ex);
     }

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.getRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the record at a given index.
 *
 * @param index The index.
 * @return The record at the specified index.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecords == null) {
+        throw new IndexOutOfBoundsException("Invalid index " + index + ", size is 0");
+    }
     return mRecords.get(index);
 }

Find a functionally equivalent code:android.animation.AnimatorSet.playSequentially:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up this AnimatorSet to play each of the supplied animations when the
 * previous animation ends.
 *
 * @param items The animations that will be started one after another.
 */

@@ -1,11 +1,12 @@
 {
-    if (items != null && items.size() > 0) {
+    if (items != null) {
         mNeedsSort = true;
-        if (items.size() == 1) {
-            play(items.get(0));
+        if (items.length == 1) {
+            play(items[0]);
         } else {
-            for (int i = 0; i < items.size() - 1; ++i) {
-                play(items.get(i)).before(items.get(i + 1));
+            mReversible = false;
+            for (int i = 0; i < items.length - 1; ++i) {
+                play(items[i]).before(items[i + 1]);
             }
         }
     }

Find a functionally equivalent code:android.net.NetworkTemplate.matchesWifi:COMMENT
Method Modifier: private     
Comment:/**
 * Check if matches Wi-Fi network template.
 */

@@ -1,7 +1,7 @@
 {
     switch(ident.mType) {
         case TYPE_WIFI:
-            return Objects.equal(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
+            return Objects.equals(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
         default:
             return false;
     }

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.getChild:COMMENT
Method Modifier: public      
Comment:/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */

@@ -1,5 +1,8 @@
 {
     enforceSealed();
+    if (mChildNodeIds == null) {
+        return null;
+    }
     if (!canPerformRequestOverConnection(mSourceNodeId)) {
         return null;
     }

Find a functionally equivalent code:android.content.pm.ResolveInfo.getIconResource:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */

@@ -1,8 +1,11 @@
 {
+    if (noResourceId)
+        return 0;
     if (icon != 0)
         return icon;
     final ComponentInfo ci = getComponentInfo();
-    if (ci != null)
+    if (ci != null) {
         return ci.getIconResource();
+    }
     return 0;
 }

Find a functionally equivalent code:android.media.AudioService.setStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamMute(int, boolean)
 */

@@ -3,8 +3,19 @@
         return;
     }
     if (isStreamAffectedByMute(streamType)) {
+        if (mHdmiManager != null) {
+            synchronized (mHdmiManager) {
+                if (streamType == AudioSystem.STREAM_MUSIC && mHdmiTvClient != null) {
+                    synchronized (mHdmiTvClient) {
+                        if (mHdmiSystemAudioSupported) {
+                            mHdmiTvClient.setSystemAudioMute(state);
+                        }
+                    }
+                }
+            }
+        }
         mStreamStates[streamType].mute(cb, state);
     }
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.ResourceHelper.getDrawable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a drawable from the given value.
 * @param value The value that contains a path to a 9 patch, a bitmap or a xml based drawable,
 * or an hexadecimal color
 * @param context the current context
 */

@@ -1,4 +1,7 @@
 {
+    if (value == null) {
+        return null;
+    }
     String stringValue = value.getValue();
     if (RenderResources.REFERENCE_NULL.equals(stringValue)) {
         return null;

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.isConnectedToMobile:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToMobile()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Return true if device is currently connected to mobile network

@@ -1,3 +1,3 @@
 {
-    return (mNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE);
+    return (mCm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_MOBILE);
 }

Find a functionally equivalent code:android.media.AudioService.makeA2dpDeviceUnavailableNow:COMMENT
Method Modifier: private     
Comment:// must be called synchronized on mConnectedDevices

@@ -4,7 +4,14 @@
     }
     AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
     mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
+    synchronized (mCurAudioRoutes) {
+        // Remove A2DP routes as well
+        if (mCurAudioRoutes.mBluetoothName != null) {
+            mCurAudioRoutes.mBluetoothName = null;
+            sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES, SENDMSG_NOOP, 0, 0, null, 0);
+        }
+    }
 }

Find a functionally equivalent code:android.widget.CalendarView.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default maximal date is 01/01/2100.
 * <p>
 *
 * @return The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

@@ -1,3 +1,3 @@
 {
-    return mMaxDate.getTimeInMillis();
+    return mDelegate.getMaxDate();
 }

Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayClear:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_CLEAR event
 */

@@ -1,7 +1,7 @@
 {
     if (DEBUG_RC)
         Log.i(TAG, "Clear remote control display");
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         synchronized (mCurrentRcLock) {
             mCurrentRcClientGen++;
             // synchronously update the displays and clients with the new client generation

Find a functionally equivalent code:android.os.RecoverySystem.rebootWipeCache:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboot into the recovery system to wipe the /cache partition.
 * @throws IOException if something goes wrong.
 */

@@ -1,3 +1,3 @@
 {
-    bootCommand(context, "--wipe_cache\n--locale=" + Locale.getDefault().toString());
+    rebootWipeCache(context, context.getPackageName());
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.restoreHierarchyState:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -21,30 +21,31 @@
     if (panelStates != null) {
         restorePanelState(panelStates);
     }
-    if (mActionBar != null) {
+    if (mDecorContentParent != null) {
         SparseArray<Parcelable> actionBarStates = savedInstanceState.getSparseParcelableArray(ACTION_BAR_TAG);
         if (actionBarStates != null) {
-            mActionBar.restoreHierarchyState(actionBarStates);
+            doPendingInvalidatePanelMenu();
+            mDecorContentParent.restoreToolbarHierarchyState(actionBarStates);
         } else {
             Log.w(TAG, "Missing saved instance states for action bar views! " + "State will not be restored.");
         }

Find a functionally equivalent code:android.widget.DatePicker.setSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the spinners are shown.
 *
 * @param shown True if the spinners are to be shown.
 */

@@ -1,3 +1,3 @@
 {
-    mSpinners.setVisibility(shown ? VISIBLE : GONE);
+    mDelegate.setSpinnersShown(shown);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.initializePanelDecor:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Perform initial setup of a panel. This should at the very least set the
 * style information in the PanelFeatureState and must set
 * PanelFeatureState.decor to the panel's window decor view.
 *
 * @param st The panel being initialized.
 */

@@ -2,6 +2,12 @@
     st.decorView = new DecorView(getContext(), st.featureId);
     st.gravity = Gravity.CENTER | Gravity.BOTTOM;
     st.setStyle(getContext());
+    TypedArray a = getContext().obtainStyledAttributes(null, R.styleable.Window, 0, st.listPresenterTheme);
+    final float elevation = a.getDimension(R.styleable.Window_windowElevation, 0);
+    if (elevation != 0) {
+        st.decorView.setElevation(elevation);
+    }
+    a.recycle();
     return true;
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserSwitching:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitching(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user change begins.
 */


Find a functionally equivalent code:com.android.internal.os.RuntimeInit.wtf:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Report a serious error in the current process.  May or may not cause
 * the process to terminate (depends on system settings).
 *
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */

@@ -1,6 +1,6 @@
 {
     try {
-        if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject, tag, new ApplicationErrorReport.CrashInfo(t))) {
+        if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject, tag, system, new ApplicationErrorReport.CrashInfo(t))) {
             // The Activity Manager has already written us off -- now exit.
             Process.killProcess(Process.myPid());
             System.exit(10);

Find a functionally equivalent code:android.content.RestrictionEntry.setAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current list of selected values for an entry of type {@link #TYPE_MULTI_SELECT}.
 * These values will be persisted by the system for later use by the application.
 * @param allSelectedStrings the current list of selected values.
 */

@@ -1,3 +1,3 @@
 {
-    currentValues = allSelectedStrings;
+    mCurrentValues = allSelectedStrings;
 }

Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromResourceStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream, using the given resources and
 * value to determine density information.
 */


Find a functionally equivalent code:android.app.WallpaperManager.getCropAndSetWallpaperIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to "image/*"
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not "image/*"
 */

@@ -1,4 +1,7 @@
 {
+    if (imageUri == null) {
+        throw new IllegalArgumentException("Image URI must not be null");
+    }
     if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
         throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
     }

Find a functionally equivalent code:android.graphics.Matrix.postRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified rotation.
 * M' = R(degrees) * M
 */

@@ -1,3 +1,4 @@
 {
-    return native_postRotate(native_instance, degrees);
+    native_postRotate(native_instance, degrees);
+    return true;
 }

Find a functionally equivalent code:android.view.ViewGroup.resetTouchState:COMMENT
Method Modifier: private     
Comment:/**
 * Resets all touch state in preparation for a new cycle.
 */

@@ -2,5 +2,6 @@
     clearTouchTargets();
     resetCancelNextUpFlag(this);
     mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
+    mNestedScrollAxes = SCROLL_AXIS_NONE;
 }

Find a functionally equivalent code:android.graphics.Canvas.getClipBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Return the bounds of the current clip (in local coordinates) in the
 * bounds parameter, and return true if it is non-empty. This can be useful
 * in a way similar to quickReject, in that it tells you that drawing
 * outside of these bounds will be clipped out.
 *
 * @param bounds Return the clip bounds here. If it is null, ignore it but
 * still return true if the current clip is non-empty.
 * @return true if the current clip is non-empty.
 */

@@ -1,3 +1,3 @@
 {
-    return native_getClipBounds(mNativeCanvas, bounds);
+    return native_getClipBounds(mNativeCanvasWrapper, bounds);
 }

Find a functionally equivalent code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     
Comment:/**
 * Check if mobile network with matching IMSI.
 */

@@ -3,8 +3,8 @@
         // TODO: consider matching against WiMAX subscriber identity
         return true;
     } else {
-        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equal(mSubscriberId, ident.mSubscriberId));
+        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equals(mSubscriberId, ident.mSubscriberId));
     }
 }

Find a functionally equivalent code:android.os.Bundle.getCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (CharSequence[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "CharSequence[]", e);
-        return null;
-    }
+    return super.getCharSequenceArray(key);
 }

Find a functionally equivalent code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

@@ -3,12 +3,16 @@
         /**
          * Valid methods
          */
+        case Eap.TLS:
+            setPhase2Method(Phase2.NONE);
+        /* fall through */
         case Eap.PEAP:
         case Eap.PWD:
-        case Eap.TLS:
         case Eap.TTLS:
+        case Eap.SIM:
+        case Eap.AKA:
             mFields.put(EAP_KEY, Eap.strings[eapMethod]);
             mFields.put(OPP_KEY_CACHING, "1");
             break;

Find a functionally equivalent code:android.view.ViewGroup.removeAllViewsInLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may "have" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

@@ -15,21 +15,21 @@
             mTransition.removeChild(this, view);
         }
         if (view == focused) {
-            view.unFocus();
+            view.unFocus(null);
             clearChildFocus = true;
         }
         if (view.isAccessibilityFocused()) {

Find a functionally equivalent code:android.net.nsd.NsdServiceInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

@@ -1,12 +1,24 @@
 {
     dest.writeString(mServiceName);
     dest.writeString(mServiceType);
-    dest.writeParcelable(mTxtRecord, flags);
     if (mHost != null) {
-        dest.writeByte((byte) 1);
+        dest.writeInt(1);
         dest.writeByteArray(mHost.getAddress());
     } else {
-        dest.writeByte((byte) 0);
+        dest.writeInt(0);
     }
     dest.writeInt(mPort);
+    // TXT record key/value pairs.
+    dest.writeInt(mTxtRecord.size());
+    for (String key : mTxtRecord.keySet()) {
+        byte[] value = mTxtRecord.get(key);
+        if (value != null) {
+            dest.writeInt(1);
+            dest.writeInt(value.length);
+            dest.writeByteArray(value);
+        } else {
+            dest.writeInt(0);
+        }
+        dest.writeString(key);
+    }
 }

Find a functionally equivalent code:android.appwidget.AppWidgetProvider.onReceive:COMMENT
Method Modifier: public      
Comment:// BEGIN_INCLUDE(onReceive)

@@ -27,31 +27,41 @@
         this.onEnabled(context);
     } else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
         this.onDisabled(context);
+    } else if (AppWidgetManager.ACTION_APPWIDGET_RESTORED.equals(action)) {
+        Bundle extras = intent.getExtras();
+        if (extras != null) {
+            int[] oldIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS);
+            int[] newIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
+            if (oldIds != null && oldIds.length > 0) {
+                this.onRestored(context, oldIds, newIds);
+                this.onUpdate(context, AppWidgetManager.getInstance(context), newIds);
+            }
+        }
     }
 }

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

@@ -2,13 +2,11 @@
     try {
         return getDimension(index);
     } catch (RuntimeException e) {
-        if (mResourceData[index] != null) {
-            String s = mResourceData[index].getValue();
-            if (s != null) {
-                // looks like we were unable to resolve the dimension value
-                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
-            }
+        String s = getString(index);
+        if (s != null) {
+            // looks like we were unable to resolve the dimension value
+            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
         }
         return defValue;
     }

Find a functionally equivalent code:android.view.LayoutInflater.setFactory2:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #setFactory}, but allows you to set a {@link Factory2}
 * interface.
 */

@@ -9,14 +9,14 @@
     if (mFactory == null) {
         mFactory = mFactory2 = factory;
     } else {
-        mFactory = new FactoryMerger(factory, factory, mFactory, mFactory2);
+        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
     }
 }

Find a functionally equivalent code:android.media.MediaFocusControl.isPlaystateActive:COMMENT
<android.media.MediaFocusControl: boolean isPlaystateActive(int)>
Method Modifier: protected   private     static      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Returns true if the given playback state is considered "active", i.e. it describes a state
 * where playback is happening, or about to
 * @param playState the playback state to evaluate
 * @return true if active, false otherwise (inactive or unknown)
 */


Find a functionally equivalent code:android.graphics.Canvas.drawArc:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Draw the specified arc, which will be scaled to fit inside the
 * specified oval.</p>
 *
 * <p>If the start angle is negative or >= 360, the start angle is treated
 * as start angle modulo 360.</p>
 *
 * <p>If the sweep angle is >= 360, then the oval is drawn
 * completely. Note that this differs slightly from SkPath::arcTo, which
 * treats the sweep angle modulo 360. If the sweep angle is negative,
 * the sweep angle is treated as sweep angle modulo 360</p>
 *
 * <p>The arc is drawn clockwise. An angle of 0 degrees correspond to the
 * geometric angle of 0 degrees (3 o'clock on a watch.)</p>
 *
 * @param oval       The bounds of oval used to define the shape and size
 * of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 * @param useCenter If true, include the center of the oval in the arc, and
 * close it if it is being stroked. This will draw a wedge
 * @param paint      The paint used to draw the arc
 */

@@ -1,6 +1,3 @@
 {
-    if (oval == null) {
-        throw new NullPointerException();
-    }
-    native_drawArc(mNativeCanvas, oval, startAngle, sweepAngle, useCenter, paint.mNativePaint);
+    drawArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter, paint);
 }

Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCDList:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the list of remote control displays
 */

@@ -1,9 +1,9 @@
 {
     pw.println("\nRemote Control Display list entries:");
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
         while (displayIterator.hasNext()) {
-            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
+            final DisplayInfoForServer di = displayIterator.next();
             pw.println("  IRCD: " + di.mRcDisplay + "  -- w:" + di.mArtworkExpectedWidth + "  -- h:" + di.mArtworkExpectedHeight + "  -- wantsPosSync:" + di.mWantsPositionSync + "  -- " + (di.mEnabled ? "enabled" : "disabled"));
         }
     }

Find a functionally equivalent code:android.os.Bundle.putFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a float array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putFloatArray(key, value);
 }

Find a functionally equivalent code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

@@ -9,35 +9,14 @@
         throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
     }
     mSampleRate = sampleRateInHz;
-    // channel config
-    switch(channelConfig) {
-        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
-        case AudioFormat.CHANNEL_IN_DEFAULT:
-        case AudioFormat.CHANNEL_IN_MONO:
-        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
-            mChannelCount = 1;
-            mChannelMask = AudioFormat.CHANNEL_IN_MONO;
-            break;
-        case AudioFormat.CHANNEL_IN_STEREO:
-        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
-            mChannelCount = 2;
-            mChannelMask = AudioFormat.CHANNEL_IN_STEREO;
-            break;
-        case (AudioFormat.CHANNEL_IN_FRONT | AudioFormat.CHANNEL_IN_BACK):
-            mChannelCount = 2;
-            mChannelMask = channelConfig;
-            break;
-        default:
-            throw new IllegalArgumentException("Unsupported channel configuration.");
-    }
     // audio format
     switch(audioFormat) {
         case AudioFormat.ENCODING_DEFAULT:

Find a functionally equivalent code:android.app.Activity.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */

@@ -1,24 +1,3 @@
 {
-    if (mParent == null) {
-        int resultCode;
-        Intent resultData;
-        synchronized (this) {
-            resultCode = mResultCode;
-            resultData = mResultData;
-        }
-        if (false)
-            Log.v(TAG, "Finishing self: token=" + mToken);
-        try {
-            if (resultData != null) {
-                resultData.prepareToLeaveProcess();
-            }
-            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
-                mFinished = true;
-            }
-        } catch (RemoteException e) {
-        // Empty
-        }
-    } else {
-        mParent.finishFromChild(this);
-    }
+    finish(false);
 }

Find a functionally equivalent code:android.content.res.Resources.getPreloadedDrawables:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */


Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.animate:COMMENT
Method Modifier: public      
Comment:/**
 * Animate an object
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#animate(Object, String, boolean, IAnimationListener)
 */

@@ -2,8 +2,8 @@
     checkLock();
     BridgeContext context = getContext();
     // find the animation file.
-    ResourceValue animationResource = null;
+    ResourceValue animationResource;
     int animationId = 0;
     if (isFrameworkAnimation) {
         animationResource = context.getRenderResources().getFrameworkResource(ResourceType.ANIMATOR, animationName);

Find a functionally equivalent code:android.content.res.ColorStateList.inflate:COMMENT
Method Modifier: private     
Comment:/**
 * Fill in this object based on the contents of an XML "selector" element.
 */

@@ -2,11 +2,10 @@
     int type;
     final int innerDepth = parser.getDepth() + 1;
     int depth;
-    int listAllocated = 20;
+    int[][] stateSpecList = ArrayUtils.newUnpaddedArray(int[].class, 20);
+    int[] colorList = new int[stateSpecList.length];
     int listSize = 0;
-    int[] colorList = new int[listAllocated];
-    int[][] stateSpecList = new int[listAllocated][];
     while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
         if (type != XmlPullParser.START_TAG) {
             continue;
@@ -13,18 +12,19 @@
         if (depth > innerDepth || !parser.getName().equals("item")) {
             continue;
         }
+        int alphaRes = 0;
+        float alpha = 1.0f;
         int colorRes = 0;
         int color = 0xffff0000;
         boolean haveColor = false;
@@ -24,30 +25,36 @@
             final int stateResId = attrs.getAttributeNameResource(i);
             if (stateResId == 0)
                 break;
-            if (stateResId == com.android.internal.R.attr.color) {
+            if (stateResId == com.android.internal.R.attr.alpha) {
+                alphaRes = attrs.getAttributeResourceValue(i, 0);
+                if (alphaRes == 0) {
+                    alpha = attrs.getAttributeFloatValue(i, 1.0f);
+                }
+            } else if (stateResId == com.android.internal.R.attr.color) {
                 colorRes = attrs.getAttributeResourceValue(i, 0);
                 if (colorRes == 0) {
                     color = attrs.getAttributeIntValue(i, color);
@@ -40,59 +46,62 @@
         } else if (!haveColor) {
             throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'android:color' attribute.");
         }
+        if (alphaRes != 0) {
+            alpha = r.getFloat(alphaRes);
+        }
+        // Apply alpha modulation.
+        final int alphaMod = MathUtils.constrain((int) (Color.alpha(color) * alpha), 0, 255);
+        color = (color & 0xFFFFFF) | (alphaMod << 24);
         if (listSize == 0 || stateSpec.length == 0) {
             mDefaultColor = color;
         }
-        if (listSize + 1 >= listAllocated) {
-            listAllocated = ArrayUtils.idealIntArraySize(listSize + 1);
-            int[] ncolor = new int[listAllocated];
-            System.arraycopy(colorList, 0, ncolor, 0, listSize);
-            int[][] nstate = new int[listAllocated][];
-            System.arraycopy(stateSpecList, 0, nstate, 0, listSize);
-            colorList = ncolor;
-            stateSpecList = nstate;
-        }
-        colorList[listSize] = color;
-        stateSpecList[listSize] = stateSpec;
+        colorList = GrowingArrayUtils.append(colorList, listSize, color);
+        stateSpecList = GrowingArrayUtils.append(stateSpecList, listSize, stateSpec);
         listSize++;
     }
     mColors = new int[listSize];

Find a functionally equivalent code:android.service.dreams.DreamService.dispatchTrackballEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,8 +1,8 @@
 {
     if (!mInteractive) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on trackballEvent");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on trackballEvent");
+        wakeUp();
         return true;
     }
     return mWindow.superDispatchTrackballEvent(event);

Find a functionally equivalent code:android.app.Notification.Builder.buildUnstyled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Apply the unstyled operations and return a new {@link Notification} object.
 * @hide
 */

@@ -4,10 +4,11 @@
     n.icon = mSmallIcon;
     n.iconLevel = mSmallIconLevel;
     n.number = mNumber;
-    n.contentView = makeContentView();
+    n.color = sanitizeColor();
+    setBuilderContentView(n, makeContentView());
     n.contentIntent = mContentIntent;
     n.deleteIntent = mDeleteIntent;
     n.fullScreenIntent = mFullScreenIntent;
@@ -13,41 +14,47 @@
     n.largeIcon = mLargeIcon;
     n.sound = mSound;
     n.audioStreamType = mAudioStreamType;
+    n.audioAttributes = mAudioAttributes;
     n.vibrate = mVibrate;
     n.ledARGB = mLedArgb;
     n.ledOnMS = mLedOnMs;
     n.ledOffMS = mLedOffMs;
     n.defaults = mDefaults;
     n.flags = mFlags;
-    n.bigContentView = makeBigContentView();
+    setBuilderBigContentView(n, makeBigContentView());
+    setBuilderHeadsUpContentView(n, makeHeadsUpContentView());
     if (mLedOnMs != 0 || mLedOffMs != 0) {
         n.flags |= FLAG_SHOW_LIGHTS;
     }
     if ((mDefaults & DEFAULT_LIGHTS) != 0) {
         n.flags |= FLAG_SHOW_LIGHTS;
     }
-    if (mKindList.size() > 0) {
-        n.kind = new String[mKindList.size()];
-        mKindList.toArray(n.kind);
-    } else {
-        n.kind = null;
-    }
+    n.category = mCategory;
+    n.mGroupKey = mGroupKey;
+    n.mSortKey = mSortKey;
     n.priority = mPriority;
     if (mActions.size() > 0) {
         n.actions = new Action[mActions.size()];
         mActions.toArray(n.actions);
     }
+    n.visibility = mVisibility;
+    if (mPublicVersion != null) {
+        n.publicVersion = new Notification();
+        mPublicVersion.cloneInto(n.publicVersion, true);
+    }
+    // Note: If you're adding new fields, also update restoreFromNotitification().
     return n;
 }

Find a functionally equivalent code:android.view.HardwareLayer.setTransform:COMMENT
<android.view.HardwareLayer: void setTransform(Matrix)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Sets an optional transform on this layer.
 *
 * @param matrix The transform to apply to the layer.
 */

@@ -1 +1,4 @@
-
+{
+    nSetTransform(mFinalizer.get(), matrix.native_instance);
+    mRenderer.pushLayerUpdate(this);
+}

Find a functionally equivalent code:android.graphics.Bitmap.getPixels:COMMENT
Method Modifier: public      
Comment:/**
 * Returns in pixels[] a copy of the data in the bitmap. Each value is
 * a packed int representing a {@link Color}. The stride parameter allows
 * the caller to allow for gaps in the returned pixels array between
 * rows. For normal packed results, just pass width for the stride value.
 * The returned colors are non-premultiplied ARGB values.
 *
 * @param pixels   The array to receive the bitmap's colors
 * @param offset   The first index to write into pixels[]
 * @param stride   The number of entries in pixels[] to skip between
 * rows (must be >= bitmap's width). Can be negative.
 * @param x        The x coordinate of the first pixel to read from
 * the bitmap
 * @param y        The y coordinate of the first pixel to read from
 * the bitmap
 * @param width    The number of pixels to read from each row
 * @param height   The number of rows to read
 *
 * @throws IllegalArgumentException if x, y, width, height exceed the
 * bounds of the bitmap, or if abs(stride) < width.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

@@ -5,9 +5,9 @@
         return;
     }
     checkPixelsAccess(x, y, width, height, offset, stride, pixels);
-    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
+    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockPatternEnabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether the lock pattern is enabled, or if it is set as a backup for biometric weak
 */

@@ -1,4 +1,4 @@
 {
-    final boolean backupEnabled = getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
-    return getBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, false) && (getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING || (usingBiometricWeak() && backupEnabled));
+    final boolean backupEnabled = getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
+    return getBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, false) && (getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING || (usingBiometricWeak() && backupEnabled));
 }

Find a functionally equivalent code:android.media.MediaCodecInfo.isEncoder:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query if the codec is an encoder.
 */

@@ -1,3 +1,3 @@
 {
-    return MediaCodecList.isEncoder(mIndex);
+    return mIsEncoder;
 }

Find a functionally equivalent code:android.provider.DocumentsProvider.query:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */

@@ -8,15 +8,19 @@
             case MATCH_SEARCH:
                 return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
             case MATCH_DOCUMENT:
+            case MATCH_DOCUMENT_TREE:
+                enforceTree(uri);
                 return queryDocument(getDocumentId(uri), projection);
             case MATCH_CHILDREN:
+            case MATCH_CHILDREN_TREE:
+                enforceTree(uri);
                 if (DocumentsContract.isManageMode(uri)) {
                     return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                 } else {

Find a functionally equivalent code:android.content.RestrictionEntry.setSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current selected state for an entry of type {@link #TYPE_BOOLEAN}. This value will
 * be persisted by the system for later use by the application.
 * @param state the current selected state
 */

@@ -1,3 +1,3 @@
 {
-    currentValue = Boolean.toString(state);
+    mCurrentValue = Boolean.toString(state);
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.getAccessibilityServiceList:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */

@@ -1,6 +1,6 @@
 {
     List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
-    List<ServiceInfo> services = new ArrayList<ServiceInfo>();
+    List<ServiceInfo> services = new ArrayList<>();
     final int infoCount = infos.size();
     for (int i = 0; i < infoCount; i++) {
         AccessibilityServiceInfo info = infos.get(i);

Find a functionally equivalent code:android.graphics.Picture.nativeConstructor:COMMENT
Method Modifier: private     static      native      
Comment:// return empty picture if src is 0, or a copy of the native src


Find a functionally equivalent code:android.widget.QuickContactBadge.assignContactFromEmail:COMMENT
Method Modifier: public      
Comment:/**
 * Assign a contact based on an email address. This should only be used when
 * the contact's URI is not available, as an extra query will have to be
 * performed to lookup the URI based on the email.
 *
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performed
 * until this view is clicked.
 */


Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.beginLayoutLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -49,58 +49,58 @@
     mRestrictedScreenTop = mUnrestrictedScreenTop;
     mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
     mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
-    mDockLeft = mContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
-    mDockTop = mContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
-    mDockRight = mContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
-    mDockBottom = mContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
+    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
+    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
+    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
+    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
     mDockLayer = 0x10000000;
     mStatusBarLayer = -1;
     // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
@@ -72,84 +72,87 @@
         // drive nav being hidden only by whether it is requested.
         final int sysui = mLastSystemUiFlags;
         boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
-        boolean navTranslucent = (sysui & View.NAVIGATION_BAR_TRANSLUCENT) != 0;
+        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
         boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
         boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
         boolean navAllowedHidden = immersive || immersiveSticky;
         // transient trumps translucent
         navTranslucent &= !immersiveSticky;
-        navTranslucent &= areTranslucentBarsAllowed();
+        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
+        if (!isKeyguardShowing) {
+            navTranslucent &= areTranslucentBarsAllowed();
+        }
         // bar and ensure the application doesn't see the event.
         if (navVisible || navAllowedHidden) {
             if (mHideNavFakeWindow != null) {
@@ -116,122 +119,125 @@
                     // We currently want to hide the navigation UI.
                     mNavigationBarController.setBarShowingLw(false);
                 }
-                if (navVisible && !navTranslucent && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
+                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                     // If the opaque nav bar is currently requested to be visible,
                     // and not in the process of animating on or off, then
                     // we can tell the app that it is covered by it.
@@ -147,159 +150,162 @@
             }
             // Make sure the content and current rectangles are updated to
             // account for the restrictions from the navigation bar.
-            mContentTop = mCurTop = mDockTop;
-            mContentBottom = mCurBottom = mDockBottom;
-            mContentLeft = mCurLeft = mDockLeft;
-            mContentRight = mCurRight = mDockRight;
+            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
+            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
+            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
+            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
             mStatusBarLayer = mNavigationBar.getSurfaceLayer();
             // And compute the final frame.
-            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf);
+            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame);
             if (DEBUG_LAYOUT)
                 Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
             if (mNavigationBarController.checkHiddenLw()) {
@@ -175,196 +178,201 @@
             vf.bottom = mStableBottom;
             mStatusBarLayer = mStatusBar.getSurfaceLayer();
             // Let the status bar determine its size.
-            mStatusBar.computeFrameLw(pf, df, vf, vf, vf, dcf);
+            mStatusBar.computeFrameLw(pf, df, vf, vf, vf, dcf, vf);
             // For layout, the status bar is always at the top with our fixed height.
             mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
             boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
-            boolean statusBarTranslucent = (sysui & View.STATUS_BAR_TRANSLUCENT) != 0;
-            statusBarTranslucent &= areTranslucentBarsAllowed();
+            boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
+            if (!isKeyguardShowing) {
+                statusBarTranslucent &= areTranslucentBarsAllowed();
+            }
             // windows behind it to scroll.
             if (mStatusBar.isVisibleLw() && !statusBarTransient) {
                 // Status bar may go away, so the screen area it occupies
                 // is available to apps but just covering them when the
                 // status bar is visible.
                 mDockTop = mUnrestrictedScreenTop + mStatusBarHeight;
-                mContentTop = mCurTop = mDockTop;
-                mContentBottom = mCurBottom = mDockBottom;
-                mContentLeft = mCurLeft = mDockLeft;
-                mContentRight = mCurRight = mDockRight;
+                mContentTop = mVoiceContentTop = mCurTop = mDockTop;
+                mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
+                mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
+                mContentRight = mVoiceContentRight = mCurRight = mDockRight;
                 if (DEBUG_LAYOUT)
                     Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
             }

Find a functionally equivalent code:android.content.res.BridgeAssetManager.initSystem:COMMENT
Method Modifier: public      static      
Comment:/**
 * This initializes the static field {@link AssetManager#mSystem} which is used
 * by methods who get a global asset manager using {@link AssetManager#getSystem()}.
 * <p/>
 * They will end up using our bridge asset manager.
 * <p/>
 * {@link Bridge} calls this method after setting up a new bridge.
 */

@@ -3,9 +3,9 @@
         // Note that AssetManager() creates a system AssetManager and we override it
         // with our BridgeAssetManager.
         AssetManager.sSystem = new BridgeAssetManager();
-        AssetManager.sSystem.makeStringBlocks(false);
+        AssetManager.sSystem.makeStringBlocks(null);
     }
     return AssetManager.sSystem;
 }

Find a functionally equivalent code:android.widget.AbsSeekBar.setThumb:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the thumb that will be drawn at the end of the progress meter within the SeekBar.
 * <p>
 * If the thumb is a valid drawable (i.e. not null), half its width will be
 * used as the new thumb offset (@see #setThumbOffset(int)).
 *
 * @param thumb Drawable representing the thumb
 */

@@ -1,5 +1,5 @@
 {
-    boolean needUpdate;
+    final boolean needUpdate;
     // drawable changed)
     if (mThumb != null && thumb != mThumb) {
         mThumb.setCallback(null);
@@ -22,30 +22,31 @@
         }
     }
     mThumb = thumb;
+    applyThumbTint();
     invalidate();
     if (needUpdate) {
-        updateThumbPos(getWidth(), getHeight());
+        updateThumbAndTrackPos(getWidth(), getHeight());
         if (thumb != null && thumb.isStateful()) {
             // Note that if the states are different this won't work.
             // For now, let's consider that an app bug.

Find a functionally equivalent code:android.transition.TransitionManager.changeScene:COMMENT
Method Modifier: private     static      
Comment:/**
 * This is where all of the work of a transition/scene-change is
 * orchestrated. This method captures the start values for the given
 * transition, exits the current Scene, enters the new scene, captures
 * the end values for the transition, and finally plays the
 * resulting values-populated transition.
 *
 * @param scene The scene being entered
 * @param transition The transition to play for this scene change
 */

@@ -1,9 +1,12 @@
 {
     final ViewGroup sceneRoot = scene.getSceneRoot();
-    Transition transitionClone = transition.clone();
-    transitionClone.setSceneRoot(sceneRoot);
+    Transition transitionClone = null;
+    if (transition != null) {
+        transitionClone = transition.clone();
+        transitionClone.setSceneRoot(sceneRoot);
+    }
     Scene oldScene = Scene.getCurrentScene(sceneRoot);
-    if (oldScene != null && oldScene.isCreatedFromLayoutResource()) {
+    if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
         transitionClone.setCanRemoveViews(true);
     }
     sceneChangeSetup(sceneRoot, transitionClone);

Find a functionally equivalent code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

@@ -7,13 +7,13 @@
     mOperatorNumeric = m.getString("operator-numeric");
     mIsManualNetworkSelection = m.getBoolean("manual");
     mRilVoiceRadioTechnology = m.getInt("radioTechnology");
-    mRilVoiceRadioTechnology = m.getInt("dataRadioTechnology");
+    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
     mCssIndicator = m.getBoolean("cssIndicator");
     mNetworkId = m.getInt("networkId");
     mSystemId = m.getInt("systemId");

Find a functionally equivalent code:android.graphics.Path.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clear any lines and curves from the path, making it empty.
 * This does NOT change the fill-type setting.
 */

@@ -1,10 +1,8 @@
 {
     isSimplePath = true;
-    if (mDetectSimplePaths) {
-        mLastDirection = null;
-        if (rects != null)
-            rects.setEmpty();
-    }
+    mLastDirection = null;
+    if (rects != null)
+        rects.setEmpty();
     // We promised not to change this, so preserve it around the native
     // call, which does now reset fill type.
     final FillType fillType = getFillType();

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_VocabularyLoad:COMMENT
Method Modifier: private     static      native      
Comment:// private static native int SR_VocabularyCreate();


Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.removeChild:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a child from its current parent.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#removeChild(Object, IAnimationListener)
 */

@@ -20,26 +20,26 @@
         return SUCCESS.createResult();
     }
     Result result = removeView(parent, childView);
-    if (result.isSuccess() == false) {
+    if (!result.isSuccess()) {
         return result;
     }
     return render(false);

Find a functionally equivalent code:android.widget.CalendarView.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param minDate The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

@@ -1,26 +1,3 @@
 {
-    mTempDate.setTimeInMillis(minDate);
-    if (isSameDate(mTempDate, mMinDate)) {
-        return;
-    }
-    mMinDate.setTimeInMillis(minDate);
-    // make sure the current date is not earlier than
-    // the new min date since the latter is used for
-    // calculating the indices in the adapter thus
-    // avoiding out of bounds error
-    Calendar date = mAdapter.mSelectedDate;
-    if (date.before(mMinDate)) {
-        mAdapter.setSelectedDay(mMinDate);
-    }
-    // reinitialize the adapter since its range depends on min date
-    mAdapter.init();
-    if (date.before(mMinDate)) {
-        setDate(mTempDate.getTimeInMillis());
-    } else {
-        // we go to the current date to force the ListView to query its
-        // adapter for the shown views since we have changed the adapter
-        // range and the base from which the later calculates item indices
-        // note that calling setDate will not work since the date is the same
-        goTo(date, false, true, false);
-    }
+    mDelegate.setMinDate(minDate);
 }

Find a functionally equivalent code:android.media.AudioService.loadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Loads samples into the soundpool.
 * This method must be called at first when sound effects are enabled
 */

@@ -5,11 +5,11 @@
         sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
         while ((reply.mStatus == 1) && (attempts-- > 0)) {
             try {
-                reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
+                reply.wait(SOUND_EFFECTS_LOAD_TIMEOUT_MS);
             } catch (InterruptedException e) {
                 Log.w(TAG, "loadSoundEffects Interrupted while waiting sound pool loaded.");
             }

Find a functionally equivalent code:android.widget.RelativeLayout.LayoutParams.resolveRules:COMMENT
Method Modifier: private     
Comment:// only the "left"/"right" rules at the end.

@@ -44,50 +44,50 @@
             }
             mRules[ALIGN_PARENT_START] = 0;
         }
-        if (mRules[ALIGN_PARENT_RIGHT] == 0) {
+        if (mRules[ALIGN_PARENT_END] != 0) {
             if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                 // "right" rule is not defined but "end" rule is: use the "end" rule as the
                 // "right" rule

Find a functionally equivalent code:android.hardware.SystemSensorManager.TriggerEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

@@ -1,6 +1,9 @@
 {
     final Sensor sensor = sHandleToSensor.get(handle);
-    TriggerEvent t = mTriggerEvents.get(handle);
+    TriggerEvent t = null;
+    synchronized (mTriggerEvents) {
+        t = mTriggerEvents.get(handle);
+    }
     if (t == null) {
         Log.e(TAG, "Error: Trigger Event is null for Sensor: " + sensor);
         return;

Find a functionally equivalent code:android.app.Notification.Style.buildStyled:COMMENT
<android.app.Notification.Style: Notification buildStyled(Notification)>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

@@ -1 +1,7 @@
-
+{
+    populateTickerView(wip);
+    populateContentView(wip);
+    populateBigContentView(wip);
+    populateHeadsUpContentView(wip);
+    return wip;
+}

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.systemBooted:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,8 +1,11 @@
 {
     if (mKeyguardDelegate != null) {
+        mKeyguardDelegate.bindService(mContext);
         mKeyguardDelegate.onBootCompleted();
     }
     synchronized (mLock) {
         mSystemBooted = true;
     }
+    wakingUp();
+    screenTurningOn(null);
 }

Find a functionally equivalent code:android.text.TextLine.set:COMMENT
Method Modifier: 
Comment:/**
 * Initializes a TextLine and prepares it for use.
 *
 * @param paint the base paint for the line
 * @param text the text, can be Styled
 * @param start the start of the line relative to the text
 * @param limit the limit of the line relative to the text
 * @param dir the paragraph direction of this line
 * @param directions the directions information of this line
 * @param hasTabs true if the line might contain tabs or emoji
 * @param tabStops the tabStops. Can be null.
 */

@@ -19,25 +19,25 @@
     mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
     if (mCharsValid) {
         if (mChars == null || mChars.length < mLen) {
-            mChars = new char[ArrayUtils.idealCharArraySize(mLen)];
+            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
         }
         TextUtils.getChars(text, start, limit, mChars, 0);
         if (hasReplacement) {

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientCenter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the center location of the gradient. The radius is honored only when
 * the gradient type is set to {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param x The x coordinate of the gradient's center
 * @param y The y coordinate of the gradient's center
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

@@ -1,5 +1,5 @@
 {
     mGradientState.setGradientCenter(x, y);
-    mRectIsDirty = true;
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.os.Environment.getExternalStorageState:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the current state of the primary "external" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */

@@ -1,4 +1,4 @@
 {
     final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
-    return getStorageState(externalDir);
+    return getExternalStorageState(externalDir);
 }

Find a functionally equivalent code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

@@ -2,30 +2,35 @@
     if (otherOptions.mPackageName != null) {
         mPackageName = otherOptions.mPackageName;
     }
+    mTransitionReceiver = null;
+    mSharedElementNames = null;
+    mIsReturning = false;
+    mResultData = null;
+    mResultCode = 0;
+    mExitCoordinatorIndex = 0;
+    mAnimationType = otherOptions.mAnimationType;
     switch(otherOptions.mAnimationType) {
         case ANIM_CUSTOM:
-            mAnimationType = otherOptions.mAnimationType;
             mCustomEnterResId = otherOptions.mCustomEnterResId;
             mCustomExitResId = otherOptions.mCustomExitResId;
             mThumbnail = null;
-            if (otherOptions.mAnimationStartedListener != null) {
+            if (mAnimationStartedListener != null) {
                 try {
-                    otherOptions.mAnimationStartedListener.sendResult(null);
+                    mAnimationStartedListener.sendResult(null);
                 } catch (RemoteException e) {
                 }
             }
             mAnimationStartedListener = otherOptions.mAnimationStartedListener;
             break;
         case ANIM_SCALE_UP:
-            mAnimationType = otherOptions.mAnimationType;
             mStartX = otherOptions.mStartX;
             mStartY = otherOptions.mStartY;
-            mStartWidth = otherOptions.mStartWidth;
-            mStartHeight = otherOptions.mStartHeight;
-            if (otherOptions.mAnimationStartedListener != null) {
+            mWidth = otherOptions.mWidth;
+            mHeight = otherOptions.mHeight;
+            if (mAnimationStartedListener != null) {
                 try {
-                    otherOptions.mAnimationStartedListener.sendResult(null);
+                    mAnimationStartedListener.sendResult(null);
                 } catch (RemoteException e) {
                 }
             }
@@ -32,48 +37,66 @@
             break;
         case ANIM_THUMBNAIL_SCALE_UP:
         case ANIM_THUMBNAIL_SCALE_DOWN:
-            mAnimationType = otherOptions.mAnimationType;
+        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
+        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
             mThumbnail = otherOptions.mThumbnail;
             mStartX = otherOptions.mStartX;
             mStartY = otherOptions.mStartY;
-            if (otherOptions.mAnimationStartedListener != null) {
+            mWidth = otherOptions.mWidth;
+            mHeight = otherOptions.mHeight;
+            if (mAnimationStartedListener != null) {
                 try {
-                    otherOptions.mAnimationStartedListener.sendResult(null);
+                    mAnimationStartedListener.sendResult(null);
                 } catch (RemoteException e) {
                 }
             }
             mAnimationStartedListener = otherOptions.mAnimationStartedListener;
             break;
+        case ANIM_SCENE_TRANSITION:
+            mTransitionReceiver = otherOptions.mTransitionReceiver;
+            mSharedElementNames = otherOptions.mSharedElementNames;
+            mIsReturning = otherOptions.mIsReturning;
+            mThumbnail = null;
+            mAnimationStartedListener = null;
+            mResultData = otherOptions.mResultData;
+            mResultCode = otherOptions.mResultCode;
+            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
+            break;
     }
 }

Find a functionally equivalent code:javax.obex.ClientOperation.startProcessing:COMMENT
Method Modifier: private     
Comment:/**
 * This method starts the processing thread results. It will send the
 * initial request. If the response takes more then one packet, a thread
 * will be started to handle additional requests
 * @throws IOException if an IO error occurs
 */

@@ -5,18 +5,26 @@
     boolean more = true;
     if (mGetOperation) {
         if (!mOperationDone) {
-            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
-            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
-                more = sendRequest(0x03);
-            }
-            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
-                mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
-            }
-            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+            if (!mGetFinalFlag) {
+                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
+                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
+                    more = sendRequest(0x03);
+                }
+                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
+                }
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mOperationDone = true;
+                }
+            } else {
+                more = sendRequest(0x83);
+                if (more) {
+                    throw new IOException("FINAL_GET forced but data did not fit into single packet!");
+                }
                 mOperationDone = true;
             }
         }

Find a functionally equivalent code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
@@ -13,18 +16,23 @@
             return csl.getDefaultColor();
         }
         return defValue;
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardTransportControlView.populateMetadata:COMMENT
Method Modifier: private     
Comment:/**
 * Populates the given metadata into the view
 */

@@ -10,19 +10,17 @@
         Log.e(TAG, "Couldn't get remote control client package icon", e);
     }
     setBadgeIcon(badgeIcon);
-    if (!TextUtils.isEmpty(mMetadata.trackTitle)) {
-        mTrackTitle.setText(mMetadata.trackTitle);
-    }
-    StringBuilder sb = new StringBuilder();
+    mTrackTitle.setText(!TextUtils.isEmpty(mMetadata.trackTitle) ? mMetadata.trackTitle : null);
+    final StringBuilder sb = new StringBuilder();
     if (!TextUtils.isEmpty(mMetadata.artist)) {
         if (sb.length() != 0) {
             sb.append(" - ");
@@ -26,32 +24,31 @@
         }
         sb.append(mMetadata.albumTitle);
     }
-    mTrackArtistAlbum.setText(sb.toString());
+    final String trackArtistAlbum = sb.toString();
+    mTrackArtistAlbum.setText(!TextUtils.isEmpty(trackArtistAlbum) ? trackArtistAlbum : null);
     if (mMetadata.duration >= 0) {
         setSeekBarsEnabled(true);
         setSeekBarDuration(mMetadata.duration);

Find a functionally equivalent code:android.content.RestrictionEntry.getDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the provided user-visible description of the entry, if any.
 * @return the user-visible description, null if none was set earlier.
 */

@@ -1,3 +1,3 @@
 {
-    return description;
+    return mDescription;
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callAdd:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses {@link ClassWithNative#add(int, int)} via reflection.
 */

@@ -1,5 +1,5 @@
 {
-    Method m = instance.getClass().getMethod("add", new Class<?>[] { int.class, int.class });
-    Object result = m.invoke(instance, new Object[] { a, b });
-    return ((Integer) result).intValue();
+    Method m = instance.getClass().getMethod("add", int.class, int.class);
+    Object result = m.invoke(instance, a, b);
+    return (Integer) result;
 }

Find a functionally equivalent code:android.content.Intent.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,5 +1,99 @@
 {
-    StringBuilder b = new StringBuilder(128);
-    toShortString(b, secure, comp, extras, clip);
-    return b.toString();
+    boolean first = true;
+    if (mAction != null) {
+        b.append("act=").append(mAction);
+        first = false;
+    }
+    if (mCategories != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("cat=[");
+        for (int i = 0; i < mCategories.size(); i++) {
+            if (i > 0)
+                b.append(',');
+            b.append(mCategories.valueAt(i));
+        }
+        b.append("]");
+    }
+    if (mData != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("dat=");
+        if (secure) {
+            b.append(mData.toSafeString());
+        } else {
+            b.append(mData);
+        }
+    }
+    if (mType != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("typ=").append(mType);
+    }
+    if (mFlags != 0) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("flg=0x").append(Integer.toHexString(mFlags));
+    }
+    if (mPackage != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("pkg=").append(mPackage);
+    }
+    if (comp && mComponent != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("cmp=").append(mComponent.flattenToShortString());
+    }
+    if (mSourceBounds != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("bnds=").append(mSourceBounds.toShortString());
+    }
+    if (mClipData != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        if (clip) {
+            b.append("clip={");
+            mClipData.toShortString(b);
+            b.append('}');
+        } else {
+            b.append("(has clip)");
+        }
+    }
+    if (extras && mExtras != null) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("(has extras)");
+    }
+    if (mContentUserHint != UserHandle.USER_CURRENT) {
+        if (!first) {
+            b.append(' ');
+        }
+        first = false;
+        b.append("u=").append(mContentUserHint);
+    }
+    if (mSelector != null) {
+        b.append(" sel=");
+        mSelector.toShortString(b, secure, comp, extras, clip);
+        b.append("}");
+    }
 }

Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.launchActivity:COMMENT
Method Modifier: private     
Comment:/**
 * Launches and activity and queries for errors.
 *
 * @param packageName {@link String} the package name of the application to
 * launch.
 * @return {@link Collection} of {@link ProcessErrorStateInfo} detected
 * during the app launch.
 */

@@ -1,22 +1,18 @@
 {
+    // the recommended way to see if this is a tv or not.
+    boolean isleanback = !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN) && !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
     Intent homeIntent = new Intent(Intent.ACTION_MAIN);
     homeIntent.addCategory(Intent.CATEGORY_HOME);
     homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-    Intent intent = mPackageManager.getLaunchIntentForPackage(packageName);
-    // Skip if the apk does not have a launch intent.
-    if (intent == null) {
-        Log.d(TAG, "Skipping " + packageName + "; missing launch intent");
-        return null;
+    Intent intent;
+    if (isleanback) {
+        Log.d(TAG, "Leanback and relax! " + packageName);
+        intent = mPackageManager.getLeanbackLaunchIntentForPackage(packageName);
+    } else {
+        intent = mPackageManager.getLaunchIntentForPackage(packageName);
     }
-    // We check for any Crash or ANR dialogs that are already up, and we
-    // ignore them. This is
-    // so that we don't report crashes that were caused by prior apps (which
-    // those particular
-    // tests should have caught and reported already). Otherwise, test
-    // failures would cascade
-    // from the initial broken app to many/all of the tests following that
-    // app's launch.
-    final Collection<ProcessErrorStateInfo> preErr = mActivityManager.getProcessesInErrorState();
+    assertNotNull("Skipping " + packageName + "; missing launch intent", intent);
+    String processName = getProcessName(packageName);
     // Launch Activity
     mContext.startActivity(intent);
     try {
@@ -35,43 +31,43 @@
     // much time as
     // possible to occur.
     final Collection<ProcessErrorStateInfo> postErr = mActivityManager.getProcessesInErrorState();
-    // present when we started
-    if (preErr != null && postErr != null) {
-        postErr.removeAll(preErr);
+    if (postErr == null) {
+        return null;
+    }
+    for (ProcessErrorStateInfo error : postErr) {
+        if (error.processName.equals(processName)) {
+            return error;
+        }
     }
-    return postErr;
+    return null;
 }

Find a functionally equivalent code:android.widget.SuggestionsAdapter.newView:COMMENT
Method Modifier: public      
Comment:/**
 * Tags the view with cached child view look-ups.
 */

@@ -1,5 +1,8 @@
 {
-    View v = super.newView(context, cursor, parent);
+    final View v = super.newView(context, cursor, parent);
     v.setTag(new ChildViewCache(v));
+    // Set up icon.
+    final ImageView iconRefine = (ImageView) v.findViewById(R.id.edit_query);
+    iconRefine.setImageResource(mCommitIconResId);
     return v;
 }

Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putString:COMMENT
Method Modifier: public      
Comment:/**
 * Adds textual information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key The identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUM},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUMARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_AUTHOR},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPILATION},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPOSER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DATE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_GENRE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_WRITER}.
 * @param value The text for the given key, or {@code null} to signify there is no valid
 * information for the field.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 */

@@ -1,4 +1,12 @@
 {
     super.putString(key, value);
+    if (mMetadataBuilder != null) {
+        // MediaMetadata supports all the same fields as MetadataEditor
+        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
+        // But just in case, don't add things we don't understand
+        if (metadataKey != null) {
+            mMetadataBuilder.putText(metadataKey, value);
+        }
+    }
     return this;
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupStartValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the start values for an animation.
 * The start values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

@@ -1,3 +1,6 @@
 {
-    setupValue(target, mKeyframeSet.mKeyframes.get(0));
+    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
+    if (!keyframes.isEmpty()) {
+        setupValue(target, keyframes.get(0));
+    }
 }

Find a functionally equivalent code:android.app.Activity.startActivityFromFragment:COMMENT
Method Modifier: public      
Comment:/**
 * This is called when a Fragment in this activity calls its
 * {@link Fragment#startActivity} or {@link Fragment#startActivityForResult}
 * method.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param fragment The fragment making the call.
 * @param intent The intent to start.
 * @param requestCode Reply request code.  < 0 if reply is not requested.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Fragment#startActivity
 * @see Fragment#startActivityForResult
 */

@@ -1,4 +1,7 @@
 {
+    if (options != null) {
+        mActivityTransitionState.startExitOutTransition(this, options);
+    }
     Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, fragment, intent, requestCode, options);
     if (ar != null) {
         mMainThread.sendActivityResult(mToken, fragment.mWho, requestCode, ar.getResultCode(), ar.getResultData());

Find a functionally equivalent code:android.media.RemoteController.MetadataEditor.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies all of the metadata changes that have been set since the MediaMetadataEditor
 * instance was created with {@link RemoteController#editMetadata()}
 * or since {@link #clear()} was called.
 */

@@ -3,22 +3,20 @@
     if (!mMetadataChanged) {
         return;
     }
-    final int genId;
-    synchronized (mGenLock) {
-        genId = mClientGenerationIdCurrent;
-    }
     synchronized (mInfoLock) {
-        if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
-            Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
-            mAudioManager.updateRemoteControlClientMetadata(genId, MediaMetadataEditor.RATING_KEY_BY_USER, rating);
-        } else {
-            Log.e(TAG, "no metadata to apply");
+        if (mCurrentSession != null) {
+            if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
+                Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
+                if (rating != null) {
+                    mCurrentSession.getTransportControls().setRating(rating);
+                }
+            }
         }
-        // NOT setting mApplied to true as this type of MetadataEditor will be applied
-        // multiple times, whenever the user of a RemoteController needs to change the
-        // metadata (e.g. user changes the rating of a song more than once during playback)
-        mApplied = false;
     }
+    // NOT setting mApplied to true as this type of MetadataEditor will be applied
+    // multiple times, whenever the user of a RemoteController needs to change the
+    // metadata (e.g. user changes the rating of a song more than once during playback)
+    mApplied = false;
 }

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

@@ -1,13 +1,4 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return defValue;
-    }
-    if (mResourceData[index] == null) {
-        return defValue;
-    }
-    String s = mResourceData[index].getValue();
-    if (s != null) {
-        return XmlUtils.convertValueToBoolean(s, defValue);
-    }
-    return defValue;
+    String s = getString(index);
+    return s == null ? defValue : XmlUtils.convertValueToBoolean(s, defValue);
 }

Find a functionally equivalent code:android.content.res.AssetManager.retrieveAttributes:COMMENT
Method Modifier: default     final       native      
Comment:/*package*/


Find a functionally equivalent code:android.app.Notification.lightenPayload:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Removes heavyweight parts of the Notification object for archival or for sending to
 * listeners when the full contents are not necessary.
 * @hide
 */

@@ -2,11 +2,15 @@
     tickerView = null;
     contentView = null;
     bigContentView = null;
+    headsUpContentView = null;
     largeIcon = null;
     if (extras != null) {
         extras.remove(Notification.EXTRA_LARGE_ICON);
         extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
         extras.remove(Notification.EXTRA_PICTURE);
+        extras.remove(Notification.EXTRA_BIG_TEXT);
+        // Prevent light notifications from being rebuilt.
+        extras.remove(Builder.EXTRA_NEEDS_REBUILD);
     }
 }

Find a functionally equivalent code:android.app.SharedPreferencesImpl.writeToFile:COMMENT
Method Modifier: private     
Comment:// Note: must hold mWritingToDiskLock

@@ -31,37 +31,37 @@
         str.close();
         ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
         try {
-            final StructStat stat = Libcore.os.stat(mFile.getPath());
+            final StructStat stat = Os.stat(mFile.getPath());
             synchronized (this) {
                 mStatTimestamp = stat.st_mtime;
                 mStatSize = stat.st_size;

Find a functionally equivalent code:android.media.AudioService.sendMasterVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

@@ -1,5 +1,5 @@
 {
-    mVolumePanel.postMasterVolumeChanged(flags);
+    mVolumeController.postMasterVolumeChanged(flags);
     Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
     intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
     intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);

Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.markAsVoiceMail:COMMENT
Method Modifier: internal    
Comment:/* package */

@@ -1,7 +1,7 @@
 {
     mIsVoiceMail = true;
     try {
-        String voiceMailLabel = TelephonyManager.getDefault().getVoiceMailAlphaTag();
+        String voiceMailLabel = TelephonyManager.getDefault().getVoiceMailAlphaTag(subId);
         phoneNumber = voiceMailLabel;
     } catch (SecurityException se) {
         // Should never happen: if this process does not have

Find a functionally equivalent code:android.os.Bundle.getByte:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    return getByte(key, (byte) 0);
+    return super.getByte(key);
 }

Find a functionally equivalent code:android.view.Window.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity of the window, as per the Gravity constants.  This
 * controls how the window manager is positioned in the overall window; it
 * is only useful when using WRAP_CONTENT for the layout width or height.
 *
 * @param gravity The desired gravity constant.
 *
 * @see Gravity
 * @see #setLayout
 */

@@ -1,7 +1,5 @@
 {
     final WindowManager.LayoutParams attrs = getAttributes();
     attrs.gravity = gravity;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.widget.ActivityChooserView.Callbacks.onItemClick:COMMENT
Method Modifier: public      
Comment:// AdapterView#OnItemClickListener

@@ -22,28 +22,29 @@
                     Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                     if (launchIntent != null) {
                         launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-                        mContext.startActivity(launchIntent);
+                        ResolveInfo resolveInfo = mAdapter.getDataModel().getActivity(position);
+                        startActivity(launchIntent, resolveInfo);
                     }
                 }
             }

Find a functionally equivalent code:android.widget.ProgressBar.tileify:COMMENT
Method Modifier: private     
Comment:/**
 * Converts a drawable to a tiled version of itself. It will recursively
 * traverse layer and state list drawables.
 */

@@ -21,34 +21,39 @@
         }
         return out;
     } else if (drawable instanceof BitmapDrawable) {
-        final Bitmap tileBitmap = ((BitmapDrawable) drawable).getBitmap();
+        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
+        final Bitmap tileBitmap = bitmap.getBitmap();
         if (mSampleTile == null) {
             mSampleTile = tileBitmap;
         }
         final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
         final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
         shapeDrawable.getPaint().setShader(bitmapShader);
-        return (clip) ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
+        // Ensure the tint and filter are propagated in the correct order.
+        shapeDrawable.setTintList(bitmap.getTint());
+        shapeDrawable.setTintMode(bitmap.getTintMode());
+        shapeDrawable.setColorFilter(bitmap.getColorFilter());
+        return clip ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
     }
     return drawable;
 }

Find a functionally equivalent code:android.widget.ActivityChooserView.Callbacks.onClick:COMMENT
Method Modifier: public      
Comment:// View.OnClickListener

@@ -6,12 +6,12 @@
         Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
         if (launchIntent != null) {
             launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
-            mContext.startActivity(launchIntent);
+            startActivity(launchIntent, defaultActivity);
         }
     } else if (view == mExpandActivityOverflowButton) {
         mIsSelectingDefaultActivity = false;

Find a functionally equivalent code:android.graphics.Picture.beginRecording:COMMENT
Method Modifier: public      
Comment:/**
 * To record a picture, call beginRecording() and then draw into the Canvas
 * that is returned. Nothing we appear on screen, but all of the draw
 * commands (e.g. {@link Canvas#drawRect(Rect, Paint)}) will be recorded.
 * To stop recording, call endRecording(). After endRecording() the Canvas
 * that was returned must no longer be used, and nothing should be drawn
 * into it.
 */

@@ -1,5 +1,5 @@
 {
-    int ni = nativeBeginRecording(mNativePicture, width, height);
+    long ni = nativeBeginRecording(mNativePicture, width, height);
     mRecordingCanvas = new RecordingCanvas(this, ni);
     return mRecordingCanvas;
 }

Find a functionally equivalent code:android.os.BatteryStats.getScreenOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the screen has been on while the device was
 * running on battery.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.media.RemoteController.getRemoteControlClientPackageName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,9 @@
 {
-    return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
+    if (USE_SESSIONS) {
+        synchronized (mInfoLock) {
+            return mCurrentSession != null ? mCurrentSession.getPackageName() : null;
+        }
+    } else {
+        return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
+    }
 }

Find a functionally equivalent code:android.hardware.SensorManager.getQuaternionFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a normalized quaternion.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
 * quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
 * @param rv the rotation vector to convert
 * @param Q an array of floats in which to store the computed quaternion
 */

@@ -1,5 +1,5 @@
 {
-    if (rv.length == 4) {
+    if (rv.length >= 4) {
         Q[0] = rv[3];
     } else {
         Q[0] = 1 - rv[0] * rv[0] - rv[1] * rv[1] - rv[2] * rv[2];

Find a functionally equivalent code:android.content.res.BridgeTypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

@@ -1,6 +1,3 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return false;
-    }
-    return mResourceData[index] != null;
+    return index >= 0 && index < mResourceData.length && mResourceData[index] != null;
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onPhoneStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onPhoneStateChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the phone state changes. String will be one of:
 * {@link TelephonyManager#EXTRA_STATE_IDLE}
 * {@link TelephonyManager@EXTRA_STATE_RINGING}
 * {@link TelephonyManager#EXTRA_STATE_OFFHOOK
 */


Find a functionally equivalent code:android.service.dreams.DreamService.dispatchKeyShortcutEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,8 +1,8 @@
 {
     if (!mInteractive) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on keyShortcutEvent");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on keyShortcutEvent");
+        wakeUp();
         return true;
     }
     return mWindow.superDispatchKeyShortcutEvent(event);

Find a functionally equivalent code:android.widget.TextView.sendAfterTextChanged:COMMENT
Method Modifier: 
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

@@ -6,9 +6,10 @@
             list.get(i).afterTextChanged(text);
         }
     }
+    hideErrorIfUnchanged();
 }

Find a functionally equivalent code:android.media.AudioService.setMode:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setMode(int)
 */

@@ -1,7 +1,14 @@
 {
+    if (DEBUG_MODE) {
+        Log.v(TAG, "setMode(mode=" + mode + ")");
+    }
     if (!checkAudioSettingsPermission("setMode()")) {
         return;
     }
+    if ((mode == AudioSystem.MODE_IN_CALL) && (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE) != PackageManager.PERMISSION_GRANTED)) {
+        Log.w(TAG, "MODIFY_PHONE_STATE Permission Denial: setMode(MODE_IN_CALL) from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
+        return;
+    }
     if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
         return;
     }

Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolumeHandling:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether volume for the playback associated with this route is fixed
 * ({@link RouteInfo#PLAYBACK_VOLUME_FIXED}) or can modified
 * ({@link RouteInfo#PLAYBACK_VOLUME_VARIABLE}).
 * @param volumeHandling
 */

@@ -1,6 +1,6 @@
 {
     if (mVolumeHandling != volumeHandling) {
         mVolumeHandling = volumeHandling;
-        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING, volumeHandling);
+        configureSessionVolume();
     }
 }

Find a functionally equivalent code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

@@ -1,11 +1,16 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
     if (type == TypedValue.TYPE_NULL) {
         return defValue;
     } else if (type == TypedValue.TYPE_DIMENSION) {
-        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
+        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:android.os.ParcelFileDescriptor.createPipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        final FileDescriptor[] fds = Libcore.os.pipe();
+        final FileDescriptor[] fds = Os.pipe();
         return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
     } catch (ErrnoException e) {
         throw e.rethrowAsIOException();

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.windowTypeToLayerLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -14,53 +14,53 @@
             return 3;
         case TYPE_SEARCH_BAR:
             return 4;
+        case TYPE_VOICE_INTERACTION:
+            // voice interaction layer is almost immediately above apps.
+            return 5;
         case TYPE_RECENTS_OVERLAY:
         case TYPE_SYSTEM_DIALOG:
-            return 5;
+            return 6;
         case TYPE_TOAST:
             // toasts and the plugged-in battery thing
-            return 6;
+            return 7;
         case TYPE_PRIORITY_PHONE:
             // SIM errors and unlock.  Not sure if this really should be in a high layer.
-            return 7;
+            return 8;
         case TYPE_DREAM:
             // used for Dreams (screensavers with TYPE_DREAM windows)
-            return 8;
+            return 9;
         case TYPE_SYSTEM_ALERT:
             // like the ANR / app crashed dialogs
-            return 9;
+            return 10;
         case TYPE_INPUT_METHOD:
             // on-screen keyboards and other such input method user interfaces go here.
-            return 10;
+            return 11;
         case TYPE_INPUT_METHOD_DIALOG:
             // on-screen keyboards and other such input method user interfaces go here.
-            return 11;
+            return 12;
         case TYPE_KEYGUARD_SCRIM:
             // the safety window that shows behind keyguard while keyguard is starting
-            return 12;
-        case TYPE_KEYGUARD:
-            // responsible for power management when displayed.
             return 13;
-        case TYPE_KEYGUARD_DIALOG:
-            return 14;
         case TYPE_STATUS_BAR_SUB_PANEL:
-            return 15;
+            return 14;
         case TYPE_STATUS_BAR:
-            return 16;
+            return 15;
         case TYPE_STATUS_BAR_PANEL:
+            return 16;
+        case TYPE_KEYGUARD_DIALOG:
             return 17;
         case TYPE_VOLUME_OVERLAY:
             // changes the device volume

Find a functionally equivalent code:android.hardware.SystemSensorManager.registerListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -4,10 +4,10 @@
         return false;
     }
     // Trigger Sensors should use the requestTriggerSensor call.
-    if (Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
+    if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
         Log.e(TAG, "Trigger Sensors should use the requestTriggerSensor.");
         return false;
     }

Find a functionally equivalent code:android.provider.Browser.deleteHistoryWhere:COMMENT
Method Modifier: private     static      final       
Comment:/**
 * Helper function to delete all history items and release the icons for them in the
 * {@link WebIconDatabase}.
 *
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr   The ContentResolver used to access the database.
 * @param whereClause   String to limit the items affected.
 * null means all items.
 */

@@ -3,14 +3,8 @@
     try {
         cursor = cr.query(History.CONTENT_URI, new String[] { History.URL }, whereClause, null, null);
         if (cursor.moveToFirst()) {
-            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
-            do {
-                // Delete favicons
-                // TODO don't release if the URL is bookmarked
-                iconDb.releaseIconForPageUrl(cursor.getString(0));
-            } while (cursor.moveToNext());
             cr.delete(History.CONTENT_URI, whereClause, null);
         }
     } catch (IllegalStateException e) {

Find a functionally equivalent code:android.util.SparseBooleanArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -4,26 +4,11 @@
         mValues[i] = value;
     } else {
         i = ~i;
-        if (mSize >= mKeys.length) {
-            int n = ArrayUtils.idealIntArraySize(mSize + 1);
-            int[] nkeys = new int[n];
-            boolean[] nvalues = new boolean[n];
-            // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-        if (mSize - i != 0) {
-            // Log.e("SparseBooleanArray", "move " + (mSize - i));
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleMPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method Profiling w/Streaming Start" request.
     */

@@ -2,8 +2,8 @@
     ByteBuffer in = wrapChunk(request);
     int bufferSize = in.getInt();
     int flags = in.getInt();
-    if (false) {
+    if (DEBUG) {
         Log.v("ddm-heap", "Method prof stream start: size=" + bufferSize + ", flags=" + flags);
     }
     try {

Find a functionally equivalent code:android.media.RemoteControlClient.setOnGetPlaybackPositionListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be called whenever the media current playback position is needed.
 * Queries will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the listener to be called to retrieve the playback position
 */

@@ -1,16 +1,6 @@
 {
     synchronized (mCacheLock) {
-        int oldCapa = mPlaybackPositionCapabilities;
-        if (l != null) {
-            mPlaybackPositionCapabilities |= MEDIA_POSITION_READABLE;
-        } else {
-            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_READABLE;
-        }
         mPositionProvider = l;
-        if (oldCapa != mPlaybackPositionCapabilities) {
-            // tell RCDs that this RCC's playback position capabilities have changed
-            sendTransportControlInfo_syncCacheLock(null);
-        }
         if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
             // playback position is already moving, but now we have a position provider,
             // so schedule a drift check right now

Find a functionally equivalent code:android.os.RecoverySystem.verifyPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently "/system/etc/security/otacerts.zip").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */

@@ -38,57 +38,59 @@
         if (signedData == null) {
             throw new IOException("signedData is null");
         }
-        Collection encCerts = signedData.getCertificates();
+        List<Certificate> encCerts = signedData.getCertificates();
         if (encCerts.isEmpty()) {
             throw new IOException("encCerts is empty");
         }
         // Take the first certificate from the signature (packages
         // should contain only one).
-        Iterator it = encCerts.iterator();
+        Iterator<Certificate> it = encCerts.iterator();
         X509Certificate cert = null;
         if (it.hasNext()) {
-            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            InputStream is = new ByteArrayInputStream(it.next().getEncoded());
+            cert = (X509Certificate) cf.generateCertificate(is);
         } else {
             throw new SignatureException("signature contains no certificates");
         }
-        List sigInfos = signedData.getSignerInfos();
+        List<SignerInfo> sigInfos = signedData.getSignerInfos();
         SignerInfo sigInfo;
         if (!sigInfos.isEmpty()) {
             sigInfo = (SignerInfo) sigInfos.get(0);
@@ -60,69 +62,71 @@
         }
         // Check that the public key of the certificate contained
         // in the package equals one of our trusted public keys.
-        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
+        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
         PublicKey signatureKey = cert.getPublicKey();
         boolean verified = false;
-        for (Certificate c : trusted) {
+        for (X509Certificate c : trusted) {
             if (c.getPublicKey().equals(signatureKey)) {
                 verified = true;
                 break;

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.turnScreenOff:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOff()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Turn screen off

@@ -1,5 +1,5 @@
 {
-    log("Turn screen off");
+    logv("Turn screen off");
     PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
     pm.goToSleep(SystemClock.uptimeMillis());
 }

Find a functionally equivalent code:android.widget.DatePicker.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param maxDate The maximal supported date.
 */

@@ -1,13 +1,3 @@
 {
-    mTempDate.setTimeInMillis(maxDate);
-    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
-        return;
-    }
-    mMaxDate.setTimeInMillis(maxDate);
-    mCalendarView.setMaxDate(maxDate);
-    if (mCurrentDate.after(mMaxDate)) {
-        mCurrentDate.setTimeInMillis(mMaxDate.getTimeInMillis());
-        updateCalendarView();
-    }
-    updateSpinners();
+    mDelegate.setMaxDate(maxDate);
 }

Find a functionally equivalent code:android.graphics.Bitmap.createBitmap:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns an immutable bitmap from the source bitmap. The new bitmap may
 * be the same object as source, or a copy may have been made.  It is
 * initialized with the same density as the original bitmap.
 */


Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleMPRS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method PRofiling Start" request.
     */

@@ -4,10 +4,10 @@
     int flags = in.getInt();
     int len = in.getInt();
     String fileName = getString(in, len);
-    if (false)
+    if (DEBUG)
         Log.v("ddm-heap", "Method profiling start: filename='" + fileName + "', size=" + bufferSize + ", flags=" + flags);
     try {
         Debug.startMethodTracing(fileName, bufferSize, flags);

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetter:COMMENT
Method Modifier: 
Comment:/**
 * Utility function to get the setter from targetClass
 * @param targetClass The Class on which the requested method should exist.
 */

@@ -1,3 +1,4 @@
 {
-    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
+    Class<?> propertyType = mConverter == null ? mValueType : mConverter.getTargetType();
+    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", propertyType);
 }

Find a functionally equivalent code:android.app.ContextImpl.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,6 @@
 {
-    startActivityAsUser(intent, null, user);
+    try {
+        ActivityManagerNative.getDefault().startActivityAsUser(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, null, 0, Intent.FLAG_ACTIVITY_NEW_TASK, null, options, user.getIdentifier());
+    } catch (RemoteException re) {
+    }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.init:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -2,9 +2,11 @@
     mContext = context;
     mWindowManager = windowManager;
     mWindowManagerFuncs = windowManagerFuncs;
-    mHeadless = "1".equals(SystemProperties.get("ro.config.headless", "0"));
+    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
+    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
     mHandler = new PolicyHandler();
+    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
     mOrientationListener = new MyOrientationListener(mContext, mHandler);
     try {
         mOrientationListener.setCurrentRotation(windowManager.getRotation());
@@ -26,31 +28,34 @@
     mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
     mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
     mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
+    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
     mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
     mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
     mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
@@ -37,42 +40,46 @@
     mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
     mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
     readConfigurationDependentBehaviors();
+    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
     // register for dock events
     IntentFilter filter = new IntentFilter();
     filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
@@ -92,97 +96,103 @@
     mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
     mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
     mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
+    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
+    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
     mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
     mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
     mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
@@ -99,107 +105,111 @@
     // Controls rotation and the like.
     initializeHdmiState();
     // Match current screen state.
-    if (mPowerManager.isScreenOn()) {
-        screenTurningOn(null);
-    } else {
-        screenTurnedOff(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
+    if (!mPowerManager.isInteractive()) {
+        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
     }
 }

Find a functionally equivalent code:com.android.internal.os.RuntimeInit.zygoteInit:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * The main function called when started through the zygote process. This
 * could be unified with main(), if the native code in nativeFinishInit()
 * were rationalized with Zygote startup.<p>
 *
 * Current recognized args:
 * <ul>
 * <li> <code> [--] &lt;start class name&gt;  &lt;args&gt;
 * </ul>
 *
 * @param targetSdkVersion target SDK version
 * @param argv arg strings
 */

@@ -4,8 +4,8 @@
     redirectLogStreams();
     commonInit();
     nativeZygoteInit();
-    applicationInit(targetSdkVersion, argv);
+    applicationInit(targetSdkVersion, argv, classLoader);
 }

Find a functionally equivalent code:android.graphics.Canvas.drawLine:COMMENT
Method Modifier: public      
Comment:/**
 * Draw a line segment with the specified start and stop x,y coordinates,
 * using the specified paint.
 *
 * <p>Note that since a line is always "framed", the Style is ignored in the paint.</p>
 *
 * <p>Degenerate lines (length is 0) will not be drawn.</p>
 *
 * @param startX The x-coordinate of the start point of the line
 * @param startY The y-coordinate of the start point of the line
 * @param paint  The paint used to draw the line
 */

@@ -1,3 +1,3 @@
 {
-    native_drawLine(mNativeCanvas, startX, startY, stopX, stopY, paint.mNativePaint);
+    native_drawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.mNativePaint);
 }

Find a functionally equivalent code:android.content.ContentResolver.isSyncPending:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return true if the pending status is true of any matching authorities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if there is a pending sync with the matching account and authority
 */

@@ -1,7 +1,3 @@
 {
-    try {
-        return getContentService().isSyncPending(account, authority);
-    } catch (RemoteException e) {
-        throw new RuntimeException("the ContentService should always be reachable", e);
-    }
+    return isSyncPendingAsUser(account, authority, UserHandle.myUserId());
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGattServer.sendResponse:COMMENT
Method Modifier: public      
Comment:/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */

@@ -1,5 +1,5 @@
 {
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "sendResponse() - device: " + device.getAddress());
     if (mService == null || mServerIf == 0)
         return false;

Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.runOnce:COMMENT
Method Modifier: internal    
Comment:/**
 * Reads one start command from the command socket. If successful,
 * a child is forked and a {@link ZygoteInit.MethodAndArgsCaller}
 * exception is thrown in that child while in the parent process,
 * the method returns normally. On failure, the child is not
 * spawned and messages are printed to the log and stderr. Returns
 * a boolean status value indicating whether an end-of-file on the command
 * socket has been encountered.
 *
 * @return false if command socket should continue to be read from, or
 * true if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()
 * method in child process
 */

@@ -2,7 +2,8 @@
     String[] args;
     Arguments parsedArgs = null;
     FileDescriptor[] descriptors;
+    long startTime = SystemClock.elapsedRealtime();
     try {
         args = readArgumentList();
         descriptors = mSocket.getAncillaryFileDescriptors();
@@ -10,15 +11,17 @@
         closeSocket();
         return true;
     }
+    checkTime(startTime, "zygoteConnection.runOnce: readArgumentList");
     if (args == null) {
         // EOF reached.
         closeSocket();
@@ -27,50 +29,82 @@
     FileDescriptor serverPipeFd = null;
     try {
         parsedArgs = new Arguments(args);
+        if (parsedArgs.abiListQuery) {
+            return handleAbiListQuery();
+        }
+        if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
+            throw new ZygoteSecurityException("Client may not specify capabilities: " + "permitted=0x" + Long.toHexString(parsedArgs.permittedCapabilities) + ", effective=0x" + Long.toHexString(parsedArgs.effectiveCapabilities));
+        }
         applyUidSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyRlimitSecurityPolicy(parsedArgs, peer, peerSecurityContext);
-        applyCapabilitiesSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyInvokeWithSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyseInfoSecurityPolicy(parsedArgs, peer, peerSecurityContext);
+        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
         applyDebuggerSystemProperty(parsedArgs);
         applyInvokeWithSystemProperty(parsedArgs);
+        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
         int[][] rlimits = null;
         if (parsedArgs.rlimits != null) {
             rlimits = parsedArgs.rlimits.toArray(intArray2d);
         }
         if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
-            FileDescriptor[] pipeFds = Libcore.os.pipe();
+            FileDescriptor[] pipeFds = Os.pipe();
             childPipeFd = pipeFds[1];
             serverPipeFd = pipeFds[0];
             ZygoteInit.setCloseOnExec(serverPipeFd, true);
         }
-        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);
+        /**
+         * In order to avoid leaking descriptors to the Zygote child,
+         * the native code must close the two Zygote socket descriptors
+         * in the child process before it switches from Zygote-root to
+         * the UID and privileges of the application being launched.
+         *
+         * In order to avoid "bad file descriptor" errors when the
+         * two LocalSocket objects are closed, the Posix file
+         * descriptors are released via a dup2() call which closes
+         * the socket and substitutes an open descriptor to /dev/null.
+         */
+        int[] fdsToClose = { -1, -1 };
+        FileDescriptor fd = mSocket.getFileDescriptor();
+        if (fd != null) {
+            fdsToClose[0] = fd.getInt$();
+        }
+        fd = ZygoteInit.getServerSocketFileDescriptor();
+        if (fd != null) {
+            fdsToClose[1] = fd.getInt$();
+        }
+        fd = null;
+        checkTime(startTime, "zygoteConnection.runOnce: preForkAndSpecialize");
+        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir);
+        checkTime(startTime, "zygoteConnection.runOnce: postForkAndSpecialize");
     } catch (IOException ex) {
         logAndPrintError(newStderr, "Exception creating pipe", ex);
     } catch (ErrnoException ex) {

Find a functionally equivalent code:android.media.AudioService.sendVolumeUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

@@ -1,8 +1,16 @@
 {
-    if (!mVoiceCapable && (streamType == AudioSystem.STREAM_RING)) {
+    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
         streamType = AudioSystem.STREAM_NOTIFICATION;
     }
-    mVolumePanel.postVolumeChanged(streamType, flags);
+    // only when TV receives volume notification from Audio Receiver.
+    if (mHdmiTvClient != null && streamType == AudioSystem.STREAM_MUSIC) {
+        synchronized (mHdmiTvClient) {
+            if (mHdmiSystemAudioSupported && ((flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) == 0)) {
+                flags &= ~AudioManager.FLAG_SHOW_UI;
+            }
+        }
+    }
+    mVolumeController.postVolumeChanged(streamType, flags);
     if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
         oldIndex = (oldIndex + 5) / 10;
         index = (index + 5) / 10;

Find a functionally equivalent code:android.graphics.Picture.getWidth:COMMENT
<android.graphics.Picture: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the width of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

@@ -1 +1,3 @@
-
+{
+    return nativeGetWidth(mNativePicture);
+}

Find a functionally equivalent code:android.media.MediaFocusControl.registerMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.registerMediaButtonEventReceiverForCalls(ComponentName c)
 * precondition: c != null
 */

@@ -3,9 +3,9 @@
         Log.e(TAG, "Invalid permissions to register media button receiver for calls");
         return;
     }
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         mMediaReceiverForCalls = c;
     }
 }

Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.requestUpdateVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request an incremental volume update for this route.
 * @param direction Delta to apply to the current volume
 */

@@ -7,12 +7,12 @@
             Log.e(TAG, "Error setting local stream volume", e);
         }
     } else {
-        Log.e(TAG, getClass().getSimpleName() + ".requestChangeVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
+        sStatic.requestUpdateVolume(this, direction);
     }
 }

Find a functionally equivalent code:android.view.ViewGroup.offsetChildrenTopAndBottom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Offset the vertical location of all children of this view by the specified number of pixels.
 *
 * @param offset the number of pixels to offset
 *
 * @hide
 */

@@ -6,17 +6,18 @@
         final View v = children[i];
         v.mTop += offset;
         v.mBottom += offset;
-        if (v.mDisplayList != null) {
+        if (v.mRenderNode != null) {
             invalidate = true;
-            v.mDisplayList.offsetTopAndBottom(offset);
+            v.mRenderNode.offsetTopAndBottom(offset);
         }
     }
     if (invalidate) {
         invalidateViewProperty(false, false);
     }
+    notifySubtreeAccessibilityStateChangedIfNeeded();
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.removeConfiguredNetworksAndDisableWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean removeConfiguredNetworksAndDisableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Remove configured networks and disable wifi
 */

@@ -2,11 +2,11 @@
     if (!disconnectAP()) {
         return false;
     }
-    sleep(SHORT_TIMEOUT);
+    SystemClock.sleep(SHORT_TIMEOUT);
     if (!mWifiManager.setWifiEnabled(false)) {
         return false;
     }
-    sleep(SHORT_TIMEOUT);
+    SystemClock.sleep(SHORT_TIMEOUT);
     return true;
 }

Find a functionally equivalent code:android.graphics.Canvas.isOpaque:COMMENT
<android.graphics.Canvas: boolean isOpaque()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return true if the device that the current layer draws into is opaque
 * (i.e. does not support per-pixel alpha).
 *
 * @return true if the device that the current layer draws into is opaque
 */

@@ -1 +1,3 @@
-
+{
+    return native_isOpaque(mNativeCanvasWrapper);
+}

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.notifyLidSwitchChanged:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,7 +1,4 @@
 {
-    // do nothing if headless
-    if (mHeadless)
-        return;
     // lid changed state
     final int newLidState = lidOpen ? LID_OPEN : LID_CLOSED;
     if (newLidState == mLidState) {

Find a functionally equivalent code:android.view.ViewGroup.dispatchDetachedFromWindow:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

@@ -20,24 +20,25 @@
     for (int i = 0; i < count; i++) {
         children[i].dispatchDetachedFromWindow();
     }
+    clearDisappearingChildren();
     super.dispatchDetachedFromWindow();
 }

Find a functionally equivalent code:android.os.Parcel.readSerializable:COMMENT
Method Modifier: public      final       
Comment:/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 */

@@ -1,17 +1,3 @@
 {
-    String name = readString();
-    if (name == null) {
-        // return null, which indicates that the name wasn't found in the parcel.
-        return null;
-    }
-    byte[] serializedData = createByteArray();
-    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
-    try {
-        ObjectInputStream ois = new ObjectInputStream(bais);
-        return (Serializable) ois.readObject();
-    } catch (IOException ioe) {
-        throw new RuntimeException("Parcelable encountered " + "IOException reading a Serializable object (name = " + name + ")", ioe);
-    } catch (ClassNotFoundException cnfe) {
-        throw new RuntimeException("Parcelable encountered" + "ClassNotFoundException reading a Serializable object (name = " + name + ")", cnfe);
-    }
+    return readSerializable(null);
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.DependencyFinder.DependencyVisitor.MyMethodVisitor.visitFieldInsn:COMMENT
Method Modifier: public      
Comment:// field instruction

@@ -1,5 +1,6 @@
 {
-    // name is the field's name.
+    // owner is the class that declares the field.
+    considerName(owner);
     // desc is the field's descriptor (see Type).
     considerDesc(desc);
 }

Find a functionally equivalent code:android.os.storage.IMountService.changeEncryptionPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Changes the encryption password.
 */


Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.launchHomeFromHotKey:COMMENT
Method Modifier: internal    
Comment:/**
 * A home key -> launch home action was detected.  Take the appropriate action
 * given the situation with the keyguard.
 */

@@ -1,11 +1,12 @@
 {
-    if (mKeyguardDelegate != null && mKeyguardDelegate.isShowingAndNotHidden()) {
+    if (mKeyguardDelegate != null && mKeyguardDelegate.isShowingAndNotOccluded()) {
     // don't launch home if keyguard showing
     } else if (!mHideLockScreen && mKeyguardDelegate.isInputRestricted()) {
         // when in keyguard restricted mode, must first verify unlock
         // before launching home
         mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {
 
+            @Override
             public void onKeyguardExitResult(boolean success) {
                 if (success) {
                     try {
@@ -23,29 +24,38 @@
             ActivityManagerNative.getDefault().stopAppSwitches();
         } catch (RemoteException e) {
         }
-        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
-        startDockOrHome();
+        if (mRecentsVisible) {
+            // Hide Recents and notify it to launch Home
+            awakenDreams();
+            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
+            hideRecentApps(false, true);
+        } else {
+            // Otherwise, just launch Home
+            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);
+            startDockOrHome();
+        }
     }
 }

Find a functionally equivalent code:android.text.SpannableStringInternal.setSpan:COMMENT
Method Modifier: 
Comment:/* package */

@@ -29,37 +29,36 @@
         }
     }
     if (mSpanCount + 1 >= mSpans.length) {
-        int newsize = ArrayUtils.idealIntArraySize(mSpanCount + 1);
-        Object[] newtags = new Object[newsize];
-        int[] newdata = new int[newsize * 3];
+        Object[] newtags = ArrayUtils.newUnpaddedObjectArray(GrowingArrayUtils.growSize(mSpanCount));
+        int[] newdata = new int[newtags.length * 3];
         System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
         System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
         mSpans = newtags;

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setStroke:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Set the stroke width and color for the drawable. If width is zero,
 * then no stroke is drawn. This method can also be used to dash the stroke.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param width The width in pixels of the stroke
 * @param color The color of the stroke
 * @param dashWidth The length in pixels of the dashes, set to 0 to disable dashes
 * @param dashGap The gap in pixels between dashes
 *
 * @see #mutate()
 * @see #setStroke(int, int)
 */

@@ -1,15 +1,4 @@
 {
-    mGradientState.setStroke(width, color, dashWidth, dashGap);
-    if (mStrokePaint == null) {
-        mStrokePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-        mStrokePaint.setStyle(Paint.Style.STROKE);
-    }
-    mStrokePaint.setStrokeWidth(width);
-    mStrokePaint.setColor(color);
-    DashPathEffect e = null;
-    if (dashWidth > 0) {
-        e = new DashPathEffect(new float[] { dashWidth, dashGap }, 0);
-    }
-    mStrokePaint.setPathEffect(e);
-    invalidateSelf();
+    mGradientState.setStroke(width, ColorStateList.valueOf(color), dashWidth, dashGap);
+    setStrokeInternal(width, color, dashWidth, dashGap);
 }

Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateSupplicantDetails:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Only updates details fetched from the supplicant @hide
 */


Find a functionally equivalent code:javax.obex.HeaderSet.setHeader:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the value of the header identifier to the value provided. The type
 * of object must correspond to the Java type defined in the description of
 * this interface. If <code>null</code> is passed as the
 * <code>headerValue</code> then the header will be removed from the set of
 * headers to include in the next request.
 * @param headerID the identifier to include in the message
 * @param headerValue the value of the header identifier
 * @throws IllegalArgumentException if the header identifier provided is not
 * one defined in this interface or a user-defined header; if the
 * type of <code>headerValue</code> is not the correct Java type as
 * defined in the description of this interface\
 */

@@ -19,24 +19,25 @@
             if ((headerValue != null) && (!(headerValue instanceof String))) {
                 throw new IllegalArgumentException("Name must be a String");
             }
+            mEmptyName = false;
             mName = (String) headerValue;
             break;
         case TYPE:

Find a functionally equivalent code:android.graphics.drawable.Drawable.createFromXmlInner:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create from inside an XML document.  Called on a parser positioned at
 * a tag in an XML document, tries to create a Drawable from that tag.
 * Returns null if the tag is not a valid drawable.
 */

@@ -1,44 +1,3 @@
 {
-    Drawable drawable;
-    final String name = parser.getName();
-    if (name.equals("selector")) {
-        drawable = new StateListDrawable();
-    } else if (name.equals("level-list")) {
-        drawable = new LevelListDrawable();
-    } else if (name.equals("layer-list")) {
-        drawable = new LayerDrawable();
-    } else if (name.equals("transition")) {
-        drawable = new TransitionDrawable();
-    } else if (name.equals("color")) {
-        drawable = new ColorDrawable();
-    } else if (name.equals("shape")) {
-        drawable = new GradientDrawable();
-    } else if (name.equals("scale")) {
-        drawable = new ScaleDrawable();
-    } else if (name.equals("clip")) {
-        drawable = new ClipDrawable();
-    } else if (name.equals("rotate")) {
-        drawable = new RotateDrawable();
-    } else if (name.equals("animated-rotate")) {
-        drawable = new AnimatedRotateDrawable();
-    } else if (name.equals("animation-list")) {
-        drawable = new AnimationDrawable();
-    } else if (name.equals("inset")) {
-        drawable = new InsetDrawable();
-    } else if (name.equals("bitmap")) {
-        // noinspection deprecation
-        drawable = new BitmapDrawable(r);
-        if (r != null) {
-            ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
-        }
-    } else if (name.equals("nine-patch")) {
-        drawable = new NinePatchDrawable();
-        if (r != null) {
-            ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
-        }
-    } else {
-        throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
-    }
-    drawable.inflate(r, parser, attrs);
-    return drawable;
+    return createFromXmlInner(r, parser, attrs, null);
 }

Find a functionally equivalent code:android.widget.RemoteViews.reapply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies all of the actions to the provided view.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param v The view to apply the actions to.  This should be the result of
 * the {@link #apply(Context,ViewGroup)} call.
 */


Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onDeviceProvisioned:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDeviceProvisioned()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the device becomes provisioned
 */


Find a functionally equivalent code:android.widget.TextView.getShadowColor:COMMENT
Method Modifier: public      
Comment:/**
 * @return the color of the shadow layer
 *
 * @see #setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 */

@@ -1,3 +1,3 @@
 {
-    return mTextPaint.shadowColor;
+    return mShadowColor;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.addStartingWindow:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -58,64 +58,64 @@
         return view.getParent() != null ? view : null;
     } catch (WindowManager.BadTokenException e) {
         // ignore
-        Log.w(TAG, appToken + " already running, starting window not displayed");
+        Log.w(TAG, appToken + " already running, starting window not displayed. " + e.getMessage());
     } catch (RuntimeException e) {
         // don't crash if something else bad happens, for example a
         // failure loading resources because we are loading from an app

Find a functionally equivalent code:android.hardware.camera2.CameraMetadata.getKeysStatic:COMMENT
Method Modifier: default     static      
Comment:/*package*/

@@ -1,19 +1,35 @@
 {
-    ArrayList<Key<?>> keyList = new ArrayList<Key<?>>();
+    if (VERBOSE)
+        Log.v(TAG, "getKeysStatic for " + type);
+    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
+    if (type.equals(TotalCaptureResult.class)) {
+        type = CaptureResult.class;
+    }
+    if (filterTags != null) {
+        Arrays.sort(filterTags);
+    }
+    ArrayList<TKey> keyList = new ArrayList<TKey>();
     Field[] fields = type.getDeclaredFields();
     for (Field field : fields) {
         // Filter for Keys that are public
-        if (field.getType().isAssignableFrom(Key.class) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
-            Key<?> key;
+        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
+            TKey key;
             try {
-                key = (Key<?>) field.get(instance);
+                key = (TKey) field.get(instance);
             } catch (IllegalAccessException e) {
                 throw new AssertionError("Can't get IllegalAccessException", e);
             } catch (IllegalArgumentException e) {
                 throw new AssertionError("Can't get IllegalArgumentException", e);
             }
-            if (instance == null || instance.get(key) != null) {
-                keyList.add(key);
+            if (instance == null || instance.getProtected(key) != null) {
+                if (shouldKeyBeAdded(key, field, filterTags)) {
+                    keyList.add(key);
+                    if (VERBOSE) {
+                        Log.v(TAG, "getKeysStatic - key was added - " + key);
+                    }
+                } else if (VERBOSE) {
+                    Log.v(TAG, "getKeysStatic - key was filtered - " + key);
+                }
             }
         }
     }

Find a functionally equivalent code:android.provider.DocumentsContract.createDocument:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

@@ -1,8 +1,8 @@
 {
     final Bundle in = new Bundle();
-    in.putString(Document.COLUMN_DOCUMENT_ID, getDocumentId(parentDocumentUri));
+    in.putParcelable(DocumentsContract.EXTRA_URI, parentDocumentUri);
     in.putString(Document.COLUMN_MIME_TYPE, mimeType);
     in.putString(Document.COLUMN_DISPLAY_NAME, displayName);
     final Bundle out = client.call(METHOD_CREATE_DOCUMENT, null, in);
-    return buildDocumentUri(parentDocumentUri.getAuthority(), out.getString(Document.COLUMN_DOCUMENT_ID));
+    return out.getParcelable(DocumentsContract.EXTRA_URI);
 }

Find a functionally equivalent code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureResultKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */

@@ -1,6 +1,12 @@
 {
     if (mAvailableResultKeys == null) {
-        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class);
+        Object crKey = CaptureResult.Key.class;
+        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
+        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
+        if (filterTags == null) {
+            throw new AssertionError("android.request.availableResultKeys must be non-null " + "in the characteristics");
+        }
+        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags);
     }
     return mAvailableResultKeys;
 }

Find a functionally equivalent code:android.hardware.input.InputManager.InputDeviceVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,10 @@
 {
-    vibrate(pattern, repeat);
+    if (repeat >= pattern.length) {
+        throw new ArrayIndexOutOfBoundsException();
+    }
+    try {
+        mIm.vibrate(mDeviceId, pattern, repeat, mToken);
+    } catch (RemoteException ex) {
+        Log.w(TAG, "Failed to vibrate.", ex);
+    }
 }

Find a functionally equivalent code:android.animation.AnimatorSet.start:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
 * it is responsible. The details of when exactly those animations are started depends on
 * the dependency relationships that have been set up between the animations.
 */

@@ -2,7 +2,10 @@
     mTerminated = false;
     mStarted = true;
     mPaused = false;
+    for (Node node : mNodes) {
+        node.animation.setAllowRunningAsynchronously(false);
+    }
     if (mDuration >= 0) {
         // If the duration was set on this AnimatorSet, pass it along to all child animations
         for (Node node : mNodes) {

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserRemoved:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserRemoved(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when a user is removed.
 */


Find a functionally equivalent code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: 
Comment:/**
 * Clears the state of this instance.
 */

@@ -1,6 +1,6 @@
 {
     mSealed = false;
-    mBooleanProperties = PROPERTY_IMPORTANT_FOR_ACCESSIBILITY;
+    mBooleanProperties = 0;
     mCurrentItemIndex = UNDEFINED;
     mItemCount = UNDEFINED;
     mFromIndex = UNDEFINED;

Find a functionally equivalent code:android.widget.ActivityChooserModel.loadActivitiesIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * Loads the activities for the current intent if needed which is
 * if they are not already loaded for the current intent.
 *
 * @return Whether loading was performed.
 */

@@ -6,12 +6,15 @@
         final int resolveInfoCount = resolveInfos.size();
         for (int i = 0; i < resolveInfoCount; i++) {
             ResolveInfo resolveInfo = resolveInfos.get(i);
-            mActivities.add(new ActivityResolveInfo(resolveInfo));
+            ActivityInfo activityInfo = resolveInfo.activityInfo;
+            if (ActivityManager.checkComponentPermission(activityInfo.permission, android.os.Process.myUid(), activityInfo.applicationInfo.uid, activityInfo.exported) == PackageManager.PERMISSION_GRANTED) {
+                mActivities.add(new ActivityResolveInfo(resolveInfo));
+            }
         }
         return true;
     }

Find a functionally equivalent code:android.widget.FastScroller.setAlwaysShow:COMMENT
Method Modifier: public      
Comment:/**
 * @param alwaysShow Whether the fast scroll thumb should always be shown
 */

@@ -1,6 +1,6 @@
 {
     if (mAlwaysShow != alwaysShow) {
         mAlwaysShow = alwaysShow;
-        onStateDependencyChanged();
+        onStateDependencyChanged(false);
     }
 }

Find a functionally equivalent code:android.media.MediaFocusControl.dispatchMediaKeyEvent:COMMENT
Method Modifier: private     
Comment:/**
 * Handles the dispatching of the media button events to one of the registered listeners,
 * or if there was none, broadcast an ACTION_MEDIA_BUTTON intent to the rest of the system.
 * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
 * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
 * is dispatched.
 */

@@ -4,17 +4,17 @@
     }
     Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
     keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
-    synchronized (mRCStack) {
-        if (!mRCStack.empty()) {
+    synchronized (mPRStack) {
+        if (!mPRStack.empty()) {
             // send the intent that was registered by the client
             try {
-                mRCStack.peek().mMediaIntent.send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
+                mPRStack.peek().getMediaButtonIntent().send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
                 keyIntent, this, mEventHandler);
             } catch (CanceledException e) {
-                Log.e(TAG, "Error sending pending intent " + mRCStack.peek());
+                Log.e(TAG, "Error sending pending intent " + mPRStack.peek());
                 e.printStackTrace();
             }
         } else {

Find a functionally equivalent code:android.widget.EdgeEffect.onRelease:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the object is released after being pulled.
 * This will begin the "decay" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */

@@ -4,15 +4,11 @@
         return;
     }
     mState = STATE_RECEDE;
-    mEdgeAlphaStart = mEdgeAlpha;
-    mEdgeScaleYStart = mEdgeScaleY;
     mGlowAlphaStart = mGlowAlpha;
     mGlowScaleYStart = mGlowScaleY;
-    mEdgeAlphaFinish = 0.f;
-    mEdgeScaleYFinish = 0.f;
     mGlowAlphaFinish = 0.f;
     mGlowScaleYFinish = 0.f;
     mStartTime = AnimationUtils.currentAnimationTimeMillis();

Find a functionally equivalent code:android.widget.CalendarView.getFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the first day of week.
 *
 * @return The first day of the week conforming to the {@link CalendarView}
 * APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

@@ -1,3 +1,3 @@
 {
-    return mFirstDayOfWeek;
+    return mDelegate.getFirstDayOfWeek();
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.turnScreenOn:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOn()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Turn screen on

@@ -1,5 +1,5 @@
 {
-    log("Turn screen on");
+    logv("Turn screen on");
     PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
     pm.wakeUp(SystemClock.uptimeMillis());
     // disable lock screen

Find a functionally equivalent code:android.widget.FastScroller.isPointInside:COMMENT
Method Modifier: private     
Comment:/**
 * Returns whether a coordinate is inside the scroller's activation area. If
 * there is a track image, touching anywhere within the thumb-width of the
 * track activates scrolling. Otherwise, the user has to touch inside thumb
 * itself.
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return Whether the coordinate is inside the scroller's activation area.
 */

@@ -1,3 +1,3 @@
 {
-    return isPointInsideX(x) && (mHasTrackImage || isPointInsideY(y));
+    return isPointInsideX(x) && (mTrackDrawable != null || isPointInsideY(y));
 }

Find a functionally equivalent code:android.media.RemoteController.setArtworkConfiguration:COMMENT
Method Modifier: public      
Comment:/**
 * Set the maximum artwork image dimensions to be received in the metadata.
 * No bitmaps will be received unless this has been specified.
 * @param width the maximum width in pixels
 * @param height  the maximum height in pixels
 * @return true if the artwork dimension was successfully set.
 * @throws IllegalArgumentException
 */


Find a functionally equivalent code:android.media.AudioService.setStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setStreamVolume(int, int, int)
 */

@@ -1,50 +1,3 @@
 {
-    if (mUseFixedVolume) {
-        return;
-    }
-    ensureValidStreamType(streamType);
-    int streamTypeAlias = mStreamVolumeAlias[streamType];
-    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
-    final int device = getDeviceForStream(streamType);
-    int oldIndex;
-    // is not an a2dp device
-    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
-        return;
-    }
-    if (mAppOps.noteOp(STEAM_VOLUME_OPS[streamTypeAlias], Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
-        return;
-    }
-    synchronized (mSafeMediaVolumeState) {
-        // reset any pending volume command
-        mPendingVolumeCommand = null;
-        oldIndex = streamState.getIndex(device);
-        index = rescaleIndex(index * 10, streamType, streamTypeAlias);
-        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
-            synchronized (mA2dpAvrcpLock) {
-                if (mA2dp != null && mAvrcpAbsVolSupported) {
-                    mA2dp.setAvrcpAbsoluteVolume(index);
-                }
-            }
-        }
-        flags &= ~AudioManager.FLAG_FIXED_VOLUME;
-        if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
-            flags |= AudioManager.FLAG_FIXED_VOLUME;
-            // volume is either 0 or max allowed for fixed volume devices
-            if (index != 0) {
-                if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
-                    index = mSafeMediaVolumeIndex;
-                } else {
-                    index = streamState.getMaxIndex();
-                }
-            }
-        }
-        if (!checkSafeMediaVolume(streamTypeAlias, index, device)) {
-            mVolumePanel.postDisplaySafeVolumeWarning(flags);
-            mPendingVolumeCommand = new StreamVolumeCommand(streamType, index, flags, device);
-        } else {
-            onSetStreamVolume(streamType, index, flags, device);
-            index = mStreamStates[streamType].getIndex(device);
-        }
-    }
-    sendVolumeUpdate(streamType, oldIndex, index, flags);
+    setStreamVolume(streamType, index, flags, callingPackage, Binder.getCallingUid());
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.checkPasswordHistory:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Check to see if a password matches any of the passwords stored in the
 * password history.
 *
 * @param password The password to check.
 * @return Whether the password matches any in the history.
 */

@@ -1,5 +1,5 @@
 {
-    String passwordHashString = new String(passwordToHash(password));
+    String passwordHashString = new String(passwordToHash(password, getCurrentOrCallingUserId()));
     String passwordHistory = getString(PASSWORD_HISTORY_KEY);
     if (passwordHistory == null) {
         return false;

Find a functionally equivalent code:android.media.MediaFocusControl.setNewRcClientOnDisplays_syncRcsCurrc:COMMENT
Method Modifier: private     
Comment:/**
 * Update the remote control displays with the new "focused" client generation
 */

@@ -1,5 +1,5 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         if (mRcDisplays.size() > 0) {
             final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
             while (displayIterator.hasNext()) {

Find a functionally equivalent code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

@@ -34,44 +34,45 @@
         }
         Object[] args = mConstructorArgs;
         args[1] = attrs;
+        constructor.setAccessible(true);
         final View view = constructor.newInstance(args);
         if (view instanceof ViewStub) {
-            // always use ourselves when inflating ViewStub later
+            // Use the same context when inflating ViewStub later.
             final ViewStub viewStub = (ViewStub) view;
-            viewStub.setLayoutInflater(this);
+            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
         }
         return view;
     } catch (NoSuchMethodException e) {

Find a functionally equivalent code:android.content.res.TypedArray.length:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of values in this array.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return mLength;
 }

Find a functionally equivalent code:android.text.GraphicsOperations.getTextRunAdvances:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Paint#getTextRunAdvances}.
 * @hide
 */


Find a functionally equivalent code:android.print.PrintManager.getGlobalPrintManagerForUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates an instance that can access all print jobs.
 *
 * @param userId The user id for which to get all print jobs.
 * @return An instance if the caller has the permission to access all print
 * jobs, null otherwise.
 * @hide
 */

@@ -1,3 +1,7 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return null;
+    }
     return new PrintManager(mContext, mService, userId, APP_ID_ANY);
 }

Find a functionally equivalent code:com.android.internal.widget.RotarySelector.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

@@ -4,9 +4,9 @@
         if (mVibrator == null) {
             mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
         }
-        mVibrator.vibrate(duration);
+        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
     }
 }

Find a functionally equivalent code:android.widget.Switch.setThumbResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param resId Resource ID of a thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

@@ -1,3 +1,3 @@
 {
-    setThumbDrawable(getContext().getResources().getDrawable(resId));
+    setThumbDrawable(getContext().getDrawable(resId));
 }

Find a functionally equivalent code:android.content.res.ColorStateList.withAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new ColorStateList that has the same states and
 * colors as this one but where each color has the specified alpha value
 * (0-255).
 */

@@ -1,6 +1,6 @@
 {
-    int[] colors = new int[mColors.length];
-    int len = colors.length;
+    final int[] colors = new int[mColors.length];
+    final int len = colors.length;
     for (int i = 0; i < len; i++) {
         colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
     }

Find a functionally equivalent code:android.content.Intent.parseIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parses the "intent" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named "intent"), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name="xxx"> tags to add categories and
 * <extra android:name="xxx" android:value="yyy"> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an "intent" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */

@@ -18,24 +18,24 @@
             continue;
         }
         String nodeName = parser.getName();
-        if (nodeName.equals("category")) {
+        if (nodeName.equals(TAG_CATEGORIES)) {
             sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
             String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
             sa.recycle();
@@ -26,36 +26,36 @@
                 intent.addCategory(cat);
             }
             XmlUtils.skipCurrentTag(parser);
-        } else if (nodeName.equals("extra")) {
+        } else if (nodeName.equals(TAG_EXTRA)) {
             if (intent.mExtras == null) {
                 intent.mExtras = new Bundle();
             }
-            resources.parseBundleExtra("extra", attrs, intent.mExtras);
+            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
             XmlUtils.skipCurrentTag(parser);
         } else {
             XmlUtils.skipCurrentTag(parser);

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleSwitching:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching back and forth from having connectivity to
 * having no connectivity using both WiFi and airplane mode.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

@@ -1,6 +1,6 @@
 {
-    String filename = DOWNLOAD_5MB_FILENAME;
-    long filesize = DOWNLOAD_5MB_FILESIZE;
+    String filename = DOWNLOAD_FILENAME;
+    long filesize = DOWNLOAD_FILESIZE;
     doCommonDownloadSetup();
     String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
     File downloadedFile = new File(localDownloadDirectory, filename);
@@ -19,51 +19,53 @@
         dlRequest = mDownloadManager.enqueue(request);
         waitForDownloadToStart(dlRequest);
         // make sure we're starting to download some data...
-        waitForFileToGrow(downloadedFile);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download disable
         setWiFiStateOn(false);
         // download disable
         Log.i(LOG_TAG, "Turning on airplane mode...");
         setAirplaneModeOn(true);
-        // wait 30 secs
-        Thread.sleep(30 * 1000);
+        // wait 5 secs
+        Thread.sleep(5 * 1000);
         // download disable
         setWiFiStateOn(true);
-        // wait 30 secs
-        Thread.sleep(30 * 1000);
+        // wait 5 secs
+        Thread.sleep(5 * 1000);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download enable
         Log.i(LOG_TAG, "Turning off airplane mode...");
         setAirplaneModeOn(false);
         // wait 5 seconds
         Thread.sleep(5 * 1000);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download disable
         Log.i(LOG_TAG, "Turning off WiFi...");
         setWiFiStateOn(false);
-        // wait 30 secs
-        Thread.sleep(30 * 1000);
+        // wait 5 secs
+        Thread.sleep(5 * 1000);
         // finally, turn WiFi back on and finish up the download
         Log.i(LOG_TAG, "Turning on WiFi...");
         setWiFiStateOn(true);
-        Log.i(LOG_TAG, "Waiting up to 3 minutes for download to complete...");
-        waitForDownloadsOrTimeout(dlRequest, 3 * 60 * 1000);
+        Log.i(LOG_TAG, "Waiting up to 10 minutes for download to complete...");
+        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
         ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
         verifyFileSize(pfd, filesize);
     } finally {

Find a functionally equivalent code:android.widget.DatePicker.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default maximal date is 12/31/2100.
 * <p>
 *
 * @return The maximal supported date.
 */

@@ -1,3 +1,3 @@
 {
-    return mCalendarView.getMaxDate();
+    return mDelegate.getMaxDate().getTimeInMillis();
 }

Find a functionally equivalent code:android.view.Window.setDimAmount:COMMENT
Method Modifier: public      
Comment:/**
 * Set the amount of dim behind the window when using
 * {@link WindowManager.LayoutParams#FLAG_DIM_BEHIND}.  This overrides
 * the default dim amount of that is selected by the Window based on
 * its theme.
 *
 * @param amount The new dim amount, from 0 for no dim to 1 for full dim.
 */

@@ -2,8 +2,6 @@
     final WindowManager.LayoutParams attrs = getAttributes();
     attrs.dimAmount = amount;
     mHaveDimAmount = true;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.appwidget.AppWidgetHostView.updateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */

@@ -33,39 +33,39 @@
     } else {
         // Prepare a local reference to the remote Context so we're ready to
         // inflate any requested LayoutParams.
-        mRemoteContext = getRemoteContext(remoteViews);
+        mRemoteContext = getRemoteContext();
         int layoutId = remoteViews.getLayoutId();
         // layout matches, try recycling it
         if (content == null && layoutId == mLayoutId) {

Find a functionally equivalent code:android.content.res.TypedArray.getIndexCount:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of indices in the array that actually have data.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return mIndices[0];
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.handleKeyguardVisibilityChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Handle {@link #MSG_KEYGUARD_VISIBILITY_CHANGED}
 */

@@ -6,12 +6,12 @@
     for (int i = 0; i < mCallbacks.size(); i++) {
         KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
         if (cb != null) {
-            cb.onKeyguardVisibilityChanged(isShowing);
+            cb.onKeyguardVisibilityChangedRaw(isShowing);
         }
     }
 }

Find a functionally equivalent code:android.util.EventLog.Event.getData:COMMENT
Method Modifier: public      
Comment:/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */

@@ -1,8 +1,12 @@
 {
     try {
-        mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
+        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
+        if (offset == 0) {
+            offset = V1_PAYLOAD_START;
+        }
+        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
         // Just after the tag.
-        mBuffer.position(DATA_START);
+        mBuffer.position(offset + DATA_OFFSET);
         return decodeObject();
     } catch (IllegalArgumentException e) {
         Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);

Find a functionally equivalent code:android.app.SearchDialog.updateSearchBadge:COMMENT
Method Modifier: private     
Comment:/**
 * Setup the search "Badge" if requested by mode flags.
 */

@@ -5,11 +5,11 @@
     CharSequence text = null;
     // optionally show one or the other.
     if (mSearchable.useBadgeIcon()) {
-        icon = mActivityContext.getResources().getDrawable(mSearchable.getIconId());
+        icon = mActivityContext.getDrawable(mSearchable.getIconId());
         visibility = View.VISIBLE;
         if (DBG)
             Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());

Find a functionally equivalent code:android.content.Intent.migrateExtraStreamToClipData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
 * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
 * intents in {@link #ACTION_CHOOSER}.
 *
 * @return Whether any contents were migrated.
 * @hide
 */

@@ -7,26 +7,37 @@
         return false;
     final String action = getAction();
     if (ACTION_CHOOSER.equals(action)) {
+        // Inspect contained intents to see if we need to migrate extras. We
+        // don't promote ClipData to the parent, since ChooserActivity will
+        // already start the picked item as the caller, and we can't combine
+        // the flags in a safe way.
+        boolean migrated = false;
         try {
-            // Inspect target intent to see if we need to migrate
-            final Intent target = getParcelableExtra(EXTRA_INTENT);
-            if (target != null && target.migrateExtraStreamToClipData()) {
-                // Since we migrated in child, we need to promote ClipData
-                // and flags to ourselves to grant.
-                setClipData(target.getClipData());
-                addFlags(target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION));
-                return true;
-            } else {
-                return false;
+            final Intent intent = getParcelableExtra(EXTRA_INTENT);
+            if (intent != null) {
+                migrated |= intent.migrateExtraStreamToClipData();
+            }
+        } catch (ClassCastException e) {
+        }
+        try {
+            final Parcelable[] intents = getParcelableArrayExtra(EXTRA_INITIAL_INTENTS);
+            if (intents != null) {
+                for (int i = 0; i < intents.length; i++) {
+                    final Intent intent = (Intent) intents[i];
+                    if (intent != null) {
+                        migrated |= intent.migrateExtraStreamToClipData();
+                    }
+                }
             }
         } catch (ClassCastException e) {
         }
+        return migrated;
     } else if (ACTION_SEND.equals(action)) {
         try {
             final Uri stream = getParcelableExtra(EXTRA_STREAM);
@@ -68,73 +79,96 @@
             }
         } catch (ClassCastException e) {
         }
+    } else if (MediaStore.ACTION_IMAGE_CAPTURE.equals(action) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(action) || MediaStore.ACTION_VIDEO_CAPTURE.equals(action)) {
+        final Uri output;
+        try {
+            output = getParcelableExtra(MediaStore.EXTRA_OUTPUT);
+        } catch (ClassCastException e) {
+            return false;
+        }
+        if (output != null) {
+            setClipData(ClipData.newRawUri("", output));
+            addFlags(FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_READ_URI_PERMISSION);
+            return true;
+        }
     }
     return false;
 }

Find a functionally equivalent code:android.service.dreams.DreamService.setScreenBright:COMMENT
Method Modifier: public      
Comment:/**
 * Marks this dream as keeping the screen bright while dreaming.
 *
 * @param screenBright True to keep the screen bright while dreaming.
 */

@@ -1,5 +1,7 @@
 {
-    mScreenBright = screenBright;
-    int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
-    applyWindowFlags(mScreenBright ? flag : 0, flag);
+    if (mScreenBright != screenBright) {
+        mScreenBright = screenBright;
+        int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
+        applyWindowFlags(mScreenBright ? flag : 0, flag);
+    }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.preparePanel:COMMENT
Method Modifier: public      final       internal    
Comment:/**
 * Prepares the panel to either be opened or chorded. This creates the Menu
 * instance for the panel and populates it via the Activity callbacks.
 *
 * @param st The panel state to prepare.
 * @param event The event that triggered the preparing of the panel.
 * @return Whether the panel was prepared. If the panel should not be shown,
 * returns false.
 */

@@ -15,24 +15,24 @@
         st.createdPanelView = cb.onCreatePanelView(st.featureId);
     }
     final boolean isActionBarMenu = (st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR);
-    if (isActionBarMenu && mActionBar != null) {
+    if (isActionBarMenu && mDecorContentParent != null) {
         // Enforce ordering guarantees around events so that the action bar never
         // dispatches menu-related events before the panel is prepared.
-        mActionBar.setMenuPrepared();
+        mDecorContentParent.setMenuPrepared();
     }
     if (st.createdPanelView == null) {
         // Init the panel state's menu--return false if init failed
@@ -28,38 +28,38 @@
                     return false;
                 }
             }
-            if (isActionBarMenu && mActionBar != null) {
+            if (isActionBarMenu && mDecorContentParent != null) {
                 if (mActionMenuPresenterCallback == null) {
                     mActionMenuPresenterCallback = new ActionMenuPresenterCallback();
                 }
-                mActionBar.setMenu(st.menu, mActionMenuPresenterCallback);
+                mDecorContentParent.setMenu(st.menu, mActionMenuPresenterCallback);
             }
             // Call callback, and return if it doesn't want to display menu.
             // Creating the panel menu will involve a lot of manipulation;
@@ -41,49 +41,49 @@
             if ((cb == null) || !cb.onCreatePanelMenu(st.featureId, st.menu)) {
                 // Ditch the menu created above
                 st.setMenu(null);
-                if (isActionBarMenu && mActionBar != null) {
+                if (isActionBarMenu && mDecorContentParent != null) {
                     // Don't show it in the action bar either
-                    mActionBar.setMenu(null, mActionMenuPresenterCallback);
+                    mDecorContentParent.setMenu(null, mActionMenuPresenterCallback);
                 }
                 return false;
             }
@@ -59,68 +59,68 @@
             st.frozenActionViewState = null;
         }
         if (!cb.onPreparePanel(st.featureId, st.createdPanelView, st.menu)) {
-            if (isActionBarMenu && mActionBar != null) {
+            if (isActionBarMenu && mDecorContentParent != null) {
                 // The app didn't want to show the menu for now but it still exists.
                 // Clear it out of the action bar.
-                mActionBar.setMenu(null, mActionMenuPresenterCallback);
+                mDecorContentParent.setMenu(null, mActionMenuPresenterCallback);
             }
             st.menu.startDispatchingItemsChanged();
             return false;

Find a functionally equivalent code:android.speech.tts.TextToSpeech.addEarcon:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>"[tick]"</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>"com.google.marvin.compass"</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */


Find a functionally equivalent code:android.service.dreams.DreamService.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -2,9 +2,9 @@
     // but finish()es on any other kind of activity
     if (!mInteractive) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on touchEvent");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on touchEvent");
+        wakeUp();
         return true;
     }
     return mWindow.superDispatchTouchEvent(event);

Find a functionally equivalent code:android.os.Parcel.readValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */

@@ -44,50 +44,50 @@
         case VAL_BYTE:
             return readByte();
         case VAL_SERIALIZABLE:
-            return readSerializable();
+            return readSerializable(loader);
         case VAL_PARCELABLEARRAY:
             return readParcelableArray(loader);
         case VAL_SPARSEARRAY:
@@ -54,59 +54,65 @@
         case VAL_BUNDLE:
             // loading will be deferred
             return readBundle(loader);
+        case VAL_PERSISTABLEBUNDLE:
+            return readPersistableBundle(loader);
+        case VAL_SIZE:
+            return readSize();
+        case VAL_SIZEF:
+            return readSizeF();
         default:
             int off = dataPosition() - 4;
             throw new RuntimeException("Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);

Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.onItemsChanged:COMMENT
<com.android.internal.view.menu.MenuBuilder: void onItemsChanged(boolean)>
Method Modifier: public      internal    
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Called when an item is added or removed.
 *
 * @param structureChanged true if the menu structure changed,
 * false if only item properties changed.
 * (Visibility is a structural property since it affects layout.)
 */


Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the view for which the view represented by this info serves as a
 * label for accessibility purposes.
 *
 * @param labeled The view for which this info serves as a label.
 */

@@ -1,3 +1,3 @@
 {
-    setLabelFor(labeled, UNDEFINED);
+    setLabelFor(labeled, UNDEFINED_ITEM_ID);
 }

Find a functionally equivalent code:android.text.Layout.drawBackground:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -36,49 +36,43 @@
                             // construction
                             if (mLineBackgroundSpans.spanStarts[j] >= end || mLineBackgroundSpans.spanEnds[j] <= start)
                                 continue;
-                            if (spansLength == spans.length) {
-                                // The spans array needs to be expanded
-                                int newSize = ArrayUtils.idealObjectArraySize(2 * spansLength);
-                                ParagraphStyle[] newSpans = new ParagraphStyle[newSize];
-                                System.arraycopy(spans, 0, newSpans, 0, spansLength);
-                                spans = newSpans;
-                            }
-                            spans[spansLength++] = mLineBackgroundSpans.spans[j];
+                            spans = GrowingArrayUtils.append(spans, spansLength, mLineBackgroundSpans.spans[j]);
+                            spansLength++;
                         }
                     }
                 }

Find a functionally equivalent code:android.widget.ShareActionProvider.setActivityChooserPolicyIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * Set the activity chooser policy of the model backed by the current
 * share history file if needed which is if there is a registered callback.
 */

@@ -3,9 +3,9 @@
         return;
     }
     if (mOnChooseActivityListener == null) {
-        mOnChooseActivityListener = new ShareAcitivityChooserModelPolicy();
+        mOnChooseActivityListener = new ShareActivityChooserModelPolicy();
     }
     ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
     dataModel.setOnChooseActivityListener(mOnChooseActivityListener);

Find a functionally equivalent code:android.util.SparseLongArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -4,18 +4,11 @@
         mValues[i] = value;
     } else {
         i = ~i;
-        if (mSize >= mKeys.length) {
-            growKeyAndValueArrays(mSize + 1);
-        }
-        if (mSize - i != 0) {
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.computePasswordQuality:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Compute the password quality from the given password string.
 */

@@ -16,22 +16,22 @@
         return DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC;
     }
     if (hasDigit) {
-        return DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
+        return maxLengthSequence(password) > MAX_ALLOWED_SEQUENCE ? DevicePolicyManager.PASSWORD_QUALITY_NUMERIC : DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;
     }
     return DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
 }

Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.setNiNotification:COMMENT
Method Modifier: private     internal    
Comment:// Sets the NI notification.

@@ -24,29 +24,30 @@
     // if not to popup dialog immediately, pending intent will open the dialog
     Intent intent = !mPopupImmediately ? getDlgIntent(notif) : new Intent();
     PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, intent, 0);
+    mNiNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
     mNiNotification.setLatestEventInfo(mContext, title, message, pi);
     notificationManager.notifyAsUser(null, notif.notificationId, mNiNotification, UserHandle.ALL);
 }

Find a functionally equivalent code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -41,55 +41,61 @@
             // Draw all leading margin spans.  Adjust left or right according
             // to the paragraph direction of the line.
             final int length = spans.length;
+            boolean useFirstLineMargin = isFirstParaLine;
             for (int n = 0; n < length; n++) {
+                if (spans[n] instanceof LeadingMarginSpan2) {
+                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
+                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
+                    // the count that is greatest
+                    if (i < startLine + count) {
+                        useFirstLineMargin = true;
+                        break;
+                    }
+                }
+            }
+            for (int n = 0; n < length; n++) {
                 if (spans[n] instanceof LeadingMarginSpan) {
                     LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
-                    boolean useFirstLineMargin = isFirstParaLine;
-                    if (margin instanceof LeadingMarginSpan2) {
-                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
-                        int startLine = getLineForOffset(sp.getSpanStart(margin));
-                        useFirstLineMargin = i < startLine + count;
-                    }
                     if (dir == DIR_RIGHT_TO_LEFT) {
                         margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                         right -= margin.getLeadingMargin(useFirstLineMargin);

Find a functionally equivalent code:android.view.Window.setBackgroundDrawableResource:COMMENT
Method Modifier: public      
Comment:/**
 * Change the background of this window to a Drawable resource. Setting the
 * background to null will make the window be opaque. To make the window
 * transparent, you can use an empty drawable (for instance a ColorDrawable
 * with the color 0 or the system drawable android:drawable/empty.)
 *
 * @param resid The resource identifier of a drawable resource which will be
 * installed as the new background.
 */

@@ -1,3 +1,3 @@
 {
-    setBackgroundDrawable(mContext.getResources().getDrawable(resid));
+    setBackgroundDrawable(mContext.getDrawable(resid));
 }

Find a functionally equivalent code:android.service.dreams.DreamService.setFullscreen:COMMENT
Method Modifier: public      
Comment:/**
 * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}
 * on the dream's window.
 *
 * @param fullscreen If true, the fullscreen flag will be set; else it
 * will be cleared.
 */

@@ -1,5 +1,7 @@
 {
-    mFullscreen = fullscreen;
-    int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
-    applyWindowFlags(mFullscreen ? flag : 0, flag);
+    if (mFullscreen != fullscreen) {
+        mFullscreen = fullscreen;
+        int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
+        applyWindowFlags(mFullscreen ? flag : 0, flag);
+    }
 }

Find a functionally equivalent code:android.text.Layout.getLineWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent and trailing whitespace.
 */

@@ -1,5 +1,5 @@
 {
     float margin = getParagraphLeadingMargin(line);
     float signedExtent = getLineExtent(line, true);
-    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
+    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
 }

Find a functionally equivalent code:android.widget.CalendarView.getUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in a not focused month.
 *
 * @return A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

@@ -1,3 +1,3 @@
 {
-    return mFocusedMonthDateColor;
+    return mDelegate.getUnfocusedMonthDateColor();
 }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_AcousticStateReset:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:android.print.PrintManager.getInstalledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of installed print services.
 *
 * @return The installed service list or an empty list.
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return Collections.emptyList();
+    }
     try {
         List<PrintServiceInfo> installedServices = mService.getInstalledPrintServices(mUserId);
         if (installedServices != null) {

Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Defines at what volume the playback associated with this route is performed (for user
 * feedback purposes). This information is only used when the playback is not local.
 * @param volume
 */

@@ -2,8 +2,10 @@
     volume = Math.max(0, Math.min(volume, getVolumeMax()));
     if (mVolume != volume) {
         mVolume = volume;
-        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME, volume);
+        if (mSvp != null) {
+            mSvp.setCurrentVolume(mVolume);
+        }
         dispatchRouteVolumeChanged(this);
         if (mGroup != null) {
             mGroup.memberVolumeChanged(this);

Find a functionally equivalent code:android.media.MediaFocusControl.unregisterRemoteControlDisplay:COMMENT
Method Modifier: protected   
Comment:/**
 * Unregister an IRemoteControlDisplay.
 * No effect if the IRemoteControlDisplay hasn't been successfully registered.
 * @see android.media.IAudioService#unregisterRemoteControlDisplay(android.media.IRemoteControlDisplay)
 * @param rcd the IRemoteControlDisplay to unregister. No effect if null.
 */

@@ -1,14 +1,14 @@
 {
     if (DEBUG_RC)
         Log.d(TAG, "<<< unregisterRemoteControlDisplay(" + rcd + ")");
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         if (rcd == null) {
             return;
         }
         boolean displayWasPluggedIn = false;
         final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
         while (displayIterator.hasNext() && !displayWasPluggedIn) {
-            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
+            final DisplayInfoForServer di = displayIterator.next();
             if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                 displayWasPluggedIn = true;
                 di.release();
@@ -18,29 +18,29 @@
         if (displayWasPluggedIn) {
             // disconnect this remote control display from all the clients, so the remote
             // control stack traversal order doesn't matter
-            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
             while (stackIterator.hasNext()) {
-                final RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRcClient != null) {
+                final PlayerRecord prse = stackIterator.next();
+                if (prse.getRcc() != null) {
                     try {
-                        rcse.mRcClient.unplugRemoteControlDisplay(rcd);
+                        prse.getRcc().unplugRemoteControlDisplay(rcd);
                     } catch (RemoteException e) {
                         Log.e(TAG, "Error disconnecting remote control display to client: ", e);
                     }

Find a functionally equivalent code:android.hardware.camera2.impl.CameraMetadataNative.set:COMMENT
Method Modifier: public      
Comment:/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */

@@ -1,5 +1,7 @@
 {
-    if (setOverride(key, value)) {
+    SetCommand s = sSetCommandMap.get(key);
+    if (s != null) {
+        s.setValue(this, value);
         return;
     }
     setBase(key, value);

Find a functionally equivalent code:android.graphics.Bitmap.copy:COMMENT
Method Modifier: public      
Comment:/**
 * Tries to make a new bitmap based on the dimensions of this bitmap,
 * setting the new bitmap's config to the one specified, and then copying
 * this bitmap's pixels into the new bitmap. If the conversion is not
 * supported, or the allocator fails, then this returns NULL.  The returned
 * bitmap initially has the same density as the original.
 *
 * @param config    The desired config for the resulting bitmap
 * @param isMutable True if the resulting bitmap should be mutable (i.e.
 * its pixels can be modified)
 * @return the new bitmap, or null if the copy could not be made.
 */

@@ -2,8 +2,8 @@
     checkRecycled("Can't copy a recycled bitmap");
     Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
     if (b != null) {
-        b.mIsPremultiplied = mIsPremultiplied;
+        b.setPremultiplied(mRequestPremultiplied);
         b.mDensity = mDensity;
     }
     return b;

Find a functionally equivalent code:android.text.format.Time.compare:COMMENT
Method Modifier: public      static      
Comment:/**
 * Compare two {@code Time} objects and return a negative number if {@code
 * a} is less than {@code b}, a positive number if {@code a} is greater than
 * {@code b}, or 0 if they are equal.
 *
 * @param a first {@code Time} instance to compare
 * @param b second {@code Time} instance to compare
 * @throws NullPointerException if either argument is {@code null}
 * @throws IllegalArgumentException if {@link #allDay} is true but {@code
 * hour}, {@code minute}, and {@code second} are not 0.
 * @return a negative result if {@code a} is earlier, a positive result if
 * {@code a} is earlier, or 0 if they are equal.
 */

@@ -4,8 +4,10 @@
     } else if (b == null) {
         throw new NullPointerException("b == null");
     }
-    return nativeCompare(a, b);
+    a.calculator.copyFieldsFromTime(a);
+    b.calculator.copyFieldsFromTime(b);
+    return TimeCalculator.compare(a.calculator, b.calculator);
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

@@ -1,5 +1,5 @@
 {
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
     if (mService == null || mClientIf == 0)
         return false;
@@ -12,21 +12,27 @@
     BluetoothDevice device = service.getDevice();
     if (device == null)
         return false;
+    synchronized (mDeviceBusy) {
+        if (mDeviceBusy)
+            return false;
+        mDeviceBusy = true;
+    }
     try {
         mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
+        mDeviceBusy = false;
         return false;
     }
     return true;

Find a functionally equivalent code:android.media.RemoteController.sendMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send a simulated key event for a media button to be received by the current client.
 * To simulate a key press, you must first send a KeyEvent built with
 * a {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the registered receiver
 * (see {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}) whose associated
 * {@link RemoteControlClient}'s metadata and playback state is published (there may be
 * none under some circumstances).
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 * @return true if the event was successfully sent, false otherwise.
 * @throws IllegalArgumentException
 */

@@ -1,31 +1,40 @@
 {
-    if (!MediaFocusControl.isMediaKeyCode(keyEvent.getKeyCode())) {
+    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
         throw new IllegalArgumentException("not a media key event");
     }
-    final PendingIntent pi;
-    synchronized (mInfoLock) {
-        if (!mIsRegistered) {
-            Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
+    if (USE_SESSIONS) {
+        synchronized (mInfoLock) {
+            if (mCurrentSession != null) {
+                return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
+            }
             return false;
         }
-        if (!mEnabled) {
-            Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
-            return false;
+    } else {
+        final PendingIntent pi;
+        synchronized (mInfoLock) {
+            if (!mIsRegistered) {
+                Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
+                return false;
+            }
+            if (!mEnabled) {
+                Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
+                return false;
+            }
+            pi = mClientPendingIntentCurrent;
         }
-        pi = mClientPendingIntentCurrent;
-    }
-    if (pi != null) {
-        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
-        try {
-            pi.send(mContext, 0, intent);
-        } catch (CanceledException e) {
-            Log.e(TAG, "Error sending intent for media button down: ", e);
+        if (pi != null) {
+            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+            intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
+            try {
+                pi.send(mContext, 0, intent);
+            } catch (CanceledException e) {
+                Log.e(TAG, "Error sending intent for media button down: ", e);
+                return false;
+            }
+        } else {
+            Log.i(TAG, "No-op when sending key click, no receiver right now");
             return false;
         }
-    } else {
-        Log.i(TAG, "No-op when sending key click, no receiver right now");
-        return false;
     }
     return true;
 }

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleWiFiEnableDisable:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching on/off WiFi at various intervals.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

@@ -1,6 +1,6 @@
 {
-    String filename = DOWNLOAD_5MB_FILENAME;
-    long filesize = DOWNLOAD_5MB_FILESIZE;
+    String filename = DOWNLOAD_FILENAME;
+    long filesize = DOWNLOAD_FILESIZE;
     doCommonDownloadSetup();
     String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
     File downloadedFile = new File(localDownloadDirectory, filename);
@@ -19,25 +19,25 @@
         dlRequest = mDownloadManager.enqueue(request);
         waitForDownloadToStart(dlRequest);
         // are we making any progress?
-        waitForFileToGrow(downloadedFile);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download disable
         Log.i(LOG_TAG, "Turning off WiFi...");
         setWiFiStateOn(false);
@@ -28,34 +28,34 @@
         // enable download...
         Log.i(LOG_TAG, "Turning on WiFi again...");
         setWiFiStateOn(true);
-        waitForFileToGrow(downloadedFile);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download disable
         Log.i(LOG_TAG, "Turning off WiFi...");
         setWiFiStateOn(false);
@@ -37,44 +37,44 @@
         // enable download...
         Log.i(LOG_TAG, "Turning on WiFi again...");
         setWiFiStateOn(true);
-        Log.i(LOG_TAG, "Waiting up to 3 minutes for download to complete...");
-        waitForDownloadsOrTimeout(dlRequest, 3 * 60 * 1000);
+        Log.i(LOG_TAG, "Waiting up to 10 minutes for download to complete...");
+        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
         ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
         verifyFileSize(pfd, filesize);
     } finally {

Find a functionally equivalent code:android.widget.CalendarView.getWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the separator line between weeks.
 *
 * @return The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

@@ -1,3 +1,3 @@
 {
-    return mWeekSeparatorLineColor;
+    return mDelegate.getWeekSeparatorLineColor();
 }

Find a functionally equivalent code:android.graphics.Canvas.drawVertices:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the array of vertices, interpreted as triangles (based on mode). The
 * verts array is required, and specifies the x,y pairs for each vertex. If
 * texs is non-null, then it is used to specify the coordinate in shader
 * coordinates to use at each vertex (the paint must have a shader in this
 * case). If there is no texs array, but there is a color array, then each
 * color is interpolated across its corresponding triangle in a gradient. If
 * both texs and colors arrays are present, then they behave as before, but
 * the resulting color at each pixels is the result of multiplying the
 * colors from the shader and the color-gradient together. The indices array
 * is optional, but if it is present, then it is used to specify the index
 * of each triangle, rather than just walking through the arrays in order.
 *
 * @param mode How to interpret the array of vertices
 * @param vertexCount The number of values in the vertices array (and
 * corresponding texs and colors arrays if non-null). Each logical
 * vertex is two values (x, y), vertexCount must be a multiple of 2.
 * @param verts Array of vertices for the mesh
 * @param vertOffset Number of values in the verts to skip before drawing.
 * @param texs May be null. If not null, specifies the coordinates to sample
 * into the current shader (e.g. bitmap tile or gradient)
 * @param texOffset Number of values in texs to skip before drawing.
 * @param colors May be null. If not null, specifies a color for each
 * vertex, to be interpolated across the triangle.
 * @param colorOffset Number of values in colors to skip before drawing.
 * @param indices If not null, array of indices to reference into the
 * vertex (texs, colors) array.
 * @param indexCount number of entries in the indices array (if not null).
 * @param paint Specifies the shader to use if the texs array is non-null.
 */

@@ -9,13 +9,13 @@
     if (indices != null) {
         checkRange(indices.length, indexOffset, indexCount);
     }
-    nativeDrawVertices(mNativeCanvas, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
+    nativeDrawVertices(mNativeCanvasWrapper, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
 }

Find a functionally equivalent code:android.widget.FastScroller.measurePreview:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the preview text bounds, taking preview image padding into
 * account. This method should only be called after {@link #layoutThumb()}
 * and {@link #layoutTrack()} have both been called at least once.
 *
 * @param v The preview text view to measure.
 * @param out Rectangle into which measured bounds are placed.
 */

@@ -5,13 +5,13 @@
     margins.top = mPreviewImage.getPaddingTop();
     margins.right = mPreviewImage.getPaddingRight();
     margins.bottom = mPreviewImage.getPaddingBottom();
-    if (mOverlayPosition == OVERLAY_AT_THUMB) {
-        measureViewToSide(v, mThumbImage, margins, out);
-    } else {
+    if (mOverlayPosition == OVERLAY_FLOATING) {
         measureFloating(v, margins, out);
+    } else {
+        measureViewToSide(v, mThumbImage, margins, out);
     }
 }

Find a functionally equivalent code:android.content.res.TypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.stress.WifiStressTest.testWifiScanning:COMMENT
Method Modifier: public      
Comment:/**
 * Stress Wifi Scanning
 * TODO: test the scanning quality for each frequency band
 */

@@ -1,58 +1,48 @@
 {
-    int scanTimeSum = 0;
-    int i;
+    long scanTimeSum = 0, i, averageScanTime = -1;
     // count times of given ssid appear in scan results.
     int ssidAppearInScanResultsCount = 0;
-    for (i = 0; i < mScanIterations; i++) {
-        log("testWifiScanning: iteration: " + i);
-        int averageScanTime = 0;
-        if (i > 0) {
-            averageScanTime = scanTimeSum / i;
-        }
+    for (i = 1; i <= mScanIterations; i++) {
+        logv("testWifiScanning: iteration: " + i);
+        averageScanTime = scanTimeSum / i;
         writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
         writeOutput(String.format("average scanning time is %d", averageScanTime));
         writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, i));
-        long startTime = System.currentTimeMillis();
-        scanResultAvailable = false;
-        assertTrue("start scan failed", mWifiManager.startScan());
-        while (true) {
-            if ((System.currentTimeMillis() - startTime) > WIFI_SCAN_TIMEOUT) {
-                fail("Wifi scanning takes more than " + WIFI_SCAN_TIMEOUT + " ms");
-            }
-            synchronized (this) {
-                try {
-                    wait(WAIT_FOR_SCAN_RESULT);
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }
-                if (scanResultAvailable) {
-                    long scanTime = (System.currentTimeMillis() - startTime);
-                    scanTimeSum += scanTime;
-                    break;
-                }
+        List<ScanResult> scanResultLocal = null;
+        // wait for a scan result
+        long start = 0;
+        synchronized (mWifiScanResultLock) {
+            start = SystemClock.uptimeMillis();
+            assertTrue("start scan failed", mWifiManager.startScan());
+            try {
+                mWifiScanResultLock.wait(WAIT_FOR_SCAN_RESULT);
+            } catch (InterruptedException e) {
+            // ignore
             }
+            scanTimeSum += SystemClock.uptimeMillis() - start;
+            // save the scan result while in lock
+            scanResultLocal = mLastScanResult;
         }
-        if ((mWifiManager.getScanResults() == null) || (mWifiManager.getScanResults().size() <= 0)) {
+        if (scanResultLocal == null || scanResultLocal.isEmpty()) {
             fail("Scan results are empty ");
         }
-        List<ScanResult> netList = mWifiManager.getScanResults();
-        if (netList != null) {
-            log("size of scan result list: " + netList.size());
-            for (int s = 0; s < netList.size(); s++) {
-                ScanResult sr = netList.get(s);
-                log(String.format("scan result for %s is: %s", sr.SSID, sr.toString()));
-                log(String.format("signal level for %s is %d ", sr.SSID, sr.level));
-                if (sr.SSID.equals(mSsid)) {
-                    ssidAppearInScanResultsCount += 1;
-                    log("Number of times " + mSsid + " appear in the scan list: " + ssidAppearInScanResultsCount);
-                    break;
-                }
+        logv("size of scan result list: " + scanResultLocal.size());
+        for (ScanResult sr : scanResultLocal) {
+            logv(String.format("scan result: " + sr.toString()));
+            if (mSsid.equals(sr.SSID)) {
+                ssidAppearInScanResultsCount += 1;
+                break;
             }
         }
     }
-    if (i == mScanIterations) {
+    Bundle result = new Bundle();
+    result.putLong("actual-iterations", i - 1);
+    result.putLong("avg-scan-time", averageScanTime);
+    result.putInt("ap-discovered", ssidAppearInScanResultsCount);
+    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
+    if (i == mScanIterations + 1) {
         writeOutput(String.format("iteration %d out of %d", i, mScanIterations));
-        writeOutput(String.format("average scanning time is %d", scanTimeSum / mScanIterations));
-        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, mScanIterations));
+        writeOutput(String.format("average scanning time is %d", scanTimeSum / (i - 1)));
+        writeOutput(String.format("ssid appear %d out of %d scan iterations", ssidAppearInScanResultsCount, i));
     }
 }

Find a functionally equivalent code:android.os.SELinux.native_restorecon:COMMENT
Method Modifier: private     static      native      
Comment:/**
 * Restores a file to its default SELinux security context.
 * If the system is not compiled with SELinux, then {@code true}
 * is automatically returned.
 * If SELinux is compiled in, but disabled, then {@code true} is
 * returned.
 *
 * @param pathname The pathname of the file to be relabeled.
 * @return a boolean indicating whether the relabeling succeeded.
 */


Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayInitInfo:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_INIT_INFO event
 * Causes the current RemoteControlClient to send its info (metadata, playstate...) to
 * a single RemoteControlDisplay, NOT all of them, as with MSG_RCDISPLAY_UPDATE.
 */

@@ -1,5 +1,5 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         synchronized (mCurrentRcLock) {
             if (mCurrentRcClient != null) {
                 if (DEBUG_RC) {

Find a functionally equivalent code:android.speech.tts.FileSynthesisCallback.closeFile:COMMENT
Method Modifier: private     
Comment:/**
 * Must be called while holding the monitor on {@link #mStateLock}.
 */

@@ -1,10 +1,4 @@
 {
-    try {
-        if (mFileChannel != null) {
-            mFileChannel.close();
-            mFileChannel = null;
-        }
-    } catch (IOException ex) {
-        Log.e(TAG, "Failed to close output file descriptor", ex);
-    }
+    // File will be closed by the SpeechItem in the speech service.
+    mFileChannel = null;
 }

Find a functionally equivalent code:android.provider.DocumentsContract.getDocumentThumbnail:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

@@ -1,6 +1,6 @@
 {
     final Bundle openOpts = new Bundle();
-    openOpts.putParcelable(DocumentsContract.EXTRA_THUMBNAIL_SIZE, size);
+    openOpts.putParcelable(ContentResolver.EXTRA_SIZE, size);
     AssetFileDescriptor afd = null;
     Bitmap bitmap = null;
     try {
@@ -11,17 +11,17 @@
         // optimal decode path; otherwise fall back to buffering.
         BufferedInputStream is = null;
         try {
-            Libcore.os.lseek(fd, offset, SEEK_SET);
+            Os.lseek(fd, offset, SEEK_SET);
         } catch (ErrnoException e) {
             is = new BufferedInputStream(new FileInputStream(fd), THUMBNAIL_BUFFER_SIZE);
             is.mark(THUMBNAIL_BUFFER_SIZE);
@@ -34,40 +34,40 @@
             bitmap = BitmapFactory.decodeStream(is, null, opts);
         } else {
             try {
-                Libcore.os.lseek(fd, offset, SEEK_SET);
+                Os.lseek(fd, offset, SEEK_SET);
             } catch (ErrnoException e) {
                 e.rethrowAsIOException();
             }

Find a functionally equivalent code:android.text.BoringLayout.init:COMMENT
Method Modifier: 
Comment:/* package */

@@ -11,19 +11,16 @@
     } else {
         spacing = metrics.descent - metrics.ascent;
     }
-    if (spacingmult != 1 || spacingadd != 0) {
-        spacing = (int) (spacing * spacingmult + spacingadd + 0.5f);
-    }
     mBottom = spacing;
     if (includepad) {
         mDesc = spacing + metrics.top;

Find a functionally equivalent code:android.media.AudioService.stopBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#stopBluetoothSco()
 */

@@ -1,5 +1,5 @@
 {
-    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mBootCompleted) {
+    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mSystemReady) {
         return;
     }
     ScoClient client = getScoClient(cb, false);

Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.clear:COMMENT
Method Modifier: 
Comment:/**
 * Clears the scrap heap.
 */

@@ -1,24 +1,13 @@
 {
     if (mViewTypeCount == 1) {
         final ArrayList<View> scrap = mCurrentScrap;
-        final int scrapCount = scrap.size();
-        for (int i = 0; i < scrapCount; i++) {
-            removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
-        }
+        clearScrap(scrap);
     } else {
         final int typeCount = mViewTypeCount;
         for (int i = 0; i < typeCount; i++) {
             final ArrayList<View> scrap = mScrapViews[i];
-            final int scrapCount = scrap.size();
-            for (int j = 0; j < scrapCount; j++) {
-                removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
-            }
+            clearScrap(scrap);
         }
     }
-    if (mTransientStateViews != null) {
-        mTransientStateViews.clear();
-    }
-    if (mTransientStateViewsById != null) {
-        mTransientStateViewsById.clear();
-    }
+    clearTransientStateViews();
 }

Find a functionally equivalent code:android.animation.AnimatorSet.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */

@@ -1,3 +1,6 @@
 {
+    if (mStartDelay > 0) {
+        mReversible = false;
+    }
     mStartDelay = startDelay;
 }

Find a functionally equivalent code:android.net.nsd.NsdServiceInfo.getTxtRecord:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,27 @@
 {
-    return mTxtRecord;
+    int txtRecordSize = getTxtRecordSize();
+    if (txtRecordSize == 0) {
+        return null;
+    }
+    byte[] txtRecord = new byte[txtRecordSize];
+    int ptr = 0;
+    for (Map.Entry<String, byte[]> entry : mTxtRecord.entrySet()) {
+        String key = entry.getKey();
+        byte[] value = entry.getValue();
+        // One byte to record the length of this key/value pair.
+        txtRecord[ptr++] = (byte) (key.length() + (value == null ? 0 : value.length) + 1);
+        // The key, in US-ASCII.
+        // Note: use the StandardCharsets const here because it doesn't raise exceptions and we
+        // already know the key is ASCII at this point.
+        System.arraycopy(key.getBytes(StandardCharsets.US_ASCII), 0, txtRecord, ptr, key.length());
+        ptr += key.length();
+        // US-ASCII '=' character.
+        txtRecord[ptr++] = (byte) '=';
+        // The value, as any raw bytes.
+        if (value != null) {
+            System.arraycopy(value, 0, txtRecord, ptr, value.length);
+            ptr += value.length;
+        }
+    }
+    return txtRecord;
 }

Find a functionally equivalent code:android.os.Environment.initForCurrentUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

@@ -1,7 +1,4 @@
 {
     final int userId = UserHandle.myUserId();
     sCurrentUser = new UserEnvironment(userId);
-    synchronized (sLock) {
-        sPrimaryVolume = null;
-    }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.hideBootMessages:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,12 +1,3 @@
 {
-    mHandler.post(new Runnable() {
-
-        @Override
-        public void run() {
-            if (mBootMsgDialog != null) {
-                mBootMsgDialog.dismiss();
-                mBootMsgDialog = null;
-            }
-        }
-    });
+    mHandler.sendEmptyMessage(MSG_HIDE_BOOT_MESSAGE);
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.passwordToHash:COMMENT
Method Modifier: public      internal    
Comment:/*
     * Generate a hash for the given password. To avoid brute force attacks, we use a salted hash.
     * Not the most secure, but it is at least a second level of protection. First level is that
     * the file is in a location only readable by the system process.
     * @param password the gesture pattern.
     * @return the hash of the pattern in a byte array.
     */

@@ -5,11 +5,11 @@
     String algo = null;
     byte[] hashed = null;
     try {
-        byte[] saltedPassword = (password + getSalt()).getBytes();
+        byte[] saltedPassword = (password + getSalt(userId)).getBytes();
         byte[] sha1 = MessageDigest.getInstance(algo = "SHA-1").digest(saltedPassword);
         byte[] md5 = MessageDigest.getInstance(algo = "MD5").digest(saltedPassword);
         hashed = (toHex(sha1) + toHex(md5)).getBytes();

Find a functionally equivalent code:android.app.Activity.onResume:COMMENT
Method Modifier: protected   
Comment:/**
 * Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or
 * {@link #onPause}, for your activity to start interacting with the user.
 * This is a good place to begin animations, open exclusive-access devices
 * (such as the camera), etc.
 *
 * <p>Keep in mind that onResume is not the best indicator that your activity
 * is visible to the user; a system window such as the keyguard may be in
 * front.  Use {@link #onWindowFocusChanged} to know for certain that your
 * activity is visible to the user (for example, to resume a game).
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestoreInstanceState
 * @see #onRestart
 * @see #onPostResume
 * @see #onPause
 */

@@ -2,6 +2,7 @@
     if (DEBUG_LIFECYCLE)
         Slog.v(TAG, "onResume " + this);
     getApplication().dispatchActivityResumed(this);
+    mActivityTransitionState.onResume();
     mCalled = true;
 }

Find a functionally equivalent code:android.graphics.drawable.BitmapDrawable.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity used to position/stretch the bitmap within its bounds.
 * See android.view.Gravity
 * @param gravity the gravity
 */

@@ -1,7 +1,7 @@
 {
     if (mBitmapState.mGravity != gravity) {
         mBitmapState.mGravity = gravity;
-        mApplyGravity = true;
+        mDstRectAndInsetsDirty = true;
         invalidateSelf();
     }
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.startSystemServer:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Prepare the arguments and fork for the system server process.
 */

@@ -1,5 +1,5 @@
 {
-    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG);
+    long capabilities = posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG);
     /* Hardcoded command line to start the system server */
     String[] args = { "--setuid=1000", "--setgid=1000", "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007", "--capabilities=" + capabilities + "," + capabilities, "--runtime-init", "--nice-name=system_server", "com.android.server.SystemServer" };
     ZygoteConnection.Arguments parsedArgs = null;
@@ -15,20 +15,23 @@
     }
     /* For child process */
     if (pid == 0) {
+        if (hasSecondZygote(abiList)) {
+            waitForSecondaryZygote(socketName);
+        }
         handleSystemServerProcess(parsedArgs);
     }
     return true;

Find a functionally equivalent code:android.database.sqlite.SQLiteConnection.dumpUnsafe:COMMENT
Method Modifier: 
Comment:/**
 * Dumps debugging information about this connection, in the case where the
 * caller might not actually own the connection.
 *
 * This function is written so that it may be called by a thread that does not
 * own the connection.  We need to be very careful because the connection state is
 * not synchronized.
 *
 * At worst, the method may return stale or slightly wrong data, however
 * it should not crash.  This is ok as it is only used for diagnostic purposes.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

@@ -1,7 +1,7 @@
 {
     printer.println("Connection #" + mConnectionId + ":");
     if (verbose) {
-        printer.println("  connectionPtr: 0x" + Integer.toHexString(mConnectionPtr));
+        printer.println("  connectionPtr: 0x" + Long.toHexString(mConnectionPtr));
     }
     printer.println("  isPrimaryConnection: " + mIsPrimaryConnection);
     printer.println("  onlyAllowReadOnlyOperations: " + mOnlyAllowReadOnlyOperations);

Find a functionally equivalent code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: 
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

@@ -10,15 +10,16 @@
     final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
     final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
     boolean matchHeight = false;
+    boolean skippedMeasure = false;
     if (mMaxAscent == null || mMaxDescent == null) {
         mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
         mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
@@ -50,55 +51,58 @@
             if (baselineAligned) {
                 final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                 child.measure(freeSpec, freeSpec);
+            } else {
+                skippedMeasure = true;
             }
         } else {
             int oldWidth = Integer.MIN_VALUE;
@@ -154,162 +157,166 @@
     int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
     widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
     // Either expand children with weight to take up available space or
-    // shrink them if they extend beyond our current bounds
+    // shrink them if they extend beyond our current bounds. If we skipped
+    // measurement on any children, we need to measure them now.
     int delta = widthSize - mTotalLength;
-    if (delta != 0 && totalWeight > 0.0f) {
+    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
         float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
         maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
         maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;

Find a functionally equivalent code:android.nfc.cardemulation.CardEmulation.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */

@@ -27,32 +27,36 @@
     if (manager == null) {
         // Get card emu service
         INfcCardEmulation service = adapter.getCardEmulationService();
+        if (service == null) {
+            Log.e(TAG, "This device does not implement the INfcCardEmulation interface.");
+            throw new UnsupportedOperationException();
+        }
         manager = new CardEmulation(context, service);
         sCardEmus.put(context, manager);
     }

Find a functionally equivalent code:android.widget.DatePicker.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initialize the state. If the provided values designate an inconsistent
 * date the values are normalized before updating the spinners.
 *
 * @param year The initial year.
 * @param monthOfYear The initial month <strong>starting from zero</strong>.
 * @param dayOfMonth The initial day of the month.
 * @param onDateChangedListener How user is notified date is changed by
 * user, can be null.
 */

@@ -1,6 +1,3 @@
 {
-    setDate(year, monthOfYear, dayOfMonth);
-    updateSpinners();
-    updateCalendarView();
-    mOnDateChangedListener = onDateChangedListener;
+    mDelegate.init(year, monthOfYear, dayOfMonth, onDateChangedListener);
 }

Find a functionally equivalent code:android.view.InputQueue.getNativePtr:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */


Find a functionally equivalent code:android.util.SparseLongArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -3,13 +3,9 @@
         put(key, value);
         return;
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        growKeyAndValueArrays(pos + 1);
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:android.content.res.ColorStateList.valueOf:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */

@@ -1,7 +1,7 @@
 {
     // TODO: should we collect these eventually?
     synchronized (sCache) {
-        WeakReference<ColorStateList> ref = sCache.get(color);
+        final WeakReference<ColorStateList> ref = sCache.get(color);
         ColorStateList csl = ref != null ? ref.get() : null;
         if (csl != null) {
             return csl;

Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.commitText:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */

@@ -2,7 +2,8 @@
     if (DEBUG)
         Log.v(TAG, "commitText " + text);
     replaceText(text, newCursorPosition, false);
+    mIMM.notifyUserAction();
     sendCurrentText();
     return true;
 }

Find a functionally equivalent code:com.android.systemui.power.PowerUI.findBatteryLevelBucket:COMMENT
Method Modifier: private     
Comment:/**
 * Buckets the battery level.
 *
 * The code in this function is a little weird because I couldn't comprehend
 * the bucket going up when the battery level was going down. --joeo
 *
 * 1 means that the battery is "ok"
 * 0 means that the battery is between "ok" and what we should warn about.
 * less than 0 means that the battery is low
 */

@@ -2,8 +2,8 @@
     if (level >= mLowBatteryAlertCloseLevel) {
         return 1;
     }
-    if (level >= mLowBatteryReminderLevels[0]) {
+    if (level > mLowBatteryReminderLevels[0]) {
         return 0;
     }
     final int N = mLowBatteryReminderLevels.length;

Find a functionally equivalent code:android.transition.Transition.getTransitionValues:COMMENT
Method Modifier: public      
Comment:/**
 * This method can be called by transitions to get the TransitionValues for
 * any particular view during the transition-playing process. This might be
 * necessary, for example, to query the before/after state of related views
 * for a given transition.
 */

@@ -3,22 +3,7 @@
         return mParent.getTransitionValues(view, start);
     }
     TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
-    TransitionValues values = valuesMaps.viewValues.get(view);
-    if (values == null) {
-        int id = view.getId();
-        if (id >= 0) {
-            values = valuesMaps.idValues.get(id);
-        }
-        if (values == null && view.getParent() instanceof ListView) {
-            ListView listview = (ListView) view.getParent();
-            int position = listview.getPositionForView(view);
-            long itemId = listview.getItemIdAtPosition(position);
-            values = valuesMaps.itemIdValues.get(itemId);
-        }
-    // TODO: Doesn't handle the case where a view was parented to a
-    // ListView (with an itemId), but no longer is
-    }
-    return values;
+    return valuesMaps.viewValues.get(view);
 }

Find a functionally equivalent code:android.graphics.Path.addArc:COMMENT
Method Modifier: public      
Comment:/**
 * Add the specified arc to the path as a new contour.
 *
 * @param oval The bounds of oval defining the shape and size of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 */

@@ -1,7 +1,3 @@
 {
-    if (oval == null) {
-        throw new NullPointerException("need oval parameter");
-    }
-    isSimplePath = false;
-    native_addArc(mNativePath, oval, startAngle, sweepAngle);
+    addArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle);
 }

Find a functionally equivalent code:android.preference.Preference.onBindView:COMMENT
Method Modifier: protected   
Comment:/**
 * Binds the created View to the data for this Preference.
 * <p>
 * This is a good place to grab references to custom Views in the layout and
 * set properties on them.
 * <p>
 * Make sure to call through to the superclass's implementation.
 *
 * @param view The View that shows this Preference.
 * @see #onCreateView(ViewGroup)
 */

@@ -19,29 +19,29 @@
             summaryView.setVisibility(View.GONE);
         }
     }
-    ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
+    final ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
     if (imageView != null) {
         if (mIconResId != 0 || mIcon != null) {
             if (mIcon == null) {
-                mIcon = getContext().getResources().getDrawable(mIconResId);
+                mIcon = getContext().getDrawable(mIconResId);
             }
             if (mIcon != null) {
                 imageView.setImageDrawable(mIcon);
@@ -31,36 +31,40 @@
         }
         imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
     }
+    final View imageFrame = view.findViewById(com.android.internal.R.id.icon_frame);
+    if (imageFrame != null) {
+        imageFrame.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
+    }
     if (mShouldDisableView) {
         setEnabledStateOnViews(view, isEnabled());
     }

Find a functionally equivalent code:android.app.Activity.shouldUpRecreateTask:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */

@@ -9,15 +9,15 @@
         if (info.taskAffinity == null) {
             return false;
         }
-        return !ActivityManagerNative.getDefault().targetTaskAffinityMatchesActivity(mToken, info.taskAffinity);
+        return ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity);
     } catch (RemoteException e) {
         return false;
     } catch (NameNotFoundException e) {

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.DelegateManager.removeJavaReferenceFor:COMMENT
Method Modifier: public      
Comment:/**
 * Removes the main reference on the given delegate.
 * @param native_object the native integer representing the delegate.
 */


Find a functionally equivalent code:android.os.Bundle.getIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (ArrayList<Integer>) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "ArrayList<Integer>", e);
-        return null;
-    }
+    return super.getIntegerArrayList(key);
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderAction.tearDown:COMMENT
Method Modifier: private     
Comment:/**
 * Tear down the session after rendering.
 * <p/>
 * The counterpart is {@link #setUp()}.
 */

@@ -18,22 +18,21 @@
         mContext.getRenderResources().setFrameworkResourceIdProvider(null);
         mContext.getRenderResources().setLogger(null);
     }
-    mContext = null;
 }

Find a functionally equivalent code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

@@ -1,6 +1,6 @@
 {
     try {
-        ActivityManagerNative.getDefault().takePersistableUriPermission(uri, modeFlags);
+        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
     } catch (RemoteException e) {
     }
 }

Find a functionally equivalent code:android.os.CountDownTimer.cancel:COMMENT
Method Modifier: public      final       
Comment:/**
 * Cancel the countdown.
 */

@@ -1,3 +1,4 @@
 {
+    mCancelled = true;
     mHandler.removeMessages(MSG);
 }

Find a functionally equivalent code:android.widget.DatePicker.getCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */

@@ -1,3 +1,3 @@
 {
-    return (mCalendarView.getVisibility() == View.VISIBLE);
+    return mDelegate.getCalendarViewShown();
 }

Find a functionally equivalent code:android.media.AudioService.checkForRingerModeChange:COMMENT
Method Modifier: private     
Comment:/**
 * Checks if the adjustment should change ringer mode instead of just
 * adjusting volume. If so, this will set the proper ringer mode and volume
 * indices on the stream states.
 */

@@ -1,5 +1,5 @@
 {
-    boolean adjustVolumeIndex = true;
+    int result = FLAG_ADJUST_VOLUME;
     int ringerMode = getRingerMode();
     switch(ringerMode) {
         case RINGER_MODE_NORMAL:
@@ -11,17 +11,17 @@
                     }
                 } else {
                     // (oldIndex < step) is equivalent to (old UI index == 0)
-                    if ((oldIndex < step) && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
+                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                         ringerMode = RINGER_MODE_SILENT;
                     }
                 }
@@ -23,51 +23,55 @@
                 break;
             }
             if ((direction == AudioManager.ADJUST_LOWER)) {
-                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
+                if (VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                     ringerMode = RINGER_MODE_SILENT;
                 }
             } else if (direction == AudioManager.ADJUST_RAISE) {
                 ringerMode = RINGER_MODE_NORMAL;
             }
-            adjustVolumeIndex = false;
+            result &= ~FLAG_ADJUST_VOLUME;
             break;
         case RINGER_MODE_SILENT:
             if (direction == AudioManager.ADJUST_RAISE) {
-                if (mHasVibrator) {
-                    ringerMode = RINGER_MODE_VIBRATE;
+                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
+                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                 } else {
-                    ringerMode = RINGER_MODE_NORMAL;
+                    if (mHasVibrator) {
+                        ringerMode = RINGER_MODE_VIBRATE;
+                    } else {
+                        ringerMode = RINGER_MODE_NORMAL;
+                    }
                 }
             }
-            adjustVolumeIndex = false;
+            result &= ~FLAG_ADJUST_VOLUME;
             break;
         default:
             Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
             break;
     }
-    setRingerMode(ringerMode);
+    setRingerMode(ringerMode, false);
     mPrevVolDirection = direction;
-    return adjustVolumeIndex;
+    return result;
 }

Find a functionally equivalent code:android.media.MediaFocusControl.onRcDisplayUpdate:COMMENT
Method Modifier: private     
Comment:/**
 * Called when processing MSG_RCDISPLAY_UPDATE event
 */

@@ -1,14 +1,14 @@
 /* USED ?*/
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         synchronized (mCurrentRcLock) {
-            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(rcse.mRcClient))) {
+            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(prse.getRcc()))) {
                 if (DEBUG_RC)
                     Log.i(TAG, "Display/update remote control ");
                 mCurrentRcClientGen++;
                 // synchronously update the displays and clients with
                 // the new client generation
-                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, rcse.mMediaIntent, /*newMediaIntent*/
+                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, prse.getMediaButtonIntent(), /*newMediaIntent*/
                 false);
                 // tell the current client that it needs to send info
                 try {

Find a functionally equivalent code:android.widget.CalendarView.getDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the calendar dates.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

@@ -1,3 +1,3 @@
 {
-    return mDateTextAppearanceResId;
+    return mDelegate.getDateTextAppearance();
 }

Find a functionally equivalent code:android.graphics.drawable.DrawableContainer.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,6 @@
 {
-    return (mCurrDrawable == null) ? Insets.NONE : mCurrDrawable.getOpticalInsets();
+    if (mCurrDrawable != null) {
+        return mCurrDrawable.getOpticalInsets();
+    }
+    return Insets.NONE;
 }

Find a functionally equivalent code:android.widget.FastScroller.measureViewToSide:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the bounds for a view that should be laid out against the edge
 * of an adjacent view. If no adjacent view is provided, lays out against
 * the list edge.
 *
 * @param view The view to measure for layout.
 * @param adjacent (Optional) The adjacent view, may be null to align to the
 * list edge.
 * @param margins Layout margins to apply to the view.
 * @param out Rectangle into which measured bounds are placed.
 */

@@ -26,32 +26,32 @@
     final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
     view.measure(widthMeasureSpec, heightMeasureSpec);
     // Align to the left or right.
-    final int width = view.getMeasuredWidth();
+    final int width = Math.min(adjMaxWidth, view.getMeasuredWidth());
     final int left;
     final int right;
     if (mLayoutFromRight) {

Find a functionally equivalent code:android.app.Fragment.initState:COMMENT
Method Modifier: 
Comment:/**
 * Called by the fragment manager once this fragment has been removed,
 * so that we don't have any left-over state if the application decides
 * to re-use the instance.  This only clears state that the framework
 * internally manages, not things the application sets.
 */

@@ -9,14 +9,15 @@
     mRestored = false;
     mBackStackNesting = 0;
     mFragmentManager = null;
+    mChildFragmentManager = null;
     mActivity = null;
     mFragmentId = 0;
     mContainerId = 0;

Find a functionally equivalent code:com.android.internal.widget.SlidingTab.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

@@ -4,9 +4,9 @@
         if (mVibrator == null) {
             mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
         }
-        mVibrator.vibrate(duration);
+        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
     }
 }

Find a functionally equivalent code:android.os.Bundle.putCharSequence:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putCharSequence(key, value);
 }

Find a functionally equivalent code:android.graphics.NinePatch.validateNinePatchChunk:COMMENT
Method Modifier: private     static      native      
Comment:/**
 * Validates the 9-patch chunk and throws an exception if the chunk is invalid.
 * If validation is successful, this method returns a native Res_png_9patch*
 * object used by the renderers.
 */


Find a functionally equivalent code:android.appwidget.AppWidgetHost.allocateAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */

@@ -1,9 +1,6 @@
 {
     try {
-        if (mPackageName == null) {
-            mPackageName = mContext.getPackageName();
-        }
-        return sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId());
+        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:com.android.systemui.screenshot.GlobalScreenshot.saveScreenshotInWorkerThread:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new worker thread and saves the screenshot to the media store.
 */

@@ -4,9 +4,11 @@
     data.image = mScreenBitmap;
     data.iconSize = mNotificationIconSize;
     data.finisher = finisher;
+    data.previewWidth = mPreviewWidth;
+    data.previewheight = mPreviewHeight;
     if (mSaveInBgTask != null) {
         mSaveInBgTask.cancel(false);
     }

Find a functionally equivalent code:android.widget.DatePicker.getDayOfMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected day of month.
 */

@@ -1,3 +1,3 @@
 {
-    return mCurrentDate.get(Calendar.DAY_OF_MONTH);
+    return mDelegate.getDayOfMonth();
 }

Find a functionally equivalent code:android.graphics.Canvas.drawCircle:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified circle using the specified paint. If radius is <= 0,
 * then nothing will be drawn. The circle will be filled or framed based
 * on the Style in the paint.
 *
 * @param cx     The x-coordinate of the center of the cirle to be drawn
 * @param cy     The y-coordinate of the center of the cirle to be drawn
 * @param radius The radius of the cirle to be drawn
 * @param paint  The paint used to draw the circle
 */

@@ -1,3 +1,3 @@
 {
-    native_drawCircle(mNativeCanvas, cx, cy, radius, paint.mNativePaint);
+    native_drawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.mNativePaint);
 }

Find a functionally equivalent code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

@@ -1,18 +1,14 @@
 {
     if (startAlpha == endAlpha) {
-        // run listener if we're noop'ing the animation, to get the end-state results now
-        if (listener != null) {
-            listener.onAnimationEnd(null);
-        }
         return null;
     }
-    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", startAlpha, endAlpha);
+    view.setTransitionAlpha(startAlpha);
+    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
     if (DBG) {
         Log.d(LOG_TAG, "Created animator " + anim);
     }
-    if (listener != null) {
-        anim.addListener(listener);
-        anim.addPauseListener(listener);
-    }
+    FadeAnimatorListener listener = new FadeAnimatorListener(view);
+    anim.addListener(listener);
+    anim.addPauseListener(listener);
     return anim;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onIntChanged:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Called when an int feature changes, for the window to update its
 * graphics.
 *
 * @param featureId The feature being changed.
 * @param value The new integer value.
 */

@@ -2,8 +2,8 @@
     if (featureId == FEATURE_PROGRESS || featureId == FEATURE_INDETERMINATE_PROGRESS) {
         updateProgressBars(value);
     } else if (featureId == FEATURE_CUSTOM_TITLE) {
-        FrameLayout titleContainer = (FrameLayout) findViewById(com.android.internal.R.id.title_container);
+        FrameLayout titleContainer = (FrameLayout) findViewById(R.id.title_container);
         if (titleContainer != null) {
             mLayoutInflater.inflate(value, titleContainer);
         }

Find a functionally equivalent code:android.graphics.Paint.setPathEffect:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the patheffect object.
 * <p />
 * Pass null to clear any previous patheffect.
 * As a convenience, the parameter passed is also returned.
 *
 * @param effect May be null. The patheffect to be installed in the paint
 * @return       effect
 */

@@ -1,5 +1,5 @@
 {
-    int effectNative = 0;
+    long effectNative = 0;
     if (effect != null) {
         effectNative = effect.native_instance;
     }

Find a functionally equivalent code:android.transition.Transition.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Pauses this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

@@ -2,10 +2,16 @@
     if (!mEnded) {
         ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
         int numOldAnims = runningAnimators.size();
-        for (int i = numOldAnims - 1; i >= 0; i--) {
-            Animator anim = runningAnimators.keyAt(i);
-            anim.pause();
+        if (sceneRoot != null) {
+            WindowId windowId = sceneRoot.getWindowId();
+            for (int i = numOldAnims - 1; i >= 0; i--) {
+                AnimationInfo info = runningAnimators.valueAt(i);
+                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
+                    Animator anim = runningAnimators.keyAt(i);
+                    anim.pause();
+                }
+            }
         }
         if (mListeners != null && mListeners.size() > 0) {
             ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

@@ -1,9 +1,10 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
+    if (!hasValue(index)) {
         return null;
     }
-    if (mResourceData[index] != null) {
-        return mResourceData[index].getValue();
-    }
-    return null;
+    // As unfortunate as it is, it's possible to use enums with all attribute formats,
+    // not just integers/enums. So, we need to search the enums always. In case
+    // enums are used, the returned value is an integer.
+    Integer v = resolveEnumAttribute(index);
+    return v == null ? mResourceData[index].getValue() : String.valueOf((int) v);
 }

Find a functionally equivalent code:android.view.Window.setLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Set the width and height layout parameters of the window.  The default
 * for both of these is MATCH_PARENT; you can change them to WRAP_CONTENT
 * or an absolute value to make a window that is not full-screen.
 *
 * @param width The desired layout width of the window.
 * @param height The desired layout height of the window.
 *
 * @see ViewGroup.LayoutParams#height
 * @see ViewGroup.LayoutParams#width
 */

@@ -2,8 +2,6 @@
     final WindowManager.LayoutParams attrs = getAttributes();
     attrs.width = width;
     attrs.height = height;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.goHome:COMMENT
Method Modifier: internal    
Comment:/**
 * goes to the home screen
 * @return whether it did anything
 */

@@ -18,30 +18,30 @@
                 sendCloseSystemWindows();
                 Intent dock = createHomeDockIntent();
                 if (dock != null) {
-                    int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, dock, dock.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, null, UserHandle.USER_CURRENT);
+                    int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, dock, dock.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, UserHandle.USER_CURRENT);
                     if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                         return false;
                     }
                 }
             }
-            int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, mHomeIntent, mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, null, UserHandle.USER_CURRENT);
+            int result = ActivityManagerNative.getDefault().startActivityAsUser(null, null, mHomeIntent, mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()), null, null, 0, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, UserHandle.USER_CURRENT);
             if (result == ActivityManager.START_RETURN_INTENT_TO_CALLER) {
                 return false;
             }

Find a functionally equivalent code:android.app.ApplicationPackageManager.getResourcesForApplicationAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -6,12 +6,12 @@
         return mContext.mMainThread.getSystemContext().getResources();
     }
     try {
-        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, 0, userId);
+        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, sDefaultFlags, userId);
         if (ai != null) {
             return getResourcesForApplication(ai);
         }

Find a functionally equivalent code:android.animation.ObjectAnimator.getTarget:COMMENT
Method Modifier: public      
Comment:/**
 * The target object whose property will be animated by this animation
 *
 * @return The object being animated
 */

@@ -1,3 +1,3 @@
 {
-    return mTarget;
+    return mTarget == null ? null : mTarget.get();
 }

Find a functionally equivalent code:android.graphics.pdf.PdfDocument.startPage:COMMENT
Method Modifier: public      
Comment:/**
 * Starts a page using the provided {@link PageInfo}. After the page
 * is created you can draw arbitrary content on the page's canvas which
 * you can get by calling {@link Page#getCanvas()}. After you are done
 * drawing the content you should finish the page by calling
 * {@link #finishPage(Page)}. After the page is finished you should
 * no longer access the page or its canvas.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * Also do not call this method if the last page returned by this method
 * is not finished by calling {@link #finishPage(Page)}.
 * </p>
 *
 * @param pageInfo The page info. Cannot be null.
 * @return A blank page.
 *
 * @see #finishPage(Page)
 */

@@ -4,10 +4,10 @@
     if (pageInfo == null) {
         throw new IllegalArgumentException("page cannot be null");
     }
-    Canvas canvas = new PdfCanvas(nativeCreatePage(pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
+    Canvas canvas = new PdfCanvas(nativeStartPage(mNativeDocument, pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
     mCurrentPage = new Page(canvas, pageInfo);
     return mCurrentPage;
 }

Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.insertForUser:COMMENT
Method Modifier: private     
Comment:// policy around permission to write settings for other users.

@@ -29,34 +29,35 @@
     }
     // Check write permissions only after determining which table the insert will touch
     checkWritePermissions(args);
+    checkUserRestrictions(name, desiredUserHandle);
     // The global table is stored under the owner, always
     if (TABLE_GLOBAL.equals(args.table)) {
         desiredUserHandle = UserHandle.USER_OWNER;
@@ -38,49 +39,57 @@
     if (SettingsCache.isRedundantSetValue(cache, name, value)) {
         return Uri.withAppendedPath(url, name);
     }
-    final AtomicInteger mutationCount = sKnownMutationsInFlight.get(desiredUserHandle);
-    mutationCount.incrementAndGet();
+    final AtomicInteger mutationCount;
+    synchronized (this) {
+        mutationCount = sKnownMutationsInFlight.get(callingUser);
+    }
+    if (mutationCount != null) {
+        mutationCount.incrementAndGet();
+    }
     DatabaseHelper dbH = getOrEstablishDatabase(desiredUserHandle);
     SQLiteDatabase db = dbH.getWritableDatabase();
     final long rowId = db.insert(args.table, null, initialValues);
-    mutationCount.decrementAndGet();
+    if (mutationCount != null) {
+        mutationCount.decrementAndGet();
+    }
     if (rowId <= 0)
         return null;
     // before we notify

Find a functionally equivalent code:android.transition.Transition.isValidTarget:COMMENT
Method Modifier: 
Comment:/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where "valid" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */

@@ -1,4 +1,5 @@
 {
+    int targetId = target.getId();
     if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
         return false;
     }
@@ -14,32 +15,37 @@
             }
         }
     }
-    if (mTargetIds.size() == 0 && mTargets.size() == 0) {
+    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
+        if (mTargetNameExcludes.contains(target.getTransitionName())) {
+            return false;
+        }
+    }
+    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
         return true;
     }
-    if (mTargetIds.size() > 0) {
-        for (int i = 0; i < mTargetIds.size(); ++i) {
-            if (mTargetIds.get(i) == targetId) {
-                return true;
-            }
-        }
+    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
+        return true;
+    }
+    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
+        return true;
     }
-    if (target != null && mTargets.size() > 0) {
-        for (int i = 0; i < mTargets.size(); ++i) {
-            if (mTargets.get(i) == target) {
+    if (mTargetTypes != null) {
+        for (int i = 0; i < mTargetTypes.size(); ++i) {
+            if (mTargetTypes.get(i).isInstance(target)) {
                 return true;
             }
         }

Find a functionally equivalent code:android.view.ViewGroup.addFocusables:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -2,7 +2,10 @@
     final int focusableCount = views.size();
     final int descendantFocusability = getDescendantFocusability();
     if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
+        if (shouldBlockFocusForTouchscreen()) {
+            focusableMode |= FOCUSABLES_TOUCH_MODE;
+        }
         final int count = mChildrenCount;
         final View[] children = mChildren;
         for (int i = 0; i < count; i++) {
@@ -12,19 +15,22 @@
         }
     }
     // among the focusable children would be more interesting.
-    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
-    (focusableCount == views.size())) {
+    if ((descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
+    (focusableCount == views.size())) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen())) {
         super.addFocusables(views, direction, focusableMode);
     }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.removeWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -2,10 +2,7 @@
     if (mStatusBar == win) {
         mStatusBar = null;
         mStatusBarController.setWindow(null);
-    } else if (mKeyguard == win) {
-        Log.v(TAG, "Removing keyguard window (Did it crash?)");
-        mKeyguard = null;
         mKeyguardDelegate.showScrim();
     } else if (mKeyguardScrim == win) {
         Log.v(TAG, "Removing keyguard scrim");

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.considerName:COMMENT
Method Modifier: public      
Comment:/**
 * Considers the given class name as a dependency.
 * If it does, add to the mOutDeps map.
 */

@@ -4,10 +4,10 @@
     }
     className = internalToBinaryClassName(className);
     // exclude classes that have already been found or are marked to be excluded
-    if (mInKeep.containsKey(className) || mOutKeep.containsKey(className) || mInDeps.containsKey(className) || mOutDeps.containsKey(className) || mExcludedClasses.contains(getBaseName(className))) {
+    if (mInKeep.containsKey(className) || mOutKeep.containsKey(className) || mInDeps.containsKey(className) || mOutDeps.containsKey(className) || mExcludedClasses.contains(getOuterClassName(className))) {
         return;
     }
     // exclude classes that are not part of the JAR file being examined
@@ -21,27 +21,27 @@
     // ignore
     }
     // to be stubbed).
-    if (className.indexOf("android") >= 0) {
+    if (className.contains("android")) {
         // TODO make configurable
         mOutDeps.put(className, cr);
     } else {

Find a functionally equivalent code:android.util.ArrayMap.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

@@ -1,8 +1,8 @@
 {
     if (mSize > 0) {
         freeArrays(mHashes, mArray, mSize);
-        mHashes = ContainerHelpers.EMPTY_INTS;
-        mArray = ContainerHelpers.EMPTY_OBJECTS;
+        mHashes = EmptyArray.INT;
+        mArray = EmptyArray.OBJECT;
         mSize = 0;
     }
 }

Find a functionally equivalent code:android.media.MediaPlayer.availableMimeTypeForExternalSource:COMMENT
Method Modifier: private     static      
Comment:/*
     * A helper function to check if the mime type is supported by media framework.
     */

@@ -1,5 +1,5 @@
 {
-    if (mimeType == MEDIA_MIMETYPE_TEXT_SUBRIP) {
+    if (MEDIA_MIMETYPE_TEXT_SUBRIP.equals(mimeType)) {
         return true;
     }
     return false;

Find a functionally equivalent code:android.os.Bundle.putCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putCharSequenceArray(key, value);
 }

Find a functionally equivalent code:android.hardware.camera2.utils.UncheckedThrow.throwAnyException:COMMENT
Method Modifier: public      static      
Comment:/**
 * Throw any kind of exception without needing it to be checked
 * @param e any instance of a Exception
 */


Find a functionally equivalent code:android.widget.Spinner.setPopupBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param resId Resource ID of a background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */

@@ -1,3 +1,3 @@
 {
-    setPopupBackgroundDrawable(getContext().getResources().getDrawable(resId));
+    setPopupBackgroundDrawable(getContext().getDrawable(resId));
 }

Find a functionally equivalent code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

@@ -10,15 +10,23 @@
             BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
             a2dp.close();
             break;
+        case BluetoothProfile.A2DP_SINK:
+            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
+            a2dpSink.close();
+            break;
+        case BluetoothProfile.AVRCP_CONTROLLER:
+            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
+            avrcp.close();
+            break;
         case BluetoothProfile.INPUT_DEVICE:
             BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
             iDev.close();
@@ -34,38 +42,50 @@
             BluetoothMap map = (BluetoothMap) proxy;
             map.close();
             break;
+        case BluetoothProfile.HEADSET_CLIENT:
+            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
+            headsetClient.close();
+            break;
     }
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.inflate:COMMENT
Method Modifier: public      
Comment:/**
 * Inflates the layout.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #init(long)} was not called.
 */

@@ -5,17 +5,18 @@
         HardwareConfig hardwareConfig = params.getHardwareConfig();
         BridgeContext context = getContext();
         boolean isRtl = Bridge.isLocaleRtl(params.getLocale());
-        int direction = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
+        int layoutDirection = isRtl ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
         // the view group that receives the window background.
-        ViewGroup backgroundView = null;
+        ViewGroup backgroundView;
         if (mWindowIsFloating || params.isForceNoDecor()) {
             backgroundView = mViewRoot = mContentRoot = new FrameLayout(context);
-            mViewRoot.setLayoutDirection(direction);
+            mViewRoot.setLayoutDirection(layoutDirection);
         } else {
+            int simulatedPlatformVersion = params.getSimulatedPlatformVersion();
             if (hasSoftwareButtons() && mNavigationBarOrientation == LinearLayout.VERTICAL) {
                 /*
                      * This is a special case where the navigation bar is on the right.
@@ -32,45 +33,47 @@
                        the bottom
                      */
                 LinearLayout topLayout = new LinearLayout(context);
-                topLayout.setLayoutDirection(direction);
+                topLayout.setLayoutDirection(layoutDirection);
                 mViewRoot = topLayout;
                 topLayout.setOrientation(LinearLayout.HORIZONTAL);
-                try {
-                    NavigationBar navigationBar = new NavigationBar(context, hardwareConfig.getDensity(), LinearLayout.VERTICAL, isRtl, params.isRtlSupported());
-                    navigationBar.setLayoutParams(new LinearLayout.LayoutParams(mNavigationBarSize, LayoutParams.MATCH_PARENT));
-                    topLayout.addView(navigationBar);
-                } catch (XmlPullParserException e) {
+                if (Config.showOnScreenNavBar(simulatedPlatformVersion)) {
+                    try {
+                        NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
+                        topLayout.addView(navigationBar);
+                    } catch (XmlPullParserException ignored) {
+                    }
                 }
             }
             /*
@@ -62,74 +64,76 @@
                  */
             LinearLayout topLayout = new LinearLayout(context);
             topLayout.setOrientation(LinearLayout.VERTICAL);
-            topLayout.setLayoutDirection(direction);
+            topLayout.setLayoutDirection(layoutDirection);
             // if we don't already have a view root this is it
             if (mViewRoot == null) {
                 mViewRoot = topLayout;
             } else {
-                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
-                layoutParams.weight = 1;
+                int topLayoutWidth = params.getHardwareConfig().getScreenWidth() - mNavigationBarSize;
+                LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(topLayoutWidth, LayoutParams.MATCH_PARENT);
                 topLayout.setLayoutParams(layoutParams);
                 // this top layout is the first layout in the horizontal layout. see above)
                 if (isRtl && params.isRtlSupported()) {
@@ -84,131 +86,130 @@
             if (mStatusBarSize > 0) {
                 // system bar
                 try {
-                    StatusBar systemBar = new StatusBar(context, hardwareConfig.getDensity(), direction, params.isRtlSupported());
-                    systemBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mStatusBarSize));
-                    topLayout.addView(systemBar);
-                } catch (XmlPullParserException e) {
+                    StatusBar statusBar = createStatusBar(context, hardwareConfig.getDensity(), layoutDirection, params.isRtlSupported(), simulatedPlatformVersion);
+                    topLayout.addView(statusBar);
+                } catch (XmlPullParserException ignored) {
                 }
             }
             LinearLayout backgroundLayout = new LinearLayout(context);
             backgroundView = backgroundLayout;
             backgroundLayout.setOrientation(LinearLayout.VERTICAL);
-            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
             layoutParams.weight = 1;
             backgroundLayout.setLayoutParams(layoutParams);
             topLayout.addView(backgroundLayout);
             // if the theme says no title/action bar, then the size will be 0
             if (mActionBarSize > 0) {
-                try {
-                    FakeActionBar actionBar = new FakeActionBar(context, hardwareConfig.getDensity(), params.getAppLabel(), params.getAppIcon());
-                    actionBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mActionBarSize));
-                    backgroundLayout.addView(actionBar);
-                } catch (XmlPullParserException e) {
-                }
+                ActionBarLayout actionBar = createActionBar(context, params);
+                backgroundLayout.addView(actionBar);
+                actionBar.createMenuPopup();
+                mContentRoot = actionBar.getContentRoot();
             } else if (mTitleBarSize > 0) {
                 try {
-                    TitleBar titleBar = new TitleBar(context, hardwareConfig.getDensity(), params.getAppLabel());
-                    titleBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mTitleBarSize));
+                    TitleBar titleBar = createTitleBar(context, params.getAppLabel(), simulatedPlatformVersion);
                     backgroundLayout.addView(titleBar);
-                } catch (XmlPullParserException e) {
+                } catch (XmlPullParserException ignored) {
                 }
             }
             // content frame
-            mContentRoot = new FrameLayout(context);
-            layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
-            layoutParams.weight = 1;
-            mContentRoot.setLayoutParams(layoutParams);
-            backgroundLayout.addView(mContentRoot);
-            if (mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
+            if (mContentRoot == null) {
+                mContentRoot = new FrameLayout(context);
+                layoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);
+                layoutParams.weight = 1;
+                mContentRoot.setLayoutParams(layoutParams);
+                backgroundLayout.addView(mContentRoot);
+            }
+            if (Config.showOnScreenNavBar(simulatedPlatformVersion) && mNavigationBarOrientation == LinearLayout.HORIZONTAL && mNavigationBarSize > 0) {
                 // system bar
                 try {
-                    NavigationBar navigationBar = new NavigationBar(context, hardwareConfig.getDensity(), LinearLayout.HORIZONTAL, isRtl, params.isRtlSupported());
-                    navigationBar.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, mNavigationBarSize));
+                    NavigationBar navigationBar = createNavigationBar(context, hardwareConfig.getDensity(), isRtl, params.isRtlSupported(), simulatedPlatformVersion);
                     topLayout.addView(navigationBar);
-                } catch (XmlPullParserException e) {
+                } catch (XmlPullParserException ignored) {
                 }
             }
         }
@@ -141,147 +140,146 @@
         // post-inflate process. For now this supports TabHost/TabWidget
         postInflateProcess(view, params.getProjectCallback());
         // get the background drawable
-        if (mWindowBackground != null && backgroundView != null) {
+        if (mWindowBackground != null) {
             Drawable d = ResourceHelper.getDrawable(mWindowBackground, context);
             backgroundView.setBackground(d);
         }

Find a functionally equivalent code:android.content.RestrictionEntry.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the type for this restriction.
 * @return the type for this restriction
 */

@@ -1,3 +1,3 @@
 {
-    return type;
+    return mType;
 }

Find a functionally equivalent code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

@@ -18,25 +18,25 @@
             return 12;
         case RAW_SENSOR:
             return 16;
-        case BAYER_RGGB:
-            return 16;
+        case RAW10:
+            return 10;
     }
     return -1;
 }

Find a functionally equivalent code:android.app.Activity.onWindowStartingActionMode:COMMENT
Method Modifier: public      
Comment:/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */

@@ -1,5 +1,5 @@
 {
-    initActionBar();
+    initWindowDecorActionBar();
     if (mActionBar != null) {
         return mActionBar.startActionMode(callback);
     }

Find a functionally equivalent code:android.media.MediaFocusControl.requestAudioFocus:COMMENT
Method Modifier: protected   
Comment:/**
 * @see AudioManager#requestAudioFocus(AudioManager.OnAudioFocusChangeListener, int, int)
 */

@@ -44,53 +44,49 @@
         }
         // push focus requester at the top of the audio focus stack
         mFocusStack.push(new FocusRequester(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid()));
-        // there's a new top of the stack, let the remote control know
-        synchronized (mRCStack) {
-            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-        }
     }
     return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
 }

Find a functionally equivalent code:android.widget.CalendarView.setShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the number of weeks to be shown.
 *
 * @param count The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

@@ -1,6 +1,3 @@
 {
-    if (mShownWeekCount != count) {
-        mShownWeekCount = count;
-        invalidate();
-    }
+    mDelegate.setShownWeekCount(count);
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.insertChild:COMMENT
Method Modifier: public      
Comment:/**
 * Insert a new child into an existing parent.
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#insertChild(Object, ILayoutPullParser, int, IAnimationListener)
 */

@@ -28,34 +28,34 @@
     }
     // add it to the parentView in the correct location
     Result result = addView(parentView, child, index);
-    if (result.isSuccess() == false) {
+    if (!result.isSuccess()) {
         return result;
     }
     result = render(false);

Find a functionally equivalent code:android.app.Activity.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically opens the options menu. If the options menu is already
 * open, this method does nothing.
 */

@@ -1,3 +1,5 @@
 {
-    mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
+    if (mActionBar == null || !mActionBar.openOptionsMenu()) {
+        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
+    }
 }

Find a functionally equivalent code:android.print.PrinterCapabilitiesInfo.getMediaSizes:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported media sizes.
 *
 * @return The media sizes.
 */

@@ -1,3 +1,3 @@
 {
-    return mMediaSizes;
+    return Collections.unmodifiableList(mMediaSizes);
 }

Find a functionally equivalent code:android.widget.CalendarView.getShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of weeks to be shown.
 *
 * @return The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

@@ -1,3 +1,3 @@
 {
-    return mShownWeekCount;
+    return mDelegate.getShownWeekCount();
 }

Find a functionally equivalent code:android.bluetooth.BluetoothDevice.createBond:COMMENT
Method Modifier: public      
Comment:/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */

@@ -4,10 +4,10 @@
         return false;
     }
     try {
-        return sService.createBond(this);
+        return sService.createBond(this, TRANSPORT_AUTO);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
     }

Find a functionally equivalent code:android.graphics.Canvas.drawPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified path using the specified paint. The path will be
 * filled or framed based on the Style in the paint.
 *
 * @param path  The path to be drawn
 * @param paint The paint used to draw the path
 */

@@ -1,3 +1,3 @@
 {
-    native_drawPath(mNativeCanvas, path.ni(), paint.mNativePaint);
+    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.mNativePaint);
 }

Find a functionally equivalent code:android.graphics.Bitmap.getAllocationByteCount:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the allocated memory used to store this bitmap's pixels.
 *
 * <p>This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to
 * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link
 * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link
 * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap
 * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be
 * the same as that returned by {@link #getByteCount()}.</p>
 *
 * <p>This value will not change over the lifetime of a Bitmap.</p>
 *
 * @see #reconfigure(int, int, Config)
 */

@@ -1,3 +1,7 @@
 {
+    if (mBuffer == null) {
+        // so alloc size is always content size
+        return getByteCount();
+    }
     return mBuffer.length;
 }

Find a functionally equivalent code:android.app.Activity.startActivityForResult:COMMENT
Method Modifier: public      
Comment:/**
 * Same as calling {@link #startActivityForResult(Intent, int, Bundle)}
 * with no options.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see #startActivity
 */


Find a functionally equivalent code:android.nfc.tech.Ndef.getNdefMessage:COMMENT
Method Modifier: public      
Comment:/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */

@@ -12,17 +12,19 @@
                 throw new TagLostException();
             }
             return msg;
+        } else if (!tagService.isPresent(serviceHandle)) {
+            throw new TagLostException();
         } else {
             return null;
         }

Find a functionally equivalent code:android.widget.AbsListView.isFastScrollEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */

@@ -1,7 +1,7 @@
 {
-    if (mFastScroller == null) {
+    if (mFastScroll == null) {
         return mFastScrollEnabled;
     } else {
-        return mFastScroller.isEnabled();
+        return mFastScroll.isEnabled();
     }
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.handleSystemServerProcess:COMMENT
Method Modifier: private     static      internal    
Comment:/**
 * Finish remaining work for the newly forked system server process.
 */

@@ -1,17 +1,34 @@
 {
     closeServerSocket();
     // set umask to 0077 so new files and directories will default to owner-only permissions.
-    Libcore.os.umask(S_IRWXG | S_IRWXO);
+    Os.umask(S_IRWXG | S_IRWXO);
     if (parsedArgs.niceName != null) {
         Process.setArgV0(parsedArgs.niceName);
     }
+    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
+    if (systemServerClasspath != null) {
+        performSystemServerDexOpt(systemServerClasspath);
+    }
     if (parsedArgs.invokeWith != null) {
-        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, parsedArgs.remainingArgs);
+        String[] args = parsedArgs.remainingArgs;
+        // correctly when we exec a new process.
+        if (systemServerClasspath != null) {
+            String[] amendedArgs = new String[args.length + 2];
+            amendedArgs[0] = "-cp";
+            amendedArgs[1] = systemServerClasspath;
+            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);
+        }
+        WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, null, args);
     } else {
+        ClassLoader cl = null;
+        if (systemServerClasspath != null) {
+            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());
+            Thread.currentThread().setContextClassLoader(cl);
+        }
         /*
              * Pass the remaining arguments to SystemServer.
              */
-        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
+        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
     }
 /* should never reach here */
 }

Find a functionally equivalent code:android.app.ActivityManager.dumpPackageStateStatic:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -1,14 +1,16 @@
 {
     FileOutputStream fout = new FileOutputStream(fd);
     PrintWriter pw = new FastPrintWriter(fout);
-    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "package", packageName });
+    dumpService(pw, fd, "package", new String[] { packageName });
+    pw.println();
+    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "-a", "package", packageName });
+    pw.println();
+    dumpService(pw, fd, "meminfo", new String[] { "--local", "--package", packageName });
     pw.println();
     dumpService(pw, fd, ProcessStats.SERVICE_NAME, new String[] { packageName });
     pw.println();
     dumpService(pw, fd, "usagestats", new String[] { "--packages", packageName });
     pw.println();
-    dumpService(pw, fd, "package", new String[] { packageName });
-    pw.println();
     dumpService(pw, fd, BatteryStats.SERVICE_NAME, new String[] { packageName });
     pw.flush();
 }

Find a functionally equivalent code:android.app.Notification.Style.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -5,8 +5,9 @@
     if (mBigContentTitle != null) {
         extras.putCharSequence(EXTRA_TITLE_BIG, mBigContentTitle);
     }
+    extras.putString(EXTRA_TEMPLATE, this.getClass().getName());
 }

Find a functionally equivalent code:android.view.HardwareLayer.isValid:COMMENT
<android.view.HardwareLayer: boolean isValid()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Indicates whether this layer can be rendered.
 *
 * @return True if the layer can be rendered into, false otherwise
 */

@@ -1 +1,3 @@
-
+{
+    return mFinalizer != null && mFinalizer.get() != 0;
+}

Find a functionally equivalent code:android.content.res.TypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {

Find a functionally equivalent code:android.graphics.Canvas.translate:COMMENT
<android.graphics.Canvas: void translate(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified translation
 *
 * @param dx The distance to translate in X
 * @param dy The distance to translate in Y
 */

@@ -1 +1,3 @@
-
+{
+    native_translate(mNativeCanvasWrapper, dx, dy);
+}

Find a functionally equivalent code:android.content.res.TypedArray.getResources:COMMENT
Method Modifier: public      
Comment:/**
 * Return the Resources object this array was loaded from.
 */

@@ -1,3 +1,6 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     return mResources;
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.DependencyVisitor.MyMethodVisitor.visitFieldInsn:COMMENT
Method Modifier: public      
Comment:// field instruction

@@ -1,6 +1,6 @@
 {
-    // name is the field's name.
-    considerName(name);
+    // owner is the class that declares the field.
+    considerName(owner);
     // desc is the field's descriptor (see Type).
     considerDesc(desc);
 }

Find a functionally equivalent code:android.view.SurfaceControl.PhysicalDisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

@@ -1,3 +1,3 @@
 {
-    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + "}";
+    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + ", appVsyncOffset " + appVsyncOffsetNanos + ", bufferDeadline " + presentationDeadlineNanos + "}";
 }

Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.doSecondaryLookupIfNecessary:COMMENT
Method Modifier: default     static      internal    
Comment:/**
 * Performs another lookup if previous lookup fails and it's a SIP call
 * and the peer's username is all numeric. Look up the username as it
 * could be a PSTN number in the contact database.
 *
 * @param context the query context
 * @param number the original phone number, could be a SIP URI
 * @param previousResult the result of previous lookup
 * @return previousResult if it's not the case
 */

@@ -2,8 +2,8 @@
     if (!previousResult.contactExists && PhoneNumberUtils.isUriNumber(number)) {
         String username = PhoneNumberUtils.getUsernameFromUriNumber(number);
         if (PhoneNumberUtils.isGlobalPhoneNumber(username)) {
-            previousResult = getCallerInfo(context, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(username)));
+            previousResult = getCallerInfo(context, Uri.withAppendedPath(PhoneLookup.ENTERPRISE_CONTENT_FILTER_URI, Uri.encode(username)));
         }
     }
     return previousResult;

Find a functionally equivalent code:com.android.internal.view.InputBindResult.writeToParcel:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

@@ -8,11 +8,12 @@
     }
     dest.writeString(id);
     dest.writeInt(sequence);
+    dest.writeInt(userActionNotificationSequenceNumber);
 }

Find a functionally equivalent code:android.content.res.TypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

@@ -1,6 +1,12 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     final TypedValue value = mValue;
     if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
+        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
+            throw new RuntimeException("Failed to resolve attribute at index " + index);
+        }
         return mResources.loadColorStateList(value, value.resourceId);
     }
     return null;

Find a functionally equivalent code:android.media.MediaPlayer.setAuxEffectSendLevel:COMMENT
<android.media.MediaPlayer: void setAuxEffectSendLevel(float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the send level of the player to the attached auxiliary effect
 * {@see #attachAuxEffect(int)}. The level value range is 0 to 1.0.
 * <p>By default the send level is 0, so even if an effect is attached to the player
 * this method must be called for the effect to be applied.
 * <p>Note that the passed level value is a raw scalar. UI controls should be scaled
 * logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 * so an appropriate conversion from linear UI input x to level is:
 * x == 0 -> level = 0
 * 0 < x <= R -> level = 10^(72*(x-R)/20/R)
 * @param level send level scalar
 */

@@ -1 +1,6 @@
-
+{
+    if (isRestricted()) {
+        return;
+    }
+    _setAuxEffectSendLevel(level);
+}

Find a functionally equivalent code:android.widget.CalendarView.setWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the separator line between weeks.
 *
 * @param color The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

@@ -1,6 +1,3 @@
 {
-    if (mWeekSeparatorLineColor != color) {
-        mWeekSeparatorLineColor = color;
-        invalidateAllWeekViews();
-    }
+    mDelegate.setWeekSeparatorLineColor(color);
 }

Find a functionally equivalent code:android.content.SyncInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     parcel.writeInt(authorityId);
-    account.writeToParcel(parcel, 0);
+    parcel.writeParcelable(account, flags);
     parcel.writeString(authority);
     parcel.writeLong(startTime);
 }

Find a functionally equivalent code:android.view.HardwareLayer.destroy:COMMENT
<android.view.HardwareLayer: void destroy()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Destroys resources without waiting for a GC.
 */

@@ -1 +1,10 @@
-
+{
+    if (!isValid()) {
+        // Already destroyed
+        return;
+    }
+    mRenderer.onLayerDestroyed(this);
+    mRenderer = null;
+    mFinalizer.release();
+    mFinalizer = null;
+}

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onRefreshCarrierInfo:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshCarrierInfo(CharSequence,CharSequence)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the carrier PLMN or SPN changes.
 *
 * @param plmn The operator name of the registered network.  May be null if it shouldn't
 * be displayed.
 * @param spn The service provider name.  May be null if it shouldn't be displayed.
 */


Find a functionally equivalent code:android.app.SharedPreferencesImpl.EditorImpl.commitToMemory:COMMENT
Method Modifier: private     
Comment:// Returns true if any changes were made

@@ -27,40 +27,39 @@
             for (Map.Entry<String, Object> e : mModified.entrySet()) {
                 String k = e.getKey();
                 Object v = e.getValue();
-                if (v == this) {
-                    // magic value for a removal mutation
+                // equivalent to calling remove on that key.
+                if (v == this || v == null) {
                     if (!mMap.containsKey(k)) {
                         continue;
                     }
                     mMap.remove(k);
                 } else {
-                    boolean isSame = false;
                     if (mMap.containsKey(k)) {
                         Object existingValue = mMap.get(k);
                         if (existingValue != null && existingValue.equals(v)) {

Find a functionally equivalent code:android.widget.ShareActionProvider.onCreateActionView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,12 +1,14 @@
 {
     // Create the view and set its data model.
-    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
     ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
-    activityChooserView.setActivityChooserModel(dataModel);
+    if (!activityChooserView.isInEditMode()) {
+        ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
+        activityChooserView.setActivityChooserModel(dataModel);
+    }
     // Lookup and set the expand action icon.
     TypedValue outTypedValue = new TypedValue();
     mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
-    Drawable drawable = mContext.getResources().getDrawable(outTypedValue.resourceId);
+    Drawable drawable = mContext.getDrawable(outTypedValue.resourceId);
     activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
     activityChooserView.setProvider(this);
     // Set content description.

Find a functionally equivalent code:android.net.Proxy.setHttpProxySystemProperty:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

@@ -2,12 +2,12 @@
     String host = null;
     String port = null;
     String exclList = null;
-    String pacFileUrl = null;
+    Uri pacFileUrl = Uri.EMPTY;
     if (p != null) {
         host = p.getHost();
         port = Integer.toString(p.getPort());
-        exclList = p.getExclusionList();
+        exclList = p.getExclusionListAsString();
         pacFileUrl = p.getPacFileUrl();
     }
     setHttpProxySystemProperty(host, port, exclList, pacFileUrl);

Find a functionally equivalent code:android.util.EventLog.Event.getTag:COMMENT
Method Modifier: public      
Comment:/**
 * @return the type tag code of the entry
 */

@@ -1,3 +1,7 @@
 {
-    return mBuffer.getInt(TAG_OFFSET);
+    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
+    if (offset == 0) {
+        offset = V1_PAYLOAD_START;
+    }
+    return mBuffer.getInt(offset);
 }

Find a functionally equivalent code:android.animation.ValueAnimator.delayedAnimationFrame:COMMENT
Method Modifier: private     
Comment:/**
 * Internal function called to process an animation frame on an animation that is currently
 * sleeping through its <code>startDelay</code> phase. The return value indicates whether it
 * should be woken up and put on the active animations queue.
 *
 * @param currentTime The current animation time, used to calculate whether the animation
 * has exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animation
 * should be added to the set of active animations.
 */

@@ -2,28 +2,27 @@
     if (!mStartedDelay) {
         mStartedDelay = true;
         mDelayStartTime = currentTime;
-    } else {
-        if (mPaused) {
-            if (mPauseTime < 0) {
-                mPauseTime = currentTime;
-            }
-            return false;
-        } else if (mResumed) {
-            mResumed = false;
-            if (mPauseTime > 0) {
-                // Offset by the duration that the animation was paused
-                mDelayStartTime += (currentTime - mPauseTime);
-            }
+    }
+    if (mPaused) {
+        if (mPauseTime < 0) {
+            mPauseTime = currentTime;
         }
-        long deltaTime = currentTime - mDelayStartTime;
-        if (deltaTime > mStartDelay) {
-            // startDelay ended - start the anim and record the
-            // mStartTime appropriately
-            mStartTime = currentTime - (deltaTime - mStartDelay);
-            mPlayingState = RUNNING;
-            return true;
+        return false;
+    } else if (mResumed) {
+        mResumed = false;
+        if (mPauseTime > 0) {
+            // Offset by the duration that the animation was paused
+            mDelayStartTime += (currentTime - mPauseTime);
         }
     }
+    long deltaTime = currentTime - mDelayStartTime;
+    if (deltaTime > mStartDelay) {
+        // startDelay ended - start the anim and record the
+        // mStartTime appropriately
+        mStartTime = currentTime - (deltaTime - mStartDelay);
+        mPlayingState = RUNNING;
+        return true;
+    }
     return false;
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupEndValue:COMMENT
Method Modifier: 
Comment:/**
 * This function is called by ObjectAnimator when setting the end values for an animation.
 * The end values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

@@ -1,3 +1,6 @@
 {
-    setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
+    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
+    if (!keyframes.isEmpty()) {
+        setupValue(target, keyframes.get(keyframes.size() - 1));
+    }
 }

Find a functionally equivalent code:com.android.documentsui.RootsCache.updateAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Gather roots from all known storage providers.
 */

@@ -2,9 +2,9 @@
     // Special root for recents
     mRecentsRoot.authority = null;
     mRecentsRoot.rootId = null;
-    mRecentsRoot.icon = R.drawable.ic_root_recent;
-    mRecentsRoot.flags = Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_CREATE;
+    mRecentsRoot.derivedIcon = R.drawable.ic_root_recent;
+    mRecentsRoot.flags = Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_IS_CHILD;
     mRecentsRoot.title = mContext.getString(R.string.root_recent);
     mRecentsRoot.availableBytes = -1;
     new UpdateTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);

Find a functionally equivalent code:android.app.ActivityThread.handleCreateBackupAgent:COMMENT
Method Modifier: private     
Comment:// Instantiate a BackupAgent and tell it that it's alive

@@ -21,31 +21,26 @@
         Slog.d(TAG, "Asked to create backup agent for nonexistent package");
         return;
     }
-    if (mBackupAgents.get(packageName) != null) {
-        Slog.d(TAG, "BackupAgent " + "  for " + packageName + " already exists");
-        return;
-    }
-    BackupAgent agent = null;
     String classname = data.appInfo.backupAgentName;
     // full backup operation but no app-supplied agent?  use the default implementation
     if (classname == null && (data.backupMode == IApplicationThread.BACKUP_MODE_FULL || data.backupMode == IApplicationThread.BACKUP_MODE_RESTORE_FULL)) {
@@ -33,59 +28,62 @@
     }
     try {
         IBinder binder = null;
-        try {
-            if (DEBUG_BACKUP)
-                Slog.v(TAG, "Initializing agent class " + classname);
-            java.lang.ClassLoader cl = packageInfo.getClassLoader();
-            agent = (BackupAgent) cl.loadClass(classname).newInstance();
-            // set up the agent's context
-            ContextImpl context = new ContextImpl();
-            context.init(packageInfo, null, this);
-            context.setOuterContext(agent);
-            agent.attach(context);
-            agent.onCreate();
+        BackupAgent agent = mBackupAgents.get(packageName);
+        if (agent != null) {
+            // reusing the existing instance
+            if (DEBUG_BACKUP) {
+                Slog.v(TAG, "Reusing existing agent instance");
+            }
             binder = agent.onBind();
-            mBackupAgents.put(packageName, agent);
-        } catch (Exception e) {
-            // If this is during restore, fail silently; otherwise go
-            // ahead and let the user see the crash.
-            Slog.e(TAG, "Agent threw during creation: " + e);
-            if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
-                throw e;
+        } else {
+            try {
+                if (DEBUG_BACKUP)
+                    Slog.v(TAG, "Initializing agent class " + classname);
+                java.lang.ClassLoader cl = packageInfo.getClassLoader();
+                agent = (BackupAgent) cl.loadClass(classname).newInstance();
+                // set up the agent's context
+                ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
+                context.setOuterContext(agent);
+                agent.attach(context);
+                agent.onCreate();
+                binder = agent.onBind();
+                mBackupAgents.put(packageName, agent);
+            } catch (Exception e) {
+                // If this is during restore, fail silently; otherwise go
+                // ahead and let the user see the crash.
+                Slog.e(TAG, "Agent threw during creation: " + e);
+                if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
+                    throw e;
+                }
+            // falling through with 'binder' still null
             }
-        // falling through with 'binder' still null
         }
         // tell the OS that we're live now
         try {

Find a functionally equivalent code:android.net.LocalSocketImpl.create:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */

@@ -16,22 +16,22 @@
                 throw new IllegalStateException("unknown sockType");
         }
         try {
-            fd = Libcore.os.socket(OsConstants.AF_UNIX, osType, 0);
+            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
             mFdCreatedInternally = true;
         } catch (ErrnoException e) {
             e.rethrowAsIOException();

Find a functionally equivalent code:android.os.ParcelFileDescriptor.fromFd:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */

@@ -2,8 +2,8 @@
     final FileDescriptor original = new FileDescriptor();
     original.setInt$(fd);
     try {
-        final FileDescriptor dup = Libcore.os.dup(original);
+        final FileDescriptor dup = Os.dup(original);
         return new ParcelFileDescriptor(dup);
     } catch (ErrnoException e) {
         throw e.rethrowAsIOException();

Find a functionally equivalent code:com.android.systemui.statusbar.policy.DeadZone.onTouchEvent:COMMENT
Method Modifier: public      
Comment:// I made you a touch event...

@@ -1,18 +1,18 @@
 {
     if (DEBUG) {
-        Log.v(TAG, this + " onTouch: " + MotionEvent.actionToString(event.getAction()));
+        Slog.v(TAG, this + " onTouch: " + MotionEvent.actionToString(event.getAction()));
     }
     final int action = event.getAction();
     if (action == MotionEvent.ACTION_OUTSIDE) {
         poke(event);
     } else if (action == MotionEvent.ACTION_DOWN) {
         if (DEBUG) {
-            Log.v(TAG, this + " ACTION_DOWN: " + event.getX() + "," + event.getY());
+            Slog.v(TAG, this + " ACTION_DOWN: " + event.getX() + "," + event.getY());
         }
         int size = (int) getSize(event.getEventTime());
         if ((mVertical && event.getX() < size) || event.getY() < size) {
             if (CHATTY) {
-                Log.v(TAG, "consuming errant click: (" + event.getX() + "," + event.getY() + ")");
+                Slog.v(TAG, "consuming errant click: (" + event.getX() + "," + event.getY() + ")");
             }
             if (mShouldFlash) {
                 post(mDebugFlash);

Find a functionally equivalent code:android.animation.ObjectAnimator.setTarget:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the target object whose property will be animated by this animation
 *
 * @param target The object being animated
 */

@@ -1,11 +1,8 @@
 {
-    if (mTarget != target) {
-        final Object oldTarget = mTarget;
-        mTarget = target;
-        if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
-            return;
-        }
-        // New target type should cause re-initialization prior to starting
+    final Object oldTarget = getTarget();
+    if (oldTarget != target) {
+        mTarget = target == null ? null : new WeakReference<Object>(target);
+        // New target should cause re-initialization prior to starting
         mInitialized = false;
     }
 }

Find a functionally equivalent code:android.graphics.drawable.NinePatchDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     if (needsMirroring()) {
-        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.right, mOpticalInsets.bottom);
+        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.left, mOpticalInsets.bottom);
     } else {
         return mOpticalInsets;
     }

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the orientation of the gradient defined in this drawable.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param orientation The desired orientation (angle) of the gradient
 *
 * @see #mutate()
 */

@@ -1,5 +1,5 @@
 {
     mGradientState.mOrientation = orientation;
-    mRectIsDirty = true;
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.preference.Preference.compareTo:COMMENT
Method Modifier: public      
Comment:/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */

@@ -1,5 +1,5 @@
 {
-    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
+    if (mOrder != another.mOrder) {
         // Do order comparison
         return mOrder - another.mOrder;
     } else if (mTitle == another.mTitle) {

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setIntValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of ints.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

@@ -1,4 +1,4 @@
 {
     mValueType = int.class;
-    mKeyframeSet = KeyframeSet.ofInt(values);
+    mKeyframes = KeyframeSet.ofInt(values);
 }

Find a functionally equivalent code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

@@ -1,6 +1,6 @@
 {
     try {
-        ActivityManagerNative.getDefault().releasePersistableUriPermission(uri, modeFlags);
+        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
     } catch (RemoteException e) {
     }
 }

Find a functionally equivalent code:android.widget.AbsListView.isFastScrollAlwaysVisible:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */

@@ -1,7 +1,7 @@
 {
-    if (mFastScroller == null) {
+    if (mFastScroll == null) {
         return mFastScrollEnabled && mFastScrollAlwaysVisible;
     } else {
-        return mFastScroller.isEnabled() && mFastScroller.isAlwaysShowEnabled();
+        return mFastScroll.isEnabled() && mFastScroll.isAlwaysShowEnabled();
     }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.GlobalActions.createDialog:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Create the global actions dialog.
 * @return A new dialog.
 */

@@ -40,122 +40,79 @@
     };
     onAirplaneModeChanged();
     mItems = new ArrayList<Action>();
-    // first: power off
-    mItems.add(new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off) {
-
-        public void onPress() {
-            // shutdown by making sure radio and power are handled accordingly.
-            mWindowManagerFuncs.shutdown(true);
-        }
-
-        public boolean onLongPress() {
-            mWindowManagerFuncs.rebootSafeMode(true);
-            return true;
-        }
-
-        public boolean showDuringKeyguard() {
-            return true;
-        }
-
-        public boolean showBeforeProvisioning() {
-            return true;
+    String[] defaultActions = mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList);
+    ArraySet<String> addedKeys = new ArraySet<String>();
+    for (int i = 0; i < defaultActions.length; i++) {
+        String actionKey = defaultActions[i];
+        if (addedKeys.contains(actionKey)) {
+            // If we already have added this, don't add it again.
+            continue;
+        }
+        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
+            mItems.add(new PowerAction());
+        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
+            mItems.add(mAirplaneModeOn);
+        } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
+            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
+                mItems.add(getBugReportAction());
+            }
+        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
+            if (mShowSilentToggle) {
+                mItems.add(mSilentModeAction);
+            }
+        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
+            if (SystemProperties.getBoolean("fw.power_user_switcher", false)) {
+                addUsersToMenu(mItems);
+            }
+        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
+            mItems.add(getSettingsAction());
+        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
+            mItems.add(getLockdownAction());
+        } else {
+            Log.e(TAG, "Invalid global action key " + actionKey);
         }
-    });
-    // next: airplane mode
-    mItems.add(mAirplaneModeOn);
-    // next: bug report, if enabled
-    if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
-        mItems.add(new SinglePressAction(com.android.internal.R.drawable.stat_sys_adb, R.string.global_action_bug_report) {
-
-            public void onPress() {
-                AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
-                builder.setTitle(com.android.internal.R.string.bugreport_title);
-                builder.setMessage(com.android.internal.R.string.bugreport_message);
-                builder.setNegativeButton(com.android.internal.R.string.cancel, null);
-                builder.setPositiveButton(com.android.internal.R.string.report, new DialogInterface.OnClickListener() {
-
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        // Add a little delay before executing, to give the
-                        // dialog a chance to go away before it takes a
-                        // screenshot.
-                        mHandler.postDelayed(new Runnable() {
-
-                            @Override
-                            public void run() {
-                                try {
-                                    ActivityManagerNative.getDefault().requestBugReport();
-                                } catch (RemoteException e) {
-                                }
-                            }
-                        }, 500);
-                    }
-                });
-                AlertDialog dialog = builder.create();
-                dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
-                dialog.show();
-            }
-
-            public boolean onLongPress() {
-                return false;
-            }
-
-            public boolean showDuringKeyguard() {
-                return true;
-            }
-
-            public boolean showBeforeProvisioning() {
-                return false;
-            }
-        });
-    }
-    // last: silent mode
-    if (mShowSilentToggle) {
-        mItems.add(mSilentModeAction);
+        // Add here so we don't add more than one.
+        addedKeys.add(actionKey);
     }
-    // one more thing: optionally add a list of users to switch to
-    if (SystemProperties.getBoolean("fw.power_user_switcher", false)) {
-        addUsersToMenu(mItems);
-    }
     mAdapter = new MyAdapter();
     AlertParams params = new AlertParams(mContext);
     params.mAdapter = mAdapter;
@@ -131,137 +88,98 @@
 
         @Override
         public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
-            return mAdapter.getItem(position).onLongPress();
+            final Action action = mAdapter.getItem(position);
+            if (action instanceof LongPressAction) {
+                return ((LongPressAction) action).onLongPress();
+            }
+            return false;
         }
     });
     dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

@@ -1,10 +1,4 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return null;
-    }
-    if (mResourceData[index] != null) {
-        // FIXME: handle styled strings!
-        return mResourceData[index].getValue();
-    }
-    return null;
+    // FIXME: handle styled strings!
+    return getString(index);
 }

Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.CallerInfoAsyncQueryHandler.onQueryComplete:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Overrides onQueryComplete from AsyncQueryHandler.
 *
 * This method takes into account the state of this class; we construct the CallerInfo
 * object only once for each set of listeners. When the query thread has done its work
 * and calls this method, we inform the remaining listeners in the queue, until we're
 * out of listeners.  Once we get the message indicating that we should expect no new
 * listeners for this CallerInfo object, we release the AsyncCursorInfo back into the
 * pool.
 */

@@ -7,35 +7,41 @@
         // check the parameters to make sure they're viable.
         if (DBG)
             Rlog.d(LOG_TAG, "Cookie is null, ignoring onQueryComplete() request.");
+        if (cursor != null) {
+            cursor.close();
+        }
         return;
     }
     if (cw.event == EVENT_END_OF_QUEUE) {
         release();
+        if (cursor != null) {
+            cursor.close();
+        }
         return;
     }
     // check the token and if needed, create the callerinfo object.
     if (mCallerInfo == null) {
-        if ((mQueryContext == null) || (mQueryUri == null)) {
+        if ((mContext == null) || (mQueryUri == null)) {
             throw new QueryPoolException("Bad context or query uri, or CallerInfoAsyncQuery already released.");
         }
         // accordingly.
         if (cw.event == EVENT_EMERGENCY_NUMBER) {
             // Note we're setting the phone number here (refer to javadoc
             // comments at the top of CallerInfo class).
-            mCallerInfo = new CallerInfo().markAsEmergency(mQueryContext);
+            mCallerInfo = new CallerInfo().markAsEmergency(mContext);
         } else if (cw.event == EVENT_VOICEMAIL_NUMBER) {
-            mCallerInfo = new CallerInfo().markAsVoiceMail();
+            mCallerInfo = new CallerInfo().markAsVoiceMail(cw.subId);
         } else {
-            mCallerInfo = CallerInfo.getCallerInfo(mQueryContext, mQueryUri, cursor);
+            mCallerInfo = CallerInfo.getCallerInfo(mContext, mQueryUri, cursor);
             if (DBG)
                 Rlog.d(LOG_TAG, "==> Got mCallerInfo: " + mCallerInfo);
-            CallerInfo newCallerInfo = CallerInfo.doSecondaryLookupIfNecessary(mQueryContext, cw.number, mCallerInfo);
+            CallerInfo newCallerInfo = CallerInfo.doSecondaryLookupIfNecessary(mContext, cw.number, mCallerInfo);
             if (newCallerInfo != mCallerInfo) {
                 mCallerInfo = newCallerInfo;
                 if (DBG)
@@ -42,53 +48,59 @@
                     // the CallerInfo object is totally blank here (i.e. no name
                     // *or* phoneNumber).  So we need to pass in cw.number as
                     // a fallback number.
-                    mCallerInfo.updateGeoDescription(mQueryContext, cw.number);
+                    mCallerInfo.updateGeoDescription(mContext, cw.number);
                 }
             }
             // Use the number entered by the user for display.
             if (!TextUtils.isEmpty(cw.number)) {
-                mCallerInfo.phoneNumber = PhoneNumberUtils.formatNumber(cw.number, mCallerInfo.normalizedNumber, CallerInfo.getCurrentCountryIso(mQueryContext));
+                mCallerInfo.phoneNumber = PhoneNumberUtils.formatNumber(cw.number, mCallerInfo.normalizedNumber, CallerInfo.getCurrentCountryIso(mContext));
             }
         }
         if (DBG)
@@ -63,66 +69,75 @@
             Rlog.d(LOG_TAG, "notifying listener: " + cw.listener.getClass().toString() + " for token: " + token + mCallerInfo);
         cw.listener.onQueryComplete(token, cw.cookie, mCallerInfo);
     }
+    if (cursor != null) {
+        cursor.close();
+    }
 }

Find a functionally equivalent code:android.graphics.Canvas.concat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified matrix. If the specified
 * matrix is null, this method does nothing.
 *
 * @param matrix The matrix to preconcatenate with the current matrix
 */

@@ -1,4 +1,4 @@
 {
     if (matrix != null)
-        native_concat(mNativeCanvas, matrix.native_instance);
+        native_concat(mNativeCanvasWrapper, matrix.native_instance);
 }

Find a functionally equivalent code:android.os.Process.myPid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process, which can be used with
 * {@link #killProcess} and {@link #sendSignal}.
 */

@@ -1,3 +1,3 @@
 {
-    return Libcore.os.getpid();
+    return Os.getpid();
 }

Find a functionally equivalent code:android.os.Bundle.putStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<String> object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putStringArrayList(key, value);
 }

Find a functionally equivalent code:android.webkit.WebSyncManager.stopSync:COMMENT
Method Modifier: public      
Comment:/**
 * stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
 * the queue to break the sync loop
 */

@@ -1,11 +1,2 @@
 {
-    if (DebugFlags.WEB_SYNC_MANAGER) {
-        Log.v(LOGTAG, "*** WebSyncManager stopSync ***, Ref count:" + mStartSyncRefCount);
-    }
-    if (mHandler == null) {
-        return;
-    }
-    if (--mStartSyncRefCount == 0) {
-        mHandler.removeMessages(SYNC_MESSAGE);
-    }
 }

Find a functionally equivalent code:android.app.Activity.onCreateView:COMMENT
Method Modifier: public      
Comment:/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */

@@ -2,62 +2,6 @@
     if (!"fragment".equals(name)) {
         return onCreateView(name, context, attrs);
     }
-    String fname = attrs.getAttributeValue(null, "class");
-    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
-    if (fname == null) {
-        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
-    }
-    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
-    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
-    a.recycle();
-    int containerId = parent != null ? parent.getId() : 0;
-    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
-        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname);
-    }
-    // If we restored from a previous state, we may already have
-    // instantiated this fragment from the state and should use
-    // that instance instead of making a new one.
-    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
-    if (fragment == null && tag != null) {
-        fragment = mFragments.findFragmentByTag(tag);
-    }
-    if (fragment == null && containerId != View.NO_ID) {
-        fragment = mFragments.findFragmentById(containerId);
-    }
-    if (FragmentManagerImpl.DEBUG)
-        Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment);
-    if (fragment == null) {
-        fragment = Fragment.instantiate(this, fname);
-        fragment.mFromLayout = true;
-        fragment.mFragmentId = id != 0 ? id : containerId;
-        fragment.mContainerId = containerId;
-        fragment.mTag = tag;
-        fragment.mInLayout = true;
-        fragment.mFragmentManager = mFragments;
-        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
-        mFragments.addFragment(fragment, true);
-    } else if (fragment.mInLayout) {
-        // previous state.
-        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname);
-    } else {
-        // This fragment was retained from a previous instance; get it
-        // going now.
-        fragment.mInLayout = true;
-        // initialize itself.
-        if (!fragment.mRetaining) {
-            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
-        }
-        mFragments.moveToState(fragment);
-    }
-    if (fragment.mView == null) {
-        throw new IllegalStateException("Fragment " + fname + " did not create a view.");
-    }
-    if (id != 0) {
-        fragment.mView.setId(id);
-    }
-    if (fragment.mView.getTag() == null) {
-        fragment.mView.setTag(tag);
-    }
-    return fragment.mView;
+    return mFragments.onCreateView(parent, name, context, attrs);
 }

Find a functionally equivalent code:android.appwidget.AppWidgetHost.stopListening:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        sService.stopListening(mHostId, mContext.getUserId());
+        sService.stopListening(mContext.getOpPackageName(), mHostId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findDeps:COMMENT
Method Modifier: 
Comment:/**
 * Finds all dependencies for all classes in keepClasses which are also
 * listed in zipClasses. Returns a map of all the dependencies found.
 */

@@ -5,10 +5,11 @@
     TreeMap<String, ClassReader> temp = new TreeMap<String, ClassReader>();
     DependencyVisitor visitor = getVisitor(zipClasses, inOutKeepClasses, new_keep, deps, new_deps);
     for (ClassReader cr : inOutKeepClasses.values()) {
+        visitor.setClassName(cr.getClassName());
         cr.accept(visitor, 0);
     }
     while (new_deps.size() > 0 || new_keep.size() > 0) {
@@ -17,22 +18,24 @@
         new_keep.clear();
         mLog.debug("Found %1$d to keep, %2$d dependencies.", inOutKeepClasses.size(), deps.size());
         for (ClassReader cr : temp.values()) {
+            visitor.setClassName(cr.getClassName());
             cr.accept(visitor, 0);
         }
     }

Find a functionally equivalent code:android.os.RecoverySystem.getTrustedCerts:COMMENT
Method Modifier: private     static      
Comment:/**
 * @return the set of certs that can be used to sign an OTA package.
 */

@@ -1,5 +1,5 @@
 {
-    HashSet<Certificate> trusted = new HashSet<Certificate>();
+    HashSet<X509Certificate> trusted = new HashSet<X509Certificate>();
     if (keystore == null) {
         keystore = DEFAULT_KEYSTORE;
     }
@@ -11,17 +11,17 @@
             ZipEntry entry = entries.nextElement();
             InputStream is = zip.getInputStream(entry);
             try {
-                trusted.add(cf.generateCertificate(is));
+                trusted.add((X509Certificate) cf.generateCertificate(is));
             } finally {
                 is.close();
             }

Find a functionally equivalent code:android.accounts.AccountManager.getAuthenticatorTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return mService.getAuthenticatorTypes();
+        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
     } catch (RemoteException e) {
         // will never happen
         throw new RuntimeException(e);

Find a functionally equivalent code:android.view.HardwareLayer.setLayerPaint:COMMENT
<android.view.HardwareLayer: void setLayerPaint(Paint)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Update the paint used when drawing this layer.
 *
 * @param paint The paint used when the layer is drawn into the destination canvas.
 * @see View#setLayerPaint(android.graphics.Paint)
 */

@@ -1,2 +1,4 @@
 {
+    nSetLayerPaint(mFinalizer.get(), paint.mNativePaint);
+    mRenderer.pushLayerUpdate(this);
 }

Find a functionally equivalent code:com.android.systemui.ExpandHelper.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Use this to abort any pending expansions in progress.
 */

@@ -1,5 +1,5 @@
 {
-    finishExpanding(true);
+    finishExpanding(true, 0f);
     clearView();
     // reset the gesture detector
     mSGD = new ScaleGestureDetector(mContext, mScaleGestureListener);

Find a functionally equivalent code:com.android.keyguard.PagedView.determineScrollingStart:COMMENT
Method Modifier: protected   
Comment:/*
     * Determines if we should change the touch state to start scrolling after the
     * user moves their touch point too far.
     */

@@ -12,21 +12,19 @@
     if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)
         return false;
     final int xDiff = (int) Math.abs(x - mLastMotionX);
-    final int yDiff = (int) Math.abs(y - mLastMotionY);
     final int touchSlop = Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
     boolean xPaged = xDiff > mPagingTouchSlop;
     boolean xMoved = xDiff > touchSlop;
-    boolean yMoved = yDiff > touchSlop;
-    return (xMoved || xPaged || yMoved) && (mUsePagingTouchSlop ? xPaged : xMoved);
+    return mUsePagingTouchSlop ? xPaged : xMoved;
 }

Find a functionally equivalent code:android.widget.TimePicker.getCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current hour in the range (0-23).
 */

@@ -1,10 +1,3 @@
 {
-    int currentHour = mHourSpinner.getValue();
-    if (is24HourView()) {
-        return currentHour;
-    } else if (mIsAm) {
-        return currentHour % HOURS_IN_HALF_DAY;
-    } else {
-        return (currentHour % HOURS_IN_HALF_DAY) + HOURS_IN_HALF_DAY;
-    }
+    return mDelegate.getCurrentHour();
 }

Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.addScrapView:COMMENT
Method Modifier: 
Comment:/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */

@@ -11,16 +11,21 @@
         return;
     }
     scrap.dispatchStartTemporaryDetach();
+    // The the accessibility state of the view may change while temporary
+    // detached and we do not allow detached views to fire accessibility
+    // events. So we are announcing that the subtree changed giving a chance
+    // to clients holding on to a view in this subtree to refresh it.
+    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
     // Don't scrap views that have transient state.
     final boolean scrapHasTransientState = scrap.hasTransientState();
     if (scrapHasTransientState) {
@@ -39,49 +44,49 @@
         } else {
             mScrapViews[viewType].add(scrap);
         }
-        // Clear any system-managed transient state.
-        if (scrap.isAccessibilityFocused()) {
-            scrap.clearAccessibilityFocus();
-        }
-        scrap.setAccessibilityDelegate(null);
         if (mRecyclerListener != null) {
             mRecyclerListener.onMovedToScrapHeap(scrap);
         }

Find a functionally equivalent code:android.bluetooth.BluetoothInputDevice.setReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param report Report receiving buffer size
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

@@ -1,5 +1,5 @@
 {
-    if (DBG)
+    if (VDBG)
         log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
     if (mService != null && isEnabled() && isValidDevice(device)) {
         try {

Find a functionally equivalent code:android.content.Intent.filterEquals:COMMENT
Method Modifier: public      
Comment:/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */

@@ -2,72 +2,18 @@
     if (other == null) {
         return false;
     }
-    if (mAction != other.mAction) {
-        if (mAction != null) {
-            if (!mAction.equals(other.mAction)) {
-                return false;
-            }
-        } else {
-            if (!other.mAction.equals(mAction)) {
-                return false;
-            }
-        }
-    }
-    if (mData != other.mData) {
-        if (mData != null) {
-            if (!mData.equals(other.mData)) {
-                return false;
-            }
-        } else {
-            if (!other.mData.equals(mData)) {
-                return false;
-            }
-        }
-    }
-    if (mType != other.mType) {
-        if (mType != null) {
-            if (!mType.equals(other.mType)) {
-                return false;
-            }
-        } else {
-            if (!other.mType.equals(mType)) {
-                return false;
-            }
-        }
-    }
-    if (mPackage != other.mPackage) {
-        if (mPackage != null) {
-            if (!mPackage.equals(other.mPackage)) {
-                return false;
-            }
-        } else {
-            if (!other.mPackage.equals(mPackage)) {
-                return false;
-            }
-        }
-    }
-    if (mComponent != other.mComponent) {
-        if (mComponent != null) {
-            if (!mComponent.equals(other.mComponent)) {
-                return false;
-            }
-        } else {
-            if (!other.mComponent.equals(mComponent)) {
-                return false;
-            }
-        }
-    }
-    if (mCategories != other.mCategories) {
-        if (mCategories != null) {
-            if (!mCategories.equals(other.mCategories)) {
-                return false;
-            }
-        } else {
-            if (!other.mCategories.equals(mCategories)) {
-                return false;
-            }
-        }
-    }
+    if (!Objects.equals(this.mAction, other.mAction))
+        return false;
+    if (!Objects.equals(this.mData, other.mData))
+        return false;
+    if (!Objects.equals(this.mType, other.mType))
+        return false;
+    if (!Objects.equals(this.mPackage, other.mPackage))
+        return false;
+    if (!Objects.equals(this.mComponent, other.mComponent))
+        return false;
+    if (!Objects.equals(this.mCategories, other.mCategories))
+        return false;
     return true;
 }

Find a functionally equivalent code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
<android.hardware.camera2.CaptureRequest: void readFromParcel(Parcel)>
Method Modifier: public      private     hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  No          Yes         Yes         
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */


Find a functionally equivalent code:android.text.format.Time.toString:COMMENT
<android.text.format.Time: String toString()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return the current time in YYYYMMDDTHHMMSS<tz> format
 */

@@ -1 +1,7 @@
-
+{
+    // toString() uses its own TimeCalculator rather than the shared one. Otherwise crazy stuff
+    // happens during debugging when the debugger calls toString().
+    TimeCalculator calculator = new TimeCalculator(this.timezone);
+    calculator.copyFieldsFromTime(this);
+    return calculator.toStringInternal();
+}

Find a functionally equivalent code:android.graphics.Path_Delegate.lineTo:COMMENT
Method Modifier: private     
Comment:/**
 * Add a line from the last point to the specified point (x,y).
 * If no moveTo() call has been made for this contour, the first point is
 * automatically set to (0,0).
 *
 * @param x The x-coordinate of the end of a line
 * @param y The y-coordinate of the end of a line
 */

@@ -1,3 +1,6 @@
 {
+    if (isEmpty()) {
+        mPath.moveTo(mLastX = 0, mLastY = 0);
+    }
     mPath.lineTo(mLastX = x, mLastY = y);
 }

Find a functionally equivalent code:com.android.smspush.WapPushManager.verifyData:COMMENT
Method Modifier: public      
Comment:/**
 * This method is used for testing
 */

@@ -2,10 +2,14 @@
     WapPushManDBHelper dbh = getDatabase(this);
     SQLiteDatabase db = dbh.getReadableDatabase();
     WapPushManDBHelper.queryData lastapp = dbh.queryLastApp(db, x_app_id, content_type);
+    if (LOCAL_LOGV)
+        Log.v(LOG_TAG, "verifyData app id: " + x_app_id + " content type: " + content_type + " lastapp: " + lastapp);
     db.close();
     if (lastapp == null)
         return false;
+    if (LOCAL_LOGV)
+        Log.v(LOG_TAG, "verifyData lastapp.packageName: " + lastapp.packageName + " lastapp.className: " + lastapp.className + " lastapp.appType: " + lastapp.appType + " lastapp.needSignature: " + lastapp.needSignature + " lastapp.furtherProcessing: " + lastapp.furtherProcessing);
     if (lastapp.packageName.equals(package_name) && lastapp.className.equals(class_name) && lastapp.appType == app_type && lastapp.needSignature == (need_signature ? 1 : 0) && lastapp.furtherProcessing == (further_processing ? 1 : 0)) {
         return true;
     } else {

Find a functionally equivalent code:android.os.ParcelFileDescriptor.open:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */


Find a functionally equivalent code:android.telephony.ServiceState.isGsm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM;
+    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA;
 }

Find a functionally equivalent code:android.media.AudioService.handleConfigurationChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Handles device configuration changes that may map to a change in the orientation
 * or orientation.
 * Monitoring orientation and rotation is optional, and is defined by the definition and value
 * of the "ro.audio.monitorOrientation" and "ro.audio.monitorRotation" system properties.
 */

@@ -11,45 +11,40 @@
                 setOrientationForAudioSystem();
             }
         }
-        if (mMonitorRotation) {
-            int newRotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();
-            if (newRotation != mDeviceRotation) {
-                mDeviceRotation = newRotation;
-                setRotationForAudioSystem();
-            }
-        }
         sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
         boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
         synchronized (mSettingsLock) {
             synchronized (mCameraSoundForced) {
                 if (cameraSoundForced != mCameraSoundForced) {
                     mCameraSoundForced = cameraSoundForced;
-                    VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
-                    if (cameraSoundForced) {
-                        s.setAllIndexesToMax();
-                        mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
-                    } else {
-                        s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
-                        mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                    if (!isPlatformTelevision()) {
+                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
+                        if (cameraSoundForced) {
+                            s.setAllIndexesToMax();
+                            mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        } else {
+                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
+                            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
+                        }
+                        // take new state into account for streams muted by ringer mode
+                        setRingerModeInt(getRingerMode(), false);
                     }
-                    // take new state into account for streams muted by ringer mode
-                    setRingerModeInt(getRingerMode(), false);
                     sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                     sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                 }
             }
         }
-        mVolumePanel.setLayoutDirection(config.getLayoutDirection());
+        mVolumeController.setLayoutDirection(config.getLayoutDirection());
     } catch (Exception e) {
         Log.e(TAG, "Error handling configuration change: ", e);
     }

Find a functionally equivalent code:android.media.MediaFocusControl.remoteControlDisplayWantsPlaybackPositionSync:COMMENT
Method Modifier: protected   
Comment:/**
 * Controls whether a remote control display needs periodic checks of the RemoteControlClient
 * playback position to verify that the estimated position has not drifted from the actual
 * position. By default the check is not performed.
 * The IRemoteControlDisplay must have been previously registered for this to have any effect.
 * @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
 * or disabled. Not null.
 * @param wantsSync if true, RemoteControlClient instances which expose their playback position
 * to the framework will regularly compare the estimated playback position with the actual
 * position, and will update the IRemoteControlDisplay implementation whenever a drift is
 * detected.
 */

@@ -1,11 +1,11 @@
 {
-    synchronized (mRCStack) {
+    synchronized (mPRStack) {
         boolean rcdRegistered = false;
         // store the information about this display
         // (display stack traversal order doesn't matter).
         final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
         while (displayIterator.hasNext()) {
-            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
+            final DisplayInfoForServer di = displayIterator.next();
             if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                 di.mWantsPositionSync = wantsSync;
                 rcdRegistered = true;
@@ -17,28 +17,28 @@
         }
         // notify all current RemoteControlClients
         // (stack traversal order doesn't matter as we notify all RCCs)
-        final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+        final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
         while (stackIterator.hasNext()) {
-            final RemoteControlStackEntry rcse = stackIterator.next();
-            if (rcse.mRcClient != null) {
+            final PlayerRecord prse = stackIterator.next();
+            if (prse.getRcc() != null) {
                 try {
-                    rcse.mRcClient.setWantsSyncForDisplay(rcd, wantsSync);
+                    prse.getRcc().setWantsSyncForDisplay(rcd, wantsSync);
                 } catch (RemoteException e) {
                     Log.e(TAG, "Error setting position sync flag for RCD on RCC: ", e);
                 }

Find a functionally equivalent code:android.view.ViewGroup.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -50,60 +50,61 @@
                     final float y = ev.getY(actionIndex);
                     // Find a child that can receive the event.
                     // Scan children from front to back.
+                    final ArrayList<View> preorderedList = buildOrderedChildList();
+                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                     final View[] children = mChildren;
-                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                     for (int i = childrenCount - 1; i >= 0; i--) {
                         final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
-                        final View child = children[childIndex];
+                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                         if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                             continue;
                         }
@@ -69,75 +70,86 @@
                         if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                             // Child wants to receive touch within its bounds.
                             mLastTouchDownTime = ev.getDownTime();
-                            mLastTouchDownIndex = childIndex;
+                            if (preorderedList != null) {
+                                // childIndex points into presorted list, find original index
+                                for (int j = 0; j < childrenCount; j++) {
+                                    if (children[childIndex] == mChildren[j]) {
+                                        mLastTouchDownIndex = j;
+                                        break;
+                                    }
+                                }
+                            } else {
+                                mLastTouchDownIndex = childIndex;
+                            }
                             mLastTouchDownX = ev.getX();
                             mLastTouchDownY = ev.getY();
                             newTouchTarget = addTouchTarget(child, idBitsToAssign);
@@ -77,82 +88,95 @@
                             break;
                         }
                     }
+                    if (preorderedList != null)
+                        preorderedList.clear();
                 }
                 if (newTouchTarget == null && mFirstTouchTarget != null) {
                     // Did not find a child to receive the event.

Find a functionally equivalent code:com.android.keyguard.EmergencyButton.takeEmergencyCallAction:COMMENT
Method Modifier: public      
Comment:/**
 * Shows the emergency dialer or returns the user to the existing call.
 */

@@ -2,8 +2,8 @@
     // TODO: implement a shorter timeout once new PowerManager API is ready.
     // should be the equivalent to the old userActivity(EMERGENCY_CALL_TIMEOUT)
     mPowerManager.userActivity(SystemClock.uptimeMillis(), true);
-    if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
+    if (mLockPatternUtils.isInCall()) {
         mLockPatternUtils.resumeCall();
     } else {
         final boolean bypassHandler = true;

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onUserInfoChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserInfoChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the user's info changed.
 */


Find a functionally equivalent code:android.print.PrintManager.removePrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes a listener for observing the state of print jobs.
 *
 * @param listener The listener to remove.
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return;
+    }
     if (mPrintJobStateChangeListeners == null) {
         return;
     }

Find a functionally equivalent code:android.content.res.AssetManager.open:COMMENT
Method Modifier: public      final       
Comment:/**
 * Open an asset using an explicit access mode, returning an InputStream to
 * read its contents.  This provides access to files that have been bundled
 * with an application as assets -- that is, files placed in to the
 * "assets" directory.
 *
 * @param fileName The name of the asset to open.  This name can be
 * hierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 *
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */

@@ -3,9 +3,9 @@
         if (!mOpen) {
             throw new RuntimeException("Assetmanager has been closed");
         }
-        int asset = openAsset(fileName, accessMode);
+        long asset = openAsset(fileName, accessMode);
         if (asset != 0) {
             AssetInputStream res = new AssetInputStream(asset);
             incRefsLocked(res.hashCode());

Find a functionally equivalent code:android.media.AudioRecord.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops recording.
 * @throws IllegalStateException
 */

@@ -4,9 +4,10 @@
     }
     // stop recording
     synchronized (mRecordingStateLock) {
+        handleFullVolumeRec(false);
         native_stop();
         mRecordingState = RECORDSTATE_STOPPED;
     }

Find a functionally equivalent code:android.widget.CalendarView.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param maxDate The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

@@ -1,19 +1,3 @@
 {
-    mTempDate.setTimeInMillis(maxDate);
-    if (isSameDate(mTempDate, mMaxDate)) {
-        return;
-    }
-    mMaxDate.setTimeInMillis(maxDate);
-    // reinitialize the adapter since its range depends on max date
-    mAdapter.init();
-    Calendar date = mAdapter.mSelectedDate;
-    if (date.after(mMaxDate)) {
-        setDate(mMaxDate.getTimeInMillis());
-    } else {
-        // we go to the current date to force the ListView to query its
-        // adapter for the shown views since we have changed the adapter
-        // range and the base from which the later calculates item indices
-        // note that calling setDate will not work since the date is the same
-        goTo(date, false, true, false);
-    }
+    mDelegate.setMaxDate(maxDate);
 }

Find a functionally equivalent code:android.os.Bundle.getStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (ArrayList<String>) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "ArrayList<String>", e);
-        return null;
-    }
+    return super.getStringArrayList(key);
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.handleParentProc:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Handles post-fork cleanup of parent proc
 *
 * @param pid != 0; pid of child if &gt; 0 or indication of failed fork
 * if &lt; 0;
 * @param descriptors null-ok; file descriptors for child's new stdio if
 * specified.
 * @param pipeFd null-ok; pipe for communication with child.
 * @param parsedArgs non-null; zygote args
 * @return true for "exit command loop" and false for "continue command
 * loop"
 */

@@ -40,46 +40,46 @@
         mSocketOutStream.writeInt(pid);
         mSocketOutStream.writeBoolean(usingWrapper);
     } catch (IOException ex) {
-        Log.e(TAG, "Error reading from command socket", ex);
+        Log.e(TAG, "Error writing to command socket", ex);
         return true;
     }
     return false;

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisSetXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashSet object from an XmlPullParser. The XML data could previously
 * have been generated by writeSetXml(). The XmlPullParser must be positioned
 * <em>after</em> the tag that begins the set.
 *
 * @param parser The XmlPullParser from which to read the set data.
 * @param endTag Name of the tag that will end the set, usually "set".
 * @param name An array of one string, used to return the name attribute
 * of the set's tag.
 *
 * @return HashSet The newly generated set.
 *
 * @throws XmlPullParserException
 * @throws java.io.IOException
 *
 * @see #readSetXml
 */

@@ -1,18 +1,3 @@
 {
-    HashSet set = new HashSet();
-    int eventType = parser.getEventType();
-    do {
-        if (eventType == parser.START_TAG) {
-            Object val = readThisValueXml(parser, name);
-            set.add(val);
-        // System.out.println("Adding to set: " + val);
-        } else if (eventType == parser.END_TAG) {
-            if (parser.getName().equals(endTag)) {
-                return set;
-            }
-            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-        }
-        eventType = parser.next();
-    } while (eventType != parser.END_DOCUMENT);
-    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    return readThisSetXml(parser, endTag, name, null);
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGattServer.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */

@@ -4,11 +4,11 @@
     if (mService == null || mServerIf == 0)
         return false;
     try {
-        mService.serverConnect(mServerIf, device.getAddress(), // autoConnect is inverse of "isDirect"
-        autoConnect ? false : true);
+        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of "isDirect"
+        mTransport);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
         return false;

Find a functionally equivalent code:android.os.Bundle.putChar:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a char, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putChar(key, value);
 }

Find a functionally equivalent code:com.android.internal.view.RotationPolicy.isRotationSupported:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Gets whether the device supports rotation. In general such a
 * device has an accelerometer and has the portrait and landscape
 * features.
 *
 * @param context Context for accessing system resources.
 * @return Whether the device supports rotation.
 */

@@ -1,4 +1,4 @@
 {
     PackageManager pm = context.getPackageManager();
-    return pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_LANDSCAPE);
+    return pm.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT) && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_LANDSCAPE) && context.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
 }

Find a functionally equivalent code:android.content.res.TypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.app.Fragment.getLayoutInflater:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Hack so that DialogFragment can make its Dialog before creating
 * its views, and the view construction can use the dialog's context for
 * inflation.  Maybe this should become a public API. Note sure.
 */

@@ -1,3 +1,12 @@
 {
-    return mActivity.getLayoutInflater();
+    // Newer platform versions use the child fragment manager's LayoutInflaterFactory.
+    if (mActivity.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
+        LayoutInflater result = mActivity.getLayoutInflater().cloneInContext(mActivity);
+        // Init if needed; use raw implementation below.
+        getChildFragmentManager();
+        result.setPrivateFactory(mChildFragmentManager.getLayoutInflaterFactory());
+        return result;
+    } else {
+        return mActivity.getLayoutInflater();
+    }
 }

Find a functionally equivalent code:android.widget.TextView.setTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 */

@@ -39,43 +39,52 @@
     if (appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_textAllCaps, false)) {
         setTransformationMethod(new AllCapsTransformationMethod(getContext()));
     }
+    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_elegantTextHeight)) {
+        setElegantTextHeight(appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_elegantTextHeight, false));
+    }
+    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_letterSpacing)) {
+        setLetterSpacing(appearance.getFloat(com.android.internal.R.styleable.TextAppearance_letterSpacing, 0));
+    }
+    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings)) {
+        setFontFeatureSettings(appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings));
+    }
     appearance.recycle();
 }

Find a functionally equivalent code:android.content.res.TypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.app.Activity.onBackPressed:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */

@@ -1,5 +1,8 @@
 {
+    if (mActionBar != null && mActionBar.collapseActionView()) {
+        return;
+    }
     if (!mFragments.popBackStackImmediate()) {
-        finish();
+        finishAfterTransition();
     }
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardAbsKeyInputView.handleAttemptLockout:COMMENT
Method Modifier: protected   
Comment:// Prevent user from using the PIN/Password entry until scheduled deadline.

@@ -1,5 +1,5 @@
 {
-    mPasswordEntry.setEnabled(false);
+    setPasswordEntryEnabled(false);
     long elapsedRealtime = SystemClock.elapsedRealtime();
     new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime, 1000) {
 

Find a functionally equivalent code:android.text.TextLine.getOffsetBeforeAfter:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the next valid offset within this directional run, skipping
 * conjuncts and zero-width characters.  This should not be called to walk
 * off the end of the line, since the returned values might not be valid
 * on neighboring lines.  If the returned offset is less than zero or
 * greater than the line length, the offset should be recomputed on the
 * preceding or following line, respectively.
 *
 * @param runIndex the run index
 * @param runStart the start of the run
 * @param runLimit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param offset the offset
 * @param after true if the new offset should logically follow the provided
 * offset
 * @return the new offset
 */

@@ -40,50 +40,50 @@
             }
         }
     }
-    int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
+    int dir = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
     int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
     if (mCharsValid) {
-        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, flags, offset, cursorOpt);
+        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, dir, offset, cursorOpt);
     } else {
-        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, flags, mStart + offset, cursorOpt) - mStart;
+        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, dir, mStart + offset, cursorOpt) - mStart;
     }
 }

Find a functionally equivalent code:com.android.internal.widget.ActionBarView.buildHomeContentDescription:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Compose a content description for the Home/Up affordance.
 *
 * <p>As this encompasses the icon/logo, title and subtitle all in one, we need
 * a description for the whole wad of stuff that can be localized properly.</p>
 */

@@ -4,10 +4,10 @@
         homeDesc = mHomeDescription;
     } else {
         if ((mDisplayOptions & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
-            homeDesc = mContext.getResources().getText(R.string.action_bar_up_description);
+            homeDesc = mContext.getResources().getText(mDefaultUpDescription);
         } else {
             homeDesc = mContext.getResources().getText(R.string.action_bar_home_description);
         }

Find a functionally equivalent code:android.security.KeyChain.createInstallIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns an {@code Intent} that can be used for credential
 * installation. The intent may be used without any extras, in
 * which case the user will be able to install credentials from
 * their own source.
 *
 * <p>Alternatively, {@link #EXTRA_CERTIFICATE} or {@link
 * #EXTRA_PKCS12} maybe used to specify the bytes of an X.509
 * certificate or a PKCS#12 key store for installation. These
 * extras may be combined with {@link #EXTRA_NAME} to provide a
 * default alias name for credentials being installed.
 *
 * <p>When used with {@link Activity#startActivityForResult},
 * {@link Activity#RESULT_OK} will be returned if a credential was
 * successfully installed, otherwise {@link
 * Activity#RESULT_CANCELED} will be returned.
 */

@@ -1,5 +1,5 @@
 {
     Intent intent = new Intent(ACTION_INSTALL);
-    intent.setClassName("com.android.certinstaller", "com.android.certinstaller.CertInstallerMain");
+    intent.setClassName(CERT_INSTALLER_PACKAGE, "com.android.certinstaller.CertInstallerMain");
     return intent;
 }

Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pManager.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Registers the application with the Wi-Fi framework. This function
 * must be the first to be called before any p2p operations are performed.
 *
 * @param srcContext is the context of the source
 * @param srcLooper is the Looper on which the callbacks are receivied
 * @param listener for callback at loss of framework communication. Can be null.
 * @return Channel instance that is necessary for performing any further p2p operations
 */

@@ -1,11 +1,3 @@
 {
-    Messenger messenger = getMessenger();
-    if (messenger == null)
-        return null;
-    Channel c = new Channel(srcContext, srcLooper, listener);
-    if (c.mAsyncChannel.connectSync(srcContext, c.mHandler, messenger) == AsyncChannel.STATUS_SUCCESSFUL) {
-        return c;
-    } else {
-        return null;
-    }
+    return initalizeChannel(srcContext, srcLooper, listener, getMessenger());
 }

Find a functionally equivalent code:android.content.AsyncTaskLoader.LoadTask.onCancelled:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

@@ -1,6 +1,6 @@
 {
     if (DEBUG)
-        Slog.v(TAG, this + " onCancelled");
+        Log.v(TAG, this + " onCancelled");
     try {
         AsyncTaskLoader.this.dispatchOnCancelled(this, data);
     } finally {

Find a functionally equivalent code:android.print.PrinterCapabilitiesInfo.getResolutions:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported resolutions.
 *
 * @return The resolutions.
 */

@@ -1,3 +1,3 @@
 {
-    return mResolutions;
+    return Collections.unmodifiableList(mResolutions);
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.areTranslucentBarsAllowed:COMMENT
Method Modifier: private     internal    
Comment:/**
 * @return whether the navigation or status bar can be made translucent
 *
 * This should return true unless touch exploration is not enabled or
 * R.boolean.config_enableTranslucentDecor is false.
 */

@@ -1,3 +1,3 @@
 {
-    return mTranslucentDecorEnabled && !mTouchExplorationEnabled;
+    return mTranslucentDecorEnabled && !mAccessibilityManager.isTouchExplorationEnabled();
 }

Find a functionally equivalent code:android.os.Bundle.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or 0.0f if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a float value
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    return getFloat(key, 0.0f);
+    return super.getFloat(key);
 }

Find a functionally equivalent code:android.os.Message.copyFrom:COMMENT
Method Modifier: public      
Comment:/**
 * Make this message like o.  Performs a shallow copy of the data field.
 * Does not copy the linked list fields, nor the timestamp or
 * target/callback of the original message.
 */

@@ -5,10 +5,11 @@
     this.arg2 = o.arg2;
     this.obj = o.obj;
     this.replyTo = o.replyTo;
+    this.sendingUid = o.sendingUid;
     if (o.data != null) {
         this.data = (Bundle) o.data.clone();
     } else {

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.findGlobs:COMMENT
Method Modifier: 
Comment:/**
 * Insert in the inOutFound map all classes found in zipClasses that match the
 * given glob pattern.
 * <p/>
 * The glob pattern is not a regexp. It only accepts the "*" keyword to mean
 * "anything but a period". The "." and "$" characters match themselves.
 * The "**" keyword means everything including ".".
 * <p/>
 * Examples:
 * <ul>
 * <li>com.foo.* matches all classes in the package com.foo but NOT sub-packages.
 * <li>com.foo*.*$Event matches all internal Event classes in a com.foo*.* class.
 * </ul>
 */

@@ -1,21 +1,8 @@
 {
-    // transforms the glob pattern in a regexp:
-    // - escape "." with "\."
-    // - replace "*" by "[^.]*"
-    // - escape "$" with "\$"
-    // - add end-of-line match $
-    globPattern = globPattern.replaceAll("\\$", "\\\\\\$");
-    globPattern = globPattern.replaceAll("\\.", "\\\\.");
-    // prevent ** from being altered by the next rule, then process the * rule and finally
-    // the real ** rule (which is now @)
-    globPattern = globPattern.replaceAll("\\*\\*", "@");
-    globPattern = globPattern.replaceAll("\\*", "[^.]*");
-    globPattern = globPattern.replaceAll("@", ".*");
-    globPattern += "$";
-    Pattern regexp = Pattern.compile(globPattern);
+    Pattern regexp = getPatternFromGlob(globPattern);
     for (Entry<String, ClassReader> entry : zipClasses.entrySet()) {
         String class_name = entry.getKey();
-        if (regexp.matcher(class_name).matches()) {
+        if (regexp.matcher(class_name).matches() && !mExcludedClasses.contains(getOuterClassName(class_name))) {
             findClass(class_name, zipClasses, inOutFound);
         }
     }

Find a functionally equivalent code:android.content.res.TypedArray.getNonResourceString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined or is not
 * an immediate string value.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.needSensorRunningLp:COMMENT
Method Modifier: internal    
Comment:/*
     * We always let the sensor be switched on by default except when
     * the user has explicitly disabled sensor based rotation or when the
     * screen is switched off.
     */

@@ -1,7 +1,9 @@
 {
-    if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
-        // orientation, then we need to turn the sensor or.
-        return true;
+    if (mSupportAutoRotation) {
+        if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE) {
+            // orientation, then we need to turn the sensor on.
+            return true;
+        }
     }
     if ((mCarDockEnablesAccelerometer && mDockMode == Intent.EXTRA_DOCK_STATE_CAR) || (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
         // orientation management,
@@ -11,15 +13,17 @@
         // still be turned off when the screen is off.)
         return false;
     }
-    return true;
+    return mSupportAutoRotation;
 }

Find a functionally equivalent code:android.media.MediaFocusControl.registerRemoteControlDisplay_int:COMMENT
Method Modifier: private     
Comment:/**
 * Register an IRemoteControlDisplay.
 * Notify all IRemoteControlClient of the new display and cause the RemoteControlClient
 * at the top of the stack to update the new display with its information.
 * @see android.media.IAudioService#registerRemoteControlDisplay(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay to register. No effect if null.
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param listenerComp the component for the listener interface, may be null if it's not needed
 * to verify it belongs to one of the enabled notification listeners
 */

@@ -2,8 +2,8 @@
     if (DEBUG_RC)
         Log.d(TAG, ">>> registerRemoteControlDisplay(" + rcd + ")");
     synchronized (mAudioFocusLock) {
-        synchronized (mRCStack) {
+        synchronized (mPRStack) {
             if ((rcd == null) || rcDisplayIsPluggedIn_syncRcStack(rcd)) {
                 return;
             }
@@ -18,29 +18,29 @@
             mRcDisplays.add(di);
             // let all the remote control clients know there is a new display (so the remote
             // control stack traversal order doesn't matter).
-            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+            Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
             while (stackIterator.hasNext()) {
-                RemoteControlStackEntry rcse = stackIterator.next();
-                if (rcse.mRcClient != null) {
+                PlayerRecord prse = stackIterator.next();
+                if (prse.getRcc() != null) {
                     try {
-                        rcse.mRcClient.plugRemoteControlDisplay(rcd, w, h);
+                        prse.getRcc().plugRemoteControlDisplay(rcd, w, h);
                     } catch (RemoteException e) {
                         Log.e(TAG, "Error connecting RCD to client: ", e);
                     }

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleReportFailedAttempt:COMMENT
Method Modifier: 
Comment:/**
 * Increments the number of failed Face Unlock attempts.
 */

@@ -4,8 +4,8 @@
     // We are going to the backup method, so we don't want to see Face Unlock again until the
     // next time the user visits keyguard.
     KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(false);
-    mKeyguardScreenCallback.reportFailedUnlockAttempt();
+    mKeyguardScreenCallback.reportUnlockAttempt(false);
 }

Find a functionally equivalent code:android.ddm.DdmHandleProfiling.handleSPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Sample Profiling w/Streaming Start" request.
     */

@@ -3,9 +3,9 @@
     int bufferSize = in.getInt();
     int flags = in.getInt();
     int interval = in.getInt();
-    if (false) {
+    if (DEBUG) {
         Log.v("ddm-heap", "Sample prof stream start: size=" + bufferSize + ", flags=" + flags + ", interval=" + interval);
     }
     try {

Find a functionally equivalent code:android.widget.CheckedTextView.internalSetPadding:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,4 +1,4 @@
 {
     super.internalSetPadding(left, top, right, bottom);
-    setBasePadding(isLayoutRtl());
+    setBasePadding(isCheckMarkAtStart());
 }

Find a functionally equivalent code:android.widget.RemoteViews.apply:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,9 +1,27 @@
 {
     RemoteViews rvToApply = getRemoteViewsToApply(context);
     View result;
-    Context c = prepareContext(context);
-    LayoutInflater inflater = (LayoutInflater) c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-    inflater = inflater.cloneInContext(c);
+    // RemoteViews may be built by an application installed in another
+    // user. So build a context that loads resources from that user but
+    // still returns the current users userId so settings like data / time formats
+    // are loaded without requiring cross user persmissions.
+    final Context contextForResources = getContextForResources(context);
+    Context inflationContext = new ContextWrapper(context) {
+
+        @Override
+        public Resources getResources() {
+            return contextForResources.getResources();
+        }
+
+        @Override
+        public Resources.Theme getTheme() {
+            return contextForResources.getTheme();
+        }
+    };
+    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+    // Clone inflater so we load resources from correct context and
+    // we don't add a filter to the static version returned by getSystemService.
+    inflater = inflater.cloneInContext(inflationContext);
     inflater.setFilter(this);
     result = inflater.inflate(rvToApply.getLayoutId(), parent, false);
     rvToApply.performApply(result, parent, handler);

Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.startQuery:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Factory method to start the query based on a number.
 *
 * Note: if the number contains an "@" character we treat it
 * as a SIP address, and look it up directly in the Data table
 * rather than using the PhoneLookup table.
 * TODO: But eventually we should expose two separate methods, one for
 * numbers and one for SIP addresses, and then have
 * PhoneUtils.startGetCallerInfo() decide which one to call based on
 * the phone type of the incoming connection.
 */

@@ -1,72 +1,4 @@
 {
-    if (DBG) {
-        Rlog.d(LOG_TAG, "##### CallerInfoAsyncQuery startQuery()... #####");
-        Rlog.d(LOG_TAG, "- number: " + /*number*/
-        "xxxxxxx");
-        Rlog.d(LOG_TAG, "- cookie: " + cookie);
-    }
-    // Construct the URI object and query params, and start the query.
-    Uri contactRef;
-    String selection;
-    String[] selectionArgs;
-    if (PhoneNumberUtils.isUriNumber(number)) {
-        // "number" is really a SIP address.
-        if (DBG)
-            Rlog.d(LOG_TAG, "  - Treating number as a SIP address: " + /*number*/
-            "xxxxxxx");
-        // We look up SIP addresses directly in the Data table:
-        contactRef = Data.CONTENT_URI;
-        // Note Data.DATA1 and SipAddress.SIP_ADDRESS are equivalent.
-        // 
-        // Also note we use "upper(data1)" in the WHERE clause, and
-        // uppercase the incoming SIP address, in order to do a
-        // case-insensitive match.
-        // 
-        // TODO: need to confirm that the use of upper() doesn't
-        // prevent us from using the index!  (Linear scan of the whole
-        // contacts DB can be very slow.)
-        // 
-        // TODO: May also need to normalize by adding "sip:" as a
-        // prefix, if we start storing SIP addresses that way in the
-        // database.
-        selection = "upper(" + Data.DATA1 + ")=?" + " AND " + Data.MIMETYPE + "='" + SipAddress.CONTENT_ITEM_TYPE + "'";
-        selectionArgs = new String[] { number.toUpperCase() };
-    } else {
-        // "number" is a regular phone number.  Use the PhoneLookup table:
-        contactRef = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));
-        selection = null;
-        selectionArgs = null;
-    }
-    if (DBG) {
-        Rlog.d(LOG_TAG, "==> contactRef: " + sanitizeUriToString(contactRef));
-        Rlog.d(LOG_TAG, "==> selection: " + selection);
-        if (selectionArgs != null) {
-            for (int i = 0; i < selectionArgs.length; i++) {
-                Rlog.d(LOG_TAG, "==> selectionArgs[" + i + "]: " + selectionArgs[i]);
-            }
-        }
-    }
-    CallerInfoAsyncQuery c = new CallerInfoAsyncQuery();
-    c.allocate(context, contactRef);
-    // create cookieWrapper, start query
-    CookieWrapper cw = new CookieWrapper();
-    cw.listener = listener;
-    cw.cookie = cookie;
-    cw.number = number;
-    // check to see if these are recognized numbers, and use shortcuts if we can.
-    if (PhoneNumberUtils.isLocalEmergencyNumber(number, context)) {
-        cw.event = EVENT_EMERGENCY_NUMBER;
-    } else if (PhoneNumberUtils.isVoiceMailNumber(number)) {
-        cw.event = EVENT_VOICEMAIL_NUMBER;
-    } else {
-        cw.event = EVENT_NEW_QUERY;
-    }
-    c.mHandler.startQuery(token, // cookie
-    cw, // uri
-    contactRef, // projection
-    null, // selection
-    selection, // selectionArgs
-    selectionArgs, // orderBy
-    null);
-    return c;
+    long subId = SubscriptionManager.getDefaultSubId();
+    return startQuery(token, context, number, listener, cookie, subId);
 }

Find a functionally equivalent code:com.android.systemui.statusbar.phone.PanelBar.startOpeningPanel:COMMENT
Method Modifier: public      
Comment:// called from PanelView when self-expanding, too

@@ -5,11 +5,11 @@
     mPanelHolder.setSelectedPanel(mTouchingPanel);
     for (PanelView pv : mPanels) {
         if (pv != panel) {
-            pv.collapse();
+            pv.collapse(false);
         }
     }
 }

Find a functionally equivalent code:android.content.res.AssetManager.releaseTheme:COMMENT
Method Modifier: default     final       
Comment:/*package*/


Find a functionally equivalent code:android.view.Window.setAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom window attributes.  <strong>PLEASE NOTE:</strong> the
 * layout params you give here should generally be from values previously
 * retrieved with {@link #getAttributes()}; you probably do not want to
 * blindly create and apply your own, since this will blow away any values
 * set by the framework that you are not interested in.
 *
 * @param a The new window attributes, which will completely override any
 * current values.
 */

@@ -1,6 +1,4 @@
 {
     mWindowAttributes.copyFrom(a);
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(mWindowAttributes);
-    }
+    dispatchWindowAttributesChanged(mWindowAttributes);
 }

Find a functionally equivalent code:android.appwidget.AppWidgetHost.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */

@@ -1,20 +1,13 @@
 {
     int[] updatedIds;
     ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
-    final int userId = mContext.getUserId();
     try {
-        if (mPackageName == null) {
-            mPackageName = mContext.getPackageName();
-        }
-        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews, userId);
+        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }
     final int N = updatedIds.length;
     for (int i = 0; i < N; i++) {
-        if (updatedViews.get(i) != null) {
-            updatedViews.get(i).setUser(new UserHandle(userId));
-        }
-        updateAppWidgetView(updatedIds[i], updatedViews.get(i), userId);
+        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
     }
 }

Find a functionally equivalent code:android.widget.FastScroller.transitionToHidden:COMMENT
Method Modifier: private     
Comment:/**
 * Shows nothing.
 */

@@ -9,12 +9,13 @@
     mDecorAnimation = new AnimatorSet();
     mDecorAnimation.playTogether(fadeOut, slideOut);
     mDecorAnimation.start();
+    mShowingPreview = false;
 }

Find a functionally equivalent code:android.app.Activity.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Declare that the options menu has changed, so should be recreated.
 * The {@link #onCreateOptionsMenu(Menu)} method will be called the next
 * time it needs to be displayed.
 */

@@ -1,3 +1,5 @@
 {
-    mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
+    if (mActionBar == null || !mActionBar.invalidateOptionsMenu()) {
+        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
+    }
 }

Find a functionally equivalent code:android.app.SearchDialog.createContentView:COMMENT
Method Modifier: private     
Comment:/**
 * We recreate the dialog view each time it becomes visible so as to limit
 * the scope of any problems with the contained resources.
 */

@@ -22,28 +22,28 @@
     mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
     mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
     mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
-    mWorkingSpinner = getContext().getResources().getDrawable(com.android.internal.R.drawable.search_spinner);
+    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
     // TODO: Restore the spinner for slow suggestion lookups
     // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
     // null, null, mWorkingSpinner, null);

Find a functionally equivalent code:android.printservice.PrintJob.getAdvancedIntOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

@@ -1,4 +1,4 @@
 {
     PrintService.throwIfNotCalledOnMainThread();
-    return 0;
+    return getInfo().getAdvancedIntOption(key);
 }

Find a functionally equivalent code:android.test.ProviderTestCase2.setUp:COMMENT
Method Modifier: protected   
Comment:/**
 * Sets up the environment for the test fixture.
 * <p>
 * Creates a new
 * {@link android.test.mock.MockContentResolver}, a new IsolatedContext
 * that isolates the provider's file operations, and a new instance of
 * the provider under test within the isolated environment.
 * </p>
 *
 * @throws Exception
 */

@@ -6,13 +6,11 @@
     new MockContext2(), // The context that file methods are delegated to
     getContext(), filenamePrefix);
     mProviderContext = new IsolatedContext(mResolver, targetContextWrapper);
-    mProvider = mProviderClass.newInstance();
-    mProvider.attachInfoForTesting(mProviderContext, null);
-    assertNotNull(mProvider);
+    mProvider = createProviderForTest(mProviderContext, mProviderClass, mProviderAuthority);
     mResolver.addProvider(mProviderAuthority, getProvider());
 }

Find a functionally equivalent code:android.os.StrictMode.writeGatheredViolationsToParcel:COMMENT
Method Modifier: default     static      
Comment:/* package */

@@ -5,11 +5,16 @@
     } else {
         p.writeInt(violations.size());
         for (int i = 0; i < violations.size(); ++i) {
+            int start = p.dataPosition();
             violations.get(i).writeToParcel(p, 0);
+            int size = p.dataPosition() - start;
+            if (size > 10 * 1024) {
+                Slog.d(TAG, "Wrote violation #" + i + " of " + violations.size() + ": " + (p.dataPosition() - start) + " bytes");
+            }
         }
         if (LOG_V)
             Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());

Find a functionally equivalent code:android.content.RestrictionEntry.getKey:COMMENT
Method Modifier: public      
Comment:/**
 * This is the unique key for the restriction entry.
 * @return the key for the restriction.
 */

@@ -1,3 +1,3 @@
 {
-    return key;
+    return mKey;
 }

Find a functionally equivalent code:android.media.MediaRouter.removeRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use only
 */

@@ -1,3 +1,3 @@
 {
-    removeRoute(info);
+    removeRouteStatic(info);
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.disableWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Disable Wifi
 * @return true if Wifi is disabled successfully
 */


Find a functionally equivalent code:android.content.res.Resources.obtainTypedArray:COMMENT
Method Modifier: public      
Comment:/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */

@@ -3,9 +3,9 @@
     if (len < 0) {
         throw new NotFoundException("Array resource ID #0x" + Integer.toHexString(id));
     }
-    TypedArray array = getCachedStyledAttributes(len);
+    TypedArray array = TypedArray.obtain(this, len);
     array.mLength = mAssets.retrieveArray(id, array.mData);
     array.mIndices[0] = 0;
     return array;

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.ResourceHelper.parseFloatAttribute:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parse a float attribute and return the parsed value into a given TypedValue.
 * @param attribute the name of the attribute. Can be null if <var>requireUnit</var> is false.
 * @param value the string value of the attribute
 * @param outValue the TypedValue to receive the parsed value
 * @param requireUnit whether the value is expected to contain a unit.
 * @return true if success.
 */

@@ -1,5 +1,5 @@
 {
-    assert requireUnit == false || attribute != null;
+    assert !requireUnit || attribute != null;
     // remove the space before and after
     value = value.trim();
     int len = value.length();
@@ -14,20 +14,20 @@
         }
     }
     // check the first character
-    if (buf[0] < '0' && buf[0] > '9' && buf[0] != '.' && buf[0] != '-') {
+    if ((buf[0] < '0' || buf[0] > '9') && buf[0] != '.' && buf[0] != '-' && buf[0] != '+') {
         return false;
     }
     // now look for the string that is after the float...
@@ -41,47 +41,47 @@
         end = end.trim();
         if (end.length() == 0) {
             if (outValue != null) {
-                if (requireUnit == false) {
+                if (!requireUnit) {
                     outValue.type = TypedValue.TYPE_FLOAT;
                     outValue.data = Float.floatToIntBits(f);
                 } else {

Find a functionally equivalent code:com.android.framework.permission.tests.VibratorServicePermissionTest.testVibratePattern:COMMENT
Method Modifier: public      
Comment:/**
 * Test that calling {@link android.os.IVibratorService#vibratePattern(long[],
 * int, android.os.IBinder)} requires permissions.
 * <p>Tests permission:
 * {@link android.Manifest.permission#VIBRATE}
 * @throws RemoteException
 */

@@ -1,6 +1,6 @@
 {
     try {
-        mVibratorService.vibratePattern(Process.myUid(), null, new long[] { 0 }, 0, new Binder());
+        mVibratorService.vibratePattern(Process.myUid(), null, new long[] { 0 }, 0, AudioManager.STREAM_ALARM, new Binder());
         fail("vibratePattern did not throw SecurityException as expected");
     } catch (SecurityException e) {
     // expected

Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPeriodicsV2:COMMENT
Method Modifier: public      
Comment:/**
 * Test that we can create, remove and retrieve periodic syncs with a provided flex time.
 */

@@ -10,44 +10,50 @@
     final int period2 = 1000;
     final int flex1 = 10;
     final int flex2 = 100;
+    EndPoint point1 = new EndPoint(account1, authority, 0);
+    EndPoint point2 = new EndPoint(account2, authority, 0);
+    EndPoint point1User2 = new EndPoint(account1, authority, 1);
     PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1, flex1);
     PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1, flex1);
     PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2, flex2);
     PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2, flex2);
+    EndPoint target1 = new EndPoint(account1, authority, 0);
+    EndPoint target2 = new EndPoint(account2, authority, 0);
+    EndPoint target1UserB = new EndPoint(account1, authority, 1);
     MockContentResolver mockResolver = new MockContentResolver();
     SyncStorageEngine engine = SyncStorageEngine.newTestInstance(new TestContext(mockResolver, getContext()));
     removePeriodicSyncs(engine, account1, 0, authority);
     removePeriodicSyncs(engine, account2, 0, authority);
     removePeriodicSyncs(engine, account1, 1, authority);
     // This should add two distinct periodic syncs for account1 and one for account2
-    engine.addPeriodicSync(sync1, 0);
-    engine.addPeriodicSync(sync2, 0);
-    // Should edit sync2 and update the period.
-    engine.addPeriodicSync(sync3, 0);
-    engine.addPeriodicSync(sync4, 0);
-    // add a second user
-    engine.addPeriodicSync(sync2, 1);
-    List<PeriodicSync> syncs = engine.getPeriodicSyncs(account1, 0, authority);
+    engine.updateOrAddPeriodicSync(target1, period1, flex1, extras1);
+    engine.updateOrAddPeriodicSync(target1, period1, flex1, extras2);
+    // Edit existing sync and update the period and flex.
+    engine.updateOrAddPeriodicSync(target1, period2, flex2, extras2);
+    engine.updateOrAddPeriodicSync(target2, period2, flex2, extras2);
+    // add a target for a second user.
+    engine.updateOrAddPeriodicSync(target1UserB, period1, flex1, extras2);
+    List<PeriodicSync> syncs = engine.getPeriodicSyncs(target1);
     assertEquals(2, syncs.size());
     assertEquals(sync1, syncs.get(0));
     assertEquals(sync3, syncs.get(1));
-    engine.removePeriodicSync(sync1, 0);
-    syncs = engine.getPeriodicSyncs(account1, 0, authority);
+    engine.removePeriodicSync(target1, extras1);
+    syncs = engine.getPeriodicSyncs(target1);
     assertEquals(1, syncs.size());
     assertEquals(sync3, syncs.get(0));
-    syncs = engine.getPeriodicSyncs(account2, 0, authority);
+    syncs = engine.getPeriodicSyncs(target2);
     assertEquals(1, syncs.size());
     assertEquals(sync4, syncs.get(0));
-    syncs = engine.getPeriodicSyncs(sync2.account, 1, sync2.authority);
+    syncs = engine.getPeriodicSyncs(target1UserB);
     assertEquals(1, syncs.size());
     assertEquals(sync2, syncs.get(0));
 }

Find a functionally equivalent code:android.net.LinkProperties.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface.
 */

@@ -10,15 +10,16 @@
     }
     dest.writeString(mDomains);
     dest.writeInt(mMtu);
+    dest.writeString(mTcpBufferSizes);
     dest.writeInt(mRoutes.size());
     for (RouteInfo route : mRoutes) {
         dest.writeParcelable(route, flags);

Find a functionally equivalent code:android.media.MediaFocusControl.rcDisplayIsPluggedIn_syncRcStack:COMMENT
Method Modifier: private     
Comment:/**
 * Is the remote control display interface already registered
 * @param rcd
 * @return true if the IRemoteControlDisplay is already in the list of displays
 */

@@ -1,7 +1,7 @@
 {
     final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
     while (displayIterator.hasNext()) {
-        final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
+        final DisplayInfoForServer di = displayIterator.next();
         if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
             return true;
         }

Find a functionally equivalent code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

@@ -18,24 +18,31 @@
     // if (appName == null)
     // appName = "unknown";
     String appName = DdmHandleAppName.getAppName();
-    ByteBuffer out = ByteBuffer.allocate(20 + vmIdent.length() * 2 + appName.length() * 2);
+    VMRuntime vmRuntime = VMRuntime.getRuntime();
+    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
+    String vmInstructionSet = vmRuntime.vmInstructionSet();
+    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
+        instructionSetDescription += " (" + vmInstructionSet + ")";
+    }
+    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
+    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2);
     out.order(ChunkHandler.CHUNK_ORDER);
     out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
     out.putInt(android.os.Process.myPid());
@@ -27,32 +34,43 @@
     putString(out, vmIdent);
     putString(out, appName);
     out.putInt(UserHandle.myUserId());
+    out.putInt(instructionSetDescription.length());
+    putString(out, instructionSetDescription);
+    out.putInt(vmFlags.length());
+    putString(out, vmFlags);
     Chunk reply = new Chunk(CHUNK_HELO, out);
     /*
          * Take the opportunity to inform DDMS if we are waiting for a

Find a functionally equivalent code:android.media.MediaRouter.addCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Add a callback to listen to events about specific kinds of media routes.
 * If the specified callback is already registered, its registration will be updated for any
 * additional route types specified.
 * <p>
 * This is a convenience method that has the same effect as calling
 * {@link #addCallback(int, Callback, int)} without flags.
 * </p>
 *
 * @param types Types of routes this callback is interested in
 * @param cb Callback to add
 */


Find a functionally equivalent code:android.content.pm.PackageItemInfo.loadDefaultIcon:COMMENT
<android.content.pm.PackageItemInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Retrieve the default graphical icon associated with this item.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's default icon
 * such as the default activity icon.
 *
 * @hide
 */


Find a functionally equivalent code:android.widget.ActivityChooserView.updateAppearance:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the buttons state.
 */

@@ -23,30 +23,30 @@
     }
     // Activity chooser content.
     if (mDefaultActivityButton.getVisibility() == VISIBLE) {
-        mActivityChooserContent.setBackgroundDrawable(mActivityChooserContentBackground);
+        mActivityChooserContent.setBackground(mActivityChooserContentBackground);
     } else {
-        mActivityChooserContent.setBackgroundDrawable(null);
+        mActivityChooserContent.setBackground(null);
     }
 }

Find a functionally equivalent code:android.view.KeyEvent.keyCodeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified keycode
 * such as "KEYCODE_A", "KEYCODE_DPAD_UP", or an equivalent numeric constant
 * such as "1001" if unknown.
 *
 * @param keyCode The key code.
 * @return The symbolic name of the specified keycode.
 *
 * @see KeyCharacterMap#getDisplayLabel
 */

@@ -1,4 +1,4 @@
 {
-    String symbolicName = KEYCODE_SYMBOLIC_NAMES.get(keyCode);
-    return symbolicName != null ? symbolicName : Integer.toString(keyCode);
+    String symbolicName = nativeKeyCodeToString(keyCode);
+    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(keyCode);
 }

Find a functionally equivalent code:android.widget.RelativeLayout.getChildMeasureSpec:COMMENT
Method Modifier: private     
Comment:/**
 * Get a measure spec that accounts for all of the constraints on this view.
 * This includes size constraints imposed by the RelativeLayout as well as
 * the View's desired dimension.
 *
 * @param childStart The left or top field of the child's layout params
 * @param childEnd The right or bottom field of the child's layout params
 * @param childSize The child's desired size (the width or height field of
 * the child's layout params)
 * @param startMargin The left or top margin
 * @param endMargin The right or bottom margin
 * @param startPadding mPaddingLeft or mPaddingTop
 * @param endPadding mPaddingRight or mPaddingBottom
 * @param mySize The width or height of this view (the RelativeLayout)
 * @return MeasureSpec for the child
 */

@@ -1,26 +1,36 @@
 {
+    int childSpecMode = 0;
+    int childSpecSize = 0;
+    // RelativeLayout's measure spec."
     if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
-        if (childSize >= 0) {
-            return MeasureSpec.makeMeasureSpec(childSize, MeasureSpec.EXACTLY);
+        if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
+            // Constraints fixed both edges, so child has an exact size.
+            childSpecSize = Math.max(0, childEnd - childStart);
+            childSpecMode = MeasureSpec.EXACTLY;
+        } else if (childSize >= 0) {
+            // The child specified an exact size.
+            childSpecSize = childSize;
+            childSpecMode = MeasureSpec.EXACTLY;
+        } else {
+            // Allow the child to be whatever size it wants.
+            childSpecSize = 0;
+            childSpecMode = MeasureSpec.UNSPECIFIED;
         }
-        // Carry it forward.
-        return MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+        return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
     }
-    int childSpecMode = 0;
-    int childSpecSize = 0;
     // Figure out start and end bounds.
     int tempStart = childStart;
     int tempEnd = childEnd;
     // view's margins and our padding
-    if (tempStart < 0) {
+    if (tempStart == VALUE_NOT_SET) {
         tempStart = startPadding + startMargin;
     }
-    if (tempEnd < 0) {
+    if (tempEnd == VALUE_NOT_SET) {
         tempEnd = mySize - endPadding - endMargin;
     }
     // Figure out maximum size available to this view
     int maxAvailable = tempEnd - tempStart;
-    if (childStart >= 0 && childEnd >= 0) {
+    if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
         // Constraints fixed both edges, so child must be an exact size
         childSpecMode = MeasureSpec.EXACTLY;
         childSpecSize = maxAvailable;

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.abortReliableWrite:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #abortReliableWrite()}
 */


Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeDispatching:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -25,30 +25,34 @@
             return -1;
         }
     }
+    // of the meta key and its corresponding up.
+    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
+        mPendingMetaAction = false;
+    }
     // timeout.
     if (keyCode == KeyEvent.KEYCODE_HOME) {
         // while it was pressed, then it is time to go home!
@@ -39,53 +43,55 @@
                 Log.i(TAG, "Ignoring HOME; event canceled.");
                 return -1;
             }
+            // If an incoming call is ringing, HOME is totally disabled.
+            // (The user is already on the InCallUI at this point,
             // and his ONLY options are to answer or reject the call.)
-            try {
-                ITelephony telephonyService = getTelephonyService();
-                if (telephonyService != null && telephonyService.isRinging()) {
-                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
-                    return -1;
-                }
-            } catch (RemoteException ex) {
-                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
+            TelecomManager telecomManager = getTelecommService();
+            if (telecomManager != null && telecomManager.isRinging()) {
+                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
+                return -1;
             }
             // Delay handling home if a double-tap is possible.
             if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
@@ -57,62 +59,69 @@
                 mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                 return -1;
             }
+            // but don't actually go home.
+            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
+                mDreamManagerInternal.stopDream(false);
+                return -1;
+            }
             // Go home!
             launchHomeFromHotKey();
             return -1;
@@ -66,72 +73,79 @@
         WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
         if (attrs != null) {
             final int type = attrs.type;
-            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
+            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                 // the "app" is keyguard, so give it the key
                 return 0;
             }
@@ -159,164 +166,182 @@
             }
         }
         return -1;
+    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
+        if (!down) {
+            Intent voiceIntent;
+            if (!keyguardOn) {
+                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
+            } else {
+                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
+                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
+            }
+            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
+        }
     } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
         if (down && repeatCount == 0) {
             mHandler.post(mScreenshotRunnable);
@@ -181,188 +199,212 @@
             brightness = Math.min(max, brightness);
             brightness = Math.max(min, brightness);
             Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
-            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
-            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
+            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
+        }
+        return -1;
+    } else if (KeyEvent.isMetaKey(keyCode)) {
+        if (down) {
+            mPendingMetaAction = true;
+        } else if (mPendingMetaAction) {
+            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
         }
         return -1;
     }
@@ -238,256 +262,280 @@
             return -1;
         }
     }
-    // Display task switcher for ALT-TAB or Meta-TAB.
+    // Display task switcher for ALT-TAB.
     if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
-        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
+        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
             final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
-            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
-                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
-                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
+            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
+                mRecentAppsHeldModifiers = shiftlessModifiers;
+                showRecentApps(true);
                 return -1;
             }
         }
-    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
-        mRecentAppsDialogHeldModifiers = 0;
-        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
+    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
+        mRecentAppsHeldModifiers = 0;
+        hideRecentApps(true, false);
     }
     // Handle keyboard language switching.
     if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
@@ -265,270 +289,298 @@
     if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
         return -1;
     }
+    // Reserve all the META modifier combos for system behavior
+    if ((metaState & KeyEvent.META_META_ON) != 0) {
+        return -1;
+    }
     // Let the application handle the key.
     return 0;
 }

Find a functionally equivalent code:android.view.textservice.TextInfo.getSequence:COMMENT
Method Modifier: public      
Comment:/**
 * @return the sequence of TextInfo
 */

@@ -1,3 +1,3 @@
 {
-    return mSequence;
+    return mSequenceNumber;
 }

Find a functionally equivalent code:android.view.ViewGroup.dispatchHoverEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

@@ -15,26 +15,27 @@
         final float y = event.getY();
         final int childrenCount = mChildrenCount;
         if (childrenCount != 0) {
-            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
+            final ArrayList<View> preorderedList = buildOrderedChildList();
+            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
             final View[] children = mChildren;
             HoverTarget lastHoverTarget = null;
             for (int i = childrenCount - 1; i >= 0; i--) {
-                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
-                final View child = children[childIndex];
+                int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
+                final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                     continue;
                 }
@@ -80,85 +81,88 @@
                     break;
                 }
             }
+            if (preorderedList != null)
+                preorderedList.clear();
         }
     }
     // Send exit events to all previously hovered children that are no longer hovered.

Find a functionally equivalent code:android.view.Surface.lockCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */

@@ -3,9 +3,9 @@
         checkNotReleasedLocked();
         if (mLockedObject != 0) {
             // we just refuse to re-lock the Surface.
-            throw new IllegalStateException("Surface was already locked");
+            throw new IllegalArgumentException("Surface was already locked");
         }
         mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
         return mCanvas;

Find a functionally equivalent code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -16,44 +16,44 @@
     // read out port number
     try {
         synchronized (this) {
-            if (VDBG)
+            if (DBG)
                 Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
             if (mSocketState != SocketState.INIT)
                 return EBADFD;
             if (mPfd == null)
                 return -1;
             FileDescriptor fd = mPfd.getFileDescriptor();
-            if (VDBG)
+            if (DBG)
                 Log.d(TAG, "bindListen(), new LocalSocket ");
             mSocket = new LocalSocket(fd);
-            if (VDBG)
+            if (DBG)
                 Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
             mSocketIS = mSocket.getInputStream();
             mSocketOS = mSocket.getOutputStream();
         }
-        if (VDBG)
+        if (DBG)
             Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
         int channel = readInt(mSocketIS);
         synchronized (this) {
             if (mSocketState == SocketState.INIT)
                 mSocketState = SocketState.LISTENING;
         }
-        if (VDBG)
+        if (DBG)
             Log.d(TAG, "channel: " + channel);
         if (mPort == -1) {
             mPort = channel;
@@ -46,51 +46,59 @@
         // else ASSERT(mPort == channel)
         ret = 0;
     } catch (IOException e) {
+        if (mPfd != null) {
+            try {
+                mPfd.close();
+            } catch (IOException e1) {
+                Log.e(TAG, "bindListen, close mPfd: " + e1);
+            }
+            mPfd = null;
+        }
         Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
         return -1;
     }

Find a functionally equivalent code:android.appwidget.AppWidgetManager.getAppWidgetInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */

@@ -1,12 +1,12 @@
 {
+    if (mService == null) {
+        return null;
+    }
     try {
-        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId, mContext.getUserId());
+        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
         if (info != null) {
             // Converting complex to dp.
-            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
-            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
-            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
-            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
+            convertSizesToPixels(info);
         }
         return info;
     } catch (RemoteException e) {

Find a functionally equivalent code:android.view.Window.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Set the type of the window, as per the WindowManager.LayoutParams
 * types.
 *
 * @param type The new window type (see WindowManager.LayoutParams).
 */

@@ -1,7 +1,5 @@
 {
     final WindowManager.LayoutParams attrs = getAttributes();
     attrs.type = type;
-    if (mCallback != null) {
-        mCallback.onWindowAttributesChanged(attrs);
-    }
+    dispatchWindowAttributesChanged(attrs);
 }

Find a functionally equivalent code:android.media.MediaFocusControl.postReevaluateRemote:COMMENT
<android.media.MediaFocusControl: void postReevaluateRemote()>
Method Modifier: protected   private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Call to make AudioService reevaluate whether it's in a mode where remote players should
 * have their volume controlled. In this implementation this is only to reset whether
 * VolumePanel should display remote volumes
 */


Find a functionally equivalent code:android.print.PrintDocumentInfo.Builder.setPageCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the total number of pages.
 * <p>
 * <strong>Default: </strong> {@link #PAGE_COUNT_UNKNOWN}
 * </p>
 *
 * @param pageCount The number of pages. Must be greater than
 * or equal to zero or {@link PrintDocumentInfo#PAGE_COUNT_UNKNOWN}.
 */

@@ -1,6 +1,6 @@
 {
     if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
-        throw new IllegalArgumentException("pageCount" + " must be greater than or euqal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
+        throw new IllegalArgumentException("pageCount" + " must be greater than or equal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
     }
     mPrototype.mPageCount = pageCount;
     return this;

Find a functionally equivalent code:android.os.Bundle.setClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Changes the ClassLoader this Bundle uses when instantiating objects.
 *
 * @param loader An explicit ClassLoader to use when instantiating objects
 * inside of the Bundle.
 */

@@ -1,3 +1,3 @@
 {
-    mClassLoader = loader;
+    super.setClassLoader(loader);
 }

Find a functionally equivalent code:android.text.format.Time.parse3339:COMMENT
Method Modifier: public      
Comment:/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>"2008-10-13T16:00:00.000Z"</li>
 * <li>"2008-10-13T16:00:00.000+07:00"</li>
 * <li>"2008-10-13T16:00:00.000-07:00"</li>
 * <li>"2008-10-13"</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

@@ -2,8 +2,8 @@
     if (s == null) {
         throw new NullPointerException("time string is null");
     }
-    if (nativeParse3339(s)) {
+    if (parse3339Internal(s)) {
         timezone = TIMEZONE_UTC;
         return true;
     }

Find a functionally equivalent code:android.bluetooth.BluetoothSocket.read:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -1,4 +1,6 @@
 {
+    if (mSocketIS == null)
+        throw new IOException("read is called on null InputStream");
     if (VDBG)
         Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
     int ret = mSocketIS.read(b, offset, length);

Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.downloadFile:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a file using http connection from a test server and reports the
 * data usage stats to instrumentation out.
 */

@@ -15,22 +15,22 @@
     results.putString("device_id", mDeviceId);
     results.putString("timestamp", ts);
     results.putInt("size", FILE_SIZE);
-    AddStatsToResults(PROF_LABEL, prof_stats, results);
-    AddStatsToResults(PROC_LABEL, proc_stats, results);
+    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
+    addStatsToResults(PROC_LABEL, proc_stats, results, mUid);
     getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
     // Clean up.
     assertTrue(cleanUpFile(tmpSaveFile));

Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.downloadFileUsingDownloadManager:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a file from a test server using the download manager and reports
 * the stats to instrumentation out.
 */

@@ -21,28 +21,29 @@
     results.putString("device_id", mDeviceId);
     results.putString("timestamp", ts);
     results.putInt("size", FILE_SIZE);
-    AddStatsToResults(PROF_LABEL, prof_stats, results);
-    AddStatsToResults(PROC_LABEL, proc_stats, results);
+    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
+    // remember to use download manager uid for proc stats
+    addStatsToResults(PROC_LABEL, proc_stats, results, downloadManagerUid);
     getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
     // Clean up.
     assertTrue(cleanUpFile(tmpSaveFile));

Find a functionally equivalent code:android.os.Bundle.putBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Boolean value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Boolean, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putBoolean(key, value);
 }

Find a functionally equivalent code:android.content.res.TypedArray.getNonConfigurationString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Retrieve the string value for the attribute at <var>index</var> that is
 * not allowed to change with the given configurations.
 *
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from
 * {@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.widget.EdgeEffect.onAbsorb:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the effect absorbs an impact at the given velocity.
 * Used when a fling reaches the scroll boundary.
 *
 * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
 * the method <code>getCurrVelocity</code> will provide a reasonable approximation
 * to use here.</p>
 *
 * @param velocity Velocity at impact in pixels per second.
 */

@@ -3,26 +3,18 @@
     velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
     mStartTime = AnimationUtils.currentAnimationTimeMillis();
     mDuration = 0.15f + (velocity * 0.02f);
-    // The edge should always be at least partially visible, regardless
-    // of velocity.
-    mEdgeAlphaStart = 0.f;
-    mEdgeScaleY = mEdgeScaleYStart = 0.f;
     // The glow depends more on the velocity, and therefore starts out
     // nearly invisible.
     mGlowAlphaStart = 0.3f;
-    mGlowScaleYStart = 0.f;
-    // Factor the velocity by 8. Testing on device shows this works best to
-    // reflect the strength of the user's scrolling.
-    mEdgeAlphaFinish = Math.max(0, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1));
-    // Edge should never get larger than the size of its asset.
-    mEdgeScaleYFinish = Math.max(HELD_EDGE_SCALE_Y, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1.f));
+    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
     // Growth for the size of the glow should be quadratic to properly
     // respond
     // to a user's scrolling speed. The faster the scrolling speed, the more
     // intense the effect should be for both the size and the saturation.
-    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f), 1.75f);
+    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
     // Alpha should change for the glow as well as size.
     mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
+    mTargetDisplacement = 0.5f;
 }

Find a functionally equivalent code:android.media.AudioTrack.isMultichannelConfigSupported:COMMENT
Method Modifier: private     static      
Comment:/**
 * Convenience method to check that the channel configuration (a.k.a channel mask) is supported
 * @param channelConfig the mask to validate
 * @return false if the AudioTrack can't be used with such a mask
 */

@@ -4,9 +4,14 @@
         loge("Channel configuration features unsupported channels");
         return false;
     }
+    final int channelCount = Integer.bitCount(channelConfig);
+    if (channelCount > CHANNEL_COUNT_MAX) {
+        loge("Channel configuration contains too many channels " + channelCount + ">" + CHANNEL_COUNT_MAX);
+        return false;
+    }
     // check for unsupported multichannel combinations:
     // - FL/FR must be present
     // - L/R channels must be paired (e.g. no single L channel)
@@ -19,23 +24,33 @@
             return false;
         }
     }
+    final int sidePair = AudioFormat.CHANNEL_OUT_SIDE_LEFT | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
+    if ((channelConfig & sidePair) != 0 && (channelConfig & sidePair) != sidePair) {
+        loge("Side channels can't be used independently");
+        return false;
+    }
     return true;
 }

Find a functionally equivalent code:android.graphics.Canvas.drawRGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified RGB color, using srcover porterduff mode.
 *
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

@@ -1,3 +1,3 @@
 {
-    native_drawRGB(mNativeCanvas, r, g, b);
+    drawColor(Color.rgb(r, g, b));
 }

Find a functionally equivalent code:android.app.Activity.onStop:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when you are no longer visible to the user.  You will next
 * receive either {@link #onRestart}, {@link #onDestroy}, or nothing,
 * depending on later user activity.
 *
 * <p>Note that this method may never be called, in low memory situations
 * where the system does not have enough memory to keep your activity's
 * process running after its {@link #onPause} method is called.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestart
 * @see #onResume
 * @see #onSaveInstanceState
 * @see #onDestroy
 */

@@ -3,8 +3,9 @@
         Slog.v(TAG, "onStop " + this);
     if (mActionBar != null)
         mActionBar.setShowHideAnimationEnabled(false);
+    mActivityTransitionState.onStop();
     getApplication().dispatchActivityStopped(this);
     mTranslucentCallback = null;
     mCalled = true;

Find a functionally equivalent code:android.view.WindowManagerPolicy.createForceHideEnterAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Create and return an animation to re-display a force hidden window.
 */


Find a functionally equivalent code:android.speech.SpeechRecognizer.destroy:COMMENT
Method Modifier: public      
Comment:/**
 * Destroys the {@code SpeechRecognizer} object.
 */

@@ -1,4 +1,11 @@
 {
+    if (mService != null) {
+        try {
+            mService.cancel(mListener);
+        } catch (final RemoteException e) {
+        // Not important
+        }
+    }
     if (mConnection != null) {
         mContext.unbindService(mConnection);
     }

Find a functionally equivalent code:android.graphics.Canvas.getMatrix:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return, in ctm, the current transformation matrix. This does not alter
 * the matrix in the canvas, but just returns a copy of it.
 */

@@ -1,3 +1,3 @@
 {
-    native_getCTM(mNativeCanvas, ctm.native_instance);
+    native_getCTM(mNativeCanvasWrapper, ctm.native_instance);
 }

Find a functionally equivalent code:android.view.GraphicBuffer.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates new <code>GraphicBuffer</code> instance. This method will return null
 * if the buffer cannot be created.
 *
 * @param width The width in pixels of the buffer
 * @param height The height in pixels of the buffer
 * @param format The format of each pixel as specified in {@link PixelFormat}
 * @param usage Hint indicating how the buffer will be used
 *
 * @return A <code>GraphicBuffer</code> instance or null
 */

@@ -1,5 +1,5 @@
 {
-    int nativeObject = nCreateGraphicBuffer(width, height, format, usage);
+    long nativeObject = nCreateGraphicBuffer(width, height, format, usage);
     if (nativeObject != 0) {
         return new GraphicBuffer(width, height, format, usage, nativeObject);
     }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isBiometricWeakInstalled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return Whether biometric weak lock is installed and that the front facing camera exists
 */

@@ -13,17 +13,20 @@
     if (getDevicePolicyManager().getCameraDisabled(null, getCurrentOrCallingUserId())) {
         return false;
     }
-    return true;
+    // entire function and a lot of other code can be removed.
+    if (DEBUG)
+        Log.d(TAG, "Forcing isBiometricWeakInstalled() to return false to disable it");
+    return false;
 }

Find a functionally equivalent code:android.text.DynamicLayout.addBlockAtOffset:COMMENT
Method Modifier: private     
Comment:/**
 * Create a new block, ending at the specified character offset.
 * A block will actually be created only if has at least one line, i.e. this offset is
 * not on the end line of the previous block.
 */

@@ -2,21 +2,15 @@
     final int line = getLineForOffset(offset);
     if (mBlockEndLines == null) {
         // Initial creation of the array, no test on previous block ending line
-        mBlockEndLines = new int[ArrayUtils.idealIntArraySize(1)];
+        mBlockEndLines = ArrayUtils.newUnpaddedIntArray(1);
         mBlockEndLines[mNumberOfBlocks] = line;
         mNumberOfBlocks++;
         return;
     }
     final int previousBlockEndLine = mBlockEndLines[mNumberOfBlocks - 1];
     if (line > previousBlockEndLine) {
-        if (mNumberOfBlocks == mBlockEndLines.length) {
-            // Grow the array if needed
-            int[] blockEndLines = new int[ArrayUtils.idealIntArraySize(mNumberOfBlocks + 1)];
-            System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, mNumberOfBlocks);
-            mBlockEndLines = blockEndLines;
-        }
-        mBlockEndLines[mNumberOfBlocks] = line;
+        mBlockEndLines = GrowingArrayUtils.append(mBlockEndLines, mNumberOfBlocks, line);
         mNumberOfBlocks++;
     }
 }

Find a functionally equivalent code:android.net.DnsPinger.getDnsList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of DNS addresses, coming from either the link properties of the
 * specified connection or the default system DNS if the link properties has no dnses.
 * @return a non-empty non-null list
 */

@@ -4,10 +4,10 @@
         loge("getCurLinkProperties:: LP for type" + mConnectionType + " is null!");
         return mDefaultDns;
     }
-    Collection<InetAddress> dnses = curLinkProps.getDnses();
+    Collection<InetAddress> dnses = curLinkProps.getDnsServers();
     if (dnses == null || dnses.size() == 0) {
         loge("getDns::LinkProps has null dns - returning default");
         return mDefaultDns;

Find a functionally equivalent code:android.print.PrintManager.getPrintJob:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a print job given its id.
 *
 * @return The print job list.
 * @see PrintJob
 * @hide
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return null;
+    }
     try {
         PrintJobInfo printJob = mService.getPrintJobInfo(printJobId, mAppId, mUserId);
         if (printJob != null) {

Find a functionally equivalent code:android.media.RemoteControlClient.setPlaybackPositionUpdateListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be called whenever the media playback position is requested
 * to be updated.
 * Notifications will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the position update listener to be called
 */

@@ -1,15 +1,5 @@
 {
     synchronized (mCacheLock) {
-        int oldCapa = mPlaybackPositionCapabilities;
-        if (l != null) {
-            mPlaybackPositionCapabilities |= MEDIA_POSITION_WRITABLE;
-        } else {
-            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_WRITABLE;
-        }
         mPositionUpdateListener = l;
-        if (oldCapa != mPlaybackPositionCapabilities) {
-            // tell RCDs that this RCC's playback position capabilities have changed
-            sendTransportControlInfo_syncCacheLock(null);
-        }
     }
 }

Find a functionally equivalent code:android.media.AudioService.setMasterMute:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setMasterMute(boolean, int)
 */

@@ -2,11 +2,14 @@
     if (mUseFixedVolume) {
         return;
     }
+    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
+        return;
+    }
     if (state != AudioSystem.getMasterMute()) {
         AudioSystem.setMasterMute(state);
         // Post a persist master volume msg
-        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, 0, null, PERSIST_DELAY);
+        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, UserHandle.getCallingUserId(), null, PERSIST_DELAY);
         sendMasterMuteUpdate(state, flags);
     }
 }

Find a functionally equivalent code:android.widget.FastScroller.transitionPreviewLayout:COMMENT
Method Modifier: private     
Comment:/**
 * Transitions the preview text to a new section. Handles animation,
 * measurement, and layout. If the new preview text is empty, returns false.
 *
 * @param sectionIndex The section index to which the preview should
 * transition.
 * @return False if the new preview text is empty.
 */

@@ -8,14 +8,14 @@
         }
     }
     final Rect bounds = mTempBounds;
-    final ImageView preview = mPreviewImage;
+    final View preview = mPreviewImage;
     final TextView showing;
     final TextView target;
     if (mShowingPrimary) {
@@ -30,39 +30,39 @@
     final Animator hideShowing = animateAlpha(showing, 0f).setDuration(DURATION_CROSS_FADE);
     hideShowing.addListener(mSwitchPrimaryListener);
     // Apply preview image padding and animate bounds, if necessary.
-    bounds.left -= mPreviewImage.getPaddingLeft();
-    bounds.top -= mPreviewImage.getPaddingTop();
-    bounds.right += mPreviewImage.getPaddingRight();
-    bounds.bottom += mPreviewImage.getPaddingBottom();
+    bounds.left -= preview.getPaddingLeft();
+    bounds.top -= preview.getPaddingTop();
+    bounds.right += preview.getPaddingRight();
+    bounds.bottom += preview.getPaddingBottom();
     final Animator resizePreview = animateBounds(preview, bounds);
     resizePreview.setDuration(DURATION_RESIZE);
     mPreviewAnimation = new AnimatorSet();
@@ -60,64 +60,64 @@
         builder.with(scaleAnim);
     }
     mPreviewAnimation.start();
-    return (text != null && text.length() > 0);
+    return !TextUtils.isEmpty(text);
 }

Find a functionally equivalent code:android.view.ViewRootImpl.InputStage.deliver:COMMENT
Method Modifier: public      final       
Comment:/**
 * Delivers an event to be processed.
 */

@@ -1,15 +1,8 @@
 {
     if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
         forward(q);
-    } else if (mView == null || !mAdded) {
-        Slog.w(TAG, "Dropping event due to root view being removed: " + q.mEvent);
+    } else if (shouldDropInputEvent(q)) {
         finish(q, false);
-    } else if (!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isTerminalInputEvent(q.mEvent)) {
-        // If this is a focused event and the window doesn't currently have input focus,
-        // then drop this event.  This could be an event that came back from the previous
-        // stage but the window has lost focus in the meantime.
-        Slog.w(TAG, "Dropping event due to no window focus: " + q.mEvent);
-        finish(q, false);
     } else {
         apply(q, onProcess(q));
     }

Find a functionally equivalent code:android.transition.Transition.playTransition:COMMENT
Method Modifier: 
Comment:/**
 * Called by TransitionManager to play the transition. This calls
 * createAnimators() to set things up and create all of the animations and then
 * runAnimations() to actually start the animations.
 */

@@ -1,34 +1,20 @@
 {
+    mStartValuesList = new ArrayList<TransitionValues>();
+    mEndValuesList = new ArrayList<TransitionValues>();
+    matchStartAndEnd(mStartValues, mEndValues);
     ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
     int numOldAnims = runningAnimators.size();
+    WindowId windowId = sceneRoot.getWindowId();
     for (int i = numOldAnims - 1; i >= 0; i--) {
         Animator anim = runningAnimators.keyAt(i);
         if (anim != null) {
             AnimationInfo oldInfo = runningAnimators.get(anim);
-            if (oldInfo != null) {
-                boolean cancel = false;
+            if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
                 TransitionValues oldValues = oldInfo.values;
                 View oldView = oldInfo.view;
-                TransitionValues newValues = mEndValues.viewValues != null ? mEndValues.viewValues.get(oldView) : null;
-                if (newValues == null) {
-                    newValues = mEndValues.idValues.get(oldView.getId());
-                }
-                if (oldValues != null) {
-                    // and won't get canceled
-                    if (newValues != null) {
-                        for (String key : oldValues.values.keySet()) {
-                            Object oldValue = oldValues.values.get(key);
-                            Object newValue = newValues.values.get(key);
-                            if (oldValue != null && newValue != null && !oldValue.equals(newValue)) {
-                                cancel = true;
-                                if (DBG) {
-                                    Log.d(LOG_TAG, "Transition.playTransition: " + "oldValue != newValue for " + key + ": old, new = " + oldValue + ", " + newValue);
-                                }
-                                break;
-                            }
-                        }
-                    }
-                }
+                TransitionValues startValues = getTransitionValues(oldView, true);
+                TransitionValues endValues = getMatchedTransitionValues(oldView, true);
+                boolean cancel = (startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues, endValues);
                 if (cancel) {
                     if (anim.isRunning() || anim.isStarted()) {
                         if (DBG) {
@@ -45,50 +31,36 @@
             }
         }
     }
-    createAnimators(sceneRoot, mStartValues, mEndValues);
+    createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);
     runAnimators();
 }

Find a functionally equivalent code:android.graphics.Matrix.postTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified translation.
 * M' = T(dx, dy) * M
 */

@@ -1,3 +1,4 @@
 {
-    return native_postTranslate(native_instance, dx, dy);
+    native_postTranslate(native_instance, dx, dy);
+    return true;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.initializePanelMenu:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * Initializes the menu associated with the given panel feature state. You
 * must at the very least set PanelFeatureState.menu to the Menu to be
 * associated with the given panel state. The default implementation creates
 * a new menu for the panel state.
 *
 * @param st The panel whose menu is being initialized.
 * @return Whether the initialization was successful.
 */

@@ -1,14 +1,30 @@
 {
     Context context = getContext();
-    // If we have an action bar, initialize the menu with a context themed for it.
-    if ((st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR) && mActionBar != null) {
-        TypedValue outValue = new TypedValue();
-        Resources.Theme currentTheme = context.getTheme();
-        currentTheme.resolveAttribute(com.android.internal.R.attr.actionBarWidgetTheme, outValue, true);
-        final int targetThemeRes = outValue.resourceId;
-        if (targetThemeRes != 0 && context.getThemeResId() != targetThemeRes) {
-            context = new ContextThemeWrapper(context, targetThemeRes);
+    // If we have an action bar, initialize the menu with the right theme.
+    if ((st.featureId == FEATURE_OPTIONS_PANEL || st.featureId == FEATURE_ACTION_BAR) && mDecorContentParent != null) {
+        final TypedValue outValue = new TypedValue();
+        final Theme baseTheme = context.getTheme();
+        baseTheme.resolveAttribute(R.attr.actionBarTheme, outValue, true);
+        Theme widgetTheme = null;
+        if (outValue.resourceId != 0) {
+            widgetTheme = context.getResources().newTheme();
+            widgetTheme.setTo(baseTheme);
+            widgetTheme.applyStyle(outValue.resourceId, true);
+            widgetTheme.resolveAttribute(R.attr.actionBarWidgetTheme, outValue, true);
+        } else {
+            baseTheme.resolveAttribute(R.attr.actionBarWidgetTheme, outValue, true);
         }
+        if (outValue.resourceId != 0) {
+            if (widgetTheme == null) {
+                widgetTheme = context.getResources().newTheme();
+                widgetTheme.setTo(baseTheme);
+            }
+            widgetTheme.applyStyle(outValue.resourceId, true);
+        }
+        if (widgetTheme != null) {
+            context = new ContextThemeWrapper(context, 0);
+            context.getTheme().setTo(widgetTheme);
+        }
     }
     final MenuBuilder menu = new MenuBuilder(context);
     menu.setCallback(this);

Find a functionally equivalent code:android.view.ViewGroup.setClipToPadding:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to the padding of the ViewGroup. This
 * allows view groups to override this behavior
 *
 * @param clipToPadding true to clip children to the padding of the
 * group, false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipToPadding
 */

@@ -1,3 +1,6 @@
 {
-    setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
+    if (hasBooleanFlag(FLAG_CLIP_TO_PADDING) != clipToPadding) {
+        setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
+        invalidate(true);
+    }
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupValue:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function to set the value stored in a particular Keyframe. The value used is
 * whatever the value is for the property name specified in the keyframe on the target object.
 *
 * @param target The target object from which the current value should be extracted.
 * @param kf The keyframe which holds the property name and value.
 */

@@ -1,6 +1,7 @@
 {
     if (mProperty != null) {
-        kf.setValue(mProperty.get(target));
+        Object value = convertBack(mProperty.get(target));
+        kf.setValue(value);
     }
     try {
         if (mGetter == null) {
@@ -11,17 +12,19 @@
                 return;
             }
         }
-        kf.setValue(mGetter.invoke(target));
+        Object value = convertBack(mGetter.invoke(target));
+        kf.setValue(value);
     } catch (InvocationTargetException e) {
         Log.e("PropertyValuesHolder", e.toString());
     } catch (IllegalAccessException e) {

Find a functionally equivalent code:android.graphics.Matrix.preTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified translation.
 * M' = M * T(dx, dy)
 */

@@ -1,3 +1,4 @@
 {
-    return native_preTranslate(native_instance, dx, dy);
+    native_preTranslate(native_instance, dx, dy);
+    return true;
 }

Find a functionally equivalent code:android.net.wifi.WifiManager.startScan:COMMENT
Method Modifier: public      
Comment:/**
 * Request a scan for access points. Returns immediately. The availability
 * of the results is made known later by means of an asynchronous event sent
 * on completion of the scan.
 * @return {@code true} if the operation succeeded, i.e., the scan was initiated
 */

@@ -1,7 +1,6 @@
 {
     try {
-        final WorkSource workSource = null;
-        mService.startScan(workSource);
+        mService.startScan(null, null);
         return true;
     } catch (RemoteException e) {
         return false;

Find a functionally equivalent code:javax.obex.ClientOperation.continueOperation:COMMENT
Method Modifier: public      
Comment:/**
 * Continues the operation since there is no data to read.
 * @param sendEmpty <code>true</code> if the operation should send an empty
 * packet or not send anything if there is no data to send
 * @param inStream <code>true</code> if the stream is input stream or is
 * output stream
 * @throws IOException if an IO error occurs
 */

@@ -14,20 +14,27 @@
             if (mPrivateInput == null) {
                 mPrivateInput = new PrivateInputStream(this);
             }
-            sendRequest(0x03);
+            if (!mGetFinalFlag) {
+                sendRequest(0x03);
+            } else {
+                sendRequest(0x83);
+                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
+                    mOperationDone = true;
+                }
+            }
             return true;
         } else if (mOperationDone) {
             return false;

Find a functionally equivalent code:android.view.ViewGroup.dispatchGetDisplayList:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is used to cause children of this ViewGroup to restore or recreate their
 * display lists. It is called by getDisplayList() when the parent ViewGroup does not need
 * to recreate its own display list, which would happen if it went through the normal
 * draw/dispatchDraw mechanisms.
 *
 * @hide
 */

@@ -4,20 +4,22 @@
     for (int i = 0; i < count; i++) {
         final View child = children[i];
         if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) && child.hasStaticLayer()) {
-            child.mRecreateDisplayList = (child.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
-            child.mPrivateFlags &= ~PFLAG_INVALIDATED;
-            child.getDisplayList();
-            child.mRecreateDisplayList = false;
+            recreateChildDisplayList(child);
         }
     }
     if (mOverlay != null) {
         View overlayView = mOverlay.getOverlayView();
-        overlayView.mRecreateDisplayList = (overlayView.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
-        overlayView.mPrivateFlags &= ~PFLAG_INVALIDATED;
-        overlayView.getDisplayList();
-        overlayView.mRecreateDisplayList = false;
+        recreateChildDisplayList(overlayView);
     }
+    if (mDisappearingChildren != null) {
+        final ArrayList<View> disappearingChildren = mDisappearingChildren;
+        final int disappearingCount = disappearingChildren.size();
+        for (int i = 0; i < disappearingCount; ++i) {
+            final View child = disappearingChildren.get(i);
+            recreateChildDisplayList(child);
+        }
+    }
 }

Find a functionally equivalent code:android.view.ViewRootImpl.InputStage.onDeliverToNext:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when an event is being delivered to the next stage.
 */

@@ -1,4 +1,7 @@
 {
+    if (DEBUG_INPUT_STAGES) {
+        Log.v(TAG, "Done with " + getClass().getSimpleName() + ". " + q);
+    }
     if (mNext != null) {
         mNext.deliver(q);
     } else {

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.makeNodeId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Makes a node id by shifting the <code>virtualDescendantId</code>
 * by {@link #VIRTUAL_DESCENDANT_ID_SHIFT} and taking
 * the bitwise or with the <code>accessibilityViewId</code>.
 *
 * @param accessibilityViewId A View accessibility id.
 * @param virtualDescendantId A virtual descendant id.
 * @return The node id.
 *
 * @hide
 */

@@ -1,3 +1,7 @@
 {
+    // remap it here.
+    if (virtualDescendantId == AccessibilityNodeProvider.HOST_VIEW_ID) {
+        virtualDescendantId = UNDEFINED_ITEM_ID;
+    }
     return (((long) virtualDescendantId) << VIRTUAL_DESCENDANT_ID_SHIFT) | accessibilityViewId;
 }

Find a functionally equivalent code:com.android.bandwidthtest.BandwidthTest.uploadFile:COMMENT
Method Modifier: protected   
Comment:/**
 * Helper method that downloads a test file to upload. The stats reported to instrumentation out
 * only include upload stats.
 */

@@ -18,25 +18,25 @@
     results.putString("device_id", mDeviceId);
     results.putString("timestamp", ts);
     results.putInt("size", FILE_SIZE);
-    AddStatsToResults(PROF_LABEL, prof_stats, results);
-    AddStatsToResults(PROC_LABEL, proc_stats, results);
+    addStatsToResults(PROF_LABEL, prof_stats, results, mUid);
+    addStatsToResults(PROC_LABEL, proc_stats, results, mUid);
     getInstrumentation().sendStatus(INSTRUMENTATION_IN_PROGRESS, results);
     // Clean up.
     assertTrue(cleanUpFile(tmpSaveFile));

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setUseLevel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets whether or not this drawable will honor its <code>level</code>
 * property.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param useLevel True if this drawable should honor its level, false otherwise
 *
 * @see #mutate()
 * @see #setLevel(int)
 * @see #getLevel()
 */

@@ -1,5 +1,5 @@
 {
     mGradientState.mUseLevel = useLevel;
-    mRectIsDirty = true;
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.graphics.Canvas.getHeight:COMMENT
<android.graphics.Canvas: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the height of the current drawing layer
 *
 * @return the height of the current drawing layer
 */

@@ -1 +1,3 @@
-
+{
+    return native_getHeight(mNativeCanvasWrapper);
+}

Find a functionally equivalent code:android.graphics.Matrix.postSkew:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified skew.
 * M' = K(kx, ky) * M
 */

@@ -1,3 +1,4 @@
 {
-    return native_postSkew(native_instance, kx, ky);
+    native_postSkew(native_instance, kx, ky);
+    return true;
 }

Find a functionally equivalent code:android.text.TextUtils.obtain:COMMENT
Method Modifier: default     static      
Comment:/* package */

@@ -5,10 +5,10 @@
         sTemp = null;
     }
     if (buf == null || buf.length < len)
-        buf = new char[ArrayUtils.idealCharArraySize(len)];
+        buf = ArrayUtils.newUnpaddedCharArray(len);
     return buf;
 }

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleUnlock:COMMENT
Method Modifier: 
Comment:/**
 * Stops the Face Unlock service and tells the device to grant access to the user.
 */

@@ -6,12 +6,12 @@
     if (authenticatedUserId == currentUserId) {
         if (DEBUG)
             Log.d(TAG, "Unlocking for user " + authenticatedUserId);
-        mKeyguardScreenCallback.reportSuccessfulUnlockAttempt();
+        mKeyguardScreenCallback.reportUnlockAttempt(true);
         mKeyguardScreenCallback.dismiss(true);
     } else {
         Log.d(TAG, "Ignoring unlock for authenticated user (" + authenticatedUserId + ") because the current user is " + currentUserId);

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

@@ -1,7 +1,7 @@
 {
     if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
         return false;
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
     if (mService == null || mClientIf == 0)
         return false;
@@ -11,20 +11,26 @@
     BluetoothDevice device = service.getDevice();
     if (device == null)
         return false;
+    synchronized (mDeviceBusy) {
+        if (mDeviceBusy)
+            return false;
+        mDeviceBusy = true;
+    }
     try {
         mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
+        mDeviceBusy = false;
         return false;
     }
     return true;

Find a functionally equivalent code:android.os.BatteryStats.getGlobalWifiRunningTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that wifi has been on and the driver has
 * been in the running state while the device was running on battery.
 *
 * {@hide}
 */


Find a functionally equivalent code:com.android.tools.layoutlib.create.Main.processArgs:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns true if args where properly parsed.
 * Returns false if program should exit with command-line usage.
 * <p/>
 * Note: the String[0] is an output parameter wrapped in an array, since there is no
 * "out" parameter support.
 */

@@ -1,11 +1,8 @@
 {
     boolean needs_dest = true;
-    for (int i = 0; i < args.length; i++) {
-        String s = args[i];
+    for (String s : args) {
         if (s.equals("-v")) {
             log.setVerbose(true);
-        } else if (s.equals("-p")) {
-            sOptions.generatePublicAccess = false;
         } else if (s.equals("--list-deps")) {
             sOptions.listAllDeps = true;
             needs_dest = false;
@@ -19,25 +16,22 @@
                 osJarPath.add(s);
             }
         } else {
-            log.error("Unknow argument: %s", s);
+            log.error("Unknown argument: %s", s);
             return false;
         }
     }
@@ -31,36 +28,32 @@
         log.error("Missing parameter: path to output jar");
         return false;
     }
-    sOptions.generatePublicAccess = false;
     return true;
 }

Find a functionally equivalent code:android.view.ViewPropertyAnimator.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the startDelay for the underlying animator that animates the requested properties.
 * By default, the animator uses the default value for ValueAnimator. Calling this method
 * will cause the declared value to be used instead.
 * @param startDelay The delay of ensuing property animations, in milliseconds. The value
 * cannot be negative.
 * @return This object, allowing calls to methods in this class to be chained.
 */

@@ -1,6 +1,6 @@
 {
     if (startDelay < 0) {
-        throw new IllegalArgumentException("Animators cannot have negative duration: " + startDelay);
+        throw new IllegalArgumentException("Animators cannot have negative start " + "delay: " + startDelay);
     }
     mStartDelaySet = true;
     mStartDelay = startDelay;

Find a functionally equivalent code:android.printservice.PrintJob.getAdvancedStringOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

@@ -1,4 +1,4 @@
 {
     PrintService.throwIfNotCalledOnMainThread();
-    return null;
+    return getInfo().getAdvancedStringOption(key);
 }

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisIntArrayXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read an int[] object from an XmlPullParser.  The XML data could
 * previously have been generated by writeIntArrayXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the list.
 *
 * @param parser The XmlPullParser from which to read the list data.
 * @param endTag Name of the tag that will end the list, usually "list".
 * @param name An array of one string, used to return the name attribute
 * of the list's tag.
 *
 * @return Returns a newly generated int[].
 *
 * @see #readListXml
 */

@@ -7,12 +7,13 @@
     } catch (NumberFormatException e) {
         throw new XmlPullParserException("Not a number in num attribute in byte-array");
     }
+    parser.next();
     int[] array = new int[num];
     int i = 0;
     int eventType = parser.getEventType();

Find a functionally equivalent code:android.media.AudioService.adjustSuggestedStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#adjustVolume(int, int)
 */

@@ -1,22 +1,3 @@
 {
-    if (DEBUG_VOL)
-        Log.d(TAG, "adjustSuggestedStreamVolume() stream=" + suggestedStreamType);
-    int streamType;
-    if (mVolumeControlStream != -1) {
-        streamType = mVolumeControlStream;
-    } else {
-        streamType = getActiveStreamType(suggestedStreamType);
-    }
-    // Play sounds on STREAM_RING only and if lock screen is not on.
-    if ((streamType != STREAM_REMOTE_MUSIC) && (flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ((mStreamVolumeAlias[streamType] != AudioSystem.STREAM_RING) || (mKeyguardManager != null && mKeyguardManager.isKeyguardLocked()))) {
-        flags &= ~AudioManager.FLAG_PLAY_SOUND;
-    }
-    if (streamType == STREAM_REMOTE_MUSIC) {
-        // don't play sounds for remote
-        flags &= ~(AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_FIXED_VOLUME);
-        // if (DEBUG_VOL) Log.i(TAG, "Need to adjust remote volume: calling adjustRemoteVolume()");
-        mMediaFocusControl.adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, flags);
-    } else {
-        adjustStreamVolume(streamType, direction, flags, callingPackage);
-    }
+    adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage, Binder.getCallingUid());
 }

Find a functionally equivalent code:android.net.wifi.WifiConfiguration.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * indicates whether the configuration is valid
 * @return true if valid, false otherwise
 * @hide
 */

@@ -1,4 +1,6 @@
 {
+    if (allowedKeyManagement == null)
+        return false;
     if (allowedKeyManagement.cardinality() > 1) {
         if (allowedKeyManagement.cardinality() != 2) {
             return false;

Find a functionally equivalent code:android.os.Bundle.putCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a char array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putCharArray(key, value);
 }

Find a functionally equivalent code:android.text.format.Time.setToNow:COMMENT
<android.text.format.Time: void setToNow()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the time of the given Time object to the current time.
 */

@@ -1 +1,3 @@
-
+{
+    set(System.currentTimeMillis());
+}

Find a functionally equivalent code:android.media.MediaPlayer.TrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -2,7 +2,8 @@
     dest.writeInt(mTrackType);
     dest.writeString(getLanguage());
     if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
+        dest.writeString(mFormat.getString(MediaFormat.KEY_MIME));
         dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
         dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
         dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.connect:COMMENT
Method Modifier: 
Comment:/*package*/


Find a functionally equivalent code:android.os.ParcelFileDescriptor.seekTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * This is needed for implementing AssetFileDescriptor.AutoCloseOutputStream,
 * and I really don't think we want it to be public.
 * @hide
 */

@@ -3,9 +3,9 @@
         return mWrapped.seekTo(pos);
     } else {
         try {
-            return Libcore.os.lseek(mFd, pos, SEEK_SET);
+            return Os.lseek(mFd, pos, SEEK_SET);
         } catch (ErrnoException e) {
             throw e.rethrowAsIOException();
         }

Find a functionally equivalent code:android.text.format.DateFormat.getBestDateTimePattern:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href="http://www.unicode.org/reports/tr35/#Date_Format_Patterns">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, "MMMMd" will return
 * "MMMM d" in the {@code en_US} locale, but "d. MMMM" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * "d 'de' MMMM".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same "MMMMd" input, this method will return "d LLLL" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so "Md" would give a different result to "MMMd", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */

@@ -1,3 +1,3 @@
 {
-    return ICU.getBestDateTimePattern(skeleton, locale.toString());
+    return ICU.getBestDateTimePattern(skeleton, locale);
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.readCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

@@ -1,7 +1,7 @@
 {
     if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
         return false;
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
     if (mService == null || mClientIf == 0)
         return false;
@@ -11,20 +11,26 @@
     BluetoothDevice device = service.getDevice();
     if (device == null)
         return false;
+    synchronized (mDeviceBusy) {
+        if (mDeviceBusy)
+            return false;
+        mDeviceBusy = true;
+    }
     try {
         mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
+        mDeviceBusy = false;
         return false;
     }
     return true;

Find a functionally equivalent code:android.graphics.Bitmap.reinit:COMMENT
Method Modifier: 
Comment:/**
 * Native bitmap has been reconfigured, so set premult and cached
 * width/height values
 */

@@ -1,5 +1,5 @@
 {
     mWidth = width;
     mHeight = height;
-    mIsPremultiplied = isPremultiplied;
+    mRequestPremultiplied = requestPremultiplied;
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.indexOfKey:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */


Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Fast path that avoids the use of chatty remoted Cursors.
 */

@@ -17,22 +17,26 @@
     if (Settings.CALL_METHOD_GET_SYSTEM.equals(method)) {
         if (LOCAL_LOGV)
             Slog.v(TAG, "call(system:" + request + ") for " + callingUser);
+        // Check if this request should be (re)directed to the primary user's db
+        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSystemCloneToManagedKeys, request)) {
+            callingUser = UserHandle.USER_OWNER;
+        }
         dbHelper = getOrEstablishDatabase(callingUser);
         cache = sSystemCaches.get(callingUser);
         return lookupValue(dbHelper, TABLE_SYSTEM, cache, request);
@@ -24,29 +28,41 @@
     if (Settings.CALL_METHOD_GET_SECURE.equals(method)) {
         if (LOCAL_LOGV)
             Slog.v(TAG, "call(secure:" + request + ") for " + callingUser);
+        // Check if this is a setting to be copied from the primary user
+        if (shouldShadowParentProfile(callingUser, sSecureCloneToManagedKeys, request)) {
+            // If the request if for location providers and there's a restriction, return none
+            if (Secure.LOCATION_PROVIDERS_ALLOWED.equals(request) && mUserManager.hasUserRestriction(UserManager.DISALLOW_SHARE_LOCATION, new UserHandle(callingUser))) {
+                return sSecureCaches.get(callingUser).putIfAbsent(request, "");
+            }
+            callingUser = UserHandle.USER_OWNER;
+        }
         dbHelper = getOrEstablishDatabase(callingUser);
         cache = sSecureCaches.get(callingUser);
         return lookupValue(dbHelper, TABLE_SECURE, cache, request);
@@ -49,64 +61,122 @@
     values.put(Settings.NameValueTable.NAME, request);
     values.put(Settings.NameValueTable.VALUE, newValue);
     if (Settings.CALL_METHOD_PUT_SYSTEM.equals(method)) {
-        if (LOCAL_LOGV)
+        if (LOCAL_LOGV) {
             Slog.v(TAG, "call_put(system:" + request + "=" + newValue + ") for " + callingUser);
+        }
+        // Extra check for USER_OWNER to optimize for the 99%
+        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSystemCloneToManagedKeys, request)) {
+            // Don't write these settings, as they are cloned from the parent profile
+            return null;
+        }
         insertForUser(Settings.System.CONTENT_URI, values, callingUser);
+        // Clone the settings to the managed profiles so that notifications can be sent out
+        if (callingUser == UserHandle.USER_OWNER && mManagedProfiles != null && sSystemCloneToManagedKeys.contains(request)) {
+            final long token = Binder.clearCallingIdentity();
+            try {
+                for (int i = mManagedProfiles.size() - 1; i >= 0; i--) {
+                    if (LOCAL_LOGV) {
+                        Slog.v(TAG, "putting to additional user " + mManagedProfiles.get(i).id);
+                    }
+                    insertForUser(Settings.System.CONTENT_URI, values, mManagedProfiles.get(i).id);
+                }
+            } finally {
+                Binder.restoreCallingIdentity(token);
+            }
+        }
     } else if (Settings.CALL_METHOD_PUT_SECURE.equals(method)) {
-        if (LOCAL_LOGV)
+        if (LOCAL_LOGV) {
             Slog.v(TAG, "call_put(secure:" + request + "=" + newValue + ") for " + callingUser);
+        }
+        // Extra check for USER_OWNER to optimize for the 99%
+        if (callingUser != UserHandle.USER_OWNER && shouldShadowParentProfile(callingUser, sSecureCloneToManagedKeys, request)) {
+            // Don't write these settings, as they are cloned from the parent profile
+            return null;
+        }
         insertForUser(Settings.Secure.CONTENT_URI, values, callingUser);
+        // Clone the settings to the managed profiles so that notifications can be sent out
+        if (callingUser == UserHandle.USER_OWNER && mManagedProfiles != null && sSecureCloneToManagedKeys.contains(request)) {
+            final long token = Binder.clearCallingIdentity();
+            try {
+                for (int i = mManagedProfiles.size() - 1; i >= 0; i--) {
+                    if (LOCAL_LOGV) {
+                        Slog.v(TAG, "putting to additional user " + mManagedProfiles.get(i).id);
+                    }
+                    try {
+                        insertForUser(Settings.Secure.CONTENT_URI, values, mManagedProfiles.get(i).id);
+                    } catch (SecurityException e) {
+                        // Temporary fix, see b/17450158
+                        Slog.w(TAG, "Cannot clone request '" + request + "' with value '" + newValue + "' to managed profile (id " + mManagedProfiles.get(i).id + ")", e);
+                    }
+                }
+            } finally {
+                Binder.restoreCallingIdentity(token);
+            }
+        }
     } else if (Settings.CALL_METHOD_PUT_GLOBAL.equals(method)) {
-        if (LOCAL_LOGV)
+        if (LOCAL_LOGV) {
             Slog.v(TAG, "call_put(global:" + request + "=" + newValue + ") for " + callingUser);
+        }
         insertForUser(Settings.Global.CONTENT_URI, values, callingUser);
     } else {
         Slog.w(TAG, "call() with invalid method: " + method);

Find a functionally equivalent code:android.text.DynamicLayout.updateBlocks:COMMENT
Method Modifier: hidden      
Comment:/**
 * This method is called every time the layout is reflowed after an edition.
 * It updates the internal block data structure. The text is split in blocks
 * of contiguous lines, with at least one block for the entire text.
 * When a range of lines is edited, new blocks (from 0 to 3 depending on the
 * overlap structure) will replace the set of overlapping blocks.
 * Blocks are listed in order and are represented by their ending line number.
 * An index is associated to each block (which will be used by display lists),
 * this class simply invalidates the index of blocks overlapping a modification.
 *
 * This method is package private and not private so that it can be tested.
 *
 * @param startLine the first line of the range of modified lines
 * @param endLine the last line of the range, possibly equal to startLine, lower
 * than getLineCount()
 * @param newLineCount the number of lines that will replace the range, possibly 0
 *
 * @hide
 */

@@ -38,46 +38,45 @@
         return;
     }
     if (newNumberOfBlocks > mBlockEndLines.length) {
-        final int newSize = ArrayUtils.idealIntArraySize(newNumberOfBlocks);
-        int[] blockEndLines = new int[newSize];
-        int[] blockIndices = new int[newSize];
+        int[] blockEndLines = ArrayUtils.newUnpaddedIntArray(Math.max(mBlockEndLines.length * 2, newNumberOfBlocks));
+        int[] blockIndices = new int[blockEndLines.length];
         System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, firstBlock);
         System.arraycopy(mBlockIndices, 0, blockIndices, 0, firstBlock);
         System.arraycopy(mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);

Find a functionally equivalent code:com.android.internal.view.menu.MenuBuilder.addMenuPresenter:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Add a presenter to this menu. This will only hold a WeakReference;
 * you do not need to explicitly remove a presenter, but you can using
 * {@link #removeMenuPresenter(MenuPresenter)}.
 *
 * @param presenter The presenter to add
 */

@@ -1,5 +1,3 @@
 {
-    mPresenters.add(new WeakReference<MenuPresenter>(presenter));
-    presenter.initForMenu(mContext, this);
-    mIsActionItemsStale = true;
+    addMenuPresenter(presenter, mContext);
 }

Find a functionally equivalent code:android.widget.CalendarView.setWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the week numbers.
 *
 * @param color The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

@@ -1,8 +1,3 @@
 {
-    if (mWeekNumberColor != color) {
-        mWeekNumberColor = color;
-        if (mShowWeekNumber) {
-            invalidateAllWeekViews();
-        }
-    }
+    mDelegate.setWeekNumberColor(color);
 }

Find a functionally equivalent code:android.content.res.Resources.selectSystemTheme:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -8,12 +8,15 @@
     if (targetSdkVersion < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
         return holo;
     }
+    if (targetSdkVersion < Build.VERSION_CODES.CUR_DEVELOPMENT) {
+        return dark;
+    }
     return deviceDefault;
 }

Find a functionally equivalent code:android.app.Notification.setLatestEventInfo:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the {@link #contentView} field to be a view with the standard "Latest Event"
 * layout.
 *
 * <p>Uses the {@link #icon} and {@link #when} fields to set the icon and time fields
 * in the view.</p>
 * @param context       The context for your application / activity.
 * @param contentTitle The title that goes in the expanded entry.
 * @param contentText  The text that goes in the expanded entry.
 * @param contentIntent The intent to launch when the user clicks the expanded notification.
 * If this is an activity, it must include the
 * {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag, which requires
 * that you take care of task management as described in the
 * <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
 * Stack</a> document.
 *
 * @deprecated Use {@link Builder} instead.
 */

@@ -7,12 +7,13 @@
     builder.setPriority(this.priority);
     builder.setTicker(this.tickerText);
     builder.setNumber(this.number);
+    builder.setColor(this.color);
     builder.mFlags = this.flags;
     builder.setSound(this.sound, this.audioStreamType);
     builder.setDefaults(this.defaults);

Find a functionally equivalent code:android.app.Activity.onPanelClosed:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPanelClosed(int, Menu)} for
 * activities. This calls through to {@link #onOptionsMenuClosed(Menu)}
 * method for the {@link android.view.Window#FEATURE_OPTIONS_PANEL} panel,
 * so that subclasses of Activity don't need to deal with feature codes.
 * For context menus ({@link Window#FEATURE_CONTEXT_MENU}), the
 * {@link #onContextMenuClosed(Menu)} will be called.
 */

@@ -8,14 +8,14 @@
             onContextMenuClosed(menu);
             break;
         case Window.FEATURE_ACTION_BAR:
-            initActionBar();
+            initWindowDecorActionBar();
             mActionBar.dispatchMenuVisibilityChanged(false);
             break;
     }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarCompile:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:android.graphics.Camera.applyToCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Computes the matrix corresponding to the current transformation
 * and applies it to the specified Canvas.
 *
 * @param canvas The Canvas to set the transform matrix onto
 */

@@ -5,10 +5,10 @@
         getMatrix(mMatrix);
         canvas.concat(mMatrix);
     } else {
-        nativeApplyToCanvas(canvas.mNativeCanvas);
+        nativeApplyToCanvas(canvas.getNativeCanvasWrapper());
     }
 }

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setGradientType:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the type of gradient used by this drawable..</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradient The type of the gradient: {@link #LINEAR_GRADIENT},
 * {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}
 *
 * @see #mutate()
 */

@@ -1,5 +1,5 @@
 {
     mGradientState.setGradientType(gradient);
-    mRectIsDirty = true;
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.widget.ImageView.setImageResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class="note">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */

@@ -1,10 +1,10 @@
 {
     if (mUri != null || mResource != resId) {
+        final int oldWidth = mDrawableWidth;
+        final int oldHeight = mDrawableHeight;
         updateDrawable(null);
         mResource = resId;
         mUri = null;
-        final int oldWidth = mDrawableWidth;
-        final int oldHeight = mDrawableHeight;
         resolveUri();
         if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
             requestLayout();

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmGenerator.transform:COMMENT
Method Modifier: 
Comment:/**
 * Transforms a class.
 * <p/>
 * There are 3 kind of transformations:
 *
 * 1- For "mock" dependencies classes, we want to remove all code from methods and replace
 * by a stub. Native methods must be implemented with this stub too. Abstract methods are
 * left intact. Modified classes must be overridable (non-private, non-final).
 * Native methods must be made non-final, non-private.
 *
 * 2- For "keep" classes, we want to rewrite all native methods as indicated above.
 * If a class has native methods, it must also be made non-private, non-final.
 *
 * Note that unfortunately static methods cannot be changed to non-static (since static and
 * non-static are invoked differently.)
 */

@@ -4,23 +4,27 @@
     String className = cr.getClassName();
     String newName = transformName(className);
     // transformName returns its input argument if there's no need to rename the class
-    if (newName != className) {
+    if (!newName.equals(className)) {
         mRenameCount++;
         // This class is being renamed, so remove it from the list of classes not renamed.
         mClassesNotRenamed.remove(className);
     }
-    mLog.debug("Transform %s%s%s%s", className, newName == className ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
+    mLog.debug("Transform %s%s%s%s", className, newName.equals(className) ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
     // Rewrite the new class from scratch, without reusing the constant pool from the
     // original class reader.
     ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
-    ClassVisitor cv = new RefactorClassAdapter(cw, mRefactorClasses);
-    if (newName != className) {
+    ClassVisitor cv = cw;
+    if (mReplaceMethodCallsClasses.contains(className)) {
+        cv = new ReplaceMethodCallsAdapter(cv);
+    }
+    cv = new RefactorClassAdapter(cv, mRefactorClasses);
+    if (!newName.equals(className)) {
         cv = new RenameClassAdapter(cv, className, newName);
     }
-    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly, stubNativesOnly || hasNativeMethods);
+    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly);
     Set<String> delegateMethods = mDelegateMethods.get(className);
     if (delegateMethods != null && !delegateMethods.isEmpty()) {
         // known to have no native methods, just skip this step.

Find a functionally equivalent code:android.content.res.AssetManager.makeStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

@@ -1,12 +1,12 @@
 {
-    final int sysNum = copyFromSystem ? sSystem.mStringBlocks.length : 0;
+    final int seedNum = (seed != null) ? seed.length : 0;
     final int num = getStringBlockCount();
     mStringBlocks = new StringBlock[num];
     if (localLOGV)
         Log.v(TAG, "Making string blocks for " + this + ": " + num);
     for (int i = 0; i < num; i++) {
-        if (i < sysNum) {
-            mStringBlocks[i] = sSystem.mStringBlocks[i];
+        if (i < seedNum) {
+            mStringBlocks[i] = seed[i];
         } else {
             mStringBlocks[i] = new StringBlock(getNativeStringBlock(i), true);
         }

Find a functionally equivalent code:android.media.MediaPlayer.TimeProvider.onNewPlayer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,6 +1,8 @@
 {
     if (mRefresh) {
         synchronized (this) {
+            mStopped = false;
+            mSeeking = true;
             scheduleNotification(NOTIFY_SEEK, 0);
         }
     }

Find a functionally equivalent code:com.android.tools.layoutlib.create.TransformClassAdapter.visitInnerClass:COMMENT
Method Modifier: public      
Comment:/* Visits the header of an inner class. */

@@ -1,9 +1,4 @@
 {
-    // remove protected or private and set as public
-    if (Main.sOptions.generatePublicAccess) {
-        access = access & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED);
-        access |= Opcodes.ACC_PUBLIC;
-    }
     // remove final
     access = access & ~Opcodes.ACC_FINAL;
     // note: leave abstract classes as such

Find a functionally equivalent code:android.util.ArrayMap.get:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a value from the array.
 * @param key The key of the value to retrieve.
 * @return Returns the value associated with the given key,
 * or null if there is no such key.
 */

@@ -1,4 +1,4 @@
 {
-    final int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
+    final int index = indexOfKey(key);
     return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
 }

Find a functionally equivalent code:android.net.Proxy.validate:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Validate syntax of hostname, port and exclusion list entries
 * {@hide}
 */

@@ -1,27 +1,23 @@
 {
     Matcher match = HOSTNAME_PATTERN.matcher(hostname);
     Matcher listMatch = EXCLLIST_PATTERN.matcher(exclList);
-    if (!match.matches()) {
-        throw new IllegalArgumentException();
-    }
-    if (!listMatch.matches()) {
-        throw new IllegalArgumentException();
-    }
-    if (hostname.length() > 0 && port.length() == 0) {
-        throw new IllegalArgumentException();
-    }
+    if (!match.matches())
+        return PROXY_HOSTNAME_INVALID;
+    if (!listMatch.matches())
+        return PROXY_EXCLLIST_INVALID;
+    if (hostname.length() > 0 && port.length() == 0)
+        return PROXY_PORT_EMPTY;
     if (port.length() > 0) {
-        if (hostname.length() == 0) {
-            throw new IllegalArgumentException();
-        }
+        if (hostname.length() == 0)
+            return PROXY_HOSTNAME_EMPTY;
         int portVal = -1;
         try {
             portVal = Integer.parseInt(port);
         } catch (NumberFormatException ex) {
-            throw new IllegalArgumentException();
-        }
-        if (portVal <= 0 || portVal > 0xFFFF) {
-            throw new IllegalArgumentException();
+            return PROXY_PORT_INVALID;
         }
+        if (portVal <= 0 || portVal > 0xFFFF)
+            return PROXY_PORT_INVALID;
     }
+    return PROXY_VALID;
 }

Find a functionally equivalent code:com.android.internal.widget.WaveView.vibrate:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Triggers haptic feedback.
 */

@@ -4,9 +4,9 @@
         if (mVibrator == null) {
             mVibrator = (android.os.Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
         }
-        mVibrator.vibrate(duration);
+        mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
     }
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyUp:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * A key was released and not handled by anything else in the window.
 *
 * @see #onKeyDown
 * @see android.view.KeyEvent
 */

@@ -6,11 +6,20 @@
     switch(keyCode) {
         case KeyEvent.KEYCODE_VOLUME_UP:
         case KeyEvent.KEYCODE_VOLUME_DOWN:
+            {
+                // use the suggested stream.
+                if (mMediaController != null) {
+                    mMediaController.adjustVolume(0, AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_VIBRATE);
+                } else {
+                    MediaSessionLegacyHelper.getHelper(getContext()).sendAdjustVolumeBy(mVolumeControlStreamType, 0, AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_VIBRATE);
+                }
+                return true;
+            }
         case KeyEvent.KEYCODE_VOLUME_MUTE:
             {
                 // Similar code is in PhoneFallbackEventHandler in case the window
@@ -15,20 +24,49 @@
                 getAudioManager().handleKeyUp(event, mVolumeControlStreamType);
                 return true;
             }
+        // KeyEvent.isMediaKey()
+        case KeyEvent.KEYCODE_MEDIA_PLAY:
+        case KeyEvent.KEYCODE_MEDIA_PAUSE:
+        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+        case KeyEvent.KEYCODE_MUTE:
+        case KeyEvent.KEYCODE_HEADSETHOOK:
+        case KeyEvent.KEYCODE_MEDIA_STOP:
+        case KeyEvent.KEYCODE_MEDIA_NEXT:
+        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+        case KeyEvent.KEYCODE_MEDIA_REWIND:
+        case KeyEvent.KEYCODE_MEDIA_RECORD:
+        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+            {
+                if (mMediaController != null) {
+                    if (mMediaController.dispatchMediaButtonEvent(event)) {
+                        return true;
+                    }
+                }
+                return false;
+            }
         case KeyEvent.KEYCODE_MENU:
             {
                 onKeyUpPanel(featureId < 0 ? FEATURE_OPTIONS_PANEL : featureId, event);

Find a functionally equivalent code:com.android.systemui.usb.StorageNotification.setMediaStorageNotification:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the media storage notification.
 */

@@ -34,40 +34,43 @@
             pi = PendingIntent.getBroadcastAsUser(mContext, 0, intent, 0, UserHandle.CURRENT);
         }
         mMediaStorageNotification.icon = icon;
+        mMediaStorageNotification.color = mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
         mMediaStorageNotification.setLatestEventInfo(mContext, title, message, pi);
+        mMediaStorageNotification.visibility = Notification.VISIBILITY_PUBLIC;
+        mMediaStorageNotification.category = Notification.CATEGORY_SYSTEM;
     }
     final int notificationId = mMediaStorageNotification.icon;
     if (visible) {

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.moveChild:COMMENT
Method Modifier: public      
Comment:/**
 * Moves a view to a new parent at a given location
 * <p>
 * {@link #acquire(long)} must have been called before this.
 *
 * @throws IllegalStateException if the current context is different than the one owned by
 * the scene, or if {@link #acquire(long)} was not called.
 *
 * @see RenderSession#moveChild(Object, Object, int, Map, IAnimationListener)
 */

@@ -17,28 +17,28 @@
                 @Override
                 public void run() {
                     Result result = moveView(previousParent, newParentView, childView, index, params);
-                    if (result.isSuccess() == false) {
+                    if (!result.isSuccess()) {
                         listener.done(result);
                     }
                     // ready to do the work, acquire the scene.
                     result = acquire(250);
-                    if (result.isSuccess() == false) {
+                    if (!result.isSuccess()) {
                         listener.done(result);
                         return;
                     }
@@ -71,77 +71,77 @@
         return SUCCESS.createResult(layoutParams);
     }
     Result result = moveView(previousParent, newParentView, childView, index, layoutParams);
-    if (result.isSuccess() == false) {
+    if (!result.isSuccess()) {
         return result;
     }
     result = render(false);

Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.sendKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */

@@ -10,14 +10,15 @@
             viewRootImpl.dispatchKeyFromIme(event);
         }
     }
+    mIMM.notifyUserAction();
     return false;
 }

Find a functionally equivalent code:android.os.Process.openZygoteSocketIfNeeded:COMMENT
Method Modifier: private     static      
Comment:/**
 * Tries to open socket to Zygote process if not already open. If
 * already open, does nothing.  May block and retry.
 */

@@ -1,49 +1,24 @@
 {
-    int retryCount;
-    if (sPreviousZygoteOpenFailed) {
-        /*
-             * If we've failed before, expect that we'll fail again and
-             * don't pause for retries.
-             */
-        retryCount = 0;
-    } else {
-        retryCount = 10;
-    }
-    /*
-         * See bug #811181: Sometimes runtime can make it up before zygote.
-         * Really, we'd like to do something better to avoid this condition,
-         * but for now just wait a bit...
-         */
-    for (int retry = 0; (sZygoteSocket == null) && (retry < (retryCount + 1)); retry++) {
-        if (retry > 0) {
-            try {
-                Log.i("Zygote", "Zygote not up yet, sleeping...");
-                Thread.sleep(ZYGOTE_RETRY_MILLIS);
-            } catch (InterruptedException ex) {
-            // should never happen
-            }
+    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
+        try {
+            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
+        } catch (IOException ioe) {
+            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
         }
+    }
+    if (primaryZygoteState.matches(abi)) {
+        return primaryZygoteState;
+    }
+    // The primary zygote didn't match. Try the secondary.
+    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
         try {
-            sZygoteSocket = new LocalSocket();
-            sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET, LocalSocketAddress.Namespace.RESERVED));
-            sZygoteInputStream = new DataInputStream(sZygoteSocket.getInputStream());
-            sZygoteWriter = new BufferedWriter(new OutputStreamWriter(sZygoteSocket.getOutputStream()), 256);
-            Log.i("Zygote", "Process: zygote socket opened");
-            sPreviousZygoteOpenFailed = false;
-            break;
-        } catch (IOException ex) {
-            if (sZygoteSocket != null) {
-                try {
-                    sZygoteSocket.close();
-                } catch (IOException ex2) {
-                    Log.e(LOG_TAG, "I/O exception on close after exception", ex2);
-                }
-            }
-            sZygoteSocket = null;
+            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
+        } catch (IOException ioe) {
+            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
         }
     }
-    if (sZygoteSocket == null) {
-        sPreviousZygoteOpenFailed = true;
-        throw new ZygoteStartFailedEx("connect failed");
+    if (secondaryZygoteState.matches(abi)) {
+        return secondaryZygoteState;
     }
+    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
 }

Find a functionally equivalent code:android.app.ActivityManager.getLauncherLargeIconSize:COMMENT
Method Modifier: public      
Comment:/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */

@@ -1,27 +1,3 @@
 {
-    final Resources res = mContext.getResources();
-    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
-    final int sw = res.getConfiguration().smallestScreenWidthDp;
-    if (sw < 600) {
-        // Smaller than approx 7" tablets, use the regular icon size.
-        return size;
-    }
-    final int density = res.getDisplayMetrics().densityDpi;
-    switch(density) {
-        case DisplayMetrics.DENSITY_LOW:
-            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
-        case DisplayMetrics.DENSITY_MEDIUM:
-            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
-        case DisplayMetrics.DENSITY_TV:
-            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
-        case DisplayMetrics.DENSITY_HIGH:
-            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
-        case DisplayMetrics.DENSITY_XHIGH:
-            return (size * DisplayMetrics.DENSITY_XXHIGH) / DisplayMetrics.DENSITY_XHIGH;
-        case DisplayMetrics.DENSITY_XXHIGH:
-            return (size * DisplayMetrics.DENSITY_XHIGH * 2) / DisplayMetrics.DENSITY_XXHIGH;
-        default:
-            // abnormal value that is a reasonable scaling of it.
-            return (int) ((size * 1.5f) + .5f);
-    }
+    return getLauncherLargeIconSizeInner(mContext);
 }

Find a functionally equivalent code:android.text.Layout.isRtlCharAt:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the character at offset is right to left (RTL).
 * @param offset the offset
 * @return true if the character is RTL, false if it is LTR
 */

@@ -10,18 +10,18 @@
     int[] runs = dirs.mDirections;
     int lineStart = getLineStart(line);
     for (int i = 0; i < runs.length; i += 2) {
-        int start = lineStart + (runs[i] & RUN_LENGTH_MASK);
-        // corresponding of the last run
-        if (offset >= start) {
+        int start = lineStart + runs[i];
+        int limit = start + (runs[i + 1] & RUN_LENGTH_MASK);
+        if (offset >= start && offset < limit) {
             int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
             return ((level & 1) != 0);
         }

Find a functionally equivalent code:android.app.admin.DevicePolicyManager.setGlobalProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by an application that is administering the device to set the
 * global proxy and exclusion list.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call
 * this method; if it has not, a security exception will be thrown.
 * Only the first device admin can set the proxy. If a second admin attempts
 * to set the proxy, the {@link ComponentName} of the admin originally setting the
 * proxy will be returned. If successful in setting the proxy, null will
 * be returned.
 * The method can be called repeatedly by the device admin alrady setting the
 * proxy to update the proxy and exclusion list.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param proxySpec the global proxy desired. Must be an HTTP Proxy.
 * Pass Proxy.NO_PROXY to reset the proxy.
 * @param exclusionList a list of domains to be excluded from the global proxy.
 * @return returns null if the proxy was successfully set, or a {@link ComponentName}
 * of the device admin that sets thew proxy otherwise.
 * @hide
 */

@@ -33,39 +33,40 @@
                     }
                     exclSpec = listBuilder.toString();
                 }
-                android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec);
+                if (android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec) != android.net.Proxy.PROXY_VALID)
+                    throw new IllegalArgumentException();
             }
             return mService.setGlobalProxy(admin, hostSpec, exclSpec, UserHandle.myUserId());
         } catch (RemoteException e) {

Find a functionally equivalent code:android.graphics.Matrix.preRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified rotation.
 * M' = M * R(degrees)
 */

@@ -1,3 +1,4 @@
 {
-    return native_preRotate(native_instance, degrees);
+    native_preRotate(native_instance, degrees);
+    return true;
 }

Find a functionally equivalent code:com.android.systemui.ExpandHelper.vibrate:COMMENT
Method Modifier: private     
Comment:/**
 * Triggers haptic feedback.
 */

@@ -2,6 +2,6 @@
     if (mVibrator == null) {
         mVibrator = (android.os.Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
     }
-    mVibrator.vibrate(duration);
+    mVibrator.vibrate(duration, VIBRATION_ATTRIBUTES);
 }

Find a functionally equivalent code:android.graphics.Bitmap.setPixel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Write the specified {@link Color} into the bitmap (assuming it is
 * mutable) at the x,y coordinate. The color must be a
 * non-premultiplied ARGB value.</p>
 *
 * @param x     The x coordinate of the pixel to replace (0...width-1)
 * @param y     The y coordinate of the pixel to replace (0...height-1)
 * @param color The ARGB color to write into the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y are outside of the bitmap's
 * bounds.
 */

@@ -4,8 +4,8 @@
         throw new IllegalStateException();
     }
     checkPixelAccess(x, y);
-    nativeSetPixel(mNativeBitmap, x, y, color, mIsPremultiplied);
+    nativeSetPixel(mNativeBitmap, x, y, color);
 }

Find a functionally equivalent code:android.os.Bundle.getCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a char[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (char[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "char[]", e);
-        return null;
-    }
+    return super.getCharArray(key);
 }

Find a functionally equivalent code:android.widget.TextView.getExtendedPaddingTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended top padding of the view, including both the
 * top Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

@@ -2,7 +2,10 @@
     if (mMaxMode != LINES) {
         return getCompoundPaddingTop();
     }
+    if (mLayout == null) {
+        assumeLayout();
+    }
     if (mLayout.getLineCount() <= mMaximum) {
         return getCompoundPaddingTop();
     }

Find a functionally equivalent code:android.view.ViewGroup.clearDisappearingChildren:COMMENT
Method Modifier: public      
Comment:/**
 * Removes any pending animations for views that have been removed. Call
 * this if you don't want animations for exiting views to stack up.
 */

@@ -1,6 +1,15 @@
 {
-    if (mDisappearingChildren != null) {
-        mDisappearingChildren.clear();
+    final ArrayList<View> disappearingChildren = mDisappearingChildren;
+    if (disappearingChildren != null) {
+        final int count = disappearingChildren.size();
+        for (int i = 0; i < count; i++) {
+            final View view = disappearingChildren.get(i);
+            if (view.mAttachInfo != null) {
+                view.dispatchDetachedFromWindow();
+            }
+            view.clearAnimation();
+        }
+        disappearingChildren.clear();
         invalidate();
     }
 }

Find a functionally equivalent code:android.media.MediaRouter.RouteInfo.isConnecting:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the route is in the process of connecting and is not
 * yet ready for use.
 *
 * @return True if this route is in the process of connecting.
 */

@@ -1,3 +1,3 @@
 {
-    return mStatusCode == STATUS_CONNECTING;
+    return mResolvedStatusCode == STATUS_CONNECTING;
 }

Find a functionally equivalent code:android.widget.FastScroller.cancelPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels a pending drag.
 *
 * @see #startPendingDrag()
 */

@@ -1,4 +1,3 @@
 {
-    mList.removeCallbacks(mDeferStartDrag);
-    mHasPendingDrag = false;
+    mPendingDrag = -1;
 }

Find a functionally equivalent code:android.net.MobileDataStateTracker.setEnableApn:COMMENT
Method Modifier: private     
Comment:/**
 * Internal method supporting the ENABLE_MMS feature.
 * @param apnType the type of APN to be enabled or disabled (e.g., mms)
 * @param enable {@code true} to enable the specified APN type,
 * {@code false} to disable it.
 * @return an integer value representing the outcome of the request.
 */

@@ -9,24 +9,23 @@
             loge("Ignoring feature request because could not acquire PhoneService");
             break;
         }
-        try {
-            if (enable) {
-                return mPhoneService.enableApnType(apnType);
-            } else {
-                return mPhoneService.disableApnType(apnType);
-            }
-        } catch (RemoteException e) {
-            if (retry == 0)
-                getPhoneService(true);
-        }
+    // try {
+    // if (enable) {
+    // return mPhoneService.enableApnType(apnType);
+    // } else {
+    // return mPhoneService.disableApnType(apnType);
+    // }
+    // } catch (RemoteException e) {
+    // if (retry == 0) getPhoneService(true);
+    // }
     }
     loge("Could not " + (enable ? "enable" : "disable") + " APN type \"" + apnType + "\"");
     return PhoneConstants.APN_REQUEST_FAILED;

Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.addAccessibilityStateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */

@@ -1,3 +1,4 @@
 {
+    // Final CopyOnArrayList - no lock needed.
     return mAccessibilityStateChangeListeners.add(listener);
 }

Find a functionally equivalent code:android.widget.AbsListView.invokeOnItemScrollListener:COMMENT
Method Modifier: 
Comment:/**
 * Notify our scroll listener (if there is one) of a change in scroll state
 */

@@ -1,6 +1,6 @@
 {
-    if (mFastScroller != null) {
-        mFastScroller.onScroll(mFirstPosition, getChildCount(), mItemCount);
+    if (mFastScroll != null) {
+        mFastScroll.onScroll(mFirstPosition, getChildCount(), mItemCount);
     }
     if (mOnScrollListener != null) {
         mOnScrollListener.onScroll(this, mFirstPosition, getChildCount(), mItemCount);

Find a functionally equivalent code:android.widget.Toast.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the view for the specified duration.
 */

@@ -3,9 +3,9 @@
         throw new RuntimeException("setView must have been called");
     }
     INotificationManager service = getService();
-    String pkg = mContext.getPackageName();
+    String pkg = mContext.getOpPackageName();
     TN tn = mTN;
     tn.mNextView = mNextView;
     try {

Find a functionally equivalent code:android.util.SparseIntArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -3,20 +3,9 @@
         put(key, value);
         return;
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        int n = ArrayUtils.idealIntArraySize(pos + 1);
-        int[] nkeys = new int[n];
-        int[] nvalues = new int[n];
-        // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
-        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-        mKeys = nkeys;
-        mValues = nvalues;
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerBaseTest.setUp:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,5 +1,6 @@
 {
+    super.setUp();
     mContext = getInstrumentation().getContext();
     mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);
-    mReceiver = registerNewMultipleDownloadsReceiver();
+    mListener = registerDownloadsListener();
 }

Find a functionally equivalent code:android.media.AudioRecord.startRecording:COMMENT
Method Modifier: public      
Comment:/**
 * Starts recording from the AudioRecord instance when the specified synchronization event
 * occurs on the specified audio session.
 * @throws IllegalStateException
 * @param syncEvent event that triggers the capture.
 * @see MediaSyncEvent
 */

@@ -5,10 +5,11 @@
     // start recording
     synchronized (mRecordingStateLock) {
         if (native_start(syncEvent.getType(), syncEvent.getAudioSessionId()) == SUCCESS) {
+            handleFullVolumeRec(true);
             mRecordingState = RECORDSTATE_RECORDING;
         }
     }

Find a functionally equivalent code:android.widget.FastScroller.transitionToDragging:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb, preview, and track.
 */

@@ -7,10 +7,11 @@
     mDecorAnimation = new AnimatorSet();
     mDecorAnimation.playTogether(fadeIn, slideIn);
     mDecorAnimation.start();
+    mShowingPreview = true;
 }

Find a functionally equivalent code:android.graphics.Canvas.skew:COMMENT
<android.graphics.Canvas: void skew(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified skew.
 *
 * @param sx The amount to skew in X
 * @param sy The amount to skew in Y
 */

@@ -1 +1,3 @@
-
+{
+    native_skew(mNativeCanvasWrapper, sx, sy);
+}

Find a functionally equivalent code:android.appwidget.AppWidgetManager.getAppWidgetIds:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */

@@ -1,6 +1,9 @@
 {
+    if (mService == null) {
+        return new int[0];
+    }
     try {
-        return sService.getAppWidgetIds(provider, mContext.getUserId());
+        return mService.getAppWidgetIds(provider);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:android.content.res.AssetManager.applyThemeStyle:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.eventTypeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */

@@ -206,211 +206,220 @@
                     eventTypeCount++;
                 }
                 break;
+            case TYPE_WINDOWS_CHANGED:
+                {
+                    if (eventTypeCount > 0) {
+                        builder.append(", ");
+                    }
+                    builder.append("TYPE_WINDOWS_CHANGED");
+                    eventTypeCount++;
+                }
+                break;
         }
     }
     if (eventTypeCount > 1) {

Find a functionally equivalent code:android.text.MeasuredText.setPara:COMMENT
Method Modifier: 
Comment:/**
 * Analyzes text for bidirectional runs.  Allocates working buffers.
 */

@@ -5,14 +5,14 @@
     mLen = len;
     mPos = 0;
     if (mWidths == null || mWidths.length < len) {
-        mWidths = new float[ArrayUtils.idealFloatArraySize(len)];
+        mWidths = ArrayUtils.newUnpaddedFloatArray(len);
     }
     if (mChars == null || mChars.length < len) {
-        mChars = new char[ArrayUtils.idealCharArraySize(len)];
+        mChars = ArrayUtils.newUnpaddedCharArray(len);
     }
     TextUtils.getChars(text, start, end, mChars, 0);
     if (text instanceof Spanned) {
@@ -33,39 +33,39 @@
         mEasy = true;
     } else {
         if (mLevels == null || mLevels.length < len) {
-            mLevels = new byte[ArrayUtils.idealByteArraySize(len)];
+            mLevels = ArrayUtils.newUnpaddedByteArray(len);
         }
         int bidiRequest;
         if (textDir == TextDirectionHeuristics.LTR) {

Find a functionally equivalent code:android.telephony.PhoneNumberUtils.isPotentialLocalEmergencyNumber:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given number might *potentially* result in a call to an
 * emergency service, for the country that the user is in. The current
 * country is determined using the CountryDetector.
 *
 * Specifically, this method will return true if the specified number
 * is an emergency number in the current country, *or* if the number
 * simply starts with the same digits as any emergency number for the
 * current country.
 *
 * This method is intended for internal use by the phone app when
 * deciding whether to allow ACTION_CALL intents from 3rd party apps
 * (where we're required to *not* allow emergency calls to be placed.)
 *
 * @param number the number to look up.
 * @param context the specific context which the number should be checked against
 * @return true if the specified number is an emergency number for a local country, based on the
 * CountryDetector.
 *
 * @see android.location.CountryDetector
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return isLocalEmergencyNumberInternal(number, context, false);
+    return isPotentialLocalEmergencyNumber(context, getDefaultVoiceSubId(), number);
 }

Find a functionally equivalent code:android.graphics.BitmapFactory.decodeStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Decode an input stream into a bitmap. If the input stream is null, or
 * cannot be used to decode a bitmap, the function returns null.
 * The stream's position will be where ever it was after the encoded data
 * was read.
 *
 * @param is The input stream that holds the raw data to be decoded into a
 * bitmap.
 * @return The decoded bitmap, or null if the image data could not be decoded.
 */


Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.getScrapView:COMMENT
Method Modifier: 
Comment:/**
 * @return A view from the ScrapViews collection. These are unordered.
 */

@@ -2,8 +2,8 @@
     if (mViewTypeCount == 1) {
         return retrieveFromScrap(mCurrentScrap, position);
     } else {
-        int whichScrap = mAdapter.getItemViewType(position);
+        final int whichScrap = mAdapter.getItemViewType(position);
         if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
             return retrieveFromScrap(mScrapViews[whichScrap], position);
         }

Find a functionally equivalent code:android.content.res.AssetManager.getThemeValue:COMMENT
Method Modifier: default     final       
Comment:/*package*/


Find a functionally equivalent code:android.text.StaticLayout.generate:COMMENT
Method Modifier: 
Comment:/* package */

@@ -1,4 +1,6 @@
 {
+    int[] breakOpp = null;
+    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
     mLineCount = 0;
     int v = 0;
     boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
@@ -8,15 +10,15 @@
     Spanned spanned = null;
     if (source instanceof Spanned)
         spanned = (Spanned) source;
-    // XXX
-    int DEFAULT_DIR = DIR_LEFT_TO_RIGHT;
     int paraEnd;
     for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
         paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
@@ -27,43 +27,43 @@
                 LeadingMarginSpan lms = sp[i];
                 firstWidth -= sp[i].getLeadingMargin(true);
                 restWidth -= sp[i].getLeadingMargin(false);
-                // paragraph.
+                // leading margin spans, not just this particular one
                 if (lms instanceof LeadingMarginSpan2) {
                     LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                     int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
-                    firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
+                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                 }
             }
             chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
             if (chooseHt.length != 0) {
                 if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
-                    chooseHtv = new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
+                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                 }
                 for (int i = 0; i < chooseHt.length; i++) {
                     int o = spanned.getSpanStart(chooseHt[i]);
@@ -58,63 +58,65 @@
         byte[] chdirs = measured.mLevels;
         int dir = measured.mDir;
         boolean easy = measured.mEasy;
+        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
+        int breakOppIndex = 0;
         int width = firstWidth;
         float w = 0;
         // here is the offset of the starting character of the line we are currently measuring
@@ -72,77 +74,81 @@
         int fit = paraStart;
         float fitWidth = w;
         int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
+        // same as fitWidth but not including any trailing whitespace
+        float fitWidthGraphing = w;
         boolean hasTabOrEmoji = false;
         boolean hasTab = false;
         TabStops tabStops = null;
@@ -139,144 +143,151 @@
                 boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                 if (w <= width || isSpaceOrTab) {
                     fitWidth = w;
+                    if (!isSpaceOrTab) {
+                        fitWidthGraphing = w;
+                    }
                     fit = j + 1;
                     if (fmTop < fitTop)
                         fitTop = fmTop;
@@ -148,159 +155,166 @@
                         fitDescent = fmDescent;
                     if (fmBottom > fitBottom)
                         fitBottom = fmBottom;
-                    // From the Unicode Line Breaking Algorithm (at least approximately)
-                    boolean isLineBreak = isSpaceOrTab || // / is class SY and - is class HY, except when followed by a digit
-                    ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || // (non-starters), which can be broken after but not before
-                    (c >= CHAR_FIRST_CJK && isIdeographic(c, true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart], false));
+                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
+                        breakOppIndex++;
+                    }
+                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                     if (isLineBreak) {
-                        okWidth = w;
+                        okWidth = fitWidthGraphing;
                         ok = j + 1;
                         if (fitTop < okTop)
                             okTop = fitTop;
@@ -165,171 +172,178 @@
                             okBottom = fitBottom;
                     }
                 } else {
-                    final boolean moreChars = (j + 1 < spanEnd);
+                    final boolean moreChars;
                     int endPos;
                     int above, below, top, bottom;
                     float currentTextWidth;
@@ -176,181 +183,189 @@
                         top = okTop;
                         bottom = okBottom;
                         currentTextWidth = okWidth;
+                        moreChars = (j + 1 < spanEnd);
                     } else if (fit != here) {
                         endPos = fit;
                         above = fitAscent;
@@ -183,195 +191,210 @@
                         top = fitTop;
                         bottom = fitBottom;
                         currentTextWidth = fitWidth;
+                        moreChars = (j + 1 < spanEnd);
                     } else {
+                        // must make progress, so take next character
                         endPos = here + 1;
-                        above = fm.ascent;
-                        below = fm.descent;
-                        top = fm.top;
-                        bottom = fm.bottom;
+                        // take all zero width characters following that
+                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
+                            endPos++;
+                        }
+                        above = fmAscent;
+                        below = fmDescent;
+                        top = fmTop;
+                        bottom = fmBottom;
                         currentTextWidth = widths[here - paraStart];
+                        moreChars = (endPos < spanEnd);
                     }
                     v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                     here = endPos;
@@ -197,202 +212,218 @@
                     j = here - 1;
                     ok = fit = here;
                     w = 0;
+                    fitWidthGraphing = w;
                     fitAscent = fitDescent = fitTop = fitBottom = 0;
                     okAscent = okDescent = okTop = okBottom = 0;
                     if (--firstWidthLineLimit <= 0) {
@@ -210,216 +226,232 @@
                         break;
                     }
                     if (mLineCount >= mMaximumVisibleLineCount) {
-                        break;
+                        return;
                     }
                 }
             }

Find a functionally equivalent code:android.widget.DatePicker.getMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected month.
 */

@@ -1,3 +1,3 @@
 {
-    return mCurrentDate.get(Calendar.MONTH);
+    return mDelegate.getMonth();
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.AbstractClassAdapter.renameTypeAsType:COMMENT
Method Modifier: 
Comment:/**
 * Renames an object type, e.g. "Lcom.package.MyClass;" or an array type that has an
 * object element, e.g. "[Lcom.package.MyClass;".
 * This is like renameType() except that it returns a Type object.
 * If the type doesn't need to be renamed, returns the input type object.
 */

@@ -5,11 +5,11 @@
     if (type.getSort() == Type.OBJECT) {
         String in = type.getInternalName();
         String newIn = renameInternalType(in);
-        if (newIn != in) {
+        if (!newIn.equals(in)) {
             return Type.getType("L" + newIn + ";");
         }
     } else if (type.getSort() == Type.ARRAY) {

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.initFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityEvent}.
 */

@@ -10,19 +10,22 @@
     readAccessibilityRecordFromParcel(this, parcel);
     // Read the records.
     final int recordCount = parcel.readInt();
-    for (int i = 0; i < recordCount; i++) {
-        AccessibilityRecord record = AccessibilityRecord.obtain();
-        readAccessibilityRecordFromParcel(record, parcel);
-        record.mConnectionId = mConnectionId;
-        mRecords.add(record);
+    if (recordCount > 0) {
+        mRecords = new ArrayList<AccessibilityRecord>(recordCount);
+        for (int i = 0; i < recordCount; i++) {
+            AccessibilityRecord record = AccessibilityRecord.obtain();
+            readAccessibilityRecordFromParcel(record, parcel);
+            record.mConnectionId = mConnectionId;
+            mRecords.add(record);
+        }
     }
 }

Find a functionally equivalent code:android.text.format.Time.normalize:COMMENT
<android.text.format.Time: long normalize(boolean)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Ensures the values in each field are in range. For example if the
 * current value of this calendar is March 32, normalize() will convert it
 * to April 1. It also fills in weekDay, yearDay, isDst and gmtoff.
 *
 * <p>
 * If "ignoreDst" is true, then this method sets the "isDst" field to -1
 * (the "unknown" value) before normalizing.  It then computes the
 * correct value for "isDst".
 *
 * <p>
 * See {@link #toMillis(boolean)} for more information about when to
 * use <tt>true</tt> or <tt>false</tt> for "ignoreDst".
 *
 * @return the UTC milliseconds since the epoch
 */

@@ -1 +1,6 @@
-
+{
+    calculator.copyFieldsFromTime(this);
+    long timeInMillis = calculator.toMillis(ignoreDst);
+    calculator.copyFieldsToTime(this);
+    return timeInMillis;
+}

Find a functionally equivalent code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

@@ -18,22 +18,29 @@
         onDisabled(context, intent);
     } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
         onPasswordExpiring(context, intent);
+    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
+        onProfileProvisioningComplete(context, intent);
+    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
+        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
+        onLockTaskModeEntering(context, intent, pkg);
+    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
+        onLockTaskModeExiting(context, intent);
     }
 }

Find a functionally equivalent code:android.view.animation.AnimationUtils.loadInterpolator:COMMENT
Method Modifier: public      static      
Comment:/**
 * Loads an {@link Interpolator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animation object reference by the specified id
 * @throws NotFoundException
 */

@@ -2,8 +2,8 @@
     XmlResourceParser parser = null;
     try {
         parser = context.getResources().getAnimation(id);
-        return createInterpolatorFromXml(context, parser);
+        return createInterpolatorFromXml(context.getResources(), context.getTheme(), parser);
     } catch (XmlPullParserException ex) {
         NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
         rnf.initCause(ex);

Find a functionally equivalent code:android.content.res.Resources.obtainAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */

@@ -1,13 +1,12 @@
 {
     int len = attrs.length;
-    TypedArray array = getCachedStyledAttributes(len);
+    TypedArray array = TypedArray.obtain(this, len);
     // XXX note that for now we only work with compiled XML files.
     // To support generic XML files we will need to manually parse
     // out the attributes from the XML file (applying type information
     // contained in the resources and such).
     XmlBlock.Parser parser = (XmlBlock.Parser) set;
     mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
-    array.mRsrcs = attrs;
     array.mXml = parser;
     return array;
 }

Find a functionally equivalent code:android.widget.CalendarView.setDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param date The selected date.
 *
 * @throws IllegalArgumentException of the provided date is before the
 * minimal or after the maximal date.
 *
 * @see #setDate(long, boolean, boolean)
 * @see #setMinDate(long)
 * @see #setMaxDate(long)
 */

@@ -1,3 +1,3 @@
 {
-    setDate(date, false, false);
+    mDelegate.setDate(date);
 }

Find a functionally equivalent code:android.content.res.TypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

@@ -1,11 +1,9 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     final TypedValue value = mValue;
     if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
-        if (false) {
-            System.out.println("******************************************************************");
-            System.out.println("Got drawable resource: type=" + value.type + " str=" + value.string + " int=0x" + Integer.toHexString(value.data) + " cookie=" + value.assetCookie);
-            System.out.println("******************************************************************");
-        }
         return mResources.getTextArray(value.resourceId);
     }
     return null;

Find a functionally equivalent code:com.android.internal.telephony.CallerInfo.toString:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return a string debug representation of this instance.
 */

@@ -3,9 +3,9 @@
     // because that will result in PII in the system log.
     final boolean VERBOSE_DEBUG = false;
     if (VERBOSE_DEBUG) {
-        return new StringBuilder(384).append(super.toString() + " { ").append("\nname: " + name).append("\nphoneNumber: " + phoneNumber).append("\nnormalizedNumber: " + normalizedNumber).append("\ngeoDescription: " + geoDescription).append("\ncnapName: " + cnapName).append("\nnumberPresentation: " + numberPresentation).append("\nnamePresentation: " + namePresentation).append("\ncontactExits: " + contactExists).append("\nphoneLabel: " + phoneLabel).append("\nnumberType: " + numberType).append("\nnumberLabel: " + numberLabel).append("\nphotoResource: " + photoResource).append("\nperson_id: " + person_id).append("\nneedUpdate: " + needUpdate).append("\ncontactRefUri: " + contactRefUri).append("\ncontactRingtoneUri: " + contactRefUri).append("\nshouldSendToVoicemail: " + shouldSendToVoicemail).append("\ncachedPhoto: " + cachedPhoto).append("\nisCachedPhotoCurrent: " + isCachedPhotoCurrent).append("\nemergency: " + mIsEmergency).append("\nvoicemail " + mIsVoiceMail).append("\ncontactExists " + contactExists).append(" }").toString();
+        return new StringBuilder(384).append(super.toString() + " { ").append("\nname: " + name).append("\nphoneNumber: " + phoneNumber).append("\nnormalizedNumber: " + normalizedNumber).append("\ngeoDescription: " + geoDescription).append("\ncnapName: " + cnapName).append("\nnumberPresentation: " + numberPresentation).append("\nnamePresentation: " + namePresentation).append("\ncontactExits: " + contactExists).append("\nphoneLabel: " + phoneLabel).append("\nnumberType: " + numberType).append("\nnumberLabel: " + numberLabel).append("\nphotoResource: " + photoResource).append("\ncontactIdOrZero: " + contactIdOrZero).append("\nneedUpdate: " + needUpdate).append("\ncontactRingtoneUri: " + contactRingtoneUri).append("\ncontactDisplayPhotoUri: " + contactDisplayPhotoUri).append("\nshouldSendToVoicemail: " + shouldSendToVoicemail).append("\ncachedPhoto: " + cachedPhoto).append("\nisCachedPhotoCurrent: " + isCachedPhotoCurrent).append("\nemergency: " + mIsEmergency).append("\nvoicemail " + mIsVoiceMail).append("\ncontactExists " + contactExists).append(" }").toString();
     } else {
         return new StringBuilder(128).append(super.toString() + " { ").append("name " + ((name == null) ? "null" : "non-null")).append(", phoneNumber " + ((phoneNumber == null) ? "null" : "non-null")).append(" }").toString();
     }

Find a functionally equivalent code:com.android.keyguard.ChallengeLayout.showChallenge:COMMENT
Method Modifier: 
Comment:/**
 * Show or hide the challenge layout.
 *
 * If you want to show the challenge layout in bouncer mode where applicable,
 * use {@link #showBouncer()} instead.
 *
 * @param b true to show, false to hide
 */


Find a functionally equivalent code:android.media.MediaCodecInfo.getName:COMMENT
Method Modifier: public      final       
Comment:/**
 * Retrieve the codec name.
 */

@@ -1,3 +1,3 @@
 {
-    return MediaCodecList.getCodecName(mIndex);
+    return mName;
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.executeReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */

@@ -1,12 +1,18 @@
 {
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
     if (mService == null || mClientIf == 0)
         return false;
+    synchronized (mDeviceBusy) {
+        if (mDeviceBusy)
+            return false;
+        mDeviceBusy = true;
+    }
     try {
         mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
+        mDeviceBusy = false;
         return false;
     }
     return true;

Find a functionally equivalent code:android.os.Bundle.putShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a short array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putShortArray(key, value);
 }

Find a functionally equivalent code:android.media.RemoteController.setSynchronizationMode:COMMENT
Method Modifier: public      
Comment:/**
 * Set the playback position synchronization mode.
 * Must be called on a registered RemoteController.
 * @param sync {@link #POSITION_SYNCHRONIZATION_NONE} or {@link #POSITION_SYNCHRONIZATION_CHECK}
 * @return true if the synchronization mode was successfully set.
 * @throws IllegalArgumentException
 */

@@ -1,5 +1,5 @@
 {
-    if ((sync != POSITION_SYNCHRONIZATION_NONE) || (sync != POSITION_SYNCHRONIZATION_CHECK)) {
+    if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {
         throw new IllegalArgumentException("Unknown synchronization mode " + sync);
     }
     if (!mIsRegistered) {

Find a functionally equivalent code:android.content.RestrictionEntry.getSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the currently selected string value.
 * @return the currently selected value, which can be null for types that aren't for holding
 * single string values.
 */

@@ -1,3 +1,3 @@
 {
-    return currentValue;
+    return mCurrentValue;
 }

Find a functionally equivalent code:android.app.admin.DevicePolicyManager.getMaximumTimeToLock:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide per-user version
 */


Find a functionally equivalent code:android.appwidget.AppWidgetManager.notifyAppWidgetViewDataChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their data.
 *
 * @param appWidgetIds  The AppWidget instances to notify of view data changes.
 * @param viewId        The collection view id.
 */

@@ -1,6 +1,9 @@
 {
+    if (mService == null) {
+        return;
+    }
     try {
-        sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId, mContext.getUserId());
+        mService.notifyAppWidgetViewDataChanged(mPackageName, appWidgetIds, viewId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:android.content.ContentResolver.getPeriodicSyncs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return getContentService().getPeriodicSyncs(account, authority);
+        return getContentService().getPeriodicSyncs(account, authority, null);
     } catch (RemoteException e) {
         throw new RuntimeException("the ContentService should always be reachable", e);
     }

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.beginReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without commiting any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */

@@ -1,5 +1,5 @@
 {
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "beginReliableWrite() - device: " + mDevice.getAddress());
     if (mService == null || mClientIf == 0)
         return false;

Find a functionally equivalent code:android.content.RestrictionEntry.setSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the string value to use as the selected value for this restriction. This value will
 * be persisted by the system for later use by the application.
 * @param selectedString the string value to select.
 */

@@ -1,3 +1,3 @@
 {
-    currentValue = selectedString;
+    mCurrentValue = selectedString;
 }

Find a functionally equivalent code:android.text.format.Time.parse:COMMENT
Method Modifier: public      
Comment:/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the "time" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>"20081013T160000Z"</li>
 * <li>"20081013T160000"</li>
 * <li>"20081013"</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with "Z" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = "20081013T160000Z";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

@@ -2,8 +2,8 @@
     if (s == null) {
         throw new NullPointerException("time string is null");
     }
-    if (nativeParse(s)) {
+    if (parseInternal(s)) {
         timezone = TIMEZONE_UTC;
         return true;
     }

Find a functionally equivalent code:com.android.server.content.SyncStorageEngineTest.testPeriodics:COMMENT
Method Modifier: public      
Comment:/**
 * Test that we can create, remove and retrieve periodic syncs. Backwards compatibility -
 * periodic syncs with no flex time are no longer used.
 */

@@ -9,14 +9,15 @@
     final int period1 = 200;
     final int period2 = 1000;
     PeriodicSync sync1 = new PeriodicSync(account1, authority, extras1, period1);
+    EndPoint end1 = new EndPoint(account1, authority, 0);
     PeriodicSync sync2 = new PeriodicSync(account1, authority, extras2, period1);
     PeriodicSync sync3 = new PeriodicSync(account1, authority, extras2, period2);
     PeriodicSync sync4 = new PeriodicSync(account2, authority, extras2, period2);
@@ -16,39 +17,40 @@
     removePeriodicSyncs(engine, account2, 0, authority);
     removePeriodicSyncs(engine, account1, 1, authority);
     // this should add two distinct periodic syncs for account1 and one for account2
-    engine.addPeriodicSync(sync1, 0);
-    engine.addPeriodicSync(sync2, 0);
-    engine.addPeriodicSync(sync3, 0);
-    engine.addPeriodicSync(sync4, 0);
+    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period1, 0, extras1);
+    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period1, 0, extras2);
+    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 0), period2, 0, extras2);
+    engine.updateOrAddPeriodicSync(new EndPoint(account2, authority, 0), period2, 0, extras2);
     // add a second user
-    engine.addPeriodicSync(sync2, 1);
-    List<PeriodicSync> syncs = engine.getPeriodicSyncs(account1, 0, authority);
+    engine.updateOrAddPeriodicSync(new EndPoint(account1, authority, 1), period1, 0, extras2);
+    List<PeriodicSync> syncs = engine.getPeriodicSyncs(new EndPoint(account1, authority, 0));
     assertEquals(2, syncs.size());
     assertEquals(sync1, syncs.get(0));
     assertEquals(sync3, syncs.get(1));
-    engine.removePeriodicSync(sync1, 0);
-    syncs = engine.getPeriodicSyncs(account1, 0, authority);
+    engine.removePeriodicSync(new EndPoint(account1, authority, 0), extras1);
+    syncs = engine.getPeriodicSyncs(new EndPoint(account1, authority, 0));
     assertEquals(1, syncs.size());
     assertEquals(sync3, syncs.get(0));
-    syncs = engine.getPeriodicSyncs(account2, 0, authority);
+    syncs = engine.getPeriodicSyncs(new EndPoint(account2, authority, 0));
     assertEquals(1, syncs.size());
     assertEquals(sync4, syncs.get(0));
-    syncs = engine.getPeriodicSyncs(sync2.account, 1, sync2.authority);
+    syncs = engine.getPeriodicSyncs(new EndPoint(sync2.account, sync2.authority, 1));
     assertEquals(1, syncs.size());
     assertEquals(sync2, syncs.get(0));
 }

Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteHost:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

@@ -1,6 +1,6 @@
 {
     try {
-        sService.deleteHost(mHostId, mContext.getUserId());
+        sService.deleteHost(mContext.getOpPackageName(), mHostId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:android.app.Activity.addContentView:COMMENT
Method Modifier: public      
Comment:/**
 * Add an additional content view to the activity.  Added after any existing
 * ones in the activity -- existing views are NOT removed.
 *
 * @param view The desired content to display.
 * @param params Layout parameters for the view.
 */

@@ -1,4 +1,4 @@
 {
     getWindow().addContentView(view, params);
-    initActionBar();
+    initWindowDecorActionBar();
 }

Find a functionally equivalent code:android.graphics.Matrix.ni:COMMENT
Method Modifier: default     final       
Comment:/*package*/


Find a functionally equivalent code:com.android.providers.settings.SettingsProvider.getOrEstablishDatabase:COMMENT
Method Modifier: private     
Comment:// Lazy initialize the database helper and caches for this user, if necessary

@@ -8,17 +8,22 @@
     }
     long oldId = Binder.clearCallingIdentity();
     try {
-        DatabaseHelper dbHelper = mOpenHelpers.get(callingUser);
+        DatabaseHelper dbHelper;
+        synchronized (this) {
+            dbHelper = mOpenHelpers.get(callingUser);
+        }
         if (null == dbHelper) {
             establishDbTracking(callingUser);
-            dbHelper = mOpenHelpers.get(callingUser);
+            synchronized (this) {
+                dbHelper = mOpenHelpers.get(callingUser);
+            }
         }
         return dbHelper;
     } finally {

Find a functionally equivalent code:android.widget.AdapterView.performItemClick:COMMENT
Method Modifier: public      
Comment:/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */

@@ -1,10 +1,10 @@
 {
     if (mOnItemClickListener != null) {
         playSoundEffect(SoundEffectConstants.CLICK);
+        mOnItemClickListener.onItemClick(this, view, position, id);
         if (view != null) {
             view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
         }
-        mOnItemClickListener.onItemClick(this, view, position, id);
         return true;
     }
     return false;

Find a functionally equivalent code:android.content.res.Resources.Theme.setTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set this theme to hold the same contents as the theme
 * <var>other</var>.  If both of these themes are from the same
 * Resources object, they will be identical after this function
 * returns.  If they are from different Resources, only the resources
 * they have in common will be set in this theme.
 *
 * @param other The existing Theme to copy from.
 */

@@ -1,3 +1,5 @@
 {
     AssetManager.copyTheme(mTheme, other.mTheme);
+    mThemeResId = other.mThemeResId;
+    mKey = other.mKey;
 }

Find a functionally equivalent code:android.view.animation.Transformation.set:COMMENT
Method Modifier: public      
Comment:/**
 * Clones the specified transformation.
 *
 * @param t The transformation to clone.
 */

@@ -1,5 +1,11 @@
 {
     mAlpha = t.getAlpha();
     mMatrix.set(t.getMatrix());
+    if (t.mHasClipRect) {
+        setClipRect(t.getClipRect());
+    } else {
+        mHasClipRect = false;
+        mClipRect.setEmpty();
+    }
     mTransformationType = t.getTransformationType();
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteInit.closeServerSocket:COMMENT
Method Modifier: default     static      internal    
Comment:/**
 * Close and clean up zygote sockets. Called on shutdown and on the
 * child's exit path.
 */

@@ -1,10 +1,16 @@
 {
     try {
         if (sServerSocket != null) {
+            FileDescriptor fd = sServerSocket.getFileDescriptor();
             sServerSocket.close();
+            if (fd != null) {
+                Os.close(fd);
+            }
         }
     } catch (IOException ex) {
         Log.e(TAG, "Zygote:  error closing sockets", ex);
+    } catch (ErrnoException ex) {
+        Log.e(TAG, "Zygote:  error closing descriptor", ex);
     }
     sServerSocket = null;
 }

Find a functionally equivalent code:android.util.LongSparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -14,36 +14,21 @@
             // Search again because indices may have changed.
             i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
         }
-        if (mSize >= mKeys.length) {
-            int n = ArrayUtils.idealLongArraySize(mSize + 1);
-            long[] nkeys = new long[n];
-            Object[] nvalues = new Object[n];
-            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-        if (mSize - i != 0) {
-            // Log.e("SparseArray", "move " + (mSize - i));
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:android.transition.Transition.end:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is called automatically by the Transition and
 * TransitionSet classes when a transition finishes, either because
 * a transition did nothing (returned a null Animator from
 * {@link Transition#createAnimator(ViewGroup, TransitionValues,
 * TransitionValues)}) or because the transition returned a valid
 * Animator and end() was called in the onAnimationEnd()
 * callback of the AnimatorListener.
 *
 * @hide
 */

@@ -9,25 +9,23 @@
             }
         }
         for (int i = 0; i < mStartValues.itemIdValues.size(); ++i) {
-            TransitionValues tv = mStartValues.itemIdValues.valueAt(i);
-            View v = tv.view;
-            if (v.hasTransientState()) {
-                v.setHasTransientState(false);
+            View view = mStartValues.itemIdValues.valueAt(i);
+            if (view != null) {
+                view.setHasTransientState(false);
             }
         }
         for (int i = 0; i < mEndValues.itemIdValues.size(); ++i) {
-            TransitionValues tv = mEndValues.itemIdValues.valueAt(i);
-            View v = tv.view;
-            if (v.hasTransientState()) {
-                v.setHasTransientState(false);
+            View view = mEndValues.itemIdValues.valueAt(i);
+            if (view != null) {
+                view.setHasTransientState(false);
             }
         }
         mEnded = true;

Find a functionally equivalent code:android.os.PowerManager.validateWakeLockParameters:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -5,10 +5,11 @@
         case SCREEN_BRIGHT_WAKE_LOCK:
         case FULL_WAKE_LOCK:
         case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
+        case DOZE_WAKE_LOCK:
             break;
         default:
             throw new IllegalArgumentException("Must specify a valid wake lock level.");

Find a functionally equivalent code:android.speech.tts.TextToSpeechService.SynthHandler.enqueueSpeechItem:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */

@@ -5,11 +5,11 @@
     }
     if (!speechItem.isValid()) {
         if (utterenceProgress != null) {
-            utterenceProgress.dispatchOnError();
+            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
         }
         return TextToSpeech.ERROR;
     }
@@ -34,40 +34,40 @@
     } else {
         Log.w(TAG, "SynthThread has quit");
         if (utterenceProgress != null) {
-            utterenceProgress.dispatchOnError();
+            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
         }
         return TextToSpeech.ERROR;
     }

Find a functionally equivalent code:android.media.Ringtone.play:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ringtone.
 */

@@ -1,13 +1,13 @@
 {
     if (mLocalPlayer != null) {
         // (typically because ringer mode is silent).
-        if (mAudioManager.getStreamVolume(mStreamType) != 0) {
+        if (mAudioManager.getStreamVolume(AudioAttributes.toLegacyStreamType(mAudioAttributes)) != 0) {
             mLocalPlayer.start();
         }
-    } else if (mAllowRemote) {
+    } else if (mAllowRemote && (mRemotePlayer != null)) {
         final Uri canonicalUri = mUri.getCanonicalUri();
         try {
-            mRemotePlayer.play(mRemoteToken, canonicalUri, mStreamType);
+            mRemotePlayer.play(mRemoteToken, canonicalUri, mAudioAttributes);
         } catch (RemoteException e) {
             if (!playFallbackRingtone()) {
                 Log.w(TAG, "Problem playing ringtone: " + e);

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

@@ -1,18 +1,11 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return defValue;
-    }
-    if (mResourceData[index] == null) {
-        return defValue;
-    }
-    String s = mResourceData[index].getValue();
-    if (s != null) {
-        try {
+    String s = getString(index);
+    try {
+        if (s != null) {
             return Float.parseFloat(s);
-        } catch (NumberFormatException e) {
-            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
-        // we'll return the default value below.
         }
+    } catch (NumberFormatException e) {
+        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
     }
     return defValue;
 }

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

@@ -1,50 +1,12 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return defValue;
-    }
-    if (mResourceData[index] == null) {
-        return defValue;
-    }
-    String s = mResourceData[index].getValue();
-    if (RenderResources.REFERENCE_NULL.equals(s)) {
-        return defValue;
-    }
-    if (s == null || s.length() == 0) {
-        return defValue;
-    }
+    String s = getString(index);
     try {
-        return XmlUtils.convertValueToInt(s, defValue);
-    } catch (NumberFormatException e) {
-    // pass
-    }
-    // Field is not null and is not an integer.
-    // Check for possible constants and try to find them.
-    // Get the map of attribute-constant -> IntegerValue
-    Map<String, Integer> map = null;
-    if (mIsFramework[index]) {
-        map = Bridge.getEnumValues(mNames[index]);
-    } else {
-        // get the styleable matching the resolved name
-        RenderResources res = mContext.getRenderResources();
-        ResourceValue attr = res.getProjectResource(ResourceType.ATTR, mNames[index]);
-        if (attr instanceof AttrResourceValue) {
-            map = ((AttrResourceValue) attr).getAttributeValues();
-        }
-    }
-    if (map != null) {
-        // accumulator to store the value of the 1+ constants.
-        int result = 0;
-        // split the value in case this is a mix of several flags.
-        String[] keywords = s.split("\\|");
-        for (String keyword : keywords) {
-            Integer i = map.get(keyword.trim());
-            if (i != null) {
-                result |= i.intValue();
-            } else {
-                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" is not a valid value", keyword, mNames[index]), null);
-            }
+        if (s != null) {
+            return XmlUtils.convertValueToInt(s, defValue);
         }
-        return result;
+    } catch (NumberFormatException e) {
+        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid integer", s, mNames[index]), null);
+        return defValue;
     }
     return defValue;
 }

Find a functionally equivalent code:android.content.ContentResolver.cancelSync:COMMENT
Method Modifier: public      static      
Comment:/**
 * Cancel any active or pending syncs that match account and authority. The account and
 * authority can each independently be set to null, which means that syncs with any account
 * or authority, respectively, will match.
 *
 * @param account filters the syncs that match by this account
 * @param authority filters the syncs that match by this authority
 */

@@ -1,6 +1,6 @@
 {
     try {
-        getContentService().cancelSync(account, authority);
+        getContentService().cancelSync(account, authority, null);
     } catch (RemoteException e) {
     }
 }

Find a functionally equivalent code:android.widget.TextView.getExtendedPaddingBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended bottom padding of the view, including both the
 * bottom Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

@@ -2,7 +2,10 @@
     if (mMaxMode != LINES) {
         return getCompoundPaddingBottom();
     }
+    if (mLayout == null) {
+        assumeLayout();
+    }
     if (mLayout.getLineCount() <= mMaximum) {
         return getCompoundPaddingBottom();
     }

Find a functionally equivalent code:android.media.AudioService.setModeInt:COMMENT
<android.media.AudioService: int setModeInt(int,IBinder,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
Comment:// any mode other than NORMAL.

@@ -1,4 +1,7 @@
 {
+    if (DEBUG_MODE) {
+        Log.v(TAG, "setModeInt(mode=" + mode + ", pid=" + pid + ")");
+    }
     int newModeOwnerPid = 0;
     if (cb == null) {
         Log.e(TAG, "setModeInt() called with null binder");
@@ -24,29 +27,35 @@
                 hdlr = mSetModeDeathHandlers.get(0);
                 cb = hdlr.getBinder();
                 mode = hdlr.getMode();
+                if (DEBUG_MODE) {
+                    Log.w(TAG, " using mode=" + mode + " instead due to death hdlr at pid=" + hdlr.mPid);
+                }
             }
         } else {
             if (hdlr == null) {
@@ -44,49 +50,58 @@
         if (mode != mMode) {
             status = AudioSystem.setPhoneState(mode);
             if (status == AudioSystem.AUDIO_STATUS_OK) {
+                if (DEBUG_MODE) {
+                    Log.v(TAG, " mode successfully set to " + mode);
+                }
                 mMode = mode;
             } else {
                 if (hdlr != null) {
@@ -51,56 +60,68 @@
                     cb.unlinkToDeath(hdlr, 0);
                 }
                 // force reading new top of mSetModeDeathHandlers stack
+                if (DEBUG_MODE) {
+                    Log.w(TAG, " mode set to MODE_NORMAL after phoneState pb");
+                }
                 mode = AudioSystem.MODE_NORMAL;
             }
         } else {
@@ -66,75 +78,83 @@
             }
         }
         int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
-        if (streamType == STREAM_REMOTE_MUSIC) {
-            // here handle remote media playback the same way as local playback
-            streamType = AudioManager.STREAM_MUSIC;
-        }
         int device = getDeviceForStream(streamType);
         int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
         setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true);

Find a functionally equivalent code:android.net.wifi.WifiConfiguration.getKeyIdForCredentials:COMMENT
<android.net.wifi.WifiConfiguration: String getKeyIdForCredentials(WifiConfiguration)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Get an identifier for associating credentials with this config
 * @param current configuration contains values for additional fields
 * that are not part of this configuration. Used
 * when a config with some fields is passed by an application.
 * @throws IllegalStateException if config is invalid for key id generation
 * @hide
 */


Find a functionally equivalent code:android.appwidget.AppWidgetHost.getAppWidgetIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 *
 * @hide
 */

@@ -3,9 +3,9 @@
         if (sService == null) {
             bindService();
         }
-        return sService.getAppWidgetIdsForHost(mHostId, mContext.getUserId());
+        return sService.getAppWidgetIdsForHost(mContext.getOpPackageName(), mHostId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:android.app.Notification.safeCharSequence:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Make sure this CharSequence is safe to put into a bundle, which basically
 * means it had better not be some custom Parcelable implementation.
 * @hide
 */

@@ -1,4 +1,9 @@
 {
+    if (cs == null)
+        return cs;
+    if (cs.length() > MAX_CHARSEQUENCE_LENGTH) {
+        cs = cs.subSequence(0, MAX_CHARSEQUENCE_LENGTH);
+    }
     if (cs instanceof Parcelable) {
         Log.e(TAG, "warning: " + cs.getClass().getCanonicalName() + " instance is a custom Parcelable and not allowed in Notification");
         return cs.toString();

Find a functionally equivalent code:android.util.SparseIntArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -4,26 +4,11 @@
         mValues[i] = value;
     } else {
         i = ~i;
-        if (mSize >= mKeys.length) {
-            int n = ArrayUtils.idealIntArraySize(mSize + 1);
-            int[] nkeys = new int[n];
-            int[] nvalues = new int[n];
-            // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-        if (mSize - i != 0) {
-            // Log.e("SparseIntArray", "move " + (mSize - i));
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:android.widget.FastScroller.setThumbPos:COMMENT
Method Modifier: private     
Comment:/**
 * Positions the thumb and preview widgets.
 *
 * @param position The position, between 0 and 1, along the track at which
 * to place the thumb.
 */

@@ -2,19 +2,31 @@
     final Rect container = mContainerRect;
     final int top = container.top;
     final int bottom = container.bottom;
-    final ImageView trackImage = mTrackImage;
-    final ImageView thumbImage = mThumbImage;
+    final View trackImage = mTrackImage;
+    final View thumbImage = mThumbImage;
     final float min = trackImage.getTop();
     final float max = trackImage.getBottom();
     final float offset = min;
     final float range = max - min;
     final float thumbMiddle = position * range + offset;
     thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
-    final float previewPos = mOverlayPosition == OVERLAY_AT_THUMB ? thumbMiddle : 0;
-    // Center the preview on the thumb, constrained to the list bounds.
-    final ImageView previewImage = mPreviewImage;
+    final View previewImage = mPreviewImage;
     final float previewHalfHeight = previewImage.getHeight() / 2f;
+    final float previewPos;
+    switch(mOverlayPosition) {
+        case OVERLAY_AT_THUMB:
+            previewPos = thumbMiddle;
+            break;
+        case OVERLAY_ABOVE_THUMB:
+            previewPos = thumbMiddle - previewHalfHeight;
+            break;
+        case OVERLAY_FLOATING:
+        default:
+            previewPos = 0;
+            break;
+    }
+    // Center the preview on the thumb, constrained to the list bounds.
     final float minP = top + previewHalfHeight;
     final float maxP = bottom - previewHalfHeight;
     final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);

Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmAnalyzer.analyze:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the analysis using parameters from the constructor.
 * Fills the generator with classes & dependencies found.
 */

@@ -1,10 +1,14 @@
 {
-    Map<String, ClassReader> zipClasses = parseZip(mOsSourceJar);
+    TreeMap<String, ClassReader> zipClasses = new TreeMap<String, ClassReader>();
+    Map<String, InputStream> filesFound = new TreeMap<String, InputStream>();
+    parseZip(mOsSourceJar, zipClasses, filesFound);
     mLog.info("Found %d classes in input JAR%s.", zipClasses.size(), mOsSourceJar.size() > 1 ? "s" : "");
     Map<String, ClassReader> found = findIncludes(zipClasses);
     Map<String, ClassReader> deps = findDeps(zipClasses, found);
     if (mGen != null) {
         mGen.setKeep(found);
         mGen.setDeps(deps);
+        mGen.setCopyFiles(filesFound);
+        mGen.setRewriteMethodCallClasses(mReplaceMethodCallClasses);
     }
 }

Find a functionally equivalent code:android.view.ViewGroup.setClipChildren:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to their bounds before drawing. This
 * allows view groups to override this behavior for animations, etc.
 *
 * @param clipChildren true to clip children to their bounds,
 * false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipChildren
 */

@@ -4,12 +4,13 @@
         setBooleanFlag(FLAG_CLIP_CHILDREN, clipChildren);
         for (int i = 0; i < mChildrenCount; ++i) {
             View child = getChildAt(i);
-            if (child.mDisplayList != null) {
-                child.mDisplayList.setClipToBounds(clipChildren);
+            if (child.mRenderNode != null) {
+                child.mRenderNode.setClipToBounds(clipChildren);
             }
         }
+        invalidate(true);
     }
 }

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handlePokeWakelock:COMMENT
Method Modifier: 
Comment:/**
 * If the screen is on, pokes the wakelock to keep the screen alive and active for a specific
 * amount of time.
 */

@@ -1,6 +1,6 @@
 {
     PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
     if (powerManager.isScreenOn()) {
-        mKeyguardScreenCallback.userActivity(millis);
+        mKeyguardScreenCallback.userActivity();
     }
 }

Find a functionally equivalent code:android.widget.ListPopupWindow.ForwardingListener.onTouchObserved:COMMENT
Method Modifier: private     
Comment:/**
 * Observes motion events and determines when to start forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to start forwarding motion events, false otherwise
 */

@@ -7,27 +7,31 @@
     switch(actionMasked) {
         case MotionEvent.ACTION_DOWN:
             mActivePointerId = srcEvent.getPointerId(0);
+            mWasLongPress = false;
             if (mDisallowIntercept == null) {
                 mDisallowIntercept = new DisallowIntercept();
             }
             src.postDelayed(mDisallowIntercept, mTapTimeout);
+            if (mTriggerLongPress == null) {
+                mTriggerLongPress = new TriggerLongPress();
+            }
+            src.postDelayed(mTriggerLongPress, mLongPressTimeout);
             break;
         case MotionEvent.ACTION_MOVE:
             final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
             if (activePointerIndex >= 0) {
                 final float x = srcEvent.getX(activePointerIndex);
                 final float y = srcEvent.getY(activePointerIndex);
+                // Has the pointer has moved outside of the view?
                 if (!src.pointInView(x, y, mScaledTouchSlop)) {
-                    // The pointer has moved outside of the view.
-                    if (mDisallowIntercept != null) {
-                        src.removeCallbacks(mDisallowIntercept);
-                    }
+                    clearCallbacks();
+                    // Don't let the parent intercept our events.
                     src.getParent().requestDisallowInterceptTouchEvent(true);
                     return true;
                 }
@@ -29,37 +33,39 @@
             break;
         case MotionEvent.ACTION_CANCEL:
         case MotionEvent.ACTION_UP:
-            if (mDisallowIntercept != null) {
-                src.removeCallbacks(mDisallowIntercept);
-            }
+            clearCallbacks();
             break;
     }
     return false;

Find a functionally equivalent code:android.os.ParcelFileDescriptor.createReliablePipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

@@ -1,7 +1,7 @@
 {
     try {
-        final FileDescriptor[] comm = createCommSocketPair(false);
-        final FileDescriptor[] fds = Libcore.os.pipe();
+        final FileDescriptor[] comm = createCommSocketPair();
+        final FileDescriptor[] fds = Os.pipe();
         return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
     } catch (ErrnoException e) {
         throw e.rethrowAsIOException();

Find a functionally equivalent code:android.view.ViewGroup.invalidateChild:COMMENT
Method Modifier: public      final       
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 */

@@ -17,23 +17,22 @@
         if (child.mLayerType != LAYER_TYPE_NONE) {
             mPrivateFlags |= PFLAG_INVALIDATED;
             mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
-            child.mLocalDirtyRect.union(dirty);
         }
         final int[] location = attachInfo.mInvalidateChildLocation;
         location[CHILD_LEFT_INDEX] = child.mLeft;

Find a functionally equivalent code:android.graphics.Bitmap.ni:COMMENT
Method Modifier: default     final       
Comment:/* package */


Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -6,23 +6,12 @@
     if (mSize >= mKeys.length && (mGarbage || hasReclaimedRefs())) {
         gc();
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        int n = ArrayUtils.idealIntArraySize(pos + 1);
-        int[] nkeys = new int[n];
-        WeakReference<?>[] nvalues = new WeakReference[n];
-        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-        mKeys = nkeys;
-        mValues = nvalues;
-    }
-    mKeys[pos] = key;
-    mValues[pos] = new WeakReference(value);
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, new WeakReference(value));
+    mSize++;
 }

Find a functionally equivalent code:android.net.http.CertificateChainValidator.handleTrustStorageUpdate:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles updates to credential storage.
 */

@@ -1,10 +1,27 @@
 {
+    TrustManagerFactory tmf;
     try {
-        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
-        if (x509TrustManager instanceof TrustManagerImpl) {
-            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
-            trustManager.handleTrustStorageUpdate();
+        tmf = TrustManagerFactory.getInstance("X.509");
+        tmf.init((KeyStore) null);
+    } catch (NoSuchAlgorithmException e) {
+        Slog.w(TAG, "Couldn't find default X.509 TrustManagerFactory");
+        return;
+    } catch (KeyStoreException e) {
+        Slog.w(TAG, "Couldn't initialize default X.509 TrustManagerFactory", e);
+        return;
+    }
+    TrustManager[] tms = tmf.getTrustManagers();
+    boolean sentUpdate = false;
+    for (TrustManager tm : tms) {
+        try {
+            Method updateMethod = tm.getClass().getDeclaredMethod("handleTrustStorageUpdate");
+            updateMethod.setAccessible(true);
+            updateMethod.invoke(tm);
+            sentUpdate = true;
+        } catch (Exception e) {
         }
-    } catch (KeyManagementException ignored) {
+    }
+    if (!sentUpdate) {
+        Slog.w(TAG, "Didn't find a TrustManager to handle CA list update");
     }
 }

Find a functionally equivalent code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

@@ -2,169 +2,95 @@
     if (DBG) {
         Log.d(LOG_TAG, "createAnimators() for " + this);
     }
-    ArrayMap<View, TransitionValues> endCopy = new ArrayMap<View, TransitionValues>(endValues.viewValues);
-    SparseArray<TransitionValues> endIdCopy = new SparseArray<TransitionValues>(endValues.idValues.size());
-    for (int i = 0; i < endValues.idValues.size(); ++i) {
-        int id = endValues.idValues.keyAt(i);
-        endIdCopy.put(id, endValues.idValues.valueAt(i));
-    }
-    LongSparseArray<TransitionValues> endItemIdCopy = new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
-    for (int i = 0; i < endValues.itemIdValues.size(); ++i) {
-        long id = endValues.itemIdValues.keyAt(i);
-        endItemIdCopy.put(id, endValues.itemIdValues.valueAt(i));
-    }
-    // Walk through the start values, playing everything we find
-    // Remove from the end set as we go
-    ArrayList<TransitionValues> startValuesList = new ArrayList<TransitionValues>();
-    ArrayList<TransitionValues> endValuesList = new ArrayList<TransitionValues>();
-    for (View view : startValues.viewValues.keySet()) {
-        TransitionValues start = null;
-        TransitionValues end = null;
-        boolean isInListView = false;
-        if (view.getParent() instanceof ListView) {
-            isInListView = true;
-        }
-        if (!isInListView) {
-            int id = view.getId();
-            start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
-            if (endValues.viewValues.get(view) != null) {
-                end = endValues.viewValues.get(view);
-                endCopy.remove(view);
-            } else if (id != View.NO_ID) {
-                end = endValues.idValues.get(id);
-                View removeView = null;
-                for (View viewToRemove : endCopy.keySet()) {
-                    if (viewToRemove.getId() == id) {
-                        removeView = viewToRemove;
-                    }
-                }
-                if (removeView != null) {
-                    endCopy.remove(removeView);
-                }
-            }
-            endIdCopy.remove(id);
-            if (isValidTarget(view, id)) {
-                startValuesList.add(start);
-                endValuesList.add(end);
-            }
-        } else {
-            ListView parent = (ListView) view.getParent();
-            if (parent.getAdapter().hasStableIds()) {
-                int position = parent.getPositionForView(view);
-                long itemId = parent.getItemIdAtPosition(position);
-                start = startValues.itemIdValues.get(itemId);
-                endItemIdCopy.remove(itemId);
-                // TODO: deal with targetIDs for itemIDs for ListView items
-                startValuesList.add(start);
-                endValuesList.add(end);
-            }
-        }
-    }
-    int startItemIdCopySize = startValues.itemIdValues.size();
-    for (int i = 0; i < startItemIdCopySize; ++i) {
-        long id = startValues.itemIdValues.keyAt(i);
-        if (isValidTarget(null, id)) {
-            TransitionValues start = startValues.itemIdValues.get(id);
-            TransitionValues end = endValues.itemIdValues.get(id);
-            endItemIdCopy.remove(id);
-            startValuesList.add(start);
-            endValuesList.add(end);
-        }
-    }
-    // Now walk through the remains of the end set
-    for (View view : endCopy.keySet()) {
-        int id = view.getId();
-        if (isValidTarget(view, id)) {
-            TransitionValues start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
-            TransitionValues end = endCopy.get(view);
-            endIdCopy.remove(id);
-            startValuesList.add(start);
-            endValuesList.add(end);
-        }
-    }
-    int endIdCopySize = endIdCopy.size();
-    for (int i = 0; i < endIdCopySize; ++i) {
-        int id = endIdCopy.keyAt(i);
-        if (isValidTarget(null, id)) {
-            TransitionValues start = startValues.idValues.get(id);
-            TransitionValues end = endIdCopy.get(id);
-            startValuesList.add(start);
-            endValuesList.add(end);
-        }
-    }
-    int endItemIdCopySize = endItemIdCopy.size();
-    for (int i = 0; i < endItemIdCopySize; ++i) {
-        long id = endItemIdCopy.keyAt(i);
-        // TODO: Deal with targetIDs and itemIDs
-        TransitionValues start = startValues.itemIdValues.get(id);
-        TransitionValues end = endItemIdCopy.get(id);
-        startValuesList.add(start);
-        endValuesList.add(end);
-    }
     ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
-    for (int i = 0; i < startValuesList.size(); ++i) {
+    long minStartDelay = Long.MAX_VALUE;
+    int minAnimator = mAnimators.size();
+    SparseLongArray startDelays = new SparseLongArray();
+    int startValuesListCount = startValuesList.size();
+    for (int i = 0; i < startValuesListCount; ++i) {
         TransitionValues start = startValuesList.get(i);
         TransitionValues end = endValuesList.get(i);
+        if (start != null && !start.targetedTransitions.contains(this)) {
+            start = null;
+        }
+        if (end != null && !end.targetedTransitions.contains(this)) {
+            end = null;
+        }
+        if (start == null && end == null) {
+            continue;
+        }
         // Only bother trying to animate with values that differ between start/end
-        if (start != null || end != null) {
-            if (start == null || !start.equals(end)) {
-                if (DBG) {
-                    View view = (end != null) ? end.view : start.view;
-                    Log.d(LOG_TAG, "  differing start/end values for view " + view);
-                    if (start == null || end == null) {
-                        Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
-                    } else {
-                        for (String key : start.values.keySet()) {
-                            Object startValue = start.values.get(key);
-                            Object endValue = end.values.get(key);
-                            if (startValue != endValue && !startValue.equals(endValue)) {
-                                Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
-                            }
+        boolean isChanged = start == null || end == null || areValuesChanged(start, end);
+        if (isChanged) {
+            if (DBG) {
+                View view = (end != null) ? end.view : start.view;
+                Log.d(LOG_TAG, "  differing start/end values for view " + view);
+                if (start == null || end == null) {
+                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
+                } else {
+                    for (String key : start.values.keySet()) {
+                        Object startValue = start.values.get(key);
+                        Object endValue = end.values.get(key);
+                        if (startValue != endValue && !startValue.equals(endValue)) {
+                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                         }
                     }
                 }
-                // TODO: what to do about targetIds and itemIds?
-                Animator animator = createAnimator(sceneRoot, start, end);
-                if (animator != null) {
-                    // Save animation info for future cancellation purposes
-                    View view = null;
-                    TransitionValues infoValues = null;
-                    if (end != null) {
-                        view = end.view;
-                        String[] properties = getTransitionProperties();
-                        if (view != null && properties != null && properties.length > 0) {
-                            infoValues = new TransitionValues();
-                            infoValues.view = view;
-                            TransitionValues newValues = endValues.viewValues.get(view);
-                            if (newValues != null) {
-                                for (int j = 0; j < properties.length; ++j) {
-                                    infoValues.values.put(properties[j], newValues.values.get(properties[j]));
-                                }
+            }
+            // TODO: what to do about targetIds and itemIds?
+            Animator animator = createAnimator(sceneRoot, start, end);
+            if (animator != null) {
+                // Save animation info for future cancellation purposes
+                View view = null;
+                TransitionValues infoValues = null;
+                if (end != null) {
+                    view = end.view;
+                    String[] properties = getTransitionProperties();
+                    if (view != null && properties != null && properties.length > 0) {
+                        infoValues = new TransitionValues();
+                        infoValues.view = view;
+                        TransitionValues newValues = endValues.viewValues.get(view);
+                        if (newValues != null) {
+                            for (int j = 0; j < properties.length; ++j) {
+                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                             }
-                            int numExistingAnims = runningAnimators.size();
-                            for (int j = 0; j < numExistingAnims; ++j) {
-                                Animator anim = runningAnimators.keyAt(j);
-                                AnimationInfo info = runningAnimators.get(anim);
-                                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
-                                    if (info.values.equals(infoValues)) {
-                                        // Favor the old animator
-                                        animator = null;
-                                        break;
-                                    }
+                        }
+                        int numExistingAnims = runningAnimators.size();
+                        for (int j = 0; j < numExistingAnims; ++j) {
+                            Animator anim = runningAnimators.keyAt(j);
+                            AnimationInfo info = runningAnimators.get(anim);
+                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
+                                if (info.values.equals(infoValues)) {
+                                    // Favor the old animator
+                                    animator = null;
+                                    break;
                                 }
                             }
                         }
-                    } else {
-                        view = (start != null) ? start.view : null;
                     }
-                    if (animator != null) {
-                        AnimationInfo info = new AnimationInfo(view, getName(), infoValues);
-                        runningAnimators.put(animator, info);
-                        mAnimators.add(animator);
+                } else {
+                    view = (start != null) ? start.view : null;
+                }
+                if (animator != null) {
+                    if (mPropagation != null) {
+                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
+                        startDelays.put(mAnimators.size(), delay);
+                        minStartDelay = Math.min(delay, minStartDelay);
                     }
+                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
+                    runningAnimators.put(animator, info);
+                    mAnimators.add(animator);
                 }
             }
         }
     }
+    if (minStartDelay != 0) {
+        for (int i = 0; i < startDelays.size(); i++) {
+            int index = startDelays.keyAt(i);
+            Animator animator = mAnimators.get(index);
+            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
+            animator.setStartDelay(delay);
+        }
+    }
 }

Find a functionally equivalent code:android.widget.DatePicker.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link NumberPicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param minDate The minimal supported date.
 */

@@ -1,13 +1,3 @@
 {
-    mTempDate.setTimeInMillis(minDate);
-    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
-        return;
-    }
-    mMinDate.setTimeInMillis(minDate);
-    mCalendarView.setMinDate(minDate);
-    if (mCurrentDate.before(mMinDate)) {
-        mCurrentDate.setTimeInMillis(mMinDate.getTimeInMillis());
-        updateCalendarView();
-    }
-    updateSpinners();
+    mDelegate.setMinDate(minDate);
 }

Find a functionally equivalent code:android.preference.PreferenceActivity.loadHeadersFromResource:COMMENT
Method Modifier: public      
Comment:/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */

@@ -20,26 +20,26 @@
             nodeName = parser.getName();
             if ("header".equals(nodeName)) {
                 Header header = new Header();
-                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
+                TypedArray sa = obtainStyledAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                 header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                 TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                 if (tv != null && tv.type == TypedValue.TYPE_STRING) {

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.showBootMessage:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,12 +1,18 @@
 {
-    if (mHeadless)
-        return;
     mHandler.post(new Runnable() {
 
         @Override
         public void run() {
             if (mBootMsgDialog == null) {
-                mBootMsgDialog = new ProgressDialog(mContext) {
+                int theme;
+                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
+                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
+                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
+                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
+                } else {
+                    theme = 0;
+                }
+                mBootMsgDialog = new ProgressDialog(mContext, theme) {
 
                     // This dialog will consume all events coming in to
                     // it, to avoid it trying to do things too early in boot.

Find a functionally equivalent code:android.provider.DocumentsProvider.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #getDocumentType(String)
 */

@@ -4,9 +4,11 @@
             case MATCH_ROOT:
                 return DocumentsContract.Root.MIME_TYPE_ITEM;
             case MATCH_DOCUMENT:
+            case MATCH_DOCUMENT_TREE:
+                enforceTree(uri);
                 return getDocumentType(getDocumentId(uri));
             default:
                 return null;

Find a functionally equivalent code:android.view.animation.Transformation.compose:COMMENT
Method Modifier: public      
Comment:/**
 * Apply this Transformation to an existing Transformation, e.g. apply
 * a scale effect to something that has already been rotated.
 * @param t
 */

@@ -1,4 +1,7 @@
 {
     mAlpha *= t.getAlpha();
     mMatrix.preConcat(t.getMatrix());
+    if (t.mHasClipRect) {
+        setClipRect(t.getClipRect());
+    }
 }

Find a functionally equivalent code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -1,3 +1,6 @@
 {
-    return available_native(fd);
+    FileDescriptor myFd = fd;
+    if (myFd == null)
+        throw new IOException("socket closed");
+    return available_native(myFd);
 }

Find a functionally equivalent code:android.text.Layout.getParagraphLeadingMargin:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the effective leading margin (unsigned) for this line,
 * taking into account LeadingMarginSpan and LeadingMarginSpan2.
 * @param line the line index
 * @return the leading margin of this line
 */

@@ -13,27 +13,30 @@
     }
     int margin = 0;
     boolean isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
+    boolean useFirstLineMargin = isFirstParaLine;
     for (int i = 0; i < spans.length; i++) {
-        LeadingMarginSpan span = spans[i];
-        boolean useFirstLineMargin = isFirstParaLine;
-        if (span instanceof LeadingMarginSpan2) {
-            int spStart = spanned.getSpanStart(span);
+        if (spans[i] instanceof LeadingMarginSpan2) {
+            int spStart = spanned.getSpanStart(spans[i]);
             int spanLine = getLineForOffset(spStart);
-            int count = ((LeadingMarginSpan2) span).getLeadingMarginLineCount();
-            useFirstLineMargin = line < spanLine + count;
+            int count = ((LeadingMarginSpan2) spans[i]).getLeadingMarginLineCount();
+            // if there is more than one LeadingMarginSpan2, use the count that is greatest
+            useFirstLineMargin |= line < spanLine + count;
         }
+    }
+    for (int i = 0; i < spans.length; i++) {
+        LeadingMarginSpan span = spans[i];
         margin += span.getLeadingMargin(useFirstLineMargin);
     }
     return margin;

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.onKeyDown:COMMENT
Method Modifier: protected   internal    
Comment:/**
 * A key was pressed down and not handled by anything else in the window.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */

@@ -17,31 +17,57 @@
     switch(keyCode) {
         case KeyEvent.KEYCODE_VOLUME_UP:
         case KeyEvent.KEYCODE_VOLUME_DOWN:
+            {
+                int direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
+                // use the suggested stream.
+                if (mMediaController != null) {
+                    mMediaController.adjustVolume(direction, AudioManager.FLAG_SHOW_UI);
+                } else {
+                    MediaSessionLegacyHelper.getHelper(getContext()).sendAdjustVolumeBy(mVolumeControlStreamType, direction, AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
+                }
+                return true;
+            }
         case KeyEvent.KEYCODE_VOLUME_MUTE:
             {
-                // Similar code is in PhoneFallbackEventHandler in case the window
-                // doesn't have one of these.  In this case, we execute it here and
-                // eat the event instead, because we have mVolumeControlStreamType
-                // and they don't.
                 getAudioManager().handleKeyDown(event, mVolumeControlStreamType);
                 return true;
             }
+        // KeyEvent.isMediaKey()
+        case KeyEvent.KEYCODE_MEDIA_PLAY:
+        case KeyEvent.KEYCODE_MEDIA_PAUSE:
+        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+        case KeyEvent.KEYCODE_MUTE:
+        case KeyEvent.KEYCODE_HEADSETHOOK:
+        case KeyEvent.KEYCODE_MEDIA_STOP:
+        case KeyEvent.KEYCODE_MEDIA_NEXT:
+        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+        case KeyEvent.KEYCODE_MEDIA_REWIND:
+        case KeyEvent.KEYCODE_MEDIA_RECORD:
+        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+            {
+                if (mMediaController != null) {
+                    if (mMediaController.dispatchMediaButtonEvent(event)) {
+                        return true;
+                    }
+                }
+                return false;
+            }
         case KeyEvent.KEYCODE_MENU:
             {
                 onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId, event);

Find a functionally equivalent code:android.content.res.AssetManager.createTheme:COMMENT
Method Modifier: default     final       
Comment:/*package*/

@@ -3,9 +3,9 @@
         if (!mOpen) {
             throw new RuntimeException("Assetmanager has been closed");
         }
-        int res = newTheme();
+        long res = newTheme();
         incRefsLocked(res);
         return res;
     }

Find a functionally equivalent code:android.app.Activity.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */

@@ -1,5 +1,9 @@
 {
     onUserInteraction();
+    // the window handling it
+    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
+        return true;
+    }
     Window win = getWindow();
     if (win.superDispatchKeyEvent(event)) {
         return true;

Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDevice.updateSupplicantDetails:COMMENT
<android.net.wifi.p2p.WifiP2pDevice: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * Updates details obtained from supplicant @hide
 */


Find a functionally equivalent code:android.graphics.Typeface.createFromAsset:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new typeface from the specified font data.
 * @param mgr The application's asset manager
 * @param path  The file name of the font data in the assets directory
 * @return The new typeface.
 */

@@ -1,3 +1,10 @@
 {
-    return new Typeface(nativeCreateFromAsset(mgr, path));
+    if (sFallbackFonts != null) {
+        FontFamily fontFamily = new FontFamily();
+        if (fontFamily.addFontFromAsset(mgr, path)) {
+            FontFamily[] families = { fontFamily };
+            return createFromFamiliesWithDefault(families);
+        }
+    }
+    throw new RuntimeException("Font asset not found " + path);
 }

Find a functionally equivalent code:android.widget.CalendarView.getWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the week numbers.
 *
 * @return The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

@@ -1,3 +1,3 @@
 {
-    return mWeekNumberColor;
+    return mDelegate.getWeekNumberColor();
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.getKeyguardStoredPasswordQuality:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Retrieves the quality mode we're in.
 * {@see DevicePolicyManager#getPasswordQuality(android.content.ComponentName)}
 *
 * @return stored password quality
 */

@@ -1,8 +1,3 @@
 {
-    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
-    // method and treat biometric as a special case.
-    if (quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
-        quality = (int) getLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
-    }
-    return quality;
+    return getKeyguardStoredPasswordQuality(getCurrentOrCallingUserId());
 }

Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.setAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color's alpha value.
 *
 * @param alpha The alpha value to set, between 0 and 255.
 */

@@ -1,11 +1,11 @@
 {
     // make it 0..256
     alpha += alpha >> 7;
-    int baseAlpha = mState.mBaseColor >>> 24;
-    int useAlpha = baseAlpha * alpha >> 8;
-    int oldUseColor = mState.mUseColor;
-    mState.mUseColor = (mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
-    if (oldUseColor != mState.mUseColor) {
+    final int baseAlpha = mColorState.mBaseColor >>> 24;
+    final int useAlpha = baseAlpha * alpha >> 8;
+    final int useColor = (mColorState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
+    if (mColorState.mUseColor != useColor) {
+        mColorState.mUseColor = useColor;
         invalidateSelf();
     }
 }

Find a functionally equivalent code:android.provider.DocumentsContract.getRootId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.
 */

@@ -1,10 +1,7 @@
 {
     final List<String> paths = rootUri.getPathSegments();
-    if (paths.size() < 2) {
-        throw new IllegalArgumentException("Not a root: " + rootUri);
+    if (paths.size() >= 2 && PATH_ROOT.equals(paths.get(0))) {
+        return paths.get(1);
     }
-    if (!PATH_ROOT.equals(paths.get(0))) {
-        throw new IllegalArgumentException("Not a root: " + rootUri);
-    }
-    return paths.get(1);
+    throw new IllegalArgumentException("Invalid URI: " + rootUri);
 }

Find a functionally equivalent code:android.app.backup.BackupAgent.fullBackupFileTree:COMMENT
Method Modifier: protected   final       hidden      
Comment:/**
 * Scan the dir tree (if it actually exists) and process each entry we find.  If the
 * 'excludes' parameter is non-null, it is consulted each time a new file system entity
 * is visited to see whether that entity (and its subtree, if appropriate) should be
 * omitted from the backup process.
 *
 * @hide
 */

@@ -13,19 +13,19 @@
                     continue;
                 }
                 // If it's a directory, enqueue its contents for scanning.
-                StructStat stat = Libcore.os.lstat(filePath);
+                StructStat stat = Os.lstat(filePath);
                 if (OsConstants.S_ISLNK(stat.st_mode)) {
                     if (DEBUG)
                         Log.i(TAG, "Symlink (skipping)!: " + file);

Find a functionally equivalent code:android.media.RemoteController.getEstimatedMediaPosition:COMMENT
Method Modifier: public      
Comment:/**
 * Return the estimated playback position of the current media track or a negative value
 * if not available.
 *
 * <p>The value returned is estimated by the current process and may not be perfect.
 * The time returned by this method is calculated from the last state change time based
 * on the current play position at that time and the last known playback speed.
 * An application may call {@link #setSynchronizationMode(int)} to apply
 * a synchronization policy that will periodically re-sync the estimated position
 * with the RemoteControlClient.</p>
 *
 * @return the current estimated playback position in milliseconds or a negative value
 * if not available
 *
 * @see OnClientUpdateListener#onClientPlaybackStateUpdate(int, long, long, float)
 */

@@ -1,18 +1,34 @@
 {
-    if (mLastPlaybackInfo != null) {
-        if (!RemoteControlClient.playbackPositionShouldMove(mLastPlaybackInfo.mState)) {
-            return mLastPlaybackInfo.mCurrentPosMs;
+    if (USE_SESSIONS) {
+        synchronized (mInfoLock) {
+            if (mCurrentSession != null) {
+                PlaybackState state = mCurrentSession.getPlaybackState();
+                if (state != null) {
+                    return state.getPosition();
+                }
+            }
         }
-        // Take the current position at the time of state change and estimate.
-        final long thenPos = mLastPlaybackInfo.mCurrentPosMs;
-        if (thenPos < 0) {
-            return -1;
+    } else {
+        final PlaybackInfo lastPlaybackInfo;
+        synchronized (mInfoLock) {
+            lastPlaybackInfo = mLastPlaybackInfo;
         }
-        final long now = SystemClock.elapsedRealtime();
-        final long then = mLastPlaybackInfo.mStateChangeTimeMs;
-        final long sinceThen = now - then;
-        final long scaledSinceThen = (long) (sinceThen * mLastPlaybackInfo.mSpeed);
-        return thenPos + scaledSinceThen;
+        if (lastPlaybackInfo != null) {
+            if (!RemoteControlClient.playbackPositionShouldMove(lastPlaybackInfo.mState)) {
+                return lastPlaybackInfo.mCurrentPosMs;
+            }
+            // Take the current position at the time of state change and
+            // estimate.
+            final long thenPos = lastPlaybackInfo.mCurrentPosMs;
+            if (thenPos < 0) {
+                return -1;
+            }
+            final long now = SystemClock.elapsedRealtime();
+            final long then = lastPlaybackInfo.mStateChangeTimeMs;
+            final long sinceThen = now - then;
+            final long scaledSinceThen = (long) (sinceThen * lastPlaybackInfo.mSpeed);
+            return thenPos + scaledSinceThen;
+        }
     }
     return -1;
 }

Find a functionally equivalent code:android.media.AudioService.setRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#setRingerMode(int)
 */

@@ -1,10 +1,13 @@
 {
-    if (mUseFixedVolume) {
+    if (mUseFixedVolume || isPlatformTelevision()) {
         return;
     }
     if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
         ringerMode = AudioManager.RINGER_MODE_SILENT;
     }
+    if (checkZen) {
+        checkZen(ringerMode);
+    }
     if (ringerMode != getRingerMode()) {
         setRingerModeInt(ringerMode, true);
         // Send sticky broadcast

Find a functionally equivalent code:com.android.smoketest.ProcessErrorsTest.runOneActivity:COMMENT
Method Modifier: public      
Comment:/**
 * A method to run the specified Activity and return a {@link Collection} of the Activities that
 * were in an error state, as listed by {@link ActivityManager.getProcessesInErrorState()}.
 * <p />
 * The method will launch the app, wait for 7 seconds, check for apps in the error state, send
 * the Home intent, wait for 2 seconds, and then return.
 */

@@ -8,13 +8,17 @@
     final Collection<ProcessError> preErrProcs = ProcessError.fromCollection(mActivityManager.getProcessesInErrorState());
     // launch app, and wait 7 seconds for it to start/settle
     final Intent intent = intentForActivity(app);
+    if (intent == null) {
+        Log.i(TAG, String.format("Activity %s/%s is disabled, skipping", app.activityInfo.packageName, app.activityInfo.name));
+        return Collections.EMPTY_LIST;
+    }
     getContext().startActivity(intent);
     try {
         Thread.sleep(appLaunchWait);

Find a functionally equivalent code:android.widget.OverScroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location. If it returns true, the
 * animation is not yet finished.
 */

@@ -10,21 +10,16 @@
             final long elapsedTime = time - mScrollerX.mStartTime;
             final int duration = mScrollerX.mDuration;
             if (elapsedTime < duration) {
-                float q = (float) (elapsedTime) / duration;
-                if (mInterpolator == null) {
-                    q = Scroller.viscousFluid(q);
-                } else {
-                    q = mInterpolator.getInterpolation(q);
-                }
+                final float q = mInterpolator.getInterpolation(elapsedTime / (float) duration);
                 mScrollerX.updateScroll(q);
                 mScrollerY.updateScroll(q);
             } else {

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.setSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the source to be a virtual descendant of the given <code>root</code>.
 * If <code>virtualDescendantId</code> is {@link View#NO_ID} the root
 * is set as the source.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report themselves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 */

@@ -1,6 +1,6 @@
 {
     enforceNotSealed();
-    mWindowId = (root != null) ? root.getAccessibilityWindowId() : UNDEFINED;
-    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
+    mWindowId = (root != null) ? root.getAccessibilityWindowId() : UNDEFINED_ITEM_ID;
+    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
     mSourceNodeId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
 }

Find a functionally equivalent code:android.widget.DatePicker.getSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the spinners are shown.
 *
 * @return True if the spinners are shown.
 */

@@ -1,3 +1,3 @@
 {
-    return mSpinners.isShown();
+    return mDelegate.getSpinnersShown();
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.usingBiometricWeak:COMMENT
Method Modifier: public      internal    
Comment:/**
 * @return true if the lockscreen method is set to biometric weak
 */

@@ -1,4 +1,4 @@
 {
-    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
+    int quality = (int) getLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
     return quality == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindow.updateProgressBars:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Updates the progress bars that are shown in the title bar.
 *
 * @param value Can be one of {@link Window#PROGRESS_VISIBILITY_ON},
 * {@link Window#PROGRESS_VISIBILITY_OFF},
 * {@link Window#PROGRESS_INDETERMINATE_ON},
 * {@link Window#PROGRESS_INDETERMINATE_OFF}, or a value
 * starting at {@link Window#PROGRESS_START} through
 * {@link Window#PROGRESS_END} for setting the default
 * progress (if {@link Window#PROGRESS_END} is given,
 * the progress bar widgets in the title will be hidden after an
 * animation), a value between
 * {@link Window#PROGRESS_SECONDARY_START} -
 * {@link Window#PROGRESS_SECONDARY_END} for the
 * secondary progress (if
 * {@link Window#PROGRESS_SECONDARY_END} is given, the
 * progress bar widgets will still be shown with the secondary
 * progress bar will be completely filled in.)
 */

@@ -4,39 +4,69 @@
     final int features = getLocalFeatures();
     if (value == PROGRESS_VISIBILITY_ON) {
         if ((features & (1 << FEATURE_PROGRESS)) != 0) {
-            int level = horizontalProgressBar.getProgress();
-            int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ? View.VISIBLE : View.INVISIBLE;
-            horizontalProgressBar.setVisibility(visibility);
+            if (horizontalProgressBar != null) {
+                int level = horizontalProgressBar.getProgress();
+                int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ? View.VISIBLE : View.INVISIBLE;
+                horizontalProgressBar.setVisibility(visibility);
+            } else {
+                Log.e(TAG, "Horizontal progress bar not located in current window decor");
+            }
         }
         if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
-            circularProgressBar.setVisibility(View.VISIBLE);
+            if (circularProgressBar != null) {
+                circularProgressBar.setVisibility(View.VISIBLE);
+            } else {
+                Log.e(TAG, "Circular progress bar not located in current window decor");
+            }
         }
     } else if (value == PROGRESS_VISIBILITY_OFF) {
         if ((features & (1 << FEATURE_PROGRESS)) != 0) {
-            horizontalProgressBar.setVisibility(View.GONE);
+            if (horizontalProgressBar != null) {
+                horizontalProgressBar.setVisibility(View.GONE);
+            } else {
+                Log.e(TAG, "Horizontal progress bar not located in current window decor");
+            }
         }
         if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {
-            circularProgressBar.setVisibility(View.GONE);
+            if (circularProgressBar != null) {
+                circularProgressBar.setVisibility(View.GONE);
+            } else {
+                Log.e(TAG, "Circular progress bar not located in current window decor");
+            }
         }
     } else if (value == PROGRESS_INDETERMINATE_ON) {
-        horizontalProgressBar.setIndeterminate(true);
+        if (horizontalProgressBar != null) {
+            horizontalProgressBar.setIndeterminate(true);
+        } else {
+            Log.e(TAG, "Horizontal progress bar not located in current window decor");
+        }
     } else if (value == PROGRESS_INDETERMINATE_OFF) {
-        horizontalProgressBar.setIndeterminate(false);
+        if (horizontalProgressBar != null) {
+            horizontalProgressBar.setIndeterminate(false);
+        } else {
+            Log.e(TAG, "Horizontal progress bar not located in current window decor");
+        }
     } else if (PROGRESS_START <= value && value <= PROGRESS_END) {
-        // We want to set the progress value before testing for visibility
-        // so that when the progress bar becomes visible again, it has the
         // correct level.
-        horizontalProgressBar.setProgress(value - PROGRESS_START);
+        if (horizontalProgressBar != null) {
+            horizontalProgressBar.setProgress(value - PROGRESS_START);
+        } else {
+            Log.e(TAG, "Horizontal progress bar not located in current window decor");
+        }
         if (value < PROGRESS_END) {
             showProgressBars(horizontalProgressBar, circularProgressBar);
         } else {
             hideProgressBars(horizontalProgressBar, circularProgressBar);
         }
     } else if (PROGRESS_SECONDARY_START <= value && value <= PROGRESS_SECONDARY_END) {
-        horizontalProgressBar.setSecondaryProgress(value - PROGRESS_SECONDARY_START);
+        if (horizontalProgressBar != null) {
+            horizontalProgressBar.setSecondaryProgress(value - PROGRESS_SECONDARY_START);
+        } else {
+            Log.e(TAG, "Horizontal progress bar not located in current window decor");
+        }
         showProgressBars(horizontalProgressBar, circularProgressBar);
     }
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onClockVisibilityChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onClockVisibilityChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when visibility of lockscreen clock changes, such as when
 * obscured by a widget.
 */


Find a functionally equivalent code:android.graphics.Canvas.clipPath:COMMENT
Method Modifier: public      
Comment:/**
 * Intersect the current clip with the specified path.
 *
 * @param path The path to intersect with the current clip
 * @return     true if the resulting is non-empty
 */


Find a functionally equivalent code:android.app.Activity.onMenuOpened:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * @return The default implementation returns true.
 */

@@ -1,6 +1,6 @@
 {
     if (featureId == Window.FEATURE_ACTION_BAR) {
-        initActionBar();
+        initWindowDecorActionBar();
         if (mActionBar != null) {
             mActionBar.dispatchMenuVisibilityChanged(true);
         } else {

Find a functionally equivalent code:android.widget.CalendarView.getFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in the focused month.
 *
 * @return The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

@@ -1,3 +1,3 @@
 {
-    return mFocusedMonthDateColor;
+    return mDelegate.getFocusedMonthDateColor();
 }

Find a functionally equivalent code:android.service.notification.StatusBarNotification.cloneLight:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -2,6 +2,6 @@
     final Notification no = new Notification();
     // light copy
     this.notification.cloneInto(no, false);
-    return new StatusBarNotification(this.pkg, this.basePkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
+    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
 }

Find a functionally equivalent code:android.graphics.drawable.BitmapDrawable.getBitmap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the bitmap used by this drawable to render. May be null.
 */

@@ -1,3 +1,3 @@
 {
-    return mBitmap;
+    return mBitmapState.mBitmap;
 }

Find a functionally equivalent code:android.graphics.Canvas.getWidth:COMMENT
<android.graphics.Canvas: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the width of the current drawing layer
 *
 * @return the width of the current drawing layer
 */

@@ -1 +1,3 @@
-
+{
+    return native_getWidth(mNativeCanvasWrapper);
+}

Find a functionally equivalent code:android.os.UserManager.getMaxSupportedUsers:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the maximum number of users that can be created on this device. A return value
 * of 1 means that it is a single user device.
 * @hide
 * @return a value greater than or equal to 1
 */

@@ -2,6 +2,9 @@
     // Don't allow multiple users on certain builds
     if (android.os.Build.ID.startsWith("JVP"))
         return 1;
+    // Svelte devices don't get multi-user.
+    if (ActivityManager.isLowRamDeviceStatic())
+        return 1;
     return SystemProperties.getInt("fw.max_users", Resources.getSystem().getInteger(R.integer.config_multiuserMaximumUsers));
 }

Find a functionally equivalent code:android.widget.FastScroller.transitionToVisible:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb and track.
 */

@@ -8,11 +8,12 @@
     mDecorAnimation = new AnimatorSet();
     mDecorAnimation.playTogether(fadeIn, fadeOut, slideIn);
     mDecorAnimation.start();
+    mShowingPreview = false;
 }

Find a functionally equivalent code:android.content.ContentProvider.attachInfo:COMMENT
Method Modifier: public      
Comment:/**
 * After being instantiated, this is called to tell the content provider
 * about itself.
 *
 * @param context The context this provider is running in
 * @param info Registered information about this content provider
 */


Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.updateEncryptionPassword:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Update the encryption password if it is enabled *
 */

@@ -1,17 +1,23 @@
 {
-    DevicePolicyManager dpm = getDevicePolicyManager();
-    if (dpm.getStorageEncryptionStatus(getCurrentOrCallingUserId()) != DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE) {
+    if (!isDeviceEncryptionEnabled()) {
         return;
     }
-    IBinder service = ServiceManager.getService("mount");
+    final IBinder service = ServiceManager.getService("mount");
     if (service == null) {
         Log.e(TAG, "Could not find the mount service to update the encryption password");
         return;
     }
-    IMountService mountService = IMountService.Stub.asInterface(service);
-    try {
-        mountService.changeEncryptionPassword(password);
-    } catch (RemoteException e) {
-        Log.e(TAG, "Error changing encryption password", e);
-    }
+    new AsyncTask<Void, Void, Void>() {
+
+        @Override
+        protected Void doInBackground(Void... dummy) {
+            IMountService mountService = IMountService.Stub.asInterface(service);
+            try {
+                mountService.changeEncryptionPassword(type, password);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error changing encryption password", e);
+            }
+            return null;
+        }
+    }.execute();
 }

Find a functionally equivalent code:android.widget.CalendarView.getDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @return The selected date.
 */

@@ -1,3 +1,3 @@
 {
-    return mAdapter.mSelectedDate.getTimeInMillis();
+    return mDelegate.getDate();
 }

Find a functionally equivalent code:android.widget.CalendarView.setOnDateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be notified upon selected date change.
 *
 * @param listener The listener to be notified.
 */

@@ -1,3 +1,3 @@
 {
-    mOnDateChangeListener = listener;
+    mDelegate.setOnDateChangeListener(listener);
 }

Find a functionally equivalent code:android.text.Layout.measurePara:COMMENT
Method Modifier: default     static      
Comment:/* package */

@@ -16,21 +16,30 @@
         int len = mt.mLen;
         boolean hasTabs = false;
         TabStops tabStops = null;
+        // leading margins should be taken into account when measuring a paragraph
+        int margin = 0;
+        if (text instanceof Spanned) {
+            Spanned spanned = (Spanned) text;
+            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
+            for (LeadingMarginSpan lms : spans) {
+                margin += lms.getLeadingMargin(true);
+            }
+        }
         for (int i = 0; i < len; ++i) {
             if (chars[i] == '\t') {
                 hasTabs = true;
@@ -31,37 +40,46 @@
             }
         }
         tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
-        return tl.metrics(null);
+        return margin + tl.metrics(null);
     } finally {
         TextLine.recycle(tl);
         MeasuredText.recycle(mt);

Find a functionally equivalent code:android.content.ContentResolver.setSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set whether or not the provider is synced when it receives a network tickle.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being controlled
 * @param sync true if the provider should be synced when tickles are received for it
 */

@@ -1,8 +1,3 @@
 {
-    try {
-        getContentService().setSyncAutomatically(account, authority, sync);
-    } catch (RemoteException e) {
-    // exception ignored; if this is thrown then it means the runtime is in the midst of
-    // being restarted
-    }
+    setSyncAutomaticallyAsUser(account, authority, sync, UserHandle.myUserId());
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.Arguments.parseArgs:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Parses the commandline arguments intended for the Zygote spawner
 * (such as "--setuid=" and "--setgid=") and creates an array
 * containing the remaining args.
 *
 * Per security review bug #1112214, duplicate args are disallowed in
 * critical cases to make injection harder.
 */

@@ -106,111 +106,117 @@
             mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER;
         } else if (arg.equals("--mount-external-multiuser-all")) {
             mountExternal = Zygote.MOUNT_EXTERNAL_MULTIUSER_ALL;
+        } else if (arg.equals("--query-abi-list")) {
+            abiListQuery = true;
+        } else if (arg.startsWith("--instruction-set=")) {
+            instructionSet = arg.substring(arg.indexOf('=') + 1);
+        } else if (arg.startsWith("--app-data-dir=")) {
+            appDataDir = arg.substring(arg.indexOf('=') + 1);
         } else {
             break;
         }

Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.scrapActiveViews:COMMENT
Method Modifier: 
Comment:/**
 * Move all views remaining in mActiveViews to mScrapViews.
 */

@@ -8,46 +8,49 @@
         final View victim = activeViews[i];
         if (victim != null) {
             final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
-            int whichScrap = lp.viewType;
+            final int whichScrap = lp.viewType;
             activeViews[i] = null;
-            final boolean scrapHasTransientState = victim.hasTransientState();
-            if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
-                // Do not move views that should be ignored
-                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
+            if (victim.hasTransientState()) {
+                // Store views with transient state for later use.
+                victim.dispatchStartTemporaryDetach();
+                if (mAdapter != null && mAdapterHasStableIds) {
+                    if (mTransientStateViewsById == null) {
+                        mTransientStateViewsById = new LongSparseArray<View>();
+                    }
+                    long id = mAdapter.getItemId(mFirstActivePosition + i);
+                    mTransientStateViewsById.put(id, victim);
+                } else if (!mDataChanged) {
+                    if (mTransientStateViews == null) {
+                        mTransientStateViews = new SparseArray<View>();
+                    }
+                    mTransientStateViews.put(mFirstActivePosition + i, victim);
+                } else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
+                    // The data has changed, we can't keep this view.
                     removeDetachedView(victim, false);
                 }
-                if (scrapHasTransientState) {
-                    if (mAdapter != null && mAdapterHasStableIds) {
-                        if (mTransientStateViewsById == null) {
-                            mTransientStateViewsById = new LongSparseArray<View>();
-                        }
-                        long id = mAdapter.getItemId(mFirstActivePosition + i);
-                        mTransientStateViewsById.put(id, victim);
-                    } else {
-                        if (mTransientStateViews == null) {
-                            mTransientStateViews = new SparseArray<View>();
-                        }
-                        mTransientStateViews.put(mFirstActivePosition + i, victim);
-                    }
+            } else if (!shouldRecycleViewType(whichScrap)) {
+                // Discard non-recyclable views except headers/footers.
+                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
+                    removeDetachedView(victim, false);
                 }
-                continue;
-            }
-            if (multipleScraps) {
-                scrapViews = mScrapViews[whichScrap];
-            }
-            victim.dispatchStartTemporaryDetach();
-            lp.scrappedFromPosition = mFirstActivePosition + i;
-            scrapViews.add(victim);
-            victim.setAccessibilityDelegate(null);
-            if (hasListener) {
-                mRecyclerListener.onMovedToScrapHeap(victim);
+            } else {
+                // Store everything else on the appropriate scrap heap.
+                if (multipleScraps) {
+                    scrapViews = mScrapViews[whichScrap];
+                }
+                victim.dispatchStartTemporaryDetach();
+                lp.scrappedFromPosition = mFirstActivePosition + i;
+                scrapViews.add(victim);
+                if (hasListener) {
+                    mRecyclerListener.onMovedToScrapHeap(victim);
+                }
             }
         }
     }

Find a functionally equivalent code:android.view.MenuInflater.parseMenu:COMMENT
Method Modifier: private     
Comment:/**
 * Called internally to fill the given menu. If a sub menu is seen, it will
 * call this recursively.
 */

@@ -32,37 +32,38 @@
                 } else if (tagName.equals(XML_MENU)) {
                     // A menu start tag denotes a submenu for an item
                     SubMenu subMenu = menuState.addSubMenuItem();
+                    registerMenu(subMenu, attrs);
                     // Parse the submenu into returned SubMenu
                     parseMenu(parser, attrs, subMenu);
                 } else {
@@ -50,58 +51,59 @@
                     // a submenu, it would have been added already)
                     if (!menuState.hasAddedItem()) {
                         if (menuState.itemActionProvider != null && menuState.itemActionProvider.hasSubMenu()) {
-                            menuState.addSubMenuItem();
+                            registerMenu(menuState.addSubMenuItem(), attrs);
                         } else {
-                            menuState.addItem();
+                            registerMenu(menuState.addItem(), attrs);
                         }
                     }
                 } else if (tagName.equals(XML_MENU)) {

Find a functionally equivalent code:android.net.ConnectivityManager.getLinkProperties:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the IP information for a given network type.
 *
 * @param networkType the network type of interest.
 * @return a {@link LinkProperties} object describing the IP info
 * for the given networkType, or {@code null} if there is
 * no current default network.
 *
 * <p>This method requires the call to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 * {@hide}
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return mService.getLinkProperties(networkType);
+        return mService.getLinkPropertiesForType(networkType);
     } catch (RemoteException e) {
         return null;
     }

Find a functionally equivalent code:android.app.backup.FullBackup.restoreFile:COMMENT
Method Modifier: public      static      
Comment:/**
 * Copy data from a socket to the given File location on permanent storage.  The
 * modification time and access mode of the resulting file will be set if desired,
 * although group/all rwx modes will be stripped: the restored file will not be
 * accessible from outside the target application even if the original file was.
 * If the {@code type} parameter indicates that the result should be a directory,
 * the socket parameter may be {@code null}; even if it is valid, no data will be
 * read from it in this case.
 * <p>
 * If the {@code mode} argument is negative, then the resulting output file will not
 * have its access mode or last modification time reset as part of this operation.
 *
 * @param data Socket supplying the data to be copied to the output file.  If the
 * output is a directory, this may be {@code null}.
 * @param size Number of bytes of data to copy from the socket to the file.  At least
 * this much data must be available through the {@code data} parameter.
 * @param type Must be either {@link BackupAgent#TYPE_FILE} for ordinary file data
 * or {@link BackupAgent#TYPE_DIRECTORY} for a directory.
 * @param mode Unix-style file mode (as used by the chmod(2) syscall) to be set on
 * the output file or directory.  group/all rwx modes are stripped even if set
 * in this parameter.  If this parameter is negative then neither
 * the mode nor the mtime values will be applied to the restored file.
 * @param mtime A timestamp in the standard Unix epoch that will be imposed as the
 * last modification time of the output file.  if the {@code mode} parameter is
 * negative then this parameter will be ignored.
 * @param outFile Location within the filesystem to place the data.  This must point
 * to a location that is writeable by the caller, preferably using an absolute path.
 * @throws IOException
 */

@@ -51,57 +51,57 @@
         try {
             // explicitly prevent emplacement of files accessible by outside apps
             mode &= 0700;
-            Libcore.os.chmod(outFile.getPath(), (int) mode);
+            Os.chmod(outFile.getPath(), (int) mode);
         } catch (ErrnoException e) {
             e.rethrowAsIOException();
         }

Find a functionally equivalent code:com.android.compatibilitytest.AppCompatibility.testAppStability:COMMENT
Method Modifier: public      
Comment:/**
 * Actual test case that launches the package and throws an exception on the
 * first error.
 *
 * @throws Exception
 */

@@ -2,12 +2,12 @@
     String packageName = mArgs.getString(PACKAGE_TO_LAUNCH);
     if (packageName != null) {
         Log.d(TAG, "Launching app " + packageName);
-        Collection<ProcessErrorStateInfo> err = launchActivity(packageName);
+        ProcessErrorStateInfo err = launchActivity(packageName);
         // Make sure there are no errors when launching the application,
         // otherwise raise an
         // exception with the first error encountered.
-        assertNull(getFirstError(err), err);
+        assertNull(getStackTrace(err), err);
         assertTrue("App crashed after launch.", processStillUp(packageName));
     } else {
         Log.d(TAG, "Missing argument, use " + PACKAGE_TO_LAUNCH + " to specify the package to launch");

Find a functionally equivalent code:android.graphics.Paint_Delegate.measureText:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -1,3 +1,3 @@
 {
-    return new BidiRenderer(null, this, text).renderText(index, index + count, isRtl, null, 0, false, 0, 0);
+    return new BidiRenderer(null, this, text).renderText(index, index + count, bidiFlags, advances, advancesIndex, false);
 }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setFloatValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of floats.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

@@ -1,4 +1,4 @@
 {
     mValueType = float.class;
-    mKeyframeSet = KeyframeSet.ofFloat(values);
+    mKeyframes = KeyframeSet.ofFloat(values);
 }

Find a functionally equivalent code:android.app.IActivityManager.profileControl:COMMENT
Method Modifier: public      
Comment:// Turn on/off profiling in a particular process.


Find a functionally equivalent code:android.content.RestrictionEntry.getAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of currently selected values.
 * @return the list of current selections, if type is {@link #TYPE_MULTI_SELECT},
 * null otherwise.
 */

@@ -1,3 +1,3 @@
 {
-    return currentValues;
+    return mCurrentValues;
 }

Find a functionally equivalent code:android.transition.Transition.captureHierarchy:COMMENT
Method Modifier: private     
Comment:/**
 * Recursive method which captures values for an entire view hierarchy,
 * starting at some root view. Transitions without targetIDs will use this
 * method to capture values for all possible views.
 *
 * @param view The view for which to capture values. Children of this View
 * will also be captured, recursively down to the leaf nodes.
 * @param start true if values are being captured in the start scene, false
 * otherwise.
 */

@@ -2,25 +2,8 @@
     if (view == null) {
         return;
     }
-    boolean isListViewItem = false;
-    if (view.getParent() instanceof ListView) {
-        isListViewItem = true;
-    }
-    if (isListViewItem && !((ListView) view.getParent()).getAdapter().hasStableIds()) {
-        // ignore listview children unless we can track them with stable IDs
-        return;
-    }
-    int id = View.NO_ID;
-    long itemId = View.NO_ID;
-    if (!isListViewItem) {
-        id = view.getId();
-    } else {
-        ListView listview = (ListView) view.getParent();
-        int position = listview.getPositionForView(view);
-        itemId = listview.getItemIdAtPosition(position);
-        view.setHasTransientState(true);
-    }
+    int id = view.getId();
     if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
         return;
     }
@@ -34,63 +17,36 @@
             }
         }
     }
-    TransitionValues values = new TransitionValues();
-    values.view = view;
-    if (start) {
-        captureStartValues(values);
-    } else {
-        captureEndValues(values);
-    }
-    if (start) {
-        if (!isListViewItem) {
-            mStartValues.viewValues.put(view, values);
-            if (id >= 0) {
-                mStartValues.idValues.put((int) id, values);
-            }
+    if (view.getParent() instanceof ViewGroup) {
+        TransitionValues values = new TransitionValues();
+        values.view = view;
+        if (start) {
+            captureStartValues(values);
         } else {
-            mStartValues.itemIdValues.put(itemId, values);
+            captureEndValues(values);
         }
-    } else {
-        if (!isListViewItem) {
-            mEndValues.viewValues.put(view, values);
-            if (id >= 0) {
-                mEndValues.idValues.put((int) id, values);
-            }
+        values.targetedTransitions.add(this);
+        capturePropagationValues(values);
+        if (start) {
+            addViewValues(mStartValues, view, values);
         } else {
-            mEndValues.itemIdValues.put(itemId, values);
+            addViewValues(mEndValues, view, values);
         }
     }
     if (view instanceof ViewGroup) {
@@ -68,74 +41,47 @@
         if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
             return;
         }
-        if (mTargetTypeChildExcludes != null && view != null) {
+        if (mTargetTypeChildExcludes != null) {
             int numTypes = mTargetTypeChildExcludes.size();
             for (int i = 0; i < numTypes; ++i) {
                 if (mTargetTypeChildExcludes.get(i).isInstance(view)) {

Find a functionally equivalent code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

@@ -12,17 +12,30 @@
         if (LOG_V)
             Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
         ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
+        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
+            String front = info.crashInfo.stackTrace.substring(256);
+            // First, drain the remaining violations from the parcel.
+            while (i < numViolations) {
+                info = new ViolationInfo(p, !currentlyGathering);
+                i++;
+            }
+            // Next clear out all gathered violations.
+            clearGatheredViolations();
+            // Now report the problem.
+            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
+            return;
+        }
         info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
         BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
         if (policy instanceof AndroidBlockGuardPolicy) {

Find a functionally equivalent code:android.media.MediaPlayer.setAudioStreamType:COMMENT
<android.media.MediaPlayer: void setAudioStreamType(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the audio stream type for this MediaPlayer. See {@link AudioManager}
 * for a list of stream types. Must call this method before prepare() or
 * prepareAsync() in order for the target stream type to become effective
 * thereafter.
 *
 * @param streamtype the audio stream type
 * @see android.media.AudioManager
 */

@@ -1 +1,4 @@
-
+{
+    _setAudioStreamType(streamtype);
+    mStreamType = streamtype;
+}

Find a functionally equivalent code:android.os.Bundle.getByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a byte[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (byte[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "byte[]", e);
-        return null;
-    }
+    return super.getByteArray(key);
 }

Find a functionally equivalent code:android.service.dreams.DreamService.detach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.
 *
 * Must run on mHandler.
 */

@@ -1,24 +1,21 @@
 {
-    if (mWindow == null) {
-        // already detached!
-        return;
-    }
-    try {
+    if (mStarted) {
+        if (mDebug)
+            Slog.v(TAG, "detach(): Calling onDreamingStopped()");
+        mStarted = false;
         onDreamingStopped();
-    } catch (Throwable t) {
-        Slog.w(TAG, "Crashed in onDreamingStopped()", t);
-    // we were going to stop anyway
     }
-    if (mDebug)
-        Slog.v(TAG, "detach(): Removing window from window manager");
-    try {
+    if (mWindow != null) {
         // force our window to be removed synchronously
-        mWindowManager.removeViewImmediate(mWindow.getDecorView());
+        if (mDebug)
+            Slog.v(TAG, "detach(): Removing window from window manager");
+        mWindow.getWindowManager().removeViewImmediate(mWindow.getDecorView());
+        mWindow = null;
+    }
+    if (mWindowToken != null) {
         // the following will print a log message if it finds any other leaked windows
         WindowManagerGlobal.getInstance().closeAll(mWindowToken, this.getClass().getName(), "Dream");
-    } catch (Throwable t) {
-        Slog.w(TAG, "Crashed removing window view", t);
+        mWindowToken = null;
+        mCanDoze = false;
     }
-    mWindow = null;
-    mWindowToken = null;
 }

Find a functionally equivalent code:android.widget.TimePicker.getCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current minute.
 */

@@ -1,3 +1,3 @@
 {
-    return mMinuteSpinner.getValue();
+    return mDelegate.getCurrentMinute();
 }

Find a functionally equivalent code:android.widget.Switch.hitThumb:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if (x, y) is within the target area of the switch thumb
 */

@@ -1,7 +1,9 @@
 {
+    // Relies on mTempRect, MUST be called first!
+    final int thumbOffset = getThumbOffset();
     mThumbDrawable.getPadding(mTempRect);
     final int thumbTop = mSwitchTop - mTouchSlop;
-    final int thumbLeft = mSwitchLeft + (int) (mThumbPosition + 0.5f) - mTouchSlop;
+    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
     final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
     final int thumbBottom = mSwitchBottom + mTouchSlop;
     return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_GrammarAllowOnly:COMMENT
Method Modifier: private     static      native      
Comment:// transcription, SR_SemanticResult** result, size_t* resultCount);


Find a functionally equivalent code:android.text.method.Touch.onTouchEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */

@@ -21,38 +21,46 @@
         case MotionEvent.ACTION_MOVE:
             ds = buffer.getSpans(0, buffer.length(), DragState.class);
             if (ds.length > 0) {
+                ds[0].mIsSelectionStarted = false;
                 if (ds[0].mFarEnough == false) {
                     int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                     if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                         ds[0].mFarEnough = true;
+                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
+                            ds[0].mIsActivelySelecting = true;
+                            ds[0].mIsSelectionStarted = true;
+                        }
                     }
                 }
                 if (ds[0].mFarEnough) {
                     ds[0].mUsed = true;
                     boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
+                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
+                        ds[0].mIsActivelySelecting = false;
+                    }
                     float dx;
                     float dy;
-                    if (cap) {
+                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                         // if we're selecting, we want the scroll to go in
                         // the direction of the drag
                         dx = event.getX() - ds[0].mX;
@@ -51,57 +59,67 @@
                     ny = Math.max(ny, 0);
                     int oldX = widget.getScrollX();
                     int oldY = widget.getScrollY();
-                    scrollTo(widget, layout, nx, ny);
+                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
+                        scrollTo(widget, layout, nx, ny);
+                    }
                     // If we actually scrolled, then cancel the up action.
                     if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                         widget.cancelLongPress();

Find a functionally equivalent code:android.view.Surface.transferFrom:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * This is intended to be used by {@link SurfaceView#updateWindow} only.
 * @param other access is not thread safe
 * @hide
 * @deprecated
 */

@@ -3,9 +3,9 @@
         throw new IllegalArgumentException("other must not be null");
     }
     if (other != this) {
-        final int newPtr;
+        final long newPtr;
         synchronized (other.mLock) {
             newPtr = other.mNativeObject;
             other.setNativeObjectLocked(0);

Find a functionally equivalent code:android.view.accessibility.AccessibilityEvent.getRecordCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of records contained in the event.
 *
 * @return The number of records.
 */

@@ -1,3 +1,3 @@
 {
-    return mRecords.size();
+    return mRecords == null ? 0 : mRecords.size();
 }

Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.isRunning:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Indicates whether the animation is currently running or not.</p>
 *
 * @return true if the animation is running, false otherwise
 */

@@ -1,3 +1,3 @@
 {
-    return mCurFrame > -1;
+    return mRunning;
 }

Find a functionally equivalent code:android.os.Bundle.getCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (ArrayList<CharSequence>) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "ArrayList<CharSequence>", e);
-        return null;
-    }
+    return super.getCharSequenceArrayList(key);
 }

Find a functionally equivalent code:android.content.res.TypedArray.peekValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     final TypedValue value = mValue;
     if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
         return value;

Find a functionally equivalent code:android.os.Bundle.getBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (boolean[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "byte[]", e);
-        return null;
-    }
+    return super.getBooleanArray(key);
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onSimStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onSimStateChanged(State)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the SIM state changes.
 * @param simState
 */


Find a functionally equivalent code:android.widget.FastScroller.scrollTo:COMMENT
Method Modifier: private     
Comment:/**
 * Scrolls to a specific position within the section
 * @param position
 */

@@ -87,95 +87,96 @@
     }
     if (mCurrentSection != sectionIndex) {
         mCurrentSection = sectionIndex;
-        if (transitionPreviewLayout(sectionIndex)) {
+        final boolean hasPreview = transitionPreviewLayout(sectionIndex);
+        if (!mShowingPreview && hasPreview) {
             transitionToDragging();
-        } else {
+        } else if (mShowingPreview && !hasPreview) {
             transitionToVisible();
         }
     }

Find a functionally equivalent code:android.widget.ListView.arrowScrollImpl:COMMENT
Method Modifier: private     
Comment:/**
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable,
 * whether there are focusable items etc.
 *
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */

@@ -51,57 +51,57 @@
     }
     if (needToRedraw) {
         if (selectedView != null) {
-            positionSelector(selectedPos, selectedView);
+            positionSelectorLikeFocus(selectedPos, selectedView);
             mSelectedTop = selectedView.getTop();
         }
         if (!awakenScrollBars()) {

Find a functionally equivalent code:android.content.RestrictionEntry.setDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible description of the entry, as a possible sub-text for the title.
 * You can use this to describe the entry in more detail or to display the current state of
 * the restriction.
 * @param description the user-visible description string.
 */

@@ -1,3 +1,3 @@
 {
-    this.description = description;
+    this.mDescription = description;
 }

Find a functionally equivalent code:android.media.MediaFocusControl.registerMediaButtonIntent:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.registerMediaButtonIntent(PendingIntent pi, ComponentName c)
 * precondition: mediaIntent != null
 */

@@ -1,10 +1,9 @@
 {
     Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
-    synchronized (mAudioFocusLock) {
-        synchronized (mRCStack) {
-            pushMediaButtonReceiver_syncAfRcs(mediaIntent, eventReceiver, token);
+    synchronized (mPRStack) {
+        if (pushMediaButtonReceiver_syncPrs(mediaIntent, eventReceiver, token)) {
             // new RC client, assume every type of information shall be queried
-            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
+            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
         }
     }
 }

Find a functionally equivalent code:com.android.framework.permission.tests.VibratorServicePermissionTest.testVibrate:COMMENT
Method Modifier: public      
Comment:/**
 * Test that calling {@link android.os.IVibratorService#vibrate(long)} requires permissions.
 * <p>Tests permission:
 * {@link android.Manifest.permission#VIBRATE}
 * @throws RemoteException
 */

@@ -1,6 +1,6 @@
 {
     try {
-        mVibratorService.vibrate(Process.myUid(), null, 2000, new Binder());
+        mVibratorService.vibrate(Process.myUid(), null, 2000, AudioManager.STREAM_ALARM, new Binder());
         fail("vibrate did not throw SecurityException as expected");
     } catch (SecurityException e) {
     // expected

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.runDownloadMultipleAirplaneModeEnableDisable:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that downloads resume when switching on/off Airplane mode numerous times at
 * various intervals.
 *
 * Note: Device has no mobile access when running this test.
 *
 * @throws Exception if unsuccessful
 */

@@ -1,6 +1,6 @@
 {
-    String filename = DOWNLOAD_5MB_FILENAME;
-    long filesize = DOWNLOAD_5MB_FILESIZE;
+    String filename = DOWNLOAD_FILENAME;
+    long filesize = DOWNLOAD_FILESIZE;
     // make sure WiFi is enabled, and airplane mode is not on
     doCommonDownloadSetup();
     String localDownloadDirectory = Environment.getExternalStorageDirectory().getPath();
@@ -20,26 +20,26 @@
         dlRequest = mDownloadManager.enqueue(request);
         waitForDownloadToStart(dlRequest);
         // are we making any progress?
-        waitForFileToGrow(downloadedFile);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // download disable
         Log.i(LOG_TAG, "Turning on Airplane mode...");
         setAirplaneModeOn(true);
@@ -30,36 +30,36 @@
         Log.i(LOG_TAG, "Turning off Airplane mode...");
         setAirplaneModeOn(false);
         // make sure we're starting to download some data...
-        waitForFileToGrow(downloadedFile);
+        waitToReceiveData(dlRequest, EXPECTED_PROGRESS);
         // reenable the connection to start up the download again
         Log.i(LOG_TAG, "Turning on Airplane mode again...");
         setAirplaneModeOn(true);
@@ -39,47 +39,47 @@
         // Finish up the download...
         Log.i(LOG_TAG, "Turning off Airplane mode again...");
         setAirplaneModeOn(false);
-        Log.i(LOG_TAG, "Waiting up to 3 minutes for donwload to complete...");
-        // wait up to 3 mins before timeout
-        waitForDownloadsOrTimeout(dlRequest, 180 * 1000);
+        Log.i(LOG_TAG, "Waiting up to 10 minutes for donwload to complete...");
+        // wait up to 10 mins
+        assertTrue("download not finished", waitForDownload(dlRequest, 10 * 60 * 1000));
         ParcelFileDescriptor pfd = mDownloadManager.openDownloadedFile(dlRequest);
         verifyFileSize(pfd, filesize);
     } finally {

Find a functionally equivalent code:android.view.LayoutInflater_Delegate.rInflate:COMMENT
Method Modifier: default     static      
Comment:/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 *
 * This implementation just records the merge status before calling the default implementation.
 */

@@ -6,12 +6,12 @@
         }
     }
     // ---- START DEFAULT IMPLEMENTATION.
-    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate);
+    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate, inheritContext);
     if (finishInflate == false) {
         // this is a merge rInflate!
         if (thisInflater instanceof BridgeInflater) {

Find a functionally equivalent code:android.graphics.Canvas.drawPaint:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with
 * the specified paint. This is equivalent (but faster) to drawing an
 * infinitely large rectangle with the specified paint.
 *
 * @param paint The paint used to draw onto the canvas
 */

@@ -1,3 +1,3 @@
 {
-    native_drawPaint(mNativeCanvas, paint.mNativePaint);
+    native_drawPaint(mNativeCanvasWrapper, paint.mNativePaint);
 }

Find a functionally equivalent code:com.android.internal.util.FileRotator.maybeRotate:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Examine all files managed by this rotator, renaming or deleting if their
 * age matches the configured thresholds.
 */

@@ -2,8 +2,12 @@
     final long rotateBefore = currentTimeMillis - mRotateAgeMillis;
     final long deleteBefore = currentTimeMillis - mDeleteAgeMillis;
     final FileInfo info = new FileInfo(mPrefix);
-    for (String name : mBasePath.list()) {
+    String[] baseFiles = mBasePath.list();
+    if (baseFiles == null) {
+        return;
+    }
+    for (String name : baseFiles) {
         if (!info.parse(name))
             continue;
         if (info.isActive()) {

Find a functionally equivalent code:android.preference.DialogPreference.setDialogIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the icon (resource ID) of the dialog. This will be shown on
 * subsequent dialogs.
 *
 * @param dialogIconRes The icon, as a resource ID.
 */

@@ -1,3 +1,3 @@
 {
-    mDialogIcon = getContext().getResources().getDrawable(dialogIconRes);
+    mDialogIcon = getContext().getDrawable(dialogIconRes);
 }

Find a functionally equivalent code:android.util.ArraySet.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

@@ -5,12 +5,12 @@
         if (DEBUG)
             Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
         freeArrays(mHashes, mArray, mSize);
-        mHashes = ContainerHelpers.EMPTY_INTS;
-        mArray = ContainerHelpers.EMPTY_OBJECTS;
+        mHashes = EmptyArray.INT;
+        mArray = EmptyArray.OBJECT;
         mSize = 0;
     } else {
         if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {

Find a functionally equivalent code:android.view.animation.Transformation.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Reset the transformation to a state that leaves the object
 * being animated in an unmodified state. The transformation type is
 * {@link #TYPE_BOTH} by default.
 */

@@ -4,9 +4,11 @@
     } else {
         mMatrix.reset();
     }
+    mClipRect.setEmpty();
+    mHasClipRect = false;
     mAlpha = 1.0f;
     mTransformationType = TYPE_BOTH;
 }

Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.ClassLoader2.callGet_Original:COMMENT
Method Modifier: public      
Comment:/**
 * Accesses the "_Original" methods for {@link OuterClass#get}
 * or {@link InnerClass#get}via reflection.
 */

@@ -1,5 +1,5 @@
 {
-    Method m = instance.getClass().getMethod("get_Original", new Class<?>[] { int.class, long.class });
-    Object result = m.invoke(instance, new Object[] { a, b });
-    return ((Integer) result).intValue();
+    Method m = instance.getClass().getMethod("get_Original", int.class, long.class);
+    Object result = m.invoke(instance, a, b);
+    return (Integer) result;
 }

Find a functionally equivalent code:android.widget.AbsListView.PositionScroller.scrollToVisible:COMMENT
<android.widget.AbsListView.PositionScroller: void scrollToVisible(int,int,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Scroll such that targetPos is in the visible padded region without scrolling
 * boundPos out of view. Assumes targetPos is onscreen.
 */


Find a functionally equivalent code:android.os.Process.myPpid:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Returns the identifier of this process' parent.
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return Libcore.os.getppid();
+    return Os.getppid();
 }

Find a functionally equivalent code:android.net.wifi.p2p.WifiP2pDeviceList.updateStatus:COMMENT
<android.net.wifi.p2p.WifiP2pDeviceList: void updateStatus(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
Comment:/**
 * @hide
 */


Find a functionally equivalent code:android.graphics.Picture.createFromStream:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Create a new picture (already recorded) from the data in the stream. This
 * data was generated by a previous call to writeToStream(). Pictures that
 * have been persisted across device restarts are not guaranteed to decode
 * properly and are highly discouraged.
 *
 * <p>
 * <strong>Note:</strong> a picture created from an input stream cannot be
 * replayed on a hardware accelerated canvas.
 *
 * @see #writeToStream(java.io.OutputStream)
 * @deprecated The recommended alternative is to not use writeToStream and
 * instead draw the picture into a Bitmap from which you can persist it as
 * raw or compressed pixels.
 */

@@ -1,3 +1,3 @@
 {
-    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]), true);
+    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]));
 }

Find a functionally equivalent code:android.os.NullVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,5 @@
 {
-    vibrate(pattern, repeat);
+    if (repeat >= pattern.length) {
+        throw new ArrayIndexOutOfBoundsException();
+    }
 }

Find a functionally equivalent code:android.ddm.DdmHandleHeap.handleHPGC:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "HeaP Garbage Collection" request.
     */

@@ -1,7 +1,7 @@
 {
     if (false)
         Log.d("ddm-heap", "Heap GC request");
-    System.gc();
+    Runtime.getRuntime().gc();
     // empty response
     return null;
 }

Find a functionally equivalent code:android.text.format.Time.format:COMMENT
Method Modifier: public      
Comment:/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */

@@ -1,26 +1,4 @@
 {
-    synchronized (Time.class) {
-        Locale locale = Locale.getDefault();
-        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
-            LocaleData localeData = LocaleData.get(locale);
-            sAm = localeData.amPm[0];
-            sPm = localeData.amPm[1];
-            sZeroDigit = localeData.zeroDigit;
-            sShortMonths = localeData.shortMonthNames;
-            sLongMonths = localeData.longMonthNames;
-            sLongStandaloneMonths = localeData.longStandAloneMonthNames;
-            sShortWeekdays = localeData.shortWeekdayNames;
-            sLongWeekdays = localeData.longWeekdayNames;
-            Resources r = Resources.getSystem();
-            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
-            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
-            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
-            sLocale = locale;
-        }
-        String result = format1(format);
-        if (sZeroDigit != '0') {
-            result = localizeDigits(result);
-        }
-        return result;
-    }
+    calculator.copyFieldsFromTime(this);
+    return calculator.format(format);
 }

Find a functionally equivalent code:android.provider.DocumentsContract.deleteDocument:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

@@ -1,5 +1,5 @@
 {
     final Bundle in = new Bundle();
-    in.putString(Document.COLUMN_DOCUMENT_ID, getDocumentId(documentUri));
+    in.putParcelable(DocumentsContract.EXTRA_URI, documentUri);
     client.call(METHOD_DELETE_DOCUMENT, null, in);
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.verifyCellularConnection:COMMENT
<com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest: void verifyCellularConnection()>
Method Modifier: public      private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// help function to verify 3G connection

@@ -1,5 +1,5 @@
 {
-    NetworkInfo extraNetInfo = mCM.getActiveNetworkInfo();
+    NetworkInfo extraNetInfo = mCm.getActiveNetworkInfo();
     assertEquals("network type is not MOBILE", ConnectivityManager.TYPE_MOBILE, extraNetInfo.getType());
     assertTrue("not connected to cellular network", extraNetInfo.isConnected());
 }

Find a functionally equivalent code:android.util.SparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -14,36 +14,21 @@
             // Search again because indices may have changed.
             i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
         }
-        if (mSize >= mKeys.length) {
-            int n = ArrayUtils.idealIntArraySize(mSize + 1);
-            int[] nkeys = new int[n];
-            Object[] nvalues = new Object[n];
-            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-        if (mSize - i != 0) {
-            // Log.e("SparseArray", "move " + (mSize - i));
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:android.widget.CalendarView.setFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of the focused month.
 *
 * @param color The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

@@ -1,12 +1,3 @@
 {
-    if (mFocusedMonthDateColor != color) {
-        mFocusedMonthDateColor = color;
-        final int childCount = mListView.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            WeekView weekView = (WeekView) mListView.getChildAt(i);
-            if (weekView.mHasFocusedDay) {
-                weekView.invalidate();
-            }
-        }
-    }
+    mDelegate.setFocusedMonthDateColor(color);
 }

Find a functionally equivalent code:android.provider.Settings.Secure.putIntForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -1,7 +1,3 @@
 {
-    if (LOCATION_MODE.equals(name)) {
-        // TODO: once b/10491283 fixed, remove this hack
-        return setLocationModeForUser(cr, value, userHandle);
-    }
     return putStringForUser(cr, name, Integer.toString(value), userHandle);
 }

Find a functionally equivalent code:com.android.keyguard.FaceUnlock.handleServiceConnected:COMMENT
Method Modifier: 
Comment:/**
 * Tells the service to start its UI via an AIDL interface.  Called when the
 * onServiceConnected() callback is received.
 */

@@ -20,26 +20,26 @@
             // When switching between portrait and landscape view while Face Unlock is running,
             // the screen will eventually go dark unless we poke the wakelock when Face Unlock
             // is restarted.
-            mKeyguardScreenCallback.userActivity(0);
+            mKeyguardScreenCallback.userActivity();
             int[] position;
             position = new int[2];
             mFaceUnlockView.getLocationInWindow(position);

Find a functionally equivalent code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

@@ -1,11 +1,16 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
     if (type == TypedValue.TYPE_NULL) {
         return defValue;
     } else if (type == TypedValue.TYPE_DIMENSION) {
-        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
+        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:android.view.inputmethod.InputMethodManager.clearBindingLocked:COMMENT
Method Modifier: 
Comment:/**
 * Reset all of the state associated with being bound to an input method.
 */

@@ -1,4 +1,6 @@
 {
+    if (DEBUG)
+        Log.v(TAG, "Clearing binding!");
     clearConnectionLocked();
     setInputChannelLocked(null);
     mBindSequence = -1;

Find a functionally equivalent code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureRequestKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */

@@ -1,6 +1,12 @@
 {
     if (mAvailableRequestKeys == null) {
-        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class);
+        Object crKey = CaptureRequest.Key.class;
+        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
+        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
+        if (filterTags == null) {
+            throw new AssertionError("android.request.availableRequestKeys must be non-null " + "in the characteristics");
+        }
+        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
     }
     return mAvailableRequestKeys;
 }

Find a functionally equivalent code:android.widget.TextView.setError:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the right-hand compound drawable of the TextView to the "error"
 * icon and sets an error message that will be displayed in a popup when
 * the TextView has focus.  The icon and error message will be reset to
 * null when any key events cause changes to the TextView's text.  If the
 * <code>error</code> is <code>null</code>, the error message and icon
 * will be cleared.
 */

@@ -2,8 +2,8 @@
     if (error == null) {
         setError(null, null);
     } else {
-        Drawable dr = getContext().getResources().getDrawable(com.android.internal.R.drawable.indicator_input_error);
+        Drawable dr = getContext().getDrawable(com.android.internal.R.drawable.indicator_input_error);
         dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight());
         setError(error, dr);
     }

Find a functionally equivalent code:android.animation.PropertyValuesHolder.init:COMMENT
Method Modifier: 
Comment:/**
 * Internal function, called by ValueAnimator, to set up the TypeEvaluator that will be used
 * to calculate animated values.
 */

@@ -7,12 +7,12 @@
     if (mEvaluator != null) {
         // KeyframeSet knows how to evaluate the common types - only give it a custom
         // evaluator if one has been set on this class
-        mKeyframeSet.setEvaluator(mEvaluator);
+        mKeyframes.setEvaluator(mEvaluator);
     }
 }

Find a functionally equivalent code:android.app.KeyguardManager.exitKeyguardSecurely:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
 * and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
 * instead; this allows you to seamlessly hide the keyguard as your application
 * moves in and out of the foreground and does not require that any special
 * permissions be requested.
 *
 * Exit the keyguard securely.  The use case for this api is that, after
 * disabling the keyguard, your app, which was granted permission to
 * disable the keyguard and show a limited amount of information deemed
 * safe without the user getting past the keyguard, needs to navigate to
 * something that is not safe to view without getting past the keyguard.
 *
 * This will, if the keyguard is secure, bring up the unlock screen of
 * the keyguard.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#DISABLE_KEYGUARD}.
 *
 * @param callback Let's you know whether the operation was succesful and
 * it is safe to launch anything that would normally be considered safe
 * once the user has gotten past the keyguard.
 */

@@ -3,9 +3,11 @@
         mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {
 
             public void onKeyguardExitResult(boolean success) throws RemoteException {
-                callback.onKeyguardExitResult(success);
+                if (callback != null) {
+                    callback.onKeyguardExitResult(success);
+                }
             }
         });
     } catch (RemoteException e) {

Find a functionally equivalent code:android.content.pm.PackageItemInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */

@@ -1,9 +1,3 @@
 {
-    if (icon != 0) {
-        Drawable dr = pm.getDrawable(packageName, icon, getApplicationInfo());
-        if (dr != null) {
-            return dr;
-        }
-    }
-    return loadDefaultIcon(pm);
+    return pm.loadItemIcon(this, getApplicationInfo());
 }

Find a functionally equivalent code:android.animation.LayoutTransition.setupChangeAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function called by runChangingTransition for both the children and the parent
 * hierarchy.
 */

@@ -49,56 +49,60 @@
                 PropertyValuesHolder[] oldValues = valueAnim.getValues();
                 for (int i = 0; i < oldValues.length; ++i) {
                     PropertyValuesHolder pvh = oldValues[i];
-                    KeyframeSet keyframeSet = pvh.mKeyframeSet;
-                    if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
+                    if (pvh.mKeyframes instanceof KeyframeSet) {
+                        KeyframeSet keyframeSet = (KeyframeSet) pvh.mKeyframes;
+                        if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
+                            valuesDiffer = true;
+                        }
+                    } else if (!pvh.mKeyframes.getValue(0).equals(pvh.mKeyframes.getValue(1))) {
                         valuesDiffer = true;
                     }
                 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.clearLock:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Clear any lock pattern or password.
 */

@@ -6,9 +6,10 @@
     saveLockPattern(null);
     setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
     setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
+    onAfterChangingPassword();
 }

Find a functionally equivalent code:android.os.BatteryStats.Uid.getSensorStats:COMMENT
Method Modifier: public      abstract    
Comment:/**
 * Returns a mapping containing sensor statistics.
 *
 * @return a Map from Integer sensor ids to Uid.Sensor objects.
 */


Find a functionally equivalent code:android.graphics.Bitmap.setPixels:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Replace pixels in the bitmap with the colors in the array. Each element
 * in the array is a packed int prepresenting a non-premultiplied ARGB
 * {@link Color}.</p>
 *
 * @param pixels   The colors to write to the bitmap
 * @param offset   The index of the first color to read from pixels[]
 * @param stride   The number of colors in pixels[] to skip between rows.
 * Normally this value will be the same as the width of
 * the bitmap, but it can be larger (or negative).
 * @param x        The x coordinate of the first pixel to write to in
 * the bitmap.
 * @param y        The y coordinate of the first pixel to write to in
 * the bitmap.
 * @param width    The number of colors to copy from pixels[] per row
 * @param height   The number of rows to write to the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y, width, height are outside of
 * the bitmap's bounds.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

@@ -8,12 +8,12 @@
         return;
     }
     checkPixelsAccess(x, y, width, height, offset, stride, pixels);
-    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
+    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
 }

Find a functionally equivalent code:android.util.Spline.interpolate:COMMENT
<android.util.Spline: float interpolate(float)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Interpolates the value of Y = f(X) for given X.
 * Clamps X to the domain of the spline.
 *
 * @param x The X value.
 * @return The interpolated Y = f(X) value.
 */

@@ -1,26 +1 @@
-{
-    // Handle the boundary cases.
-    final int n = mX.length;
-    if (Float.isNaN(x)) {
-        return x;
-    }
-    if (x <= mX[0]) {
-        return mY[0];
-    }
-    if (x >= mX[n - 1]) {
-        return mY[n - 1];
-    }
-    // Find the index 'i' of the last point with smaller X.
-    // We know this will be within the spline due to the boundary tests.
-    int i = 0;
-    while (x >= mX[i + 1]) {
-        i += 1;
-        if (x == mX[i]) {
-            return mY[i];
-        }
-    }
-    // Perform cubic Hermite spline interpolation.
-    float h = mX[i + 1] - mX[i];
-    float t = (x - mX[i]) / h;
-    return (mY[i] * (1 + 2 * t) + h * mM[i] * t) * (1 - t) * (1 - t) + (mY[i + 1] * (3 - 2 * t) + h * mM[i + 1] * (t - 1)) * t * t;
-}
+

Find a functionally equivalent code:android.media.Ringtone.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops a playing ringtone.
 */

@@ -1,7 +1,7 @@
 {
     if (mLocalPlayer != null) {
         destroyLocalPlayer();
-    } else if (mAllowRemote) {
+    } else if (mAllowRemote && (mRemotePlayer != null)) {
         try {
             mRemotePlayer.stop(mRemoteToken);
         } catch (RemoteException e) {

Find a functionally equivalent code:android.widget.ListPopupWindow.ForwardingListener.onTouchForwarded:COMMENT
Method Modifier: private     
Comment:/**
 * Handled forwarded motion events and determines when to stop
 * forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to continue forwarding motion events, false to cancel
 */

@@ -15,19 +15,22 @@
     // Forward converted event to destination view, then recycle it.
     final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
     dstEvent.recycle();
-    return handled;
+    // Always cancel forwarding when the touch stream ends.
+    final int action = srcEvent.getActionMasked();
+    final boolean keepForwarding = action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL;
+    return handled && keepForwarding;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.layoutWindowLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,6 +1,7 @@
 {
     // we've already done the status bar
-    if (win == mStatusBar || win == mNavigationBar) {
+    final WindowManager.LayoutParams attrs = win.getAttrs();
+    if ((win == mStatusBar && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) == 0) || win == mNavigationBar) {
         return;
     }
     final boolean isDefaultDisplay = win.isDefaultDisplay();
@@ -10,27 +11,34 @@
             Slog.i(TAG, "Offset ime target window by the last ime window state");
         offsetInputMethodWindowLw(mLastInputMethodWindow);
     }
-    final int fl = attrs.flags;
+    final int fl = PolicyControl.getWindowFlags(win, attrs);
     final int sim = attrs.softInputMode;
-    final int sysUiFl = win.getSystemUiVisibility();
+    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
     final Rect pf = mTmpParentFrame;
     final Rect df = mTmpDisplayFrame;
     final Rect of = mTmpOverscanFrame;
     final Rect cf = mTmpContentFrame;
     final Rect vf = mTmpVisibleFrame;
     final Rect dcf = mTmpDecorFrame;
+    final Rect sf = mTmpStableFrame;
     dcf.setEmpty();
     final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
     final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
+    if (isDefaultDisplay) {
+        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
+    } else {
+        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
+    }
     if (!isDefaultDisplay) {
         if (attached != null) {
             // If this window is attached to another, our display
@@ -45,50 +52,67 @@
         // IM dock windows always go to the bottom of the screen.
         attrs.gravity = Gravity.BOTTOM;
         mDockLayer = win.getSurfaceLayer();
+    } else if (win == mStatusBar && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
+        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
+        pf.top = df.top = of.top = mUnrestrictedScreenTop;
+        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
+        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
+        cf.left = vf.left = mStableLeft;
+        cf.top = vf.top = mStableTop;
+        cf.right = vf.right = mStableRight;
+        vf.bottom = mStableBottom;
+        cf.bottom = mContentBottom;
     } else {
         // Default policy decor for the default display
         dcf.left = mSystemLeft;
@@ -55,65 +72,82 @@
         final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
         final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
         if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
-            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0) {
+            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                 // Ensure policy decor includes status bar
                 dcf.top = mStableTop;
             }
-            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0) {
+            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                 // Ensure policy decor includes navigation bar
                 dcf.bottom = mStableBottom;
                 dcf.right = mStableRight;
@@ -94,100 +111,117 @@
                     pf.top = df.top = of.top = mOverscanScreenTop;
                     pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                     pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
-                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
+                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                     // Asking for layout as if the nav bar is hidden, lets the
                     // application extend into the unrestricted overscan screen area.  We
                     // only do this for application windows to ensure no window that
@@ -124,139 +141,163 @@
                     of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                 }
                 if ((fl & FLAG_FULLSCREEN) == 0) {
-                    if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
-                        cf.left = mDockLeft;
-                        cf.top = mDockTop;
-                        cf.right = mDockRight;
-                        cf.bottom = mDockBottom;
+                    if (win.isVoiceInteraction()) {
+                        cf.left = mVoiceContentLeft;
+                        cf.top = mVoiceContentTop;
+                        cf.right = mVoiceContentRight;
+                        cf.bottom = mVoiceContentBottom;
                     } else {
-                        cf.left = mContentLeft;
-                        cf.top = mContentTop;
-                        cf.right = mContentRight;
-                        cf.bottom = mContentBottom;
+                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                            cf.left = mDockLeft;
+                            cf.top = mDockTop;
+                            cf.right = mDockRight;
+                            cf.bottom = mDockBottom;
+                        } else {
+                            cf.left = mContentLeft;
+                            cf.top = mContentTop;
+                            cf.right = mContentRight;
+                            cf.bottom = mContentBottom;
+                        }
                     }
                 } else {
                     // Full screen windows are always given a layout that is as if the
@@ -187,197 +211,226 @@
                 pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                 pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
             } else if (attrs.type == TYPE_WALLPAPER) {
-                // The wallpaper also has Real Ultimate Power.
-                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
-                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
-                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
-                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
+                // The wallpaper also has Real Ultimate Power, but we want to tell
+                // it about the overscan area.
+                pf.left = df.left = mOverscanScreenLeft;
+                pf.top = df.top = mOverscanScreenTop;
+                pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
+                pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
+                of.left = cf.left = mUnrestrictedScreenLeft;
+                of.top = cf.top = mUnrestrictedScreenTop;
+                of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
+                of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
             } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                 // Asking to layout into the overscan region, so give it that pure
                 // unrestricted area.
@@ -199,205 +228,234 @@
                 pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                 pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                 pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
-            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_TOAST || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
+            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                 // Asking for layout as if the nav bar is hidden, lets the
                 // application extend into the unrestricted screen area.  We
                 // only do this for application windows (or toasts) to ensure no window that
@@ -245,252 +274,281 @@
                 pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                 pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                 pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
-            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
-                // Toasts are stable to interim decor changes.
+            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT || attrs.type == TYPE_VOLUME_OVERLAY) {
+                // These dialogs are stable to interim decor changes.
                 pf.left = df.left = of.left = cf.left = mStableLeft;
                 pf.top = df.top = of.top = cf.top = mStableTop;
                 pf.right = df.right = of.right = cf.right = mStableRight;
@@ -256,262 +285,296 @@
                 pf.top = mContentTop;
                 pf.right = mContentRight;
                 pf.bottom = mContentBottom;
-                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
+                if (win.isVoiceInteraction()) {
+                    df.left = of.left = cf.left = mVoiceContentLeft;
+                    df.top = of.top = cf.top = mVoiceContentTop;
+                    df.right = of.right = cf.right = mVoiceContentRight;
+                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
+                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                     df.left = of.left = cf.left = mDockLeft;
                     df.top = of.top = cf.top = mDockTop;
                     df.right = of.right = cf.right = mDockRight;
@@ -280,294 +314,335 @@
     }
     // TYPE_SYSTEM_ERROR is above the NavigationBar so it can't be allowed to extend over it.
     if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
-        df.left = df.top = of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
-        df.right = df.bottom = of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
+        df.left = df.top = -10000;
+        df.right = df.bottom = 10000;
+        if (attrs.type != TYPE_WALLPAPER) {
+            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
+            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
+        }
     }
     if (DEBUG_LAYOUT)
-        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString());
-    win.computeFrameLw(pf, df, of, cf, vf, dcf);
+        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString());
+    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf);
     // can't appear underneath them.
     if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
         setLastInputMethodWindowLw(null, null);
         offsetInputMethodWindowLw(win);
     }
+    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
+        offsetVoiceInputWindowLw(win);
+    }
 }

Find a functionally equivalent code:android.app.Instrumentation.newActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Perform instantiation of the process's {@link Activity} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Activity
 * object.
 * @param intent The Intent object that specified the activity class being
 * instantiated.
 *
 * @return The newly instantiated Activity object.
 */


Find a functionally equivalent code:android.content.SyncRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */

@@ -1,9 +1,9 @@
 {
+    // Validate the extras bundle
+    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
     if (mCustomExtras == null) {
         mCustomExtras = new Bundle();
     }
-    // Validate the extras bundle
-    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
     // Combine builder extra flags into the config bundle.
     mSyncConfigExtras = new Bundle();
     if (mIgnoreBackoff) {
@@ -22,49 +22,39 @@
         mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
     }
     if (mIsManual) {
-        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
+        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
+        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
     }
-    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD, mTxBytes);
-    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD, mRxBytes);
-    mSyncConfigExtras.putInt(ContentResolver.SYNC_EXTRAS_PRIORITY, mPriority);
     if (mSyncType == SYNC_TYPE_PERIODIC) {
         // If this is a periodic sync ensure than invalid extras were not set.
-        validatePeriodicExtras(mCustomExtras);
-        validatePeriodicExtras(mSyncConfigExtras);
-        // Verify that account and provider are not null.
-        if (mAccount == null) {
-            throw new IllegalArgumentException("Account must not be null for periodic" + " sync.");
-        }
-        if (mAuthority == null) {
-            throw new IllegalArgumentException("Authority must not be null for periodic" + " sync.");
+        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
+            throw new IllegalArgumentException("Illegal extras were set");
         }
-    } else if (mSyncType == SYNC_TYPE_UNKNOWN) {
-        throw new IllegalArgumentException("Must call either syncOnce() or syncPeriodic()");
     }
     // Ensure that a target for the sync has been set.
     if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
-        throw new IllegalArgumentException("Must specify an adapter with " + "setSyncAdapter(Account, String");
+        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
     }
     return new SyncRequest(this);
 }

Find a functionally equivalent code:android.content.res.AssetManager.dumpTheme:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:android.media.MediaCodecInfo.getSupportedTypes:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query the media types supported by the codec.
 */

@@ -1,3 +1,6 @@
 {
-    return MediaCodecList.getSupportedTypes(mIndex);
+    Set<String> typeSet = mCaps.keySet();
+    String[] types = typeSet.toArray(new String[typeSet.size()]);
+    Arrays.sort(types);
+    return types;
 }

Find a functionally equivalent code:android.text.SpannableStringBuilder.setSpan:COMMENT
Method Modifier: public      
Comment:/**
 * Mark the specified range of text with the specified object.
 * The flags determine how the span will behave when text is
 * inserted at the start or end of the span's range.
 */


Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCStack:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control focus stack
 */

@@ -1,10 +1,9 @@
 {
     pw.println("\nRemote Control stack entries (last is top of stack):");
-    synchronized (mRCStack) {
-        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+    synchronized (mPRStack) {
+        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
         while (stackIterator.hasNext()) {
-            RemoteControlStackEntry rcse = stackIterator.next();
-            pw.println("  pi: " + rcse.mMediaIntent + " -- pack: " + rcse.mCallingPackageName + "  -- ercvr: " + rcse.mReceiverComponent + "  -- client: " + rcse.mRcClient + "  -- uid: " + rcse.mCallingUid + "  -- type: " + rcse.mPlaybackType + "  state: " + rcse.mPlaybackState);
+            stackIterator.next().dump(pw, true);
         }
     }
 }

Find a functionally equivalent code:com.android.server.NetworkManagementServiceTest.testNetworkObservers:COMMENT
Method Modifier: public      
Comment:/**
 * Tests that network observers work properly.
 */

@@ -41,65 +41,96 @@
      * Interface class activity.
      */
     sendMessage("613 IfaceClass active rmnet0");
-    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true);
+    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 0);
+    sendMessage("613 IfaceClass active rmnet0 1234");
+    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", true, 1234);
     sendMessage("613 IfaceClass idle eth0");
-    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false);
-    sendMessage("613 IfaceClass reallyactive rmnet0");
-    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", false);
+    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 0);
+    sendMessage("613 IfaceClass idle eth0 1234");
+    expectSoon(observer).interfaceClassDataActivityChanged("eth0", false, 1234);
+    sendMessage("613 IfaceClass reallyactive rmnet0 1234");
+    expectSoon(observer).interfaceClassDataActivityChanged("rmnet0", false, 1234);
     sendMessage("613 InterfaceClass reallyactive rmnet0");
     // Invalid group.
     /**
      * IP address changes.
      */
     sendMessage("614 Address updated fe80::1/64 wlan0 128 253");
-    expectSoon(observer).addressUpdated("fe80::1/64", "wlan0", 128, 253);
-    // There is no "added".
+    expectSoon(observer).addressUpdated("wlan0", new LinkAddress("fe80::1/64", 128, 253));
+    // There is no "added", so we take this as "removed".
     sendMessage("614 Address added fe80::1/64 wlan0 128 253");
-    expectSoon(observer).addressRemoved("fe80::1/64", "wlan0", 128, 253);
+    expectSoon(observer).addressRemoved("wlan0", new LinkAddress("fe80::1/64", 128, 253));
     sendMessage("614 Address removed 2001:db8::1/64 wlan0 1 0");
-    expectSoon(observer).addressRemoved("2001:db8::1/64", "wlan0", 1, 0);
-    sendMessage("666 Address added 2001:db8::1/64 wlan0 1 0");
+    expectSoon(observer).addressRemoved("wlan0", new LinkAddress("2001:db8::1/64", 1, 0));
+    sendMessage("614 Address removed 2001:db8::1/64 wlan0 1");
+    // Not enough arguments.
+    sendMessage("666 Address removed 2001:db8::1/64 wlan0 1 0");
     // Invalid code.
+    /**
+     * DNS information broadcasts.
+     */
+    sendMessage("615 DnsInfo servers rmnet_usb0 3600 2001:db8::1");
+    expectSoon(observer).interfaceDnsServerInfo("rmnet_usb0", 3600, new String[] { "2001:db8::1" });
+    sendMessage("615 DnsInfo servers wlan0 14400 2001:db8::1,2001:db8::2");
+    expectSoon(observer).interfaceDnsServerInfo("wlan0", 14400, new String[] { "2001:db8::1", "2001:db8::2" });
+    // We don't check for negative lifetimes, only for parse errors.
+    sendMessage("615 DnsInfo servers wlan0 -3600 ::1");
+    expectSoon(observer).interfaceDnsServerInfo("wlan0", -3600, new String[] { "::1" });
+    sendMessage("615 DnsInfo servers wlan0 SIXHUNDRED ::1");
+    // Non-numeric lifetime.
+    sendMessage("615 DnsInfo servers wlan0 2001:db8::1");
+    // Missing lifetime.
+    sendMessage("615 DnsInfo servers wlan0 3600");
+    // No servers.
+    sendMessage("615 DnsInfo servers 3600 wlan0 2001:db8::1,2001:db8::2");
+    // Non-numeric lifetime.
+    sendMessage("615 DnsInfo wlan0 7200 2001:db8::1,2001:db8::2");
+    // Invalid tokens.
+    sendMessage("666 DnsInfo servers wlan0 5400 2001:db8::1");
+    // Invalid code.
+    // No syntax checking on the addresses.
+    sendMessage("615 DnsInfo servers wlan0 600 ,::,,foo,::1,");
+    expectSoon(observer).interfaceDnsServerInfo("wlan0", 600, new String[] { "", "::", "", "foo", "::1" });
     // Make sure nothing else was called.
     verifyNoMoreInteractions(observer);
 }

Find a functionally equivalent code:android.text.TextLine.drawTextRun:COMMENT
Method Modifier: private     
Comment:/**
 * Render a text run with the set-up paint.
 *
 * @param c the canvas
 * @param wp the paint used to render the text
 * @param start the start of the run
 * @param end the end of the run
 * @param contextStart the start of context for the run
 * @param contextEnd the end of the context for the run
 * @param runIsRtl true if the run is right-to-left
 * @param x the x position of the left edge of the run
 * @param y the baseline of the run
 */

@@ -1,11 +1,10 @@
 {
-    int flags = runIsRtl ? Canvas.DIRECTION_RTL : Canvas.DIRECTION_LTR;
     if (mCharsValid) {
         int count = end - start;
         int contextCount = contextEnd - contextStart;
-        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, flags, wp);
+        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, runIsRtl, wp);
     } else {
         int delta = mStart;
-        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, flags, wp);
+        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, runIsRtl, wp);
     }
 }

Find a functionally equivalent code:android.widget.TextView.paste:COMMENT
Method Modifier: private     
Comment:/**
 * Paste clipboard content between min and max positions.
 */

@@ -7,15 +7,12 @@
             CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
             if (paste != null) {
                 if (!didFirst) {
-                    long minMax = prepareSpacesAroundPaste(min, max, paste);
-                    min = TextUtils.unpackRangeStartFromLong(minMax);
-                    max = TextUtils.unpackRangeEndFromLong(minMax);
                     Selection.setSelection((Spannable) mText, max);
                     ((Editable) mText).replace(min, max, paste);
                     didFirst = true;

Find a functionally equivalent code:android.view.accessibility.AccessibilityNodeInfo.init:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes this instance from another one.
 *
 * @param other The other instance.
 */

@@ -11,24 +11,39 @@
     mPackageName = other.mPackageName;
     mClassName = other.mClassName;
     mText = other.mText;
+    mError = other.mError;
     mContentDescription = other.mContentDescription;
     mViewIdResourceName = other.mViewIdResourceName;
-    mActions = other.mActions;
+    final ArrayList<AccessibilityAction> otherActions = other.mActions;
+    if (otherActions != null && otherActions.size() > 0) {
+        if (mActions == null) {
+            mActions = new ArrayList(otherActions);
+        } else {
+            mActions.clear();
+            mActions.addAll(other.mActions);
+        }
+    }
     mBooleanProperties = other.mBooleanProperties;
+    mMaxTextLength = other.mMaxTextLength;
     mMovementGranularities = other.mMovementGranularities;
-    final int otherChildIdCount = other.mChildNodeIds.size();
-    for (int i = 0; i < otherChildIdCount; i++) {
-        mChildNodeIds.put(i, other.mChildNodeIds.valueAt(i));
+    final LongArray otherChildNodeIds = other.mChildNodeIds;
+    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
+        if (mChildNodeIds == null) {
+            mChildNodeIds = otherChildNodeIds.clone();
+        } else {
+            mChildNodeIds.clear();
+            mChildNodeIds.addAll(otherChildNodeIds);
+        }
     }
     mTextSelectionStart = other.mTextSelectionStart;
     mTextSelectionEnd = other.mTextSelectionEnd;

Find a functionally equivalent code:android.widget.TimePicker.setCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current minute (0-59).
 */

@@ -1,7 +1,3 @@
 {
-    if (currentMinute == getCurrentMinute()) {
-        return;
-    }
-    mMinuteSpinner.setValue(currentMinute);
-    onTimeChanged();
+    mDelegate.setCurrentMinute(currentMinute);
 }

Find a functionally equivalent code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */

@@ -1,15 +1,15 @@
 {
-    PackageParser packageParser = new PackageParser(archiveFilePath);
-    DisplayMetrics metrics = new DisplayMetrics();
-    metrics.setToDefaults();
-    final File sourceFile = new File(archiveFilePath);
-    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
-    if (pkg == null) {
+    final PackageParser parser = new PackageParser();
+    final File apkFile = new File(archiveFilePath);
+    try {
+        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
+        if ((flags & GET_SIGNATURES) != 0) {
+            parser.collectCertificates(pkg, 0);
+            parser.collectManifestDigest(pkg);
+        }
+        PackageUserState state = new PackageUserState();
+        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
+    } catch (PackageParserException e) {
         return null;
     }
-    if ((flags & GET_SIGNATURES) != 0) {
-        packageParser.collectCertificates(pkg, 0);
-    }
-    PackageUserState state = new PackageUserState();
-    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
 }

Find a functionally equivalent code:android.graphics.BidiRenderer.setScriptFont:COMMENT
Method Modifier: private     static      
Comment:// TODO: Replace this method with one which returns the font based on the scriptCode.

@@ -1,7 +1,11 @@
 {
-    for (FontInfo fontInfo : fonts) {
-        if (fontInfo.mFont.canDisplayUpTo(text, run.start, run.limit) == -1) {
-            run.font = fontInfo;
+    for (Font font : fonts) {
+        if (font == null) {
+            logFontWarning();
+            continue;
+        }
+        if (font.canDisplayUpTo(text, run.start, run.limit) == -1) {
+            run.font = font;
             return;
         }
     }

Find a functionally equivalent code:android.media.AudioManager.preDispatchKeyEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -4,10 +4,10 @@
          * cancel the sound
          */
     int keyCode = event.getKeyCode();
-    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
+    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + AudioService.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
         /*
              * The user has hit another key during the delay (e.g., 300ms)
              * since the last volume key up, so cancel any sounds.

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.beginPostLayoutPolicyLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -1,5 +1,7 @@
 {
     mTopFullscreenOpaqueWindowState = null;
+    mAppsToBeHidden.clear();
+    mAppsThatDismissKeyguard.clear();
     mForceStatusBar = false;
     mForceStatusBarFromKeyguard = false;
     mForcingShowNavBar = false;
@@ -9,12 +11,15 @@
     mDismissKeyguard = DISMISS_KEYGUARD_NONE;
     mShowingLockscreen = false;
     mShowingDream = false;
+    mWinShowWhenLocked = null;
 }

Find a functionally equivalent code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -20,24 +20,27 @@
     if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
         protLevel += "|development";
     }
+    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
+        protLevel += "|appop";
+    }
     return protLevel;
 }

Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.mutate:COMMENT
Method Modifier: public      
Comment:/**
 * A mutable BitmapDrawable still shares its Bitmap with any other Drawable
 * that comes from the same resource.
 *
 * @return This drawable.
 */

@@ -1,6 +1,6 @@
 {
     if (!mMutated && super.mutate() == this) {
-        mState = new ColorState(mState);
+        mColorState = new ColorState(mColorState);
         mMutated = true;
     }
     return this;

Find a functionally equivalent code:android.os.MemoryFile.native_mmap:COMMENT
Method Modifier: private     static      native      
Comment:// returns memory address for ashmem region


Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.isConnectedToWifi:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// Return true if device is currently connected to Wifi

@@ -1,3 +1,3 @@
 {
-    return (mNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI);
+    return (mCm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_WIFI);
 }

Find a functionally equivalent code:android.view.Surface.copyFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy another surface to this one.  This surface now holds a reference
 * to the same data as the original surface, and is -not- the owner.
 * This is for use by the window manager when returning a window surface
 * back from a client, converting it from the representation being managed
 * by the window manager to the representation the client uses to draw
 * in to it.
 * @hide
 */

@@ -2,12 +2,12 @@
     if (other == null) {
         throw new IllegalArgumentException("other must not be null");
     }
-    int surfaceControlPtr = other.mNativeObject;
+    long surfaceControlPtr = other.mNativeObject;
     if (surfaceControlPtr == 0) {
         throw new NullPointerException("SurfaceControl native object is null. Are you using a released SurfaceControl?");
     }
-    int newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
+    long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
     synchronized (mLock) {
         if (mNativeObject != 0) {
             nativeRelease(mNativeObject);

Find a functionally equivalent code:com.android.frameworks.downloadmanagertests.DownloadManagerTestApp.initiateDownload:COMMENT
Method Modifier: public      
Comment:/**
 * Initiates a download.
 *
 * Queues up a download to the download manager, and saves the DownloadManager's assigned
 * download ID for this download to a file.
 *
 * @throws Exception if unsuccessful
 */

@@ -1,5 +1,5 @@
 {
-    String filename = DOWNLOAD_5MB_FILENAME;
+    String filename = DOWNLOAD_FILENAME;
     mContext.deleteFile(DOWNLOAD_STARTED_FLAG);
     FileOutputStream fileOutput = mContext.openFileOutput(DOWNLOAD_STARTED_FLAG, 0);
     DataOutputStream outputFile = null;
@@ -12,18 +12,18 @@
         Request request = new Request(remoteUri);
         dlRequest = mDownloadManager.enqueue(request);
         waitForDownloadToStart(dlRequest);
-        assertTrue(dlRequest != -1);
+        assertTrue("request id is -1 from download manager", dlRequest != -1);
         // Store ID of download for later retrieval
         outputFile = new DataOutputStream(fileOutput);
         outputFile.writeLong(dlRequest);

Find a functionally equivalent code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: 
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

@@ -1,11 +1,19 @@
 {
+    mKeyframes.invalidateCache();
     if (mProperty != null) {
         // check to make sure that mProperty is on the class of target
         try {
-            Object testValue = mProperty.get(target);
-            for (Keyframe kf : mKeyframeSet.mKeyframes) {
-                if (!kf.hasValue()) {
-                    kf.setValue(mProperty.get(target));
+            Object testValue = null;
+            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
+            int keyframeCount = keyframes == null ? 0 : keyframes.size();
+            for (int i = 0; i < keyframeCount; i++) {
+                Keyframe kf = keyframes.get(i);
+                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
+                    if (testValue == null) {
+                        testValue = convertBack(mProperty.get(target));
+                    }
+                    kf.setValue(testValue);
+                    kf.setValueWasSetOnStart(true);
                 }
             }
             return;
@@ -18,25 +26,36 @@
     if (mSetter == null) {
         setupSetter(targetClass);
     }
-    for (Keyframe kf : mKeyframeSet.mKeyframes) {
-        if (!kf.hasValue()) {
+    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
+    int keyframeCount = keyframes == null ? 0 : keyframes.size();
+    for (int i = 0; i < keyframeCount; i++) {
+        Keyframe kf = keyframes.get(i);
+        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
             if (mGetter == null) {
                 setupGetter(targetClass);
                 if (mGetter == null) {
@@ -28,34 +39,47 @@
                 }
             }
             try {
-                kf.setValue(mGetter.invoke(target));
+                Object value = convertBack(mGetter.invoke(target));
+                kf.setValue(value);
+                kf.setValueWasSetOnStart(true);
             } catch (InvocationTargetException e) {
                 Log.e("PropertyValuesHolder", e.toString());
             } catch (IllegalAccessException e) {

Find a functionally equivalent code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
@@ -6,11 +9,16 @@
         return defValue;
     } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
         return data[index + AssetManager.STYLE_DATA];
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:android.net.LocalSocketImpl.accept:COMMENT
Method Modifier: private     native      
Comment:/**
 * Accepts a connection on a server socket.
 *
 * @param fd file descriptor of server socket
 * @param s socket implementation that will become the new socket
 * @return file descriptor of new socket
 */


Find a functionally equivalent code:android.os.Bundle.putShort:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a short
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putShort(key, value);
 }

Find a functionally equivalent code:android.net.ConnectivityManager.getNetworkTypeName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a non-localized string representing a given network type.
 * ONLY used for debugging output.
 * @param type the type needing naming
 * @return a String for the given type, or a string version of the type ("87")
 * if no name is known.
 * {@hide}
 */

@@ -30,35 +30,39 @@
             return "WIFI_P2P";
         case TYPE_MOBILE_IA:
             return "MOBILE_IA";
+        case TYPE_MOBILE_EMERGENCY:
+            return "MOBILE_EMERGENCY";
+        case TYPE_PROXY:
+            return "PROXY";
         default:
             return Integer.toString(type);
     }

Find a functionally equivalent code:android.view.Window.setDefaultWindowFormat:COMMENT
Method Modifier: protected   
Comment:/**
 * Set the default format of window, as per the PixelFormat types.  This
 * is the format that will be used unless the client specifies in explicit
 * format with setFormat();
 *
 * @param format The new window format (see PixelFormat).
 *
 * @see #setFormat
 * @see PixelFormat
 */

@@ -3,10 +3,8 @@
     if (!mHaveWindowFormat) {
         final WindowManager.LayoutParams attrs = getAttributes();
         attrs.format = format;
-        if (mCallback != null) {
-            mCallback.onWindowAttributesChanged(attrs);
-        }
+        dispatchWindowAttributesChanged(attrs);
     }
 }

Find a functionally equivalent code:android.content.ContentResolver.getSyncStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the status that matches the authority.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return the SyncStatusInfo for the authority, or null if none exists
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     try {
-        return getContentService().getSyncStatus(account, authority);
+        return getContentService().getSyncStatus(account, authority, null);
     } catch (RemoteException e) {
         throw new RuntimeException("the ContentService should always be reachable", e);
     }

Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onBootCompleted:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onBootCompleted()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when boot completed.
 *
 * Note, this callback will only be received if boot complete occurs after registering with
 * KeyguardUpdateMonitor.
 */


Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitorCallback.onDevicePolicyManagerStateChanged:COMMENT
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDevicePolicyManagerStateChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
Comment:/**
 * Called when the device policy changes.
 * See {@link DevicePolicyManager#ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED}
 */


Find a functionally equivalent code:android.view.MotionEvent.axisToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified axis
 * such as "AXIS_X" or an equivalent numeric constant such as "42" if unknown.
 *
 * @param axis The axis.
 * @return The symbolic name of the specified axis.
 */

@@ -1,4 +1,4 @@
 {
-    String symbolicName = AXIS_SYMBOLIC_NAMES.get(axis);
-    return symbolicName != null ? symbolicName : Integer.toString(axis);
+    String symbolicName = nativeAxisToString(axis);
+    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(axis);
 }

Find a functionally equivalent code:com.android.internal.widget.LockPatternUtils.isLockScreenDisabled:COMMENT
Method Modifier: public      internal    
Comment:/**
 * Determine if LockScreen can be disabled. This is used, for example, to tell if we should
 * show LockScreen or go straight to the home screen.
 *
 * @return true if lock screen is can be disabled
 */

@@ -1,3 +1,15 @@
 {
-    return !isSecure() && getLong(DISABLE_LOCKSCREEN_KEY, 0) != 0;
+    if (!isSecure() && getLong(DISABLE_LOCKSCREEN_KEY, 0) != 0) {
+        // Check if the number of switchable users forces the lockscreen.
+        final List<UserInfo> users = UserManager.get(mContext).getUsers(true);
+        final int userCount = users.size();
+        int switchableUsers = 0;
+        for (int i = 0; i < userCount; i++) {
+            if (users.get(i).supportsSwitchTo()) {
+                switchableUsers++;
+            }
+        }
+        return switchableUsers < 2;
+    }
+    return false;
 }

Find a functionally equivalent code:android.graphics.Canvas.drawTextOnPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the text, with origin at (x,y), using the specified paint, along
 * the specified path. The paint's Align setting determins where along the
 * path to start the text.
 *
 * @param text     The text to be drawn
 * @param path     The path the text should follow for its baseline
 * @param hOffset  The distance along the path to add to the text's
 * starting position
 * @param vOffset  The distance above(-) or below(+) the path to position
 * the text
 * @param paint    The paint used for the text (e.g. color, size, style)
 */

@@ -1,6 +1,5 @@
 {
-    if (index < 0 || index + count > text.length) {
-        throw new ArrayIndexOutOfBoundsException();
+    if (text.length() > 0) {
+        native_drawTextOnPath(mNativeCanvasWrapper, text, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
     }
-    native_drawTextOnPath(mNativeCanvas, text, index, count, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
 }

Find a functionally equivalent code:android.widget.TimePicker.is24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if this is in 24 hour view else false.
 */

@@ -1,3 +1,3 @@
 {
-    return mIs24HourView;
+    return mDelegate.is24HourView();
 }

Find a functionally equivalent code:com.android.keyguard.KeyguardViewBase.show:COMMENT
<com.android.keyguard.KeyguardViewBase: void show()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Called when the view needs to be shown.
 */

@@ -1 +1,5 @@
-
+{
+    if (DEBUG)
+        Log.d(TAG, "show()");
+    mSecurityContainer.showPrimarySecurityScreen(false);
+}

Find a functionally equivalent code:android.provider.DocumentsProvider.attachInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class.
 */

@@ -7,12 +7,14 @@
     mMatcher.addURI(mAuthority, "root/*/search", MATCH_SEARCH);
     mMatcher.addURI(mAuthority, "document/*", MATCH_DOCUMENT);
     mMatcher.addURI(mAuthority, "document/*/children", MATCH_CHILDREN);
+    mMatcher.addURI(mAuthority, "tree/*/document/*", MATCH_DOCUMENT_TREE);
+    mMatcher.addURI(mAuthority, "tree/*/document/*/children", MATCH_CHILDREN_TREE);
     // Sanity check our setup
     if (!info.exported) {
         throw new SecurityException("Provider must be exported");

Find a functionally equivalent code:android.media.MediaMetadataEditor.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Clears all the pending metadata changes set since the MediaMetadataEditor instance was
 * created or since this method was last called.
 * Note that clearing the metadata doesn't reset the editable keys
 * (use {@link #removeEditableKeys()} instead).
 */

@@ -5,8 +5,9 @@
     }
     mEditorMetadata.clear();
     mEditorArtwork = null;
+    mMetadataBuilder = new MediaMetadata.Builder();
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.selectAnimationLw:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -2,11 +2,12 @@
     if (PRINT_ANIM)
         Log.i(TAG, "selectAnimation in " + win + ": transit=" + transit);
     if (win == mStatusBar) {
+        boolean isKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
         if (transit == TRANSIT_EXIT || transit == TRANSIT_HIDE) {
-            return R.anim.dock_top_exit;
+            return isKeyguard ? -1 : R.anim.dock_top_exit;
         } else if (transit == TRANSIT_ENTER || transit == TRANSIT_SHOW) {
-            return R.anim.dock_top_enter;
+            return isKeyguard ? -1 : R.anim.dock_top_enter;
         }
     } else if (win == mNavigationBar) {
         // This can be on either the bottom or the right.

Find a functionally equivalent code:android.widget.SuggestionsAdapter.getDrawableFromResourceValue:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a drawable given a value provided by a suggestion provider.
 *
 * This value could be just the string value of a resource id
 * (e.g., "2130837524"), in which case we will try to retrieve a drawable from
 * the provider's resources. If the value is not an integer, it is
 * treated as a Uri and opened with
 * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
 *
 * All resources and URIs are read using the suggestion provider's context.
 *
 * If the string is not formatted as expected, or no drawable can be found for
 * the provided value, this method returns null.
 *
 * @param drawableId a string like "2130837524",
 * "android.resource://com.android.alarmclock/2130837524",
 * or "content://contacts/photos/253".
 * @return a Drawable, or null if none found
 */

@@ -13,19 +13,19 @@
             return drawable;
         }
         // Not cached, find it by resource ID
-        drawable = mProviderContext.getResources().getDrawable(resourceId);
+        drawable = mProviderContext.getDrawable(resourceId);
         // Stick it in the cache, using the URI as key
         storeInIconCache(drawableUri, drawable);
         return drawable;

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.createHomeDockIntent:COMMENT
Method Modifier: internal    
Comment:/**
 * Return an Intent to launch the currently active dock app as home.  Returns
 * null if the standard home should be launched, which is the case if any of the following is
 * true:
 * <ul>
 * <li>The device is not in either car mode or desk mode
 * <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
 * <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
 * <li>The device is in car mode but there's no CAR_DOCK app with METADATA_DOCK_HOME
 * <li>The device is in desk mode but there's no DESK_DOCK app with METADATA_DOCK_HOME
 * </ul>
 * @return A dock intent.
 */

@@ -9,14 +9,17 @@
         if (ENABLE_DESK_DOCK_HOME_CAPTURE) {
             intent = mDeskDockIntent;
         }
+    } else if (mUiMode == Configuration.UI_MODE_TYPE_WATCH && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK)) {
+        // Always launch dock home from home when watch is docked, if it exists.
+        intent = mDeskDockIntent;
     }
     if (intent == null) {
         return null;

Find a functionally equivalent code:android.app.ActivityThread.getTopLevelResources:COMMENT
Method Modifier: 
Comment:/**
 * Creates the top level resources for the given package.
 */

@@ -1,3 +1,3 @@
 {
-    return mResourcesManager.getTopLevelResources(resDir, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
+    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
 }

Find a functionally equivalent code:android.util.LongSparseLongArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -3,13 +3,9 @@
         put(key, value);
         return;
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        growKeyAndValueArrays(pos + 1);
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:android.security.KeyChain.choosePrivateKeyAlias:COMMENT
Method Modifier: public      static      
Comment:/**
 * Launches an {@code Activity} for the user to select the alias
 * for a private key and certificate pair for authentication. The
 * selected alias or null will be returned via the
 * KeyChainAliasCallback callback.
 *
 * <p>{@code keyTypes} and {@code issuers} may be used to
 * highlight suggested choices to the user, although to cope with
 * sometimes erroneous values provided by servers, the user may be
 * able to override these suggestions.
 *
 * <p>{@code host} and {@code port} may be used to give the user
 * more context about the server requesting the credentials.
 *
 * <p>{@code alias} allows the chooser to preselect an existing
 * alias which will still be subject to user confirmation.
 *
 * @param activity The {@link Activity} context to use for
 * launching the new sub-Activity to prompt the user to select
 * a private key; used only to call startActivity(); must not
 * be null.
 * @param response Callback to invoke when the request completes;
 * must not be null
 * @param keyTypes The acceptable types of asymmetric keys such as
 * "RSA" or "DSA", or a null array.
 * @param issuers The acceptable certificate issuers for the
 * certificate matching the private key, or null.
 * @param host The host name of the server requesting the
 * certificate, or null if unavailable.
 * @param port The port number of the server requesting the
 * certificate, or -1 if unavailable.
 * @param alias The alias to preselect if available, or null if
 * unavailable.
 */

@@ -22,27 +22,28 @@
         throw new NullPointerException("response == null");
     }
     Intent intent = new Intent(ACTION_CHOOSER);
+    intent.setPackage(KEYCHAIN_PACKAGE);
     intent.putExtra(EXTRA_RESPONSE, new AliasResponse(response));
     intent.putExtra(EXTRA_HOST, host);
     intent.putExtra(EXTRA_PORT, port);

Find a functionally equivalent code:com.android.systemui.SearchPanelView.isShowing:COMMENT
Method Modifier: public      
Comment:/**
 * Whether the panel is showing, or, if it's animating, whether it will be
 * when the animation is done.
 */

@@ -1,3 +1,3 @@
 {
-    return mShowing;
+    return getVisibility() == View.VISIBLE && !mCircle.isAnimatingOut();
 }

Find a functionally equivalent code:android.view.ViewPropertyAnimator.getValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method gets the value of the named property from the View object.
 *
 * @param propertyConstant The property whose value should be returned
 * @return float The value of the named property
 */

@@ -1,26 +1,30 @@
 {
-    final View.TransformationInfo info = mView.mTransformationInfo;
+    final RenderNode node = mView.mRenderNode;
     switch(propertyConstant) {
         case TRANSLATION_X:
-            return info.mTranslationX;
+            return node.getTranslationX();
         case TRANSLATION_Y:
-            return info.mTranslationY;
+            return node.getTranslationY();
+        case TRANSLATION_Z:
+            return node.getTranslationZ();
         case ROTATION:
-            return info.mRotation;
+            return node.getRotation();
         case ROTATION_X:
-            return info.mRotationX;
+            return node.getRotationX();
         case ROTATION_Y:
-            return info.mRotationY;
+            return node.getRotationY();
         case SCALE_X:
-            return info.mScaleX;
+            return node.getScaleX();
         case SCALE_Y:
-            return info.mScaleY;
+            return node.getScaleY();
         case X:
-            return mView.mLeft + info.mTranslationX;
+            return mView.mLeft + node.getTranslationX();
         case Y:
-            return mView.mTop + info.mTranslationY;
+            return mView.mTop + node.getTranslationY();
+        case Z:
+            return node.getElevation() + node.getTranslationZ();
         case ALPHA:
-            return info.mAlpha;
+            return mView.mTransformationInfo.mAlpha;
     }
     return 0;
 }

Find a functionally equivalent code:android.widget.TabWidget.setLeftStripDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the drawable to use as the left part of the strip below the
 * tab indicators.
 * @param drawable the left strip drawable
 */


Find a functionally equivalent code:android.widget.Switch.setTrackDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param track Track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

@@ -1,4 +1,10 @@
 {
+    if (mTrackDrawable != null) {
+        mTrackDrawable.setCallback(null);
+    }
     mTrackDrawable = track;
+    if (track != null) {
+        track.setCallback(this);
+    }
     requestLayout();
 }

Find a functionally equivalent code:android.app.ActivityThread.ApplicationThread.scheduleLaunchActivity:COMMENT
Method Modifier: public      final       
Comment:// activity itself back to the activity manager. (matters more with ipc)

@@ -4,19 +4,19 @@
     r.token = token;
     r.ident = ident;
     r.intent = intent;
+    r.voiceInteractor = voiceInteractor;
     r.activityInfo = info;
     r.compatInfo = compatInfo;
     r.state = state;
+    r.persistentState = persistentState;
     r.pendingResults = pendingResults;
     r.pendingIntents = pendingNewIntents;
     r.startsNotResumed = notResumed;
     r.isForward = isForward;
-    r.profileFile = profileName;
-    r.profileFd = profileFd;
-    r.autoStopProfiler = autoStopProfiler;
+    r.profilerInfo = profilerInfo;
     updatePendingConfiguration(curConfig);
-    queueOrSendMessage(H.LAUNCH_ACTIVITY, r);
+    sendMessage(H.LAUNCH_ACTIVITY, r);
 }

Find a functionally equivalent code:android.graphics.Canvas.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Completely replace the current matrix with the specified matrix. If the
 * matrix parameter is null, then the current matrix is reset to identity.
 *
 * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},
 * {@link #scale(float, float)}, {@link #translate(float, float)} and
 * {@link #rotate(float)} instead of this method.
 *
 * @param matrix The matrix to replace the current matrix with. If it is
 * null, set the current matrix to identity.
 *
 * @see #concat(Matrix)
 */

@@ -1,3 +1,3 @@
 {
-    native_setMatrix(mNativeCanvas, matrix == null ? 0 : matrix.native_instance);
+    native_setMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
 }

Find a functionally equivalent code:android.media.MediaRouter.UserRouteInfo.setVolumeMax:COMMENT
Method Modifier: public      
Comment:/**
 * Defines the maximum volume at which the playback associated with this route is performed
 * (for user feedback purposes). This information is only used when the playback is not
 * local.
 * @param volumeMax
 */

@@ -1,6 +1,6 @@
 {
     if (mVolumeMax != volumeMax) {
         mVolumeMax = volumeMax;
-        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_MAX, volumeMax);
+        configureSessionVolume();
     }
 }

Find a functionally equivalent code:android.app.backup.BackupAgent.waitForSharedPrefs:COMMENT
Method Modifier: private     
Comment:// Syncing shared preferences deferred writes needs to happen on the main looper thread

@@ -1,9 +1,7 @@
 {
-    if (mHandler == null) {
-        mHandler = new Handler(Looper.getMainLooper());
-    }
+    Handler h = getHandler();
     final SharedPrefsSynchronizer s = new SharedPrefsSynchronizer();
-    mHandler.postAtFrontOfQueue(s);
+    h.postAtFrontOfQueue(s);
     try {
         s.mLatch.await();
     } catch (InterruptedException e) {

Find a functionally equivalent code:com.android.tools.layoutlib.create.RenameClassAdapter.renameInternalType:COMMENT
Method Modifier: protected   
Comment:/**
 * Renames an internal type name, e.g. "com.package.MyClass".
 * If the type doesn't need to be renamed, returns the input string as-is.
 * <p/>
 * The internal type of some of the MethodVisitor turns out to be a type
 * descriptor sometimes so descriptors are renamed too.
 */

@@ -5,11 +5,11 @@
     if (type.equals(mOldName)) {
         return mNewName;
     }
-    if (mOldBase != mOldName && type.equals(mOldBase)) {
+    if (!mOldBase.equals(mOldName) && type.equals(mOldBase)) {
         return mNewBase;
     }
     int pos = type.indexOf('$');

Find a functionally equivalent code:android.telephony.SignalStrength.getDbm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal strength as dBm
 *
 * @hide
 */

@@ -1,10 +1,9 @@
 {
     int dBm;
     if (isGsm()) {
-        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
+        dBm = getLteDbm();
+        if (dBm == INVALID) {
             dBm = getGsmDbm();
-        } else {
-            dBm = getLteDbm();
         }
     } else {
         int cdmaDbm = getCdmaDbm();

Find a functionally equivalent code:android.view.ViewGroup.requestChildFocus:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -6,16 +6,16 @@
         return;
     }
     // Unfocus us, if necessary
-    super.unFocus();
+    super.unFocus(focused);
     // We had a previous notion of who had focus. Clear it.
     if (mFocused != child) {
         if (mFocused != null) {
-            mFocused.unFocus();
+            mFocused.unFocus(focused);
         }
         mFocused = child;
     }

Find a functionally equivalent code:android.app.admin.DevicePolicyManager.setActiveAdmin:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,7 +1,7 @@
 {
     if (mService != null) {
         try {
-            mService.setActiveAdmin(policyReceiver, refreshing, UserHandle.myUserId());
+            mService.setActiveAdmin(policyReceiver, refreshing, userHandle);
         } catch (RemoteException e) {
             Log.w(TAG, "Failed talking with device policy service", e);
         }

Find a functionally equivalent code:android.text.GraphicsOperations.getTextRunCursor:COMMENT
Method Modifier: hidden      
Comment:/**
 * Just like {@link Paint#getTextRunCursor}.
 * @hide
 */


Find a functionally equivalent code:android.util.ArraySet.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

@@ -1,8 +1,8 @@
 {
     if (mSize != 0) {
         freeArrays(mHashes, mArray, mSize);
-        mHashes = ContainerHelpers.EMPTY_INTS;
-        mArray = ContainerHelpers.EMPTY_OBJECTS;
+        mHashes = EmptyArray.INT;
+        mArray = EmptyArray.OBJECT;
         mSize = 0;
     }
 }

Find a functionally equivalent code:com.android.internal.os.RuntimeInit.wrapperInit:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * The main function called when an application is started through a
 * wrapper process.
 *
 * When the wrapper starts, the runtime starts {@link RuntimeInit#main}
 * which calls {@link WrapperInit#main} which then calls this method.
 * So we don't need to call commonInit() here.
 *
 * @param targetSdkVersion target SDK version
 * @param argv arg strings
 */

@@ -1,5 +1,5 @@
 {
     if (DEBUG)
         Slog.d(TAG, "RuntimeInit: Starting application from wrapper");
-    applicationInit(targetSdkVersion, argv);
+    applicationInit(targetSdkVersion, argv, null);
 }

Find a functionally equivalent code:android.os.Bundle.putSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Serializable value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Serializable object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putSerializable(key, value);
 }

Find a functionally equivalent code:android.hardware.SystemSensorManager.unregisterListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -1,6 +1,6 @@
 {
     // Trigger Sensors should use the cancelTriggerSensor call.
-    if (sensor != null && Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
+    if (sensor != null && sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
         return;
     }
     synchronized (mSensorListeners) {

Find a functionally equivalent code:android.media.AudioManager.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * set master mute state.
 *
 * @hide
 */


Find a functionally equivalent code:android.media.MediaFocusControl.setNewRcClientGenerationOnClients_syncRcsCurrc:COMMENT
Method Modifier: private     
Comment:/**
 * Update the remote control clients with the new "focused" client generation
 */

@@ -1,12 +1,12 @@
 {
     // (using an iterator on the stack so we can safely remove an entry if needed,
     // traversal order doesn't matter here as we update all entries)
-    Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+    Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
     while (stackIterator.hasNext()) {
-        RemoteControlStackEntry se = stackIterator.next();
-        if ((se != null) && (se.mRcClient != null)) {
+        PlayerRecord se = stackIterator.next();
+        if ((se != null) && (se.getRcc() != null)) {
             try {
-                se.mRcClient.setCurrentClientGenerationId(newClientGeneration);
+                se.getRcc().setCurrentClientGenerationId(newClientGeneration);
             } catch (RemoteException e) {
                 Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()", e);
                 stackIterator.remove();

Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the album / artwork picture to be displayed on the remote control.
 * @param key the identifier of the bitmap to set. The only valid value is
 * {@link #BITMAP_KEY_ARTWORK}
 * @param bitmap The bitmap for the artwork, or null if there isn't any.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 * @see android.graphics.Bitmap
 */

@@ -1,4 +1,12 @@
 {
     super.putBitmap(key, bitmap);
+    if (mMetadataBuilder != null) {
+        // MediaMetadata supports all the same fields as MetadataEditor
+        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
+        // But just in case, don't add things we don't understand
+        if (metadataKey != null) {
+            mMetadataBuilder.putBitmap(metadataKey, bitmap);
+        }
+    }
     return this;
 }

Find a functionally equivalent code:android.provider.Settings.Global.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -2,6 +2,11 @@
     if (LOCAL_LOGV) {
         Log.v(TAG, "Global.putString(name=" + name + ", value=" + value + " for " + userHandle);
     }
+    // Global and Secure have the same access policy so we can forward writes
+    if (MOVED_TO_SECURE.contains(name)) {
+        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, value is unchanged.");
+        return Secure.putStringForUser(resolver, name, value, userHandle);
+    }
     return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
 }

Find a functionally equivalent code:android.util.ArraySet.remove:COMMENT
Method Modifier: public      
Comment:/**
 * Removes the specified object from this set.
 *
 * @param object the object to remove.
 * @return {@code true} if this set was modified, {@code false} otherwise.
 */

@@ -1,5 +1,5 @@
 {
-    int index = object == null ? indexOfNull() : indexOf(object, object.hashCode());
+    final int index = indexOf(object);
     if (index >= 0) {
         removeAt(index);
         return true;

Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.sendAccessibilityEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */

@@ -1,6 +1,15 @@
 {
-    if (!mIsEnabled) {
-        throw new IllegalStateException("Accessibility off. Did you forget to check that?");
+    final IAccessibilityManager service;
+    final int userId;
+    synchronized (mLock) {
+        service = getServiceLocked();
+        if (service == null) {
+            return;
+        }
+        if (!mIsEnabled) {
+            throw new IllegalStateException("Accessibility off. Did you forget to check that?");
+        }
+        userId = mUserId;
     }
     boolean doRecycle = false;
     try {
@@ -9,15 +18,24 @@
         // client using it is called through Binder from another process. Example: MMS
         // app adds a SMS notification and the NotificationManagerService calls this method
         long identityToken = Binder.clearCallingIdentity();
-        doRecycle = mService.sendAccessibilityEvent(event, mUserId);
+        doRecycle = service.sendAccessibilityEvent(event, userId);
         Binder.restoreCallingIdentity(identityToken);
         if (DEBUG) {
             Log.i(LOG_TAG, event + " sent");

Find a functionally equivalent code:android.media.AudioService.playSoundEffectVolume:COMMENT
Method Modifier: public      
Comment:/**
 * @see AudioManager#playSoundEffect(int, float)
 */

@@ -1,3 +1,7 @@
 {
+    if (effectType >= AudioManager.NUM_SOUND_EFFECTS || effectType < 0) {
+        Log.w(TAG, "AudioService effectType value " + effectType + " out of range");
+        return;
+    }
     sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE, effectType, (int) (volume * 1000), null, 0);
 }

Find a functionally equivalent code:android.graphics.Paint.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the paint to its default settings.
 */

@@ -11,25 +11,23 @@
     mRasterizer = null;
     mShader = null;
     mTypeface = null;
+    mNativeTypeface = 0;
     mXfermode = null;
     mHasCompatScaling = false;
     mCompatScaling = 1;
     mInvCompatScaling = 1;
-    hasShadow = false;
-    shadowDx = 0;
-    shadowDy = 0;
-    shadowRadius = 0;
-    shadowColor = 0;
     mBidiFlags = BIDI_DEFAULT_LTR;
     setTextLocale(Locale.getDefault());
+    setElegantTextHeight(false);
+    mFontFeatureSettings = null;
 }

Find a functionally equivalent code:android.os.BatteryStats.getPhoneOnTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been on while the device was
 * running on battery.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.view.ViewGroup.unFocus:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

@@ -3,11 +3,11 @@
         System.out.println(this + " unFocus()");
     }
     if (mFocused == null) {
-        super.unFocus();
+        super.unFocus(focused);
     } else {
-        mFocused.unFocus();
+        mFocused.unFocus(focused);
         mFocused = null;
     }
 }

Find a functionally equivalent code:android.media.RemoteControlClient.MetadataEditor.putLong:COMMENT
Method Modifier: public      
Comment:/**
 * Adds numerical information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key the identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_CD_TRACK_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DISC_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DURATION} (with a value
 * expressed in milliseconds),
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_YEAR}.
 * @param value The long value for the given key
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 */

@@ -1,4 +1,12 @@
 {
     super.putLong(key, value);
+    if (mMetadataBuilder != null) {
+        // MediaMetadata supports all the same fields as MetadataEditor
+        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
+        // But just in case, don't add things we don't understand
+        if (metadataKey != null) {
+            mMetadataBuilder.putLong(metadataKey, value);
+        }
+    }
     return this;
 }

Find a functionally equivalent code:android.view.ViewPropertyAnimator.startAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the underlying Animator for a set of properties. We use a single animator that
 * simply runs from 0 to 1, and then use that fractional value to set each property
 * value accordingly.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRTBackend != null && mRTBackend.startAnimation(this)) {
+        return;
+    }
     mView.setHasTransientState(true);
     ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
     ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();

Find a functionally equivalent code:android.bluetooth.BluetoothDevice.fetchUuidsWithSdp:COMMENT
Method Modifier: public      
Comment:/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */

@@ -1,6 +1,11 @@
 {
+    IBluetooth service = sService;
+    if (service == null) {
+        Log.e(TAG, "BT not enabled. Cannot fetchUuidsWithSdp");
+        return false;
+    }
     try {
-        return sService.fetchRemoteUuids(this);
+        return service.fetchRemoteUuids(this);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
     }

Find a functionally equivalent code:android.widget.ListPopupWindow.setModal:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether this window should be modal when shown.
 *
 * <p>If a popup window is modal, it will receive all touch and key input.
 * If the user touches outside the popup window's content area the popup window
 * will be dismissed.
 *
 * @param modal {@code true} if the popup window should be modal, {@code false} otherwise.
 */

@@ -1,4 +1,4 @@
 {
-    mModal = true;
+    mModal = modal;
     mPopup.setFocusable(modal);
 }

Find a functionally equivalent code:android.media.MediaFocusControl.unregisterRemoteControlClient:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterRemoteControlClient(PendingIntent pi, ...)
 * rcClient is guaranteed non-null
 */

@@ -1,32 +1,26 @@
 {
     if (DEBUG_RC)
         Log.i(TAG, "Unregister remote control client rcClient=" + rcClient);
-    synchronized (mAudioFocusLock) {
-        synchronized (mRCStack) {
-            boolean topRccChange = false;
-            try {
-                for (int index = mRCStack.size() - 1; index >= 0; index--) {
-                    final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
-                    if ((rcse.mMediaIntent.equals(mediaIntent)) && rcClient.equals(rcse.mRcClient)) {
-                        // we found the IRemoteControlClient to unregister
-                        // stop monitoring its death
-                        rcse.unlinkToRcClientDeath();
-                        // reset the client-related fields
-                        rcse.mRcClient = null;
-                        rcse.mCallingPackageName = null;
-                        topRccChange = (index == mRCStack.size() - 1);
-                        // there can only be one matching RCC in the RC stack, we're done
-                        break;
-                    }
+    synchronized (mPRStack) {
+        boolean topRccChange = false;
+        try {
+            for (int index = mPRStack.size() - 1; index >= 0; index--) {
+                final PlayerRecord prse = mPRStack.elementAt(index);
+                if ((prse.hasMatchingMediaButtonIntent(mediaIntent)) && rcClient.equals(prse.getRcc())) {
+                    // we found the IRemoteControlClient to unregister
+                    prse.resetControllerInfoForNoRcc();
+                    topRccChange = (index == mPRStack.size() - 1);
+                    // there can only be one matching RCC in the RC stack, we're done
+                    break;
                 }
-            } catch (ArrayIndexOutOfBoundsException e) {
-                // not expected to happen, indicates improper concurrent modification
-                Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
             }
-            if (topRccChange) {
-                // no more RCC for the RCD, check for potential refresh of the remote controls
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
+        } catch (ArrayIndexOutOfBoundsException e) {
+            // not expected to happen, indicates improper concurrent modification
+            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
+        }
+        if (topRccChange) {
+            // no more RCC for the RCD, check for potential refresh of the remote controls
+            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
         }
     }
 }

Find a functionally equivalent code:android.graphics.drawable.GradientDrawable.setColors:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the colors used to draw the gradient. Each color is specified as an
 * ARGB integer and the array must contain at least 2 colors.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param colors 2 or more ARGB colors
 *
 * @see #mutate()
 * @see #setColor(int)
 */

@@ -1,5 +1,5 @@
 {
     mGradientState.setColors(colors);
-    mRectIsDirty = true;
+    mGradientIsDirty = true;
     invalidateSelf();
 }

Find a functionally equivalent code:android.view.textservice.TextInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

@@ -1,5 +1,5 @@
 {
-    dest.writeString(mText);
+    TextUtils.writeToParcel(mCharSequence, dest, flags);
     dest.writeInt(mCookie);
-    dest.writeInt(mSequence);
+    dest.writeInt(mSequenceNumber);
 }

Find a functionally equivalent code:android.app.ApplicationErrorReport.CrashInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a CrashInfo instance to a parcel.
 */

@@ -1,4 +1,5 @@
 {
+    int start = dest.dataPosition();
     dest.writeString(exceptionClassName);
     dest.writeString(exceptionMessage);
     dest.writeString(throwFileName);
@@ -6,9 +7,20 @@
     dest.writeString(throwMethodName);
     dest.writeInt(throwLineNumber);
     dest.writeString(stackTrace);
+    int total = dest.dataPosition() - start;
+    if (total > 20 * 1024) {
+        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
+        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
+        Slog.d("Error", "ERR: file=" + throwFileName);
+        Slog.d("Error", "ERR: class=" + throwClassName);
+        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
+        Slog.d("Error", "ERR: stack=" + stackTrace);
+        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
+    }
 }

Find a functionally equivalent code:com.android.documentsui.SortingCursorWrapper.binarySort:COMMENT
Method Modifier: private     static      
Comment:/**
 * Borrowed from TimSort.binarySort(), but modified to sort two column
 * dataset.
 */


Find a functionally equivalent code:android.app.Notification.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Flatten this notification from a parcel.
 */

@@ -48,53 +48,59 @@
         parcel.writeInt(0);
     }
     parcel.writeInt(audioStreamType);
+    if (audioAttributes != null) {
+        parcel.writeInt(1);
+        audioAttributes.writeToParcel(parcel, 0);
+    } else {
+        parcel.writeInt(0);
+    }
     parcel.writeLongArray(vibrate);
     parcel.writeInt(ledARGB);
     parcel.writeInt(ledOnMS);
@@ -60,67 +66,74 @@
         parcel.writeInt(0);
     }
     parcel.writeInt(priority);
-    // ok for null
-    parcel.writeStringArray(kind);
+    parcel.writeString(category);
+    parcel.writeString(mGroupKey);
+    parcel.writeString(mSortKey);
     // null ok
     parcel.writeBundle(extras);
     // null ok
@@ -72,75 +79,96 @@
     } else {
         parcel.writeInt(0);
     }
+    if (headsUpContentView != null) {
+        parcel.writeInt(1);
+        headsUpContentView.writeToParcel(parcel, 0);
+    } else {
+        parcel.writeInt(0);
+    }
+    parcel.writeInt(visibility);
+    if (publicVersion != null) {
+        parcel.writeInt(1);
+        publicVersion.writeToParcel(parcel, 0);
+    } else {
+        parcel.writeInt(0);
+    }
+    parcel.writeInt(color);
 }

Find a functionally equivalent code:android.graphics.Paint.setTypeface:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the typeface object.
 * <p />
 * Pass null to clear any previous typeface.
 * As a convenience, the parameter passed is also returned.
 *
 * @param typeface May be null. The typeface to be installed in the paint
 * @return         typeface
 */

@@ -1,9 +1,10 @@
 {
-    int typefaceNative = 0;
+    long typefaceNative = 0;
     if (typeface != null) {
         typefaceNative = typeface.native_instance;
     }
     native_setTypeface(mNativePaint, typefaceNative);
     mTypeface = typeface;
+    mNativeTypeface = typefaceNative;
     return typeface;
 }

Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.handleChildProc:COMMENT
Method Modifier: private     internal    
Comment:/**
 * Handles post-fork setup of child proc, closing sockets as appropriate,
 * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller
 * if successful or returning if failed.
 *
 * @param parsedArgs non-null; zygote args
 * @param descriptors null-ok; new file descriptors for stdio if available.
 * @param pipeFd null-ok; pipe for communication back to Zygote.
 * @param newStderr null-ok; stream to use for stderr until stdio
 * is reopened.
 *
 * @throws ZygoteInit.MethodAndArgsCaller on success to
 * trampoline to code that invokes static main.
 */

@@ -1,4 +1,9 @@
 {
+    /**
+     * By the time we get here, the native code has closed the two actual Zygote
+     * socket connections, and substituted /dev/null in their place.  The LocalSocket
+     * objects still need to be closed properly.
+     */
     closeSocket();
     ZygoteInit.closeServerSocket();
     if (descriptors != null) {
@@ -19,25 +24,30 @@
         if (parsedArgs.invokeWith != null) {
             WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, pipeFd, parsedArgs.remainingArgs);
         } else {
-            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
+            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null);
         }
     } else {
         String className;

Find a functionally equivalent code:android.graphics.Canvas.drawBitmapMesh:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the bitmap through the mesh, where mesh vertices are evenly
 * distributed across the bitmap. There are meshWidth+1 vertices across, and
 * meshHeight+1 vertices down. The verts array is accessed in row-major
 * order, so that the first meshWidth+1 vertices are distributed across the
 * top of the bitmap from left to right. A more general version of this
 * method is drawVertices().
 *
 * @param bitmap The bitmap to draw using the mesh
 * @param meshWidth The number of columns in the mesh. Nothing is drawn if
 * this is 0
 * @param meshHeight The number of rows in the mesh. Nothing is drawn if
 * this is 0
 * @param verts Array of x,y pairs, specifying where the mesh should be
 * drawn. There must be at least
 * (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values
 * in the array
 * @param vertOffset Number of verts elements to skip before drawing
 * @param colors May be null. Specifies a color at each vertex, which is
 * interpolated across the cell, and whose values are
 * multiplied by the corresponding bitmap colors. If not null,
 * there must be at least (meshWidth+1) * (meshHeight+1) +
 * colorOffset values in the array.
 * @param colorOffset Number of color elements to skip before drawing
 * @param paint  May be null. The paint used to draw the bitmap
 */

@@ -12,16 +12,16 @@
         // no mul by 2, since we need only 1 color per vertex
         checkRange(colors.length, colorOffset, count);
     }
-    nativeDrawBitmapMesh(mNativeCanvas, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
+    nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
 }

Find a functionally equivalent code:android.os.Bundle.getFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a float[] value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (float[]) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "float[]", e);
-        return null;
-    }
+    return super.getFloatArray(key);
 }

Find a functionally equivalent code:android.util.LongSparseLongArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

@@ -4,18 +4,11 @@
         mValues[i] = value;
     } else {
         i = ~i;
-        if (mSize >= mKeys.length) {
-            growKeyAndValueArrays(mSize + 1);
-        }
-        if (mSize - i != 0) {
-            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-        }
-        mKeys[i] = key;
-        mValues[i] = value;
+        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
+        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
         mSize++;
     }
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testWifiStateChange:COMMENT
Method Modifier: public      
Comment:// Test case 8: test wifi state change while connecting/disconnecting to/from an AP

@@ -1,25 +1,20 @@
 {
-    assertNotNull("SSID is null", mTestAccessPoint);
-    // Connect to mTestAccessPoint
-    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
-    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
-    assertNotNull("Not associated with any AP", mWifiManager.getConnectionInfo().getBSSID());
-    try {
-        Thread.sleep(SHORT_TIMEOUT);
-    } catch (Exception e) {
-        log("exception: " + e.toString());
-    }
-    // Disconnect from the current AP
-    log("disconnect from the AP");
-    if (!disconnectAP()) {
-        log("failed to disconnect from " + mTestAccessPoint);
-    }
+    assertNotNull("SSID is null", mSsid);
+    // enable WiFi
+    assertTrue("failed to enable wifi", enableWifi());
+    // wait for wifi enable
+    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
+    // connect to Wifi
+    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
+    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
+    assertNotNull("not associated with any AP", mWifiManager.getConnectionInfo().getBSSID());
+    // disconnect from the current AP
+    assertTrue("failed to disconnect from AP", disconnectAP());
+    // below check disbabled since we have bug in what ConnectivityManager returns
     // Verify the connectivity state for Wifi is DISCONNECTED
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
-    if (!disableWifi()) {
-        log("disable Wifi failed");
-        return;
-    }
-    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
+    // assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI,
+    // State.DISCONNECTED, LONG_TIMEOUT));
+    // disable WiFi
+    assertTrue("failed to disable wifi", disableWifi());
+    assertTrue("wifi state not disabled", waitForWifiState(WifiManager.WIFI_STATE_DISABLED, LONG_TIMEOUT));
 }

Find a functionally equivalent code:android.service.dreams.DreamService.onCreate:COMMENT
Method Modifier: public      
Comment:/**
 * Called when this Dream is constructed.
 */

@@ -1,5 +1,5 @@
 {
     if (mDebug)
-        Slog.v(TAG, "onCreate() on thread " + Thread.currentThread().getId());
+        Slog.v(TAG, "onCreate()");
     super.onCreate();
 }

Find a functionally equivalent code:android.app.Notification.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */

@@ -1,12 +1,21 @@
 {
+    mOriginatingUserId = mContext.getUserId();
+    mHasThreeLines = hasThreeLines();
     Notification n = buildUnstyled();
     if (mStyle != null) {
         n = mStyle.buildStyled(n);
     }
-    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
-    addExtras(n.extras);
+    if (mExtras != null) {
+        n.extras.putAll(mExtras);
+    }
+    if (mRebuildBundle.size() > 0) {
+        n.extras.putAll(mRebuildBundle);
+        mRebuildBundle.clear();
+    }
+    populateExtras(n.extras);
     if (mStyle != null) {
         mStyle.addExtras(n.extras);
     }
+    mHasThreeLines = false;
     return n;
 }

Find a functionally equivalent code:android.graphics.NinePatch.getTransparentRegion:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns a {@link Region} representing the parts of the NinePatch that are
 * completely transparent.
 *
 * @param bounds The location and size of the NinePatch.
 *
 * @return null if the NinePatch has no transparent region to
 * report, else a {@link Region} holding the parts of the specified bounds
 * that are transparent.
 */

@@ -1,4 +1,4 @@
 {
-    int r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
+    long r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
     return r != 0 ? new Region(r) : null;
 }

Find a functionally equivalent code:android.media.MediaPlayer.start:COMMENT
Method Modifier: public      
Comment:/**
 * Starts or resumes playback. If playback had previously been paused,
 * playback will continue from where it was paused. If playback had
 * been stopped, or never started before, playback will start at the
 * beginning.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

@@ -1,4 +1,7 @@
 {
+    if (isRestricted()) {
+        _setVolume(0, 0);
+    }
     stayAwake(true);
     _start();
 }

Find a functionally equivalent code:android.util.SparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -6,23 +6,12 @@
     if (mGarbage && mSize >= mKeys.length) {
         gc();
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        int n = ArrayUtils.idealIntArraySize(pos + 1);
-        int[] nkeys = new int[n];
-        Object[] nvalues = new Object[n];
-        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-        mKeys = nkeys;
-        mValues = nvalues;
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:com.android.systemui.statusbar.BaseStatusBar.handleNotificationError:COMMENT
Method Modifier: 
Comment:/**
 * Cancel this notification and tell the StatusBarManagerService / NotificationManagerService
 * about the failure.
 *
 * WARNING: this will call back into us.  Don't hold any locks.
 */

@@ -1,7 +1,7 @@
 {
-    removeNotification(key);
+    removeNotification(n.getKey(), null);
     try {
-        mBarService.onNotificationError(n.getPackageName(), n.getTag(), n.getId(), n.getUid(), n.getInitialPid(), message);
+        mBarService.onNotificationError(n.getPackageName(), n.getTag(), n.getId(), n.getUid(), n.getInitialPid(), message, n.getUserId());
     } catch (RemoteException ex) {
     // The end is nigh.
     }

Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.getAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the alpha value of this drawable's color.
 *
 * @return A value between 0 and 255.
 */

@@ -1,3 +1,3 @@
 {
-    return mState.mUseColor >>> 24;
+    return mColorState.mUseColor >>> 24;
 }

Find a functionally equivalent code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

@@ -2,7 +2,8 @@
     dest.writeInt(mNetworkId);
     dest.writeInt(mRssi);
     dest.writeInt(mLinkSpeed);
+    dest.writeInt(mFrequency);
     if (mIpAddress != null) {
         dest.writeByte((byte) 1);
         dest.writeByteArray(mIpAddress.getAddress());
@@ -17,21 +18,29 @@
     dest.writeString(mBSSID);
     dest.writeString(mMacAddress);
     dest.writeInt(mMeteredHint ? 1 : 0);
+    dest.writeInt(score);
+    dest.writeDouble(txSuccessRate);
+    dest.writeDouble(txRetriesRate);
+    dest.writeDouble(txBadRate);
+    dest.writeDouble(rxSuccessRate);
+    dest.writeInt(badRssiCount);
+    dest.writeInt(lowRssiCount);
     mSupplicantState.writeToParcel(dest, flags);
 }

Find a functionally equivalent code:android.transition.Transition.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resumes this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

@@ -3,11 +3,15 @@
         if (!mEnded) {
             ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
             int numOldAnims = runningAnimators.size();
+            WindowId windowId = sceneRoot.getWindowId();
             for (int i = numOldAnims - 1; i >= 0; i--) {
-                Animator anim = runningAnimators.keyAt(i);
-                anim.resume();
+                AnimationInfo info = runningAnimators.valueAt(i);
+                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
+                    Animator anim = runningAnimators.keyAt(i);
+                    anim.resume();
+                }
             }
             if (mListeners != null && mListeners.size() > 0) {
                 ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();

Find a functionally equivalent code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

@@ -1,19 +1,20 @@
 {
     mTouchMode = TOUCH_MODE_IDLE;
-    // Up and not canceled, also checks the switch has not been disabled during the drag
-    boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
-    cancelSuperTouch(ev);
+    // Commit the change if the event is up and not canceled and the switch
+    // has not been disabled during the drag.
+    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
+    final boolean newState;
     if (commitChange) {
-        boolean newState;
         mVelocityTracker.computeCurrentVelocity(1000);
-        float xvel = mVelocityTracker.getXVelocity();
+        final float xvel = mVelocityTracker.getXVelocity();
         if (Math.abs(xvel) > mMinFlingVelocity) {
             newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
         } else {
             newState = getTargetCheckedState();
         }
-        animateThumbToCheckedState(newState);
     } else {
-        animateThumbToCheckedState(isChecked());
+        newState = isChecked();
     }
+    setChecked(newState);
+    cancelSuperTouch(ev);
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.waitForTetherStateChange:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: int waitForTetherStateChange(long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Wait for the wifi tethering result:
 * @param timeout is the maximum waiting time
 * @return SUCCESS if tethering result is successful
 * FAILURE if tethering result returns error.
 */

@@ -1,21 +1,26 @@
 {
-    long startTime = System.currentTimeMillis();
+    long startTime = SystemClock.uptimeMillis();
+    String[] wifiRegexes = mCm.getTetherableWifiRegexs();
     while (true) {
-        if ((System.currentTimeMillis() - startTime) > timeout) {
-            return mWifiTetherResult;
+        if ((SystemClock.uptimeMillis() - startTime) > timeout) {
+            return false;
         }
-        log("Wait for wifi tethering result.");
-        synchronized (this) {
-            try {
-                this.wait(SHORT_TIMEOUT);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
+        String[] active = mCm.getTetheredIfaces();
+        String[] error = mCm.getTetheringErroredIfaces();
+        for (String iface : active) {
+            for (String regex : wifiRegexes) {
+                if (iface.matches(regex)) {
+                    return true;
+                }
             }
-            if (mWifiTetherResult == INIT) {
-                continue;
-            } else {
-                return mWifiTetherResult;
+        }
+        for (String iface : error) {
+            for (String regex : wifiRegexes) {
+                if (iface.matches(regex)) {
+                    return false;
+                }
             }
         }
+        SystemClock.sleep(SHORT_TIMEOUT);
     }
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.impl.RenderSessionImpl.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes and acquires the scene, creating various Android objects such as context,
 * inflater, and parser.
 *
 * @param timeout the time to wait if another rendering is happening.
 *
 * @return whether the scene was prepared
 *
 * @see #acquire(long)
 * @see #release()
 */

@@ -1,6 +1,6 @@
 {
     Result result = super.init(timeout);
-    if (result.isSuccess() == false) {
+    if (!result.isSuccess()) {
         return result;
     }
     SessionParams params = getParams();
@@ -16,21 +16,22 @@
     findNavigationBar(resources, metrics);
     // FIXME: find those out, and possibly add them to the render params
     boolean hasNavigationBar = true;
+    // noinspection ConstantConditions
     IWindowManager iwm = new IWindowManagerImpl(getContext().getConfiguration(), metrics, Surface.ROTATION_0, hasNavigationBar);
     WindowManagerGlobal_Delegate.setWindowManagerService(iwm);
     // build the inflater and parser.

Find a functionally equivalent code:android.content.res.XmlBlock.nativeNext:COMMENT
Method Modifier: default     static      final       native      
Comment:/*package*/


Find a functionally equivalent code:android.util.SparseBooleanArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

@@ -3,20 +3,9 @@
         put(key, value);
         return;
     }
-    int pos = mSize;
-    if (pos >= mKeys.length) {
-        int n = ArrayUtils.idealIntArraySize(pos + 1);
-        int[] nkeys = new int[n];
-        boolean[] nvalues = new boolean[n];
-        // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
-        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-        mKeys = nkeys;
-        mValues = nvalues;
-    }
-    mKeys[pos] = key;
-    mValues[pos] = value;
-    mSize = pos + 1;
+    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
+    mValues = GrowingArrayUtils.append(mValues, mSize, value);
+    mSize++;
 }

Find a functionally equivalent code:android.widget.Switch.setTrackResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param resId Resource ID of a track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

@@ -1,3 +1,3 @@
 {
-    setTrackDrawable(getContext().getResources().getDrawable(resId));
+    setTrackDrawable(getContext().getDrawable(resId));
 }

Find a functionally equivalent code:android.content.res.AssetManager.ensureStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

@@ -2,8 +2,8 @@
     if (mStringBlocks == null) {
         synchronized (this) {
             if (mStringBlocks == null) {
-                makeStringBlocks(true);
+                makeStringBlocks(sSystem.mStringBlocks);
             }
         }
     }

Find a functionally equivalent code:com.android.systemui.recent.RecentTasksLoader.createTaskDescription:COMMENT
Method Modifier: 
Comment:// Create an TaskDescription, returning null if the title or icon is null

@@ -4,18 +4,23 @@
         intent.setComponent(origActivity);
     }
     final PackageManager pm = mContext.getPackageManager();
+    final IPackageManager ipm = AppGlobals.getPackageManager();
     intent.setFlags((intent.getFlags() & ~Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) | Intent.FLAG_ACTIVITY_NEW_TASK);
-    final ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
+    ResolveInfo resolveInfo = null;
+    try {
+        resolveInfo = ipm.resolveIntent(intent, null, 0, userId);
+    } catch (RemoteException re) {
+    }
     if (resolveInfo != null) {
         final ActivityInfo info = resolveInfo.activityInfo;
         final String title = info.loadLabel(pm).toString();
         if (title != null && title.length() > 0) {
             if (DEBUG)
                 Log.v(TAG, "creating activity desc for id=" + persistentTaskId + ", label=" + title);
-            TaskDescription item = new TaskDescription(taskId, persistentTaskId, resolveInfo, baseIntent, info.packageName, description);
+            TaskDescription item = new TaskDescription(taskId, persistentTaskId, resolveInfo, baseIntent, info.packageName, description, userId);
             item.setLabel(title);
             return item;
         } else {

Find a functionally equivalent code:android.animation.PropertyValuesHolder.calculateValue:COMMENT
Method Modifier: 
Comment:/**
 * Function used to calculate the value according to the evaluator set up for
 * this PropertyValuesHolder object. This function is called by ValueAnimator.animateValue().
 *
 * @param fraction The elapsed, interpolated fraction of the animation.
 */

@@ -1,3 +1,4 @@
 {
-    mAnimatedValue = mKeyframeSet.getValue(fraction);
+    Object value = mKeyframes.getValue(fraction);
+    mAnimatedValue = mConverter == null ? value : mConverter.convert(value);
 }

Find a functionally equivalent code:android.graphics.Canvas.getSaveCount:COMMENT
<android.graphics.Canvas: int getSaveCount()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the number of matrix/clip states on the Canvas' private stack.
 * This will equal # save() calls - # restore() calls.
 */

@@ -1 +1,3 @@
-
+{
+    return native_getSaveCount(mNativeCanvasWrapper);
+}

Find a functionally equivalent code:android.view.inputmethod.BaseInputConnection.setComposingText:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */

@@ -2,6 +2,7 @@
     if (DEBUG)
         Log.v(TAG, "setComposingText " + text);
     replaceText(text, newCursorPosition, true);
+    mIMM.notifyUserAction();
     return true;
 }

Find a functionally equivalent code:android.view.HardwareRenderer.trimMemory:COMMENT
Method Modifier: default     static      
Comment:/**
 * Invoke this method when the system is running out of memory. This
 * method will attempt to recover as much memory as possible, based on
 * the specified hint.
 *
 * @param level Hint about the amount of memory that should be trimmed,
 * see {@link android.content.ComponentCallbacks}
 */

@@ -1,4 +1,3 @@
 {
-    startTrimMemory(level);
-    endTrimMemory();
+    ThreadedRenderer.trimMemory(level);
 }

Find a functionally equivalent code:android.app.backup.BackupAgent.onRestoreFile:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Only specialized platform agents should overload this entry point to support
 * restores to crazy non-app locations.
 * @hide
 */

@@ -23,28 +23,30 @@
                 mode = -1;
             }
         }
+    } else if (domain.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
+        basePath = getNoBackupFilesDir().getCanonicalPath();
     } else {
         // Not a supported location
         Log.i(TAG, "Unrecognized domain " + domain);

Find a functionally equivalent code:com.android.internal.location.GpsNetInitiatedHandler.getDlgIntent:COMMENT
Method Modifier: private     internal    
Comment:// notification and takes user input

@@ -3,9 +3,9 @@
     String title = getDialogTitle(notif, mContext);
     String message = getDialogMessage(notif, mContext);
     // directly bring up the NI activity
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
     intent.setClass(mContext, com.android.internal.app.NetInitiatedActivity.class);
     // put data in the intent
     intent.putExtra(NI_INTENT_KEY_NOTIF_ID, notif.notificationId);

Find a functionally equivalent code:android.media.AudioService.sendMasterMuteUpdate:COMMENT
Method Modifier: private     
Comment:// UI update and Broadcast Intent

@@ -1,4 +1,4 @@
 {
-    mVolumePanel.postMasterMuteChanged(flags);
+    mVolumeController.postMasterMuteChanged(flags);
     broadcastMasterMuteStatus(muted);
 }

Find a functionally equivalent code:android.graphics.Canvas.saveLayerAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Helper for saveLayerAlpha() that takes 4 values instead of a RectF.
 */

@@ -1,3 +1,4 @@
 {
-    return native_saveLayerAlpha(mNativeCanvas, left, top, right, bottom, alpha, saveFlags);
+    alpha = Math.min(255, Math.max(0, alpha));
+    return native_saveLayerAlpha(mNativeCanvasWrapper, left, top, right, bottom, alpha, saveFlags);
 }

Find a functionally equivalent code:android.widget.AutoCompleteTextView.setAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the list of data used for auto completion. The provided list
 * must be a filterable list adapter.</p>
 *
 * <p>The caller is still responsible for managing any resources used by the adapter.
 * Notably, when the AutoCompleteTextView is closed or released, the adapter is not notified.
 * A common case is the use of {@link android.widget.CursorAdapter}, which
 * contains a {@link android.database.Cursor} that must be closed.  This can be done
 * automatically (see
 * {@link android.app.Activity#startManagingCursor(android.database.Cursor)
 * startManagingCursor()}),
 * or by manually closing the cursor when the AutoCompleteTextView is dismissed.</p>
 *
 * @param adapter the adapter holding the auto completion data
 *
 * @see #getAdapter()
 * @see android.widget.Filterable
 * @see android.widget.ListAdapter
 */

@@ -1,6 +1,6 @@
 {
     if (mObserver == null) {
-        mObserver = new PopupDataSetObserver();
+        mObserver = new PopupDataSetObserver(this);
     } else if (mAdapter != null) {
         mAdapter.unregisterDataSetObserver(mObserver);
     }

Find a functionally equivalent code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];
@@ -6,11 +9,16 @@
         return defValue;
     } else if (type == TypedValue.TYPE_FRACTION) {
         return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
+    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
+        throw new RuntimeException("Failed to resolve attribute at index " + index);
     }
     throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest.testDataConnectionWithWifiToAMToWifi:COMMENT
Method Modifier: public      
Comment:// Test case 7: test connectivity while transit from Wifi->AM->Wifi

@@ -1,40 +1,23 @@
 {
-    if (mWifiOnlyFlag) {
-        Log.v(TAG, this.getName() + " is excluded for wifi-only test");
-        return;
-    }
-    // Connect to mTestAccessPoint
-    assertNotNull("SSID is null", mTestAccessPoint);
-    // Connect to Wifi
-    assertTrue("failed to connect to " + mTestAccessPoint, connectToWifi(mTestAccessPoint));
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
-    try {
-        Thread.sleep(SHORT_TIMEOUT);
-    } catch (Exception e) {
-        log("exception: " + e.toString());
-    }
-    // Enable airplane mode without clearing Wifi
-    mCM.setAirplaneMode(true);
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, LONG_TIMEOUT));
-    try {
-        Thread.sleep(SHORT_TIMEOUT);
-    } catch (Exception e) {
-        log("exception: " + e.toString());
-    }
-    // Prepare for state validation
-    NetworkInfo networkInfo = mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-    assertEquals(State.DISCONNECTED, networkInfo.getState());
-    setStateTransitionCriteria(ConnectivityManager.TYPE_WIFI, networkInfo.getState(), NetworkState.TO_CONNECTION, State.CONNECTED);
-    // Disable airplane mode
-    mCM.setAirplaneMode(false);
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
-    if (!mWifiOnlyFlag) {
-        assertTrue(waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.DISCONNECTED, LONG_TIMEOUT));
-    }
-    // validate the state transition
-    if (!validateNetworkStates(ConnectivityManager.TYPE_WIFI)) {
-        log("Wifi state transition validation failed.");
-        log("reason: " + getTransitionFailureReason(ConnectivityManager.TYPE_WIFI));
-        assertTrue(false);
-    }
+    // connect to mTestAccessPoint
+    assertNotNull("SSID is null", mSsid);
+    // enable WiFi
+    assertTrue("failed to enable wifi", enableWifi());
+    // wait for wifi enable
+    assertTrue("wifi not enabled", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, LONG_TIMEOUT));
+    // connect to Wifi
+    assertTrue("failed to connect to " + mSsid, connectToWifi(mSsid, mPassword));
+    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
+    // enable airplane mode without clearing Wifi
+    mCm.setAirplaneMode(true);
+    // assert there is active network connection after airplane mode disabled
+    assertTrue("still has active network connection", waitUntilNoActiveNetworkConnection(LONG_TIMEOUT));
+    // disable airplane mode
+    mCm.setAirplaneMode(false);
+    // assert there is active network connection after airplane mode disabled
+    assertTrue("no active network connection after airplane mode disable", waitForActiveNetworkConnection(LONG_TIMEOUT));
+    // assert that we have a Wifi connection
+    assertTrue("wifi not connected after airplane mode disable", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
+    // verify that connection actually works
+    assertTrue("no network connectivity at end of test", checkNetworkConnectivity());
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.canHideNavigationBar:COMMENT
Method Modifier: private     internal    
Comment:/**
 * @return whether the navigation bar can be hidden, e.g. the device has a
 * navigation bar and touch exploration is not enabled
 */

@@ -1,3 +1,3 @@
 {
-    return mHasNavigationBar && !mTouchExplorationEnabled;
+    return mHasNavigationBar && !mAccessibilityManager.isTouchExplorationEnabled();
 }

Find a functionally equivalent code:com.android.layoutlib.bridge.util.SparseWeakArray.keyAt:COMMENT
Method Modifier: public      
Comment:/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 */


Find a functionally equivalent code:android.media.MediaRouter.removeCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the specified callback. It will no longer receive events about media routing.
 *
 * @param cb Callback to remove
 */

@@ -1,10 +1,8 @@
 {
     int index = findCallbackInfo(cb);
     if (index >= 0) {
-        CallbackInfo info = sStatic.mCallbacks.remove(index);
-        if ((info.flags & CALLBACK_FLAG_PERFORM_ACTIVE_SCAN) != 0) {
-            sStatic.updateActiveScan();
-        }
+        sStatic.mCallbacks.remove(index);
+        sStatic.updateDiscoveryRequest();
     } else {
         Log.w(TAG, "removeCallback(" + cb + "): callback not registered");
     }

Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerIsSignalClipping:COMMENT
Method Modifier: private     static      native      
Comment:// SR_RecognizerLockFunction function, void* data);


Find a functionally equivalent code:android.app.Activity.getActionBar:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a reference to this activity's ActionBar.
 *
 * @return The Activity's ActionBar, or null if it does not have one.
 */

@@ -1,4 +1,4 @@
 {
-    initActionBar();
+    initWindowDecorActionBar();
     return mActionBar;
 }

Find a functionally equivalent code:android.bluetooth.BluetoothGatt.readDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

@@ -1,5 +1,5 @@
 {
-    if (DBG)
+    if (VDBG)
         Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
     if (mService == null || mClientIf == 0)
         return false;
@@ -12,21 +12,27 @@
     BluetoothDevice device = service.getDevice();
     if (device == null)
         return false;
+    synchronized (mDeviceBusy) {
+        if (mDeviceBusy)
+            return false;
+        mDeviceBusy = true;
+    }
     try {
         mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
     } catch (RemoteException e) {
         Log.e(TAG, "", e);
+        mDeviceBusy = false;
         return false;
     }
     return true;

Find a functionally equivalent code:android.widget.FastScroller.startPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Delays dragging until after the framework has determined that the user is
 * scrolling, rather than tapping.
 */

@@ -1,4 +1,3 @@
 {
-    mHasPendingDrag = true;
-    mList.postDelayed(mDeferStartDrag, TAP_TIMEOUT);
+    mPendingDrag = SystemClock.uptimeMillis() + TAP_TIMEOUT;
 }

Find a functionally equivalent code:android.view.accessibility.AccessibilityManager.getInstalledAccessibilityServiceList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */

@@ -1,12 +1,25 @@
 {
+    final IAccessibilityManager service;
+    final int userId;
+    synchronized (mLock) {
+        service = getServiceLocked();
+        if (service == null) {
+            return Collections.emptyList();
+        }
+        userId = mUserId;
+    }
     List<AccessibilityServiceInfo> services = null;
     try {
-        services = mService.getInstalledAccessibilityServiceList(mUserId);
+        services = service.getInstalledAccessibilityServiceList(userId);
         if (DEBUG) {
             Log.i(LOG_TAG, "Installed AccessibilityServices " + services);
         }
     } catch (RemoteException re) {
         Log.e(LOG_TAG, "Error while obtaining the installed AccessibilityServices. ", re);
     }
-    return Collections.unmodifiableList(services);
+    if (services != null) {
+        return Collections.unmodifiableList(services);
+    } else {
+        return Collections.emptyList();
+    }
 }

Find a functionally equivalent code:android.database.ContentObserver.dispatchChange:COMMENT
Method Modifier: public      final       deprecated  
Comment:/**
 * Dispatches a change notification to the observer.
 * <p>
 * If a {@link Handler} was supplied to the {@link ContentObserver} constructor,
 * then a call to the {@link #onChange} method is posted to the handler's message queue.
 * Otherwise, the {@link #onChange} method is invoked immediately on this thread.
 * </p>
 *
 * @param selfChange True if this is a self-change notification.
 *
 * @deprecated Use {@link #dispatchChange(boolean, Uri)} instead.
 */


Find a functionally equivalent code:android.widget.CalendarView.setFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

@@ -1,8 +1,3 @@
 {
-    if (mFirstDayOfWeek == firstDayOfWeek) {
-        return;
-    }
-    mFirstDayOfWeek = firstDayOfWeek;
-    mAdapter.init();
-    setUpHeader();
+    mDelegate.setFirstDayOfWeek(firstDayOfWeek);
 }

Find a functionally equivalent code:android.content.res.AssetManager.openXmlBlockAsset:COMMENT
Method Modifier: default     final       
Comment:/*package*/

@@ -1,14 +1,3 @@
 {
-    synchronized (this) {
-        if (!mOpen) {
-            throw new RuntimeException("Assetmanager has been closed");
-        }
-        int xmlBlock = openXmlAssetNative(cookie, fileName);
-        if (xmlBlock != 0) {
-            XmlBlock res = new XmlBlock(this, xmlBlock);
-            incRefsLocked(res.hashCode());
-            return res;
-        }
-    }
-    throw new FileNotFoundException("Asset XML file: " + fileName);
+    return openXmlBlockAsset(0, fileName);
 }

Find a functionally equivalent code:android.view.HardwareLayer.copyInto:COMMENT
<android.view.HardwareLayer: boolean copyInto(Bitmap)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
Comment:/**
 * Copies this layer into the specified bitmap.
 *
 * @param bitmap The bitmap to copy they layer into
 *
 * @return True if the copy was successful, false otherwise
 */

@@ -1 +1,3 @@
-
+{
+    return mRenderer.copyLayerInto(this, bitmap);
+}

Find a functionally equivalent code:android.service.dreams.DreamService.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

@@ -2,14 +2,14 @@
     // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
     if (!mInteractive) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on keyEvent");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on keyEvent");
+        wakeUp();
         return true;
     } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
         if (mDebug)
-            Slog.v(TAG, "Finishing on back key");
-        safelyFinish();
+            Slog.v(TAG, "Waking up on back key");
+        wakeUp();
         return true;
     }
     return mWindow.superDispatchKeyEvent(event);

Find a functionally equivalent code:android.media.RemoteControlClient.editMetadata:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link MetadataEditor}.
 * @param startEmpty Set to false if you want the MetadataEditor to contain the metadata that
 * was previously applied to the RemoteControlClient, or true if it is to be created empty.
 * @return a new MetadataEditor instance.
 */

@@ -12,16 +12,22 @@
         editor.mMetadataChanged = false;
         editor.mArtworkChanged = false;
     }
+    // USE_SESSIONS
+    if (startEmpty || mMediaMetadata == null) {
+        editor.mMetadataBuilder = new MediaMetadata.Builder();
+    } else {
+        editor.mMetadataBuilder = new MediaMetadata.Builder(mMediaMetadata);
+    }
     return editor;
 }

Find a functionally equivalent code:android.content.RestrictionEntry.setTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible title for the entry.
 * @param title the user-visible title for the entry.
 */

@@ -1,3 +1,3 @@
 {
-    this.title = title;
+    this.mTitle = title;
 }

Find a functionally equivalent code:android.telephony.PhoneNumberUtils.getNumberFromIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extracts the phone number from an Intent.
 *
 * @param intent the intent to get the number of
 * @param context a context to use for database access
 *
 * @return the phone number that would be called by the intent, or
 * <code>null</code> if the number cannot be found.
 */

@@ -8,17 +8,13 @@
     if (scheme.equals("tel") || scheme.equals("sip")) {
         return uri.getSchemeSpecificPart();
     }
-    // CALL_PRIVILEGED permission).
-    if (scheme.equals("voicemail")) {
-        return TelephonyManager.getDefault().getCompleteVoiceMailNumber();
-    }
     if (context == null) {
         return null;
     }

Find a functionally equivalent code:android.os.Bundle.getShort:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a short value
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return defaultValue;
-    }
-    try {
-        return (Short) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "Short", defaultValue, e);
-        return defaultValue;
-    }
+    return super.getShort(key, defaultValue);
 }

Find a functionally equivalent code:android.content.pm.ComponentInfo.loadDefaultIcon:COMMENT
<android.content.pm.ComponentInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */


Find a functionally equivalent code:com.android.connectivitymanagertest.stress.WifiStressTest.testWifiReconnectionAfterSleep:COMMENT
Method Modifier: public      
Comment:// Stress Wifi reconnection to secure net after sleep

@@ -1,69 +1,75 @@
 {
-    int value = Settings.Global.getInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, -1);
-    log("wifi sleep policy is: " + value);
-    if (value != Settings.Global.WIFI_SLEEP_POLICY_DEFAULT) {
-        Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_DEFAULT);
-        log("set wifi sleep policy to default value");
-    }
+    // set always scan to false
+    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0);
+    // set wifi sleep policy to never on while in sleep
+    Settings.Global.putInt(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_SLEEP_POLICY, Settings.Global.WIFI_SLEEP_POLICY_NEVER);
+    // set idle timeout for wifi to 15s
     Settings.Global.putLong(mRunner.getContext().getContentResolver(), Settings.Global.WIFI_IDLE_MS, WIFI_IDLE_MS);
-    // Connect to a Wi-Fi network
-    WifiConfiguration config = new WifiConfiguration();
-    config.SSID = mSsid;
-    config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
-    if (mPassword.matches("[0-9A-Fa-f]{64}")) {
-        config.preSharedKey = mPassword;
+    WifiConfiguration config;
+    if (mPassword == null) {
+        config = WifiConfigurationHelper.createOpenConfig(mSsid);
     } else {
-        config.preSharedKey = '"' + mPassword + '"';
+        config = WifiConfigurationHelper.createPskConfig(mSsid, mPassword);
     }
-    config.ipAssignment = IpAssignment.DHCP;
-    config.proxySettings = ProxySettings.NONE;
     assertTrue("Failed to connect to Wi-Fi network: " + mSsid, connectToWifiWithConfiguration(config));
-    assertTrue(waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
-    assertTrue(waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
+    assertTrue("wifi not connected", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
     // Run ping test to verify the data connection
-    assertTrue("Wi-Fi is connected, but no data connection.", pingTest(null));
-    int i;
-    long sum = 0;
-    for (i = 0; i < mReconnectIterations; i++) {
+    assertTrue("Wi-Fi is connected, but no data connection.", pingTest());
+    long i, sum = 0, avgReconnectTime = 0;
+    for (i = 1; i <= mReconnectIterations; i++) {
         // 1. Put device into sleep mode
         // 2. Wait for the device to sleep for sometime, verify wi-fi is off and mobile is on.
         // 3. Maintain the sleep mode for some time,
         // 4. Verify the Wi-Fi is still off, and data is on
         // 5. Wake up the device, verify Wi-Fi is enabled and connected.
         writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
-        log("iteration: " + i);
+        logv("iteration: " + i);
         turnScreenOff();
+        // Use clock time since boot for intervals.
+        long start = SystemClock.uptimeMillis();
         PowerManager pm = (PowerManager) mRunner.getContext().getSystemService(Context.POWER_SERVICE);
-        assertFalse(pm.isScreenOn());
-        sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY, "Interruped while wait for wifi to be idle");
-        assertTrue("Wait for Wi-Fi to idle timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.DISCONNECTED, 6 * SHORT_TIMEOUT));
-        if (!mWifiOnlyFlag) {
+        while (pm.isInteractive() && ((SystemClock.uptimeMillis() - start) < SCREEN_OFF_TIMER)) {
+            SystemClock.sleep(100);
+        }
+        assertFalse("screen still on", pm.isInteractive());
+        // wait for WiFi timeout
+        SystemClock.sleep(WIFI_IDLE_MS + WIFI_SHUTDOWN_DELAY);
+        // 6 * SHORT_TIMEOUT));
+        if (mWifiOnlyFlag) {
+            assertTrue("expected wifi disconnect, still has active connection", waitUntilNoActiveNetworkConnection(2 * LONG_TIMEOUT));
+        } else {
             // use long timeout as the pppd startup may take several retries.
-            assertTrue("Wait for cellular connection timeout", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
+            assertTrue("no fallback on mobile or wifi didn't disconnect", waitForNetworkState(ConnectivityManager.TYPE_MOBILE, State.CONNECTED, 2 * LONG_TIMEOUT));
         }
-        sleep(mWifiSleepTime, "Interrupted while device is in sleep mode");
-        // Verify the wi-fi is still off and data connection is on
-        assertEquals("Wi-Fi is reconnected", State.DISCONNECTED, mCM.getNetworkInfo(ConnectivityManager.TYPE_WIFI).getState());
-        if (!mWifiOnlyFlag) {
-            assertEquals("Cellular connection is down", State.CONNECTED, mCM.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
-            assertTrue("Mobile is connected, but no data connection.", pingTest(null));
+        SystemClock.sleep(mWifiSleepTime);
+        // verify the wi-fi is still off and either we have no connectivity or fallback on mobile
+        if (mWifiOnlyFlag) {
+            NetworkInfo ni = mCm.getActiveNetworkInfo();
+            if (ni != null) {
+                Log.e(mLogTag, "has active network while in wifi sleep: " + ni.toString());
+                fail("active network detected");
+            }
+        } else {
+            assertEquals("mobile not connected", State.CONNECTED, mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState());
+            assertTrue("no connectivity over mobile", pingTest());
         }
         // Turn screen on again
         turnScreenOn();
-        // Wait for 2 seconds for the lock screen
-        sleep(2 * 1000, "wait 2 seconds for lock screen");
-        // Disable lock screen by inject menu key event
-        mRunner.sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);
         // Measure the time for Wi-Fi to get connected
-        long startTime = System.currentTimeMillis();
-        assertTrue("Wait for Wi-Fi enable timeout after wake up", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
-        assertTrue("Wait for Wi-Fi connection timeout after wake up", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, WIFI_CONNECTION_TIMEOUT));
-        long connectionTime = System.currentTimeMillis() - startTime;
+        long startTime = SystemClock.uptimeMillis();
+        assertTrue("screen on: wifi not enabled before timeout", waitForWifiState(WifiManager.WIFI_STATE_ENABLED, SHORT_TIMEOUT));
+        assertTrue("screen on: wifi not connected before timeout", waitForNetworkState(ConnectivityManager.TYPE_WIFI, State.CONNECTED, LONG_TIMEOUT));
+        long connectionTime = SystemClock.uptimeMillis() - startTime;
         sum += connectionTime;
-        log("average reconnection time is: " + sum / (i + 1));
-        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest(null));
+        avgReconnectTime = sum / i;
+        logv("average reconnection time is: " + avgReconnectTime);
+        assertTrue("Reconnect to Wi-Fi network, but no data connection.", pingTest());
     }
-    if (i == mReconnectIterations) {
+    Bundle result = new Bundle();
+    result.putLong("actual-iterations", i - 1);
+    result.putLong("avg-reconnect-time", avgReconnectTime);
+    getInstrumentation().sendStatus(Activity.RESULT_FIRST_USER, result);
+    if (i == mReconnectIterations + 1) {
         writeOutput(String.format("iteration %d out of %d", i, mReconnectIterations));
     }
 }

Find a functionally equivalent code:android.security.KeyChain.bind:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide for reuse by CertInstaller and Settings.
 *
 * Caller should call unbindService on the result when finished.
 */

@@ -1,35 +1,3 @@
 {
-    if (context == null) {
-        throw new NullPointerException("context == null");
-    }
-    ensureNotOnMainThread(context);
-    final BlockingQueue<IKeyChainService> q = new LinkedBlockingQueue<IKeyChainService>(1);
-    ServiceConnection keyChainServiceConnection = new ServiceConnection() {
-
-        volatile boolean mConnectedAtLeastOnce = false;
-
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            if (!mConnectedAtLeastOnce) {
-                mConnectedAtLeastOnce = true;
-                try {
-                    q.put(IKeyChainService.Stub.asInterface(service));
-                } catch (InterruptedException e) {
-                // will never happen, since the queue starts with one available slot
-                }
-            }
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-        }
-    };
-    Intent intent = new Intent(IKeyChainService.class.getName());
-    ComponentName comp = intent.resolveSystemService(context.getPackageManager(), 0);
-    intent.setComponent(comp);
-    boolean isBound = context.bindService(intent, keyChainServiceConnection, Context.BIND_AUTO_CREATE);
-    if (!isBound) {
-        throw new AssertionError("could not bind to KeyChainService");
-    }
-    return new KeyChainConnection(context, keyChainServiceConnection, q.take());
+    return bindAsUser(context, Process.myUserHandle());
 }

Find a functionally equivalent code:android.graphics.Path.toggleInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Toggles the INVERSE state of the filltype
 */

@@ -1,5 +1,5 @@
 {
     int ft = native_getFillType(mNativePath);
-    ft ^= 2;
+    ft ^= FillType.INVERSE_WINDING.nativeInt;
     native_setFillType(mNativePath, ft);
 }

Find a functionally equivalent code:android.content.RestrictionEntry.getChoiceEntries:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of strings, set earlier, that will be presented as choices to the user.
 * @return the list of choices presented to the user.
 */

@@ -1,3 +1,3 @@
 {
-    return choices;
+    return mChoiceEntries;
 }

Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.checkAddPermission:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -7,18 +7,22 @@
     String permission = null;
     switch(type) {
         case TYPE_TOAST:
+            // XXX right now the app process has complete control over
+            // this...  should introduce a token to let the system
             // monitor/control what they are doing.
+            outAppOp[0] = AppOpsManager.OP_TOAST_WINDOW;
             break;
         case TYPE_DREAM:
         case TYPE_INPUT_METHOD:
         case TYPE_WALLPAPER:
         case TYPE_PRIVATE_PRESENTATION:
+        case TYPE_VOICE_INTERACTION:
             // The window manager will check these.
             break;
         case TYPE_PHONE:

Find a functionally equivalent code:com.android.internal.util.XmlUtils.readThisMapXml:COMMENT
Method Modifier: public      static      final       internal    
Comment:/**
 * Read a HashMap object from an XmlPullParser.  The XML data could
 * previously have been generated by writeMapXml().  The XmlPullParser
 * must be positioned <em>after</em> the tag that begins the map.
 *
 * @param parser The XmlPullParser from which to read the map data.
 * @param endTag Name of the tag that will end the map, usually "map".
 * @param name An array of one string, used to return the name attribute
 * of the map's tag.
 *
 * @return HashMap The newly generated map.
 *
 * @see #readMapXml
 */

@@ -1,22 +1,3 @@
 {
-    HashMap map = new HashMap();
-    int eventType = parser.getEventType();
-    do {
-        if (eventType == parser.START_TAG) {
-            Object val = readThisValueXml(parser, name);
-            if (name[0] != null) {
-                // System.out.println("Adding to map: " + name + " -> " + val);
-                map.put(name[0], val);
-            } else {
-                throw new XmlPullParserException("Map value without name attribute: " + parser.getName());
-            }
-        } else if (eventType == parser.END_TAG) {
-            if (parser.getName().equals(endTag)) {
-                return map;
-            }
-            throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-        }
-        eventType = parser.next();
-    } while (eventType != parser.END_DOCUMENT);
-    throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    return readThisMapXml(parser, endTag, name, null);
 }

Find a functionally equivalent code:android.media.ImageReader.getNumPlanesFromFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used, when
 * reading YUV, JPEG or raw sensor data (for example, from camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

@@ -15,20 +15,21 @@
         case ImageFormat.Y8:
         case ImageFormat.Y16:
         case ImageFormat.RAW_SENSOR:
+        case ImageFormat.RAW10:
             return 1;
         default:
             throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));

Find a functionally equivalent code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

@@ -1,3 +1,8 @@
 {
-    AudioSystem.muteMicrophone(on);
+    IAudioService service = getService();
+    try {
+        service.setMicrophoneMute(on, mContext.getOpPackageName());
+    } catch (RemoteException e) {
+        Log.e(TAG, "Dead object in setMicrophoneMute", e);
+    }
 }

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.disconnectAP:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disconnectAP()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/*
     * Disconnect from the current AP and remove configured networks.
     */

@@ -1,26 +1,28 @@
 {
     // remove saved networks
     if (!mWifiManager.isWifiEnabled()) {
-        log("Enabled wifi before remove configured networks");
+        logv("Enabled wifi before remove configured networks");
         mWifiManager.setWifiEnabled(true);
-        sleep(SHORT_TIMEOUT);
+        SystemClock.sleep(SHORT_TIMEOUT);
     }
     List<WifiConfiguration> wifiConfigList = mWifiManager.getConfiguredNetworks();
     if (wifiConfigList == null) {
-        log("no configuration list is null");
+        logv("no configuration list is null");
         return true;
     }
-    log("size of wifiConfigList: " + wifiConfigList.size());
+    logv("size of wifiConfigList: " + wifiConfigList.size());
     for (WifiConfiguration wifiConfig : wifiConfigList) {
-        log("remove wifi configuration: " + wifiConfig.networkId);
+        logv("remove wifi configuration: " + wifiConfig.networkId);
         int netId = wifiConfig.networkId;
         mWifiManager.forget(netId, new WifiManager.ActionListener() {
 
+            @Override
             public void onSuccess() {
             }
 
+            @Override
             public void onFailure(int reason) {
-                log("Failed to forget " + reason);
+                logv("Failed to forget " + reason);
             }
         });
     }

Find a functionally equivalent code:android.appwidget.AppWidgetHost.deleteAllHosts:COMMENT
Method Modifier: public      static      
Comment:/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

@@ -1,3 +1,7 @@
 {
-    deleteAllHosts(UserHandle.myUserId());
+    try {
+        sService.deleteAllHosts();
+    } catch (RemoteException e) {
+        throw new RuntimeException("system server dead?", e);
+    }
 }

Find a functionally equivalent code:android.widget.TimePicker.setIs24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */

@@ -1,17 +1,3 @@
 {
-    if (mIs24HourView == is24HourView) {
-        return;
-    }
-    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
-    int currentHour = getCurrentHour();
-    // Order is important here.
-    mIs24HourView = is24HourView;
-    getHourFormatData();
-    updateHourControl();
-    // set value after spinner range is updated - be aware that because mIs24HourView has
-    // changed then getCurrentHour() is not equal to the currentHour we cached before so
-    // explicitly ask for *not* propagating any onTimeChanged()
-    setCurrentHour(currentHour, false);
-    updateMinuteControl();
-    updateAmPmControl();
+    mDelegate.setIs24HourView(is24HourView);
 }

Find a functionally equivalent code:android.printservice.PrintServiceInfo.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new instance.
 *
 * @param resolveInfo The service resolve info.
 * @param context Context for accessing resources.
 * @throws XmlPullParserException If a XML parsing error occurs.
 * @throws IOException If a I/O error occurs.
 */

@@ -1,6 +1,7 @@
 {
     String settingsActivityName = null;
     String addPrintersActivityName = null;
+    String advancedPrintOptionsActivityName = null;
     XmlResourceParser parser = null;
     PackageManager packageManager = context.getPackageManager();
     parser = resolveInfo.serviceInfo.loadXmlMetaData(packageManager, PrintService.SERVICE_META_DATA);
@@ -19,24 +20,26 @@
                 TypedArray attributes = resources.obtainAttributes(allAttributes, com.android.internal.R.styleable.PrintService);
                 settingsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_settingsActivity);
                 addPrintersActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_addPrintersActivity);
+                advancedPrintOptionsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_advancedPrintOptionsActivity);
                 attributes.recycle();
             }
         } catch (IOException ioe) {
@@ -33,37 +35,39 @@
             }
         }
     }
-    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName);
+    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName, advancedPrintOptionsActivityName);
 }

Find a functionally equivalent code:android.view.ViewPropertyAnimator.AnimatorEventListener.onAnimationUpdate:COMMENT
Method Modifier: public      
Comment:/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */

@@ -4,23 +4,23 @@
         // Shouldn't happen, but just to play it safe
         return;
     }
-    boolean useDisplayListProperties = mView.mDisplayList != null;
+    boolean hardwareAccelerated = mView.isHardwareAccelerated();
     // alpha requires slightly different treatment than the other (transform) properties.
     // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
     // logic is dependent on how the view handles an internal call to onSetAlpha().
     // We track what kinds of properties are set, and how alpha is handled when it is
     // set, and perform the invalidation steps appropriately.
     boolean alphaHandled = false;
-    if (!useDisplayListProperties) {
+    if (!hardwareAccelerated) {
         mView.invalidateParentCaches();
     }
     float fraction = animation.getAnimatedFraction();
     int propertyMask = propertyBundle.mPropertyMask;
     if ((propertyMask & TRANSFORM_MASK) != 0) {
-        mView.invalidateViewProperty(false, false);
+        mView.invalidateViewProperty(hardwareAccelerated, false);
     }
     ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
     if (valueList != null) {
@@ -33,40 +33,39 @@
         }
     }
     if ((propertyMask & TRANSFORM_MASK) != 0) {
-        mView.mTransformationInfo.mMatrixDirty = true;
-        if (!useDisplayListProperties) {
+        if (!hardwareAccelerated) {
             // force another invalidation
             mView.mPrivateFlags |= View.PFLAG_DRAWN;
         }

Find a functionally equivalent code:android.view.PointerIcon.loadCustomIcon:COMMENT
Method Modifier: public      static      
Comment:/**
 * Loads a custom pointer icon from an XML resource.
 * <p>
 * The XML resource should have the following form:
 * <code>
 * &lt;?xml version="1.0" encoding="utf-8"?&gt;
 * &lt;pointer-icon xmlns:android="http://schemas.android.com/apk/res/android"
 * android:bitmap="@drawable/my_pointer_bitmap"
 * android:hotSpotX="24"
 * android:hotSpotY="24" /&gt;
 * </code>
 * </p>
 *
 * @param resources The resources object.
 * @param resourceId The resource id.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if resources is null.
 * @throws Resources.NotFoundException if the resource was not found or the drawable
 * linked in the resource was not found.
 */

@@ -3,8 +3,8 @@
         throw new IllegalArgumentException("resources must not be null");
     }
     PointerIcon icon = new PointerIcon(STYLE_CUSTOM);
-    icon.loadResource(resources, resourceId);
+    icon.loadResource(null, resources, resourceId);
     return icon;
 }

Find a functionally equivalent code:android.media.MediaFocusControl.dumpRCCStack:COMMENT
Method Modifier: private     
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control stack, focusing
 * on RemoteControlClient data
 */

@@ -1,10 +1,9 @@
 {
     pw.println("\nRemote Control Client stack entries (last is top of stack):");
-    synchronized (mRCStack) {
-        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
+    synchronized (mPRStack) {
+        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
         while (stackIterator.hasNext()) {
-            RemoteControlStackEntry rcse = stackIterator.next();
-            pw.println("  uid: " + rcse.mCallingUid + "  -- id: " + rcse.mRccId + "  -- type: " + rcse.mPlaybackType + "  -- state: " + rcse.mPlaybackState + "  -- vol handling: " + rcse.mPlaybackVolumeHandling + "  -- vol: " + rcse.mPlaybackVolume + "  -- volMax: " + rcse.mPlaybackVolumeMax + "  -- volObs: " + rcse.mRemoteVolumeObs);
+            stackIterator.next().dump(pw, false);
         }
         synchronized (mCurrentRcLock) {
             pw.println("\nCurrent remote control generation ID = " + mCurrentRcClientGen);

Find a functionally equivalent code:android.appwidget.AppWidgetHostView.getDefaultView:COMMENT
Method Modifier: protected   
Comment:/**
 * Inflate and return the default layout requested by AppWidget provider.
 */

@@ -6,12 +6,12 @@
     Exception exception = null;
     try {
         if (mInfo != null) {
-            Context theirContext = mContext.createPackageContextAsUser(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED, mUser);
+            Context theirContext = getRemoteContext();
             mRemoteContext = theirContext;
             LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
             inflater = inflater.cloneInContext(theirContext);
@@ -27,34 +27,32 @@
         } else {
             Log.w(TAG, "can't inflate defaultView because mInfo is missing");
         }
-    } catch (PackageManager.NameNotFoundException e) {
-        exception = e;
     } catch (RuntimeException e) {
         exception = e;
     }

Find a functionally equivalent code:android.graphics.RadialGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

@@ -5,11 +5,11 @@
             copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
             break;
         case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
-            copy = new RadialGradient(mX, mY, mRadius, mColor0, mColor1, mTileMode);
+            copy = new RadialGradient(mX, mY, mRadius, mCenterColor, mEdgeColor, mTileMode);
             break;
         default:
             throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");

Find a functionally equivalent code:android.os.StrictMode.ViolationInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a ViolationInfo instance to a parcel.
 */

@@ -1,5 +1,6 @@
 {
     crashInfo.writeToParcel(dest, flags);
+    int start = dest.dataPosition();
     dest.writeInt(policy);
     dest.writeInt(durationMillis);
     dest.writeInt(violationNumThisLoop);
@@ -8,11 +9,19 @@
     dest.writeLong(numInstances);
     dest.writeString(broadcastIntentAction);
     dest.writeStringArray(tags);
+    int total = dest.dataPosition() - start;
+    if (total > 10 * 1024) {
+        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
+        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
+        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
+        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
+    }
 }

Find a functionally equivalent code:android.os.Parcel.readArrayMapInternal:COMMENT
Method Modifier: 
Comment:/* package */

@@ -4,15 +4,19 @@
         here.fillInStackTrace();
         Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
     }
+    int startPos;
     while (N > 0) {
-        Object key = readValue(loader);
         if (DEBUG_ARRAY_MAP)
-            Log.d(TAG, "  Read #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
+            startPos = dataPosition();
+        String key = readString();
         Object value = readValue(loader);
+        if (DEBUG_ARRAY_MAP)
+            Log.d(TAG, "  Read #" + (N - 1) + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString((key != null ? key.hashCode() : 0)) + " " + key);
         outVal.append(key, value);
         N--;
     }
+    outVal.validate();
 }

Find a functionally equivalent code:android.view.ViewGroup.handleFocusGainInternal:COMMENT
Method Modifier: 
Comment:/**
 * {@inheritDoc}
 */

@@ -1,6 +1,6 @@
 {
     if (mFocused != null) {
-        mFocused.unFocus();
+        mFocused.unFocus(this);
         mFocused = null;
     }
     super.handleFocusGainInternal(direction, previouslyFocusedRect);

Find a functionally equivalent code:android.media.MediaFocusControl.unregisterMediaButtonIntent:COMMENT
Method Modifier: protected   
Comment:/**
 * see AudioManager.unregisterMediaButtonIntent(PendingIntent mediaIntent)
 * precondition: mediaIntent != null, eventReceiver != null
 */

@@ -1,13 +1,11 @@
 {
     Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
-    synchronized (mAudioFocusLock) {
-        synchronized (mRCStack) {
-            boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
-            removeMediaButtonReceiver_syncAfRcs(mediaIntent);
-            if (topOfStackWillChange) {
-                // current RC client will change, assume every type of info needs to be queried
-                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
-            }
+    synchronized (mPRStack) {
+        boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
+        removeMediaButtonReceiver_syncPrs(mediaIntent);
+        if (topOfStackWillChange) {
+            // current RC client will change, assume every type of info needs to be queried
+            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
         }
     }
 }

Find a functionally equivalent code:android.content.res.Resources.loadColorStateList:COMMENT
Method Modifier: 
Comment:/*package*/

@@ -33,43 +33,43 @@
     if (value.string == null) {
         throw new NotFoundException("Resource is not a ColorStateList (color or path): " + value);
     }
-    String file = value.string.toString();
+    final String file = value.string.toString();
     if (file.endsWith(".xml")) {
         Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
         try {
-            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
+            final XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
             csl = ColorStateList.createFromXml(this, rp);
             rp.close();
         } catch (Exception e) {

Find a functionally equivalent code:android.widget.DatePicker.setCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the {@link CalendarView} is shown.
 *
 * @param shown True if the calendar view is to be shown.
 */

@@ -1,3 +1,3 @@
 {
-    mCalendarView.setVisibility(shown ? VISIBLE : GONE);
+    mDelegate.setCalendarViewShown(shown);
 }

Find a functionally equivalent code:android.text.SpannableStringBuilder.drawTextRun:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Canvas to use internally.
 * {@hide}
 */

@@ -3,15 +3,15 @@
     int contextLen = contextEnd - contextStart;
     int len = end - start;
     if (contextEnd <= mGapStart) {
-        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, flags, p);
+        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, isRtl, p);
     } else if (contextStart >= mGapStart) {
-        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, flags, p);
+        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, isRtl, p);
     } else {
         char[] buf = TextUtils.obtain(contextLen);
         getChars(contextStart, contextEnd, buf, 0);
-        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, flags, p);
+        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, isRtl, p);
         TextUtils.recycle(buf);
     }
 }

Find a functionally equivalent code:android.provider.Browser.truncateHistory:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */

@@ -5,15 +5,13 @@
         // Select non-bookmark history, ordered by date
         cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + " ASC");
         if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
-            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
             /* eliminate oldest history items */
             for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                 cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
-                iconDb.releaseIconForPageUrl(cursor.getString(1));
                 if (!cursor.moveToNext())
                     break;
             }

Find a functionally equivalent code:android.os.RecoverySystem.installPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */

@@ -1,6 +1,7 @@
 {
     String filename = packageFile.getCanonicalPath();
     Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
-    String arg = "--update_package=" + filename + "\n--locale=" + Locale.getDefault().toString();
-    bootCommand(context, arg);
+    final String filenameArg = "--update_package=" + filename;
+    final String localeArg = "--locale=" + Locale.getDefault().toString();
+    bootCommand(context, filenameArg, localeArg);
 }

Find a functionally equivalent code:android.graphics.Canvas.drawPoint:COMMENT
<android.graphics.Canvas: void drawPoint(float,float,Paint)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Helper for drawPoints() for drawing a single point.
 */

@@ -1 +1,3 @@
-
+{
+    native_drawPoint(mNativeCanvasWrapper, x, y, paint.mNativePaint);
+}

Find a functionally equivalent code:android.view.accessibility.CaptioningManager.addCaptioningChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a listener for changes in the user's preferred captioning enabled
 * state and visual properties.
 *
 * @param listener the listener to add
 */

@@ -4,14 +4,16 @@
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_ENABLED);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR);
+            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE);
             registerObserver(Secure.ACCESSIBILITY_CAPTIONING_LOCALE);
+            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_PRESET);
         }
         mListeners.add(listener);
     }

Find a functionally equivalent code:android.webkit.CookieManager.flushCookieStore:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Flushes all cookies managed by the Chrome HTTP stack to flash.
 *
 * @hide Package level api, called from CookieSyncManager
 */

@@ -1,3 +1,2 @@
 {
-    throw new MustOverrideException();
 }

Find a functionally equivalent code:android.print.PrintManager.createPrinterDiscoverySession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

@@ -1,3 +1,7 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return null;
+    }
     return new PrinterDiscoverySession(mService, mContext, mUserId);
 }

Find a functionally equivalent code:android.print.PrintManager.getPrintJobs:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */

@@ -1,4 +1,8 @@
 {
+    if (mService == null) {
+        Log.w(LOG_TAG, "Feature android.software.print not available");
+        return Collections.emptyList();
+    }
     try {
         List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
         if (printJobInfos == null) {

Find a functionally equivalent code:android.os.StrictMode.decrementExpectedActivityCount:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

@@ -30,36 +30,38 @@
     // noticeably less responsive during orientation changes when activities are
     // being restarted.  Granted, it is only a problem when StrictMode is enabled
     // but it is annoying.
-    Runtime.getRuntime().gc();
+    System.gc();
+    System.runFinalization();
+    System.gc();
     long instances = VMDebug.countInstancesOfClass(klass, false);
     if (instances > limit) {
         Throwable tr = new InstanceCountViolation(klass, instances, limit);

Find a functionally equivalent code:android.graphics.Bitmap.nativeWriteToParcel:COMMENT
Method Modifier: private     static      native      
Comment:// returns true on success


Find a functionally equivalent code:android.speech.srec.MicrophoneInputStream.AudioRecordNew:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:android.content.res.TypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

@@ -1,4 +1,7 @@
 {
+    if (mRecycled) {
+        throw new RuntimeException("Cannot make calls to a recycled instance!");
+    }
     index *= AssetManager.STYLE_NUM_ENTRIES;
     final int[] data = mData;
     final int type = data[index + AssetManager.STYLE_TYPE];

Find a functionally equivalent code:android.app.Notification.cloneInto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members
 * of this into that.
 * @hide
 */

@@ -22,27 +22,30 @@
     // android.net.Uri is immutable
     that.sound = this.sound;
     that.audioStreamType = this.audioStreamType;
+    if (this.audioAttributes != null) {
+        that.audioAttributes = new AudioAttributes.Builder(this.audioAttributes).build();
+    }
     final long[] vibrate = this.vibrate;
     if (vibrate != null) {
         final int N = vibrate.length;
@@ -34,45 +37,45 @@
     that.defaults = this.defaults;
     that.flags = this.flags;
     that.priority = this.priority;
-    final String[] thiskind = this.kind;
-    if (thiskind != null) {
-        final int N = thiskind.length;
-        final String[] thatkind = that.kind = new String[N];
-        System.arraycopy(thiskind, 0, thatkind, 0, N);
-    }
+    that.category = this.category;
+    that.mGroupKey = this.mGroupKey;
+    that.mSortKey = this.mSortKey;
     if (this.extras != null) {
         try {
             that.extras = new Bundle(this.extras);
@@ -59,64 +59,73 @@
     if (heavy && this.bigContentView != null) {
         that.bigContentView = this.bigContentView.clone();
     }
+    if (heavy && this.headsUpContentView != null) {
+        that.headsUpContentView = this.headsUpContentView.clone();
+    }
+    that.visibility = this.visibility;
+    if (this.publicVersion != null) {
+        that.publicVersion = new Notification();
+        this.publicVersion.cloneInto(that.publicVersion, heavy);
+    }
+    that.color = this.color;
     if (!heavy) {
         // will clean out extras
         that.lightenPayload();

Find a functionally equivalent code:android.appwidget.AppWidgetHost.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */

@@ -1,7 +1,5 @@
 {
-    final int userId = mContext.getUserId();
     AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
-    view.setUserId(userId);
     view.setOnClickHandler(mOnClickHandler);
     view.setAppWidget(appWidgetId, appWidget);
     synchronized (mViews) {
@@ -9,18 +7,13 @@
     }
     RemoteViews views;
     try {
-        views = sService.getAppWidgetViews(appWidgetId, userId);
-        if (views != null) {
-            views.setUser(new UserHandle(mContext.getUserId()));
-        }
+        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
     } catch (RemoteException e) {
         throw new RuntimeException("system server dead?", e);
     }

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

@@ -1,11 +1,5 @@
 {
-    if (index < 0 || index >= mResourceData.length) {
-        return defValue;
-    }
-    if (mResourceData[index] == null) {
-        return defValue;
-    }
-    String value = mResourceData[index].getValue();
+    String value = getString(index);
     if (value == null) {
         return defValue;
     }

Find a functionally equivalent code:android.os.Bundle.getSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */

@@ -1,13 +1,3 @@
 {
-    unparcel();
-    Object o = mMap.get(key);
-    if (o == null) {
-        return null;
-    }
-    try {
-        return (Serializable) o;
-    } catch (ClassCastException e) {
-        typeWarning(key, o, "Serializable", e);
-        return null;
-    }
+    return super.getSerializable(key);
 }

Find a functionally equivalent code:android.view.MotionEvent.PointerCoords.setAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

@@ -33,40 +33,40 @@
                     throw new IllegalArgumentException("Axis out of range.");
                 }
                 final long bits = mPackedAxisBits;
-                final long axisBit = 1L << axis;
-                final int index = Long.bitCount(bits & (axisBit - 1L));
+                final long axisBit = 0x8000000000000000L >>> axis;
+                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                 float[] values = mPackedAxisValues;
                 if ((bits & axisBit) == 0) {
                     if (values == null) {

Find a functionally equivalent code:android.util.Log.wtfStack:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Like {@link #wtf(String, String)}, but also writes to the log the full
 * call stack.
 * @hide
 */

@@ -1,3 +1,3 @@
 {
-    return wtf(LOG_ID_MAIN, tag, msg, null, true);
+    return wtf(LOG_ID_MAIN, tag, msg, null, true, false);
 }

Find a functionally equivalent code:android.os.Bundle.putBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a boolean array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a boolean array object, or null
 */

@@ -1,4 +1,3 @@
 {
-    unparcel();
-    mMap.put(key, value);
+    super.putBooleanArray(key, value);
 }

Find a functionally equivalent code:com.android.internal.content.NativeLibraryHelper.removeNativeBinariesLI:COMMENT
Method Modifier: public      static      internal    
Comment:// Convenience method to call removeNativeBinariesFromDirLI(File)

@@ -1,3 +1,5 @@
 {
-    return removeNativeBinariesFromDirLI(new File(nativeLibraryPath));
+    if (nativeLibraryPath == null)
+        return;
+    removeNativeBinariesFromDirLI(new File(nativeLibraryPath), false);
 }

Find a functionally equivalent code:android.graphics.drawable.ColorDrawable.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable's color value.
 *
 * @return int The color to draw.
 */

@@ -1,3 +1,3 @@
 {
-    return mState.mUseColor;
+    return mColorState.mUseColor;
 }

Find a functionally equivalent code:android.transition.Transition.animate:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This is a utility method used by subclasses to handle standard parts of
 * setting up and running an Animator: it sets the {@link #getDuration()
 * duration} and the {@link #getStartDelay() startDelay}, starts the
 * animation, and, when the animator ends, calls {@link #end()}.
 *
 * @param animator The Animator to be run during this transition.
 *
 * @hide
 */

@@ -7,13 +7,13 @@
             animator.setDuration(getDuration());
         }
         if (getStartDelay() >= 0) {
-            animator.setStartDelay(getStartDelay());
+            animator.setStartDelay(getStartDelay() + animator.getStartDelay());
         }
         if (getInterpolator() != null) {
             animator.setInterpolator(getInterpolator());

Find a functionally equivalent code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

@@ -13,21 +13,18 @@
         // get the id that will represent this style.
         return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
     }
-    if (RenderResources.REFERENCE_NULL.equals(resValue.getValue())) {
-        return defValue;
-    }
     // (and getValue() returning null!). We need to handle this!
     if (resValue.getResourceType() != null) {
         // if this is a framework id
@@ -53,66 +50,63 @@
         return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
     }
     // not a direct id valid reference? resolve it
-    Integer idValue = null;
+    Integer idValue;
     if (resValue.isFramework()) {
         idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
     } else {
         idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
     }
     if (idValue != null) {
-        return idValue.intValue();
+        return idValue;
     }
     Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
     return defValue;

Find a functionally equivalent code:android.media.MediaDrm.getProvisionRequest:COMMENT
<android.media.MediaDrm: ProvisionRequest getProvisionRequest()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * A provision request/response exchange occurs between the app and a provisioning
 * server to retrieve a device certificate.  If provisionining is required, the
 * EVENT_PROVISION_REQUIRED event will be sent to the event handler.
 * getProvisionRequest is used to obtain the opaque provision request byte array that
 * should be delivered to the provisioning server. The provision request byte array
 * is returned in ProvisionRequest.data. The recommended URL to deliver the provision
 * request to is returned in ProvisionRequest.defaultUrl.
 */

@@ -1 +1,3 @@
-
+{
+    return getProvisionRequestNative(CERTIFICATE_TYPE_NONE, "");
+}

Find a functionally equivalent code:android.view.KeyEvent.keyCodeFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets a keycode by its symbolic name such as "KEYCODE_A" or an equivalent
 * numeric constant such as "1001".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */

@@ -1,11 +1,9 @@
 {
-    if (symbolicName == null) {
-        throw new IllegalArgumentException("symbolicName must not be null");
-    }
-    final int count = KEYCODE_SYMBOLIC_NAMES.size();
-    for (int i = 0; i < count; i++) {
-        if (symbolicName.equals(KEYCODE_SYMBOLIC_NAMES.valueAt(i))) {
-            return i;
+    if (symbolicName.startsWith(LABEL_PREFIX)) {
+        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
+        int keyCode = nativeKeyCodeFromString(symbolicName);
+        if (keyCode > 0) {
+            return keyCode;
         }
     }
     try {

Find a functionally equivalent code:android.widget.CheckedTextView.setCheckMarkDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the checkmark to a given Drawable. This will be drawn when {@link #isChecked()} is true.
 *
 * @param d The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(int)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */

@@ -11,20 +11,22 @@
         setMinHeight(d.getIntrinsicHeight());
         mCheckMarkWidth = d.getIntrinsicWidth();
         d.setState(getDrawableState());
+        applyCheckMarkTint();
     } else {
         mCheckMarkWidth = 0;
     }
     mCheckMarkDrawable = d;
-    // Do padding resolution. This will call internalSetPadding() and do a requestLayout() if needed.
+    // Do padding resolution. This will call internalSetPadding() and do a
+    // requestLayout() if needed.
     resolvePadding();
 }

Find a functionally equivalent code:android.app.backup.BackupManager.requestRestore:COMMENT
Method Modifier: public      
Comment:/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */

@@ -10,16 +10,16 @@
                 result = session.restorePackage(mContext.getPackageName(), observer);
             }
         } catch (RemoteException e) {
-            Log.w(TAG, "restoreSelf() unable to contact service");
+            Log.e(TAG, "restoreSelf() unable to contact service");
         } finally {
             if (session != null) {
                 session.endRestoreSession();

Find a functionally equivalent code:android.os.BatteryStats.getPhoneDataConnectionTime:COMMENT
Method Modifier: public      abstract    hidden      
Comment:/**
 * Returns the time in microseconds that the phone has been running with
 * the given data connection.
 *
 * {@hide}
 */


Find a functionally equivalent code:android.speech.srec.Recognizer.SR_RecognizerResultGetWaveform:COMMENT
Method Modifier: private     static      native      
Comment:// 


Find a functionally equivalent code:com.android.keyguard.KeyguardUpdateMonitor.handleBootCompleted:COMMENT
Method Modifier: protected   
Comment:/**
 * Handle {@link #MSG_BOOT_COMPLETED}
 */

@@ -2,9 +2,7 @@
     if (mBootCompleted)
         return;
     mBootCompleted = true;
-    mAudioManager = new AudioManager(mContext);
-    mAudioManager.registerRemoteControlDisplay(mRemoteControlDisplay);
     for (int i = 0; i < mCallbacks.size(); i++) {
         KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
         if (cb != null) {

Find a functionally equivalent code:android.graphics.drawable.AnimationDrawable.start:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Starts the animation, looping if necessary. This method has no effect
 * if the animation is running. Do not call this in the {@link android.app.Activity#onCreate}
 * method of your activity, because the {@link android.graphics.drawable.AnimationDrawable} is
 * not yet fully attached to the window. If you want to play
 * the animation immediately, without requiring interaction, then you might want to call it
 * from the {@link android.app.Activity#onWindowFocusChanged} method in your activity,
 * which will get called when Android brings your window into focus.</p>
 *
 * @see #isRunning()
 * @see #stop()
 */

@@ -1,4 +1,5 @@
 {
+    mAnimating = true;
     if (!isRunning()) {
         run();
     }

Find a functionally equivalent code:android.graphics.Picture.getHeight:COMMENT
<android.graphics.Picture: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the height of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

@@ -1 +1,3 @@
-
+{
+    return nativeGetHeight(mNativePicture);
+}

Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.waitForWifiState:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean waitForWifiState(int,long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:// WIFI_STATE_ENALBING, WIFI_STATE_UNKNOWN

@@ -1,25 +1,16 @@
 {
-    long startTime = System.currentTimeMillis();
+    long startTime = SystemClock.uptimeMillis();
     while (true) {
-        if ((System.currentTimeMillis() - startTime) > timeout) {
-            if (mWifiState != expectedState) {
-                return false;
-            } else {
-                return true;
-            }
-        }
-        log("Wait for wifi state to be: " + expectedState);
-        synchronized (wifiObject) {
-            try {
-                wifiObject.wait(SHORT_TIMEOUT);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-            if (mWifiState != expectedState) {
-                log("Wifi state is: " + mWifiState);
-                continue;
-            }
+        int state = mWifiManager.getWifiState();
+        if (state == expectedState) {
+            logv("waitForWifiState success: state=" + state);
             return true;
         }
+        if ((SystemClock.uptimeMillis() - startTime) > timeout) {
+            logv("waitForWifiState timeout: expected=%d, actual=%d", expectedState, state);
+            return false;
+        }
+        logv("waitForWifiState interim: expected=%d, actual=%d", expectedState, state);
+        SystemClock.sleep(SHORT_TIMEOUT);
     }
 }

Find a functionally equivalent code:android.media.MediaRouter.clearUserRoutes:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all app-specified routes from the MediaRouter.
 *
 * @see #removeUserRoute(UserRouteInfo)
 */

@@ -3,9 +3,9 @@
         final RouteInfo info = sStatic.mRoutes.get(i);
         // The code below will need to change if this assumption does.
         if (info instanceof UserRouteInfo || info instanceof RouteGroup) {
-            removeRouteAt(i);
+            removeRouteStatic(info);
             i--;
         }
     }

Find a functionally equivalent code:android.media.AudioTrack.play:COMMENT
Method Modifier: public      
Comment:/**
 * Starts playing an AudioTrack.
 * If track's creation mode is {@link #MODE_STATIC}, you must have called write() prior.
 *
 * @throws IllegalStateException
 */

@@ -2,7 +2,10 @@
     if (mState != STATE_INITIALIZED) {
         throw new IllegalStateException("play() called on uninitialized AudioTrack.");
     }
+    if (isRestricted()) {
+        setVolume(0);
+    }
     synchronized (mPlayStateLock) {
         native_start();
         mPlayState = PLAYSTATE_PLAYING;

############################################
ms1 public:922
ms2 public:942
ms1 non public:373
ms2 non public:353
total methods:1295
both public:910
public2Other:12
other2Public:32
protected   ->public          :4
abstract    ->None            :3
default     abstract    ->public      :4
None->public                  :23
private     ->protected       :2
public      ->protected       :10
private     ->public          :1
None->abstract                :1
native      ->None            :20
None->private                 :2
public      ->private         :2
#####################Modfier Updated Signature#######################
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onKeyguardVisibilityChanged(boolean)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onEmergencyCallAction()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.graphics.Canvas: void restore()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.media.MediaPlayer: void prepare()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardViewBase: boolean interceptMediaKey(KeyEvent)>
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardUpdateMonitor: void dispatchBootCompleted()>
Method Modifier: public      protected   
Method Modifier: No          Yes         
Method Updated:  Yes         No          
<android.media.MediaDrm: void provideProvisionResponse(byte[])>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshBatteryInfo(BatteryStatus)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean connectToWifi(String)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.net.wifi.p2p.WifiP2pDeviceList: void updateGroupCapability(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<android.content.pm.ApplicationInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRingerModeChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.graphics.Canvas: void restoreToCount(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardViewBase: void verifyUnlock()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.os.SystemClock: boolean setCurrentTimeMillis(long)>
Method Modifier: public      static      native      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitchComplete(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onTimeChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToMobile()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserSwitching(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.media.MediaFocusControl: boolean isPlaystateActive(int)>
Method Modifier: protected   private     static      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
<android.view.HardwareLayer: void setTransform(Matrix)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
<android.app.Notification.Style: Notification buildStyled(Notification)>
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onPhoneStateChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOff()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.graphics.Picture: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean removeConfiguredNetworksAndDisableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.graphics.Canvas: boolean isOpaque()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.net.wifi.p2p.WifiP2pDeviceList: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDeviceProvisioned()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserRemoved(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: void turnScreenOn()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<com.android.internal.view.menu.MenuBuilder: void onItemsChanged(boolean)>
Method Modifier: public      internal    
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<android.view.HardwareLayer: boolean isValid()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
<android.graphics.Canvas: void translate(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.media.MediaPlayer: void setAuxEffectSendLevel(float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.view.HardwareLayer: void destroy()>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onRefreshCarrierInfo(CharSequence,CharSequence)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.view.HardwareLayer: void setLayerPaint(Paint)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.hardware.camera2.CaptureRequest: void readFromParcel(Parcel)>
Method Modifier: public      private     hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  No          Yes         Yes         
<android.text.format.Time: String toString()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onUserInfoChanged(int)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disableWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.content.pm.PackageItemInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
<android.media.MediaFocusControl: void postReevaluateRemote()>
Method Modifier: protected   private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
<android.graphics.Canvas: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.text.format.Time: void setToNow()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.graphics.Canvas: void skew(float,float)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.text.format.Time: long normalize(boolean)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.media.AudioService: int setModeInt(int,IBinder,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
<android.net.wifi.WifiConfiguration: String getKeyIdForCredentials(WifiConfiguration)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<android.net.wifi.p2p.WifiP2pDevice: void updateSupplicantDetails(WifiP2pDevice)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onClockVisibilityChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.graphics.Canvas: int getWidth()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.media.MediaPlayer: void setAudioStreamType(int)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onSimStateChanged(State)>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<android.widget.AbsListView.PositionScroller: void scrollToVisible(int,int,int)>
Method Modifier: private     
Method Modifier: No          
Method Updated:  Yes         
<android.net.wifi.p2p.WifiP2pDeviceList: void updateStatus(String,int)>
Method Modifier: public      hidden      
Method Modifier: No          Yes         
Method Updated:  Yes         Yes         
<com.android.connectivitymanagertest.functional.ConnectivityManagerMobileTest: void verifyCellularConnection()>
Method Modifier: public      private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.util.Spline: float interpolate(float)>
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean isConnectedToWifi()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onBootCompleted()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.keyguard.KeyguardUpdateMonitorCallback: void onDevicePolicyManagerStateChanged()>
Method Modifier: public      
Method Modifier: No          
Method Updated:  Yes         
<com.android.keyguard.KeyguardViewBase: void show()>
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: int waitForTetherStateChange(long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.graphics.Canvas: int getSaveCount()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.view.HardwareLayer: boolean copyInto(Bitmap)>
Method Modifier: public      default     abstract    
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          No          
<android.content.pm.ComponentInfo: Drawable loadDefaultIcon(PackageManager)>
Method Modifier: public      protected   hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean disconnectAP()>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
<android.graphics.Canvas: void drawPoint(float,float,Paint)>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.media.MediaDrm: ProvisionRequest getProvisionRequest()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<android.graphics.Picture: int getHeight()>
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: boolean waitForWifiState(int,long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
