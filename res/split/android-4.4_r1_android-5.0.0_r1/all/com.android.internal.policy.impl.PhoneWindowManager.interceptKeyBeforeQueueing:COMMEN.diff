Find a functionally equivalent code:com.android.internal.policy.impl.PhoneWindowManager.interceptKeyBeforeQueueing:COMMENT
Method Modifier: public      internal    
Comment:/**
 * {@inheritDoc}
 */

@@ -3,8 +3,9 @@
         // If we have not yet booted, don't let key events do anything.
         return 0;
     }
+    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
     final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
     final boolean canceled = event.isCanceled();
     final int keyCode = event.getKeyCode();
@@ -11,51 +12,51 @@
     // the same as if it were open and in front.
     // This will prevent any keys other than the power button from waking the screen
     // when the keyguard is hidden by another activity.
-    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (isScreenOn ? mKeyguardDelegate.isShowingAndNotHidden() : mKeyguardDelegate.isShowing()));
-    if (keyCode == KeyEvent.KEYCODE_POWER) {
-        policyFlags |= WindowManagerPolicy.FLAG_WAKE;
-    }
-    final boolean isWakeKey = (policyFlags & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
+    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? mKeyguardDelegate.isShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
     if (DEBUG_INPUT) {
-        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags) + " isWakeKey=" + isWakeKey);
-    }
-    if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0) {
-        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
+        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
     }
-    // Basic policy based on screen state and keyguard.
-    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
-    // is on or off, really.  We should care about whether the device is in an
-    // interactive state or is in suspend pretending to be "off".
-    // The primary screen might be turned off due to proximity sensor or
-    // because we are presenting media on an auxiliary screen or remotely controlling
-    // the device some other way (which is why we have an exemption here for injected
-    // events).
+    // Basic policy based on interactive state.
     int result;
-    if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
-        // When the screen is on or if the key is injected pass the key to the application.
+    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
+    if (interactive || (isInjected && !isWakeKey)) {
+        // When the device is interactive or the key is injected pass the
+        // key to the application.
         result = ACTION_PASS_TO_USER;
+        isWakeKey = false;
+    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
+        // If we're currently dozing with the screen on and the keyguard showing, pass the key
+        // to the application but preserve its wake key status to make sure we still move
+        // from dozing to fully interactive if we would normally go from off to fully
+        // interactive.
+        result = ACTION_PASS_TO_USER;
     } else {
         // When the screen is off and the key is not injected, determine whether
         // to wake the device but don't pass the key to the application.
         result = 0;
-        if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
-            result |= ACTION_WAKE_UP;
+        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
+            isWakeKey = false;
         }
     }
     // key processing.
     if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
+        if (isWakeKey) {
+            mPowerManager.wakeUp(event.getEventTime());
+        }
         return result;
     }
+    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
     // Handle special keys.
     switch(keyCode) {
         case KeyEvent.KEYCODE_VOLUME_DOWN:
@@ -54,60 +54,60 @@
             {
                 if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                     if (down) {
-                        if (isScreenOn && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                        if (interactive && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                             mVolumeDownKeyTriggered = true;
                             mVolumeDownKeyTime = event.getDownTime();
                             mVolumeDownKeyConsumedByScreenshotChord = false;
@@ -67,73 +67,73 @@
                     }
                 } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                     if (down) {
-                        if (isScreenOn && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                        if (interactive && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                             mVolumeUpKeyTriggered = true;
                             cancelPendingPowerKeyAction();
                             cancelPendingScreenshotChordAction();
@@ -78,116 +78,113 @@
                     }
                 }
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // If an incoming call is ringing, either VOLUME key means
-                                // "silence ringer".  We handle these keys here, rather than
-                                // in the InCallScreen, to make sure we'll respond to them
-                                // even if the InCallScreen hasn't come to the foreground yet.
-                                // Look for the DOWN event here, to agree with the "fallback"
-                                // behavior in the InCallScreen.
-                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
-                                // Silence the ringer.  (It's safe to call this
-                                // even if the ringer has already been silenced.)
-                                telephonyService.silenceRinger();
-                                // And *don't* pass this key thru to the current activity
-                                // (which is probably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                                break;
-                            }
-                            if (telephonyService.isOffhook() && (result & ACTION_PASS_TO_USER) == 0) {
-                                // If we are in call but we decided not to pass the key to
-                                // the application, handle the volume change here.
-                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
-                                break;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    TelecomManager telecomManager = getTelecommService();
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            // If an incoming call is ringing, either VOLUME key means
+                            // "silence ringer".  We handle these keys here, rather than
+                            // in the InCallScreen, to make sure we'll respond to them
+                            // even if the InCallScreen hasn't come to the foreground yet.
+                            // Look for the DOWN event here, to agree with the "fallback"
+                            // behavior in the InCallScreen.
+                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
+                            // Silence the ringer.  (It's safe to call this
+                            // even if the ringer has already been silenced.)
+                            telecomManager.silenceRinger();
+                            // And *don't* pass this key thru to the current activity
+                            // (which is probably the InCallScreen.)
+                            result &= ~ACTION_PASS_TO_USER;
+                            break;
+                        }
+                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
+                            // If we are in call but we decided not to pass the key to
+                            // the application, just pass it to the session service.
+                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
+                            break;
                         }
                     }
-                    if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
-                        // If music is playing but we decided not to pass the key to the
-                        // application, handle the volume change here.
-                        handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
+                    if ((result & ACTION_PASS_TO_USER) == 0) {
+                        // If we aren't passing to the user and no one else
+                        // handled it send it to the session manager to figure
+                        // out.
+                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                         break;
                     }
                 }
@@ -120,135 +117,128 @@
             {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
+                    TelecomManager telecomManager = getTelecommService();
                     boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            hungUp = telephonyService.endCall();
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
-                        }
+                    if (telecomManager != null) {
+                        hungUp = telecomManager.endCall();
                     }
-                    interceptPowerKeyDown(!isScreenOn || hungUp);
+                    interceptPowerKeyDown(!interactive || hungUp);
                 } else {
                     if (interceptPowerKeyUp(canceled)) {
                         if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
@@ -138,144 +131,138 @@
                             }
                         }
                         if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
-                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                            mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
+                            isWakeKey = false;
                         }
                     }
                 }
@@ -148,203 +142,205 @@
             {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
-                    mImmersiveModeConfirmation.onPowerKeyDown(isScreenOn, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
-                    if (isScreenOn && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
+                    boolean panic = mImmersiveModeConfirmation.onPowerKeyDown(interactive, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
+                    if (panic) {
+                        mHandler.post(mRequestTransientNav);
+                    }
+                    if (interactive && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                         mPowerKeyTriggered = true;
                         mPowerKeyTime = event.getDownTime();
                         interceptScreenshotChord();
                     }
-                    ITelephony telephonyService = getTelephonyService();
+                    TelecomManager telecomManager = getTelecommService();
                     boolean hungUp = false;
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                // Pressing Power while there's a ringing incoming
-                                // call should silence the ringer.
-                                telephonyService.silenceRinger();
-                            } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telephonyService.isOffhook()) {
-                                // Otherwise, if "Power button ends call" is enabled,
-                                // the Power button will hang up any current active call.
-                                hungUp = telephonyService.endCall();
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            // Pressing Power while there's a ringing incoming
+                            // call should silence the ringer.
+                            telecomManager.silenceRinger();
+                        } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telecomManager.isInCall() && interactive) {
+                            // Otherwise, if "Power button ends call" is enabled,
+                            // the Power button will hang up any current active call.
+                            hungUp = telecomManager.endCall();
                         }
                     }
-                    interceptPowerKeyDown(!isScreenOn || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
+                    interceptPowerKeyDown(!interactive || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                 } else {
                     mPowerKeyTriggered = false;
                     cancelPendingScreenshotChordAction();
                     if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
-                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
+                        if (mScreenOnEarly && !mScreenOnFully) {
+                            Slog.i(TAG, "Suppressed redundant power key press while " + "already in the process of turning the screen on.");
+                        } else {
+                            powerShortPress(event.getEventTime());
+                        }
+                        isWakeKey = false;
                     }
                     mPendingPowerKeyUpCanceled = false;
                 }
                 break;
             }
+        case KeyEvent.KEYCODE_SLEEP:
+            {
+                result &= ~ACTION_PASS_TO_USER;
+                if (!mPowerManager.isInteractive()) {
+                    // suppress feedback if already non-interactive
+                    useHapticFeedback = false;
+                }
+                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
+                isWakeKey = false;
+                break;
+            }
+        case KeyEvent.KEYCODE_WAKEUP:
+            {
+                result &= ~ACTION_PASS_TO_USER;
+                isWakeKey = true;
+                break;
+            }
         case KeyEvent.KEYCODE_MEDIA_PLAY:
         case KeyEvent.KEYCODE_MEDIA_PAUSE:
         case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            if (down) {
-                ITelephony telephonyService = getTelephonyService();
-                if (telephonyService != null) {
-                    try {
-                        if (!telephonyService.isIdle()) {
-                            // to avoid music playback.
-                            break;
-                        }
-                    } catch (RemoteException ex) {
-                        Log.w(TAG, "ITelephony threw RemoteException", ex);
-                    }
-                }
-            }
         case KeyEvent.KEYCODE_HEADSETHOOK:
         case KeyEvent.KEYCODE_MUTE:
         case KeyEvent.KEYCODE_MEDIA_STOP:
@@ -208,213 +210,220 @@
         case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
         case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
             {
+                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
+                    // If the global session is active pass all media keys to it
+                    // instead of the active window.
+                    result &= ~ACTION_PASS_TO_USER;
+                }
                 if ((result & ACTION_PASS_TO_USER) == 0) {
                     // Only do this if we would otherwise not pass it to the user. In that
                     // case, the PhoneWindow class will do the same thing, except it will
@@ -224,246 +231,265 @@
         case KeyEvent.KEYCODE_CALL:
             {
                 if (down) {
-                    ITelephony telephonyService = getTelephonyService();
-                    if (telephonyService != null) {
-                        try {
-                            if (telephonyService.isRinging()) {
-                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
-                                telephonyService.answerRingingCall();
-                                // And *don't* pass this key thru to the current activity
-                                // (which is presumably the InCallScreen.)
-                                result &= ~ACTION_PASS_TO_USER;
-                            }
-                        } catch (RemoteException ex) {
-                            Log.w(TAG, "ITelephony threw RemoteException", ex);
+                    TelecomManager telecomManager = getTelecommService();
+                    if (telecomManager != null) {
+                        if (telecomManager.isRinging()) {
+                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
+                            telecomManager.acceptRingingCall();
+                            // And *don't* pass this key thru to the current activity
+                            // (which is presumably the InCallScreen.)
+                            result &= ~ACTION_PASS_TO_USER;
                         }
                     }
                 }
                 break;
             }
+        case KeyEvent.KEYCODE_VOICE_ASSIST:
+            {
+                // key event here because the original key event will be recycled when we return.
+                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
+                    mBroadcastWakeLock.acquire();
+                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
+                    msg.setAsynchronous(true);
+                    msg.sendToTarget();
+                }
+            }
+    }
+    if (useHapticFeedback) {
+        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
+    }
+    if (isWakeKey) {
+        mPowerManager.wakeUp(event.getEventTime());
     }
     return result;
 }

