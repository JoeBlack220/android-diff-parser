Find a functionally equivalent code:android.text.StaticLayout.generate:COMMENT
Method Modifier: 
Comment:/* package */

@@ -1,4 +1,6 @@
 {
+    int[] breakOpp = null;
+    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
     mLineCount = 0;
     int v = 0;
     boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
@@ -8,15 +10,15 @@
     Spanned spanned = null;
     if (source instanceof Spanned)
         spanned = (Spanned) source;
-    // XXX
-    int DEFAULT_DIR = DIR_LEFT_TO_RIGHT;
     int paraEnd;
     for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
         paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
@@ -27,43 +27,43 @@
                 LeadingMarginSpan lms = sp[i];
                 firstWidth -= sp[i].getLeadingMargin(true);
                 restWidth -= sp[i].getLeadingMargin(false);
-                // paragraph.
+                // leading margin spans, not just this particular one
                 if (lms instanceof LeadingMarginSpan2) {
                     LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                     int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
-                    firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
+                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                 }
             }
             chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
             if (chooseHt.length != 0) {
                 if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
-                    chooseHtv = new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
+                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                 }
                 for (int i = 0; i < chooseHt.length; i++) {
                     int o = spanned.getSpanStart(chooseHt[i]);
@@ -58,63 +58,65 @@
         byte[] chdirs = measured.mLevels;
         int dir = measured.mDir;
         boolean easy = measured.mEasy;
+        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
+        int breakOppIndex = 0;
         int width = firstWidth;
         float w = 0;
         // here is the offset of the starting character of the line we are currently measuring
@@ -72,77 +74,81 @@
         int fit = paraStart;
         float fitWidth = w;
         int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
+        // same as fitWidth but not including any trailing whitespace
+        float fitWidthGraphing = w;
         boolean hasTabOrEmoji = false;
         boolean hasTab = false;
         TabStops tabStops = null;
@@ -139,144 +143,151 @@
                 boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                 if (w <= width || isSpaceOrTab) {
                     fitWidth = w;
+                    if (!isSpaceOrTab) {
+                        fitWidthGraphing = w;
+                    }
                     fit = j + 1;
                     if (fmTop < fitTop)
                         fitTop = fmTop;
@@ -148,159 +155,166 @@
                         fitDescent = fmDescent;
                     if (fmBottom > fitBottom)
                         fitBottom = fmBottom;
-                    // From the Unicode Line Breaking Algorithm (at least approximately)
-                    boolean isLineBreak = isSpaceOrTab || // / is class SY and - is class HY, except when followed by a digit
-                    ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || // (non-starters), which can be broken after but not before
-                    (c >= CHAR_FIRST_CJK && isIdeographic(c, true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart], false));
+                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
+                        breakOppIndex++;
+                    }
+                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                     if (isLineBreak) {
-                        okWidth = w;
+                        okWidth = fitWidthGraphing;
                         ok = j + 1;
                         if (fitTop < okTop)
                             okTop = fitTop;
@@ -165,171 +172,178 @@
                             okBottom = fitBottom;
                     }
                 } else {
-                    final boolean moreChars = (j + 1 < spanEnd);
+                    final boolean moreChars;
                     int endPos;
                     int above, below, top, bottom;
                     float currentTextWidth;
@@ -176,181 +183,189 @@
                         top = okTop;
                         bottom = okBottom;
                         currentTextWidth = okWidth;
+                        moreChars = (j + 1 < spanEnd);
                     } else if (fit != here) {
                         endPos = fit;
                         above = fitAscent;
@@ -183,195 +191,210 @@
                         top = fitTop;
                         bottom = fitBottom;
                         currentTextWidth = fitWidth;
+                        moreChars = (j + 1 < spanEnd);
                     } else {
+                        // must make progress, so take next character
                         endPos = here + 1;
-                        above = fm.ascent;
-                        below = fm.descent;
-                        top = fm.top;
-                        bottom = fm.bottom;
+                        // take all zero width characters following that
+                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
+                            endPos++;
+                        }
+                        above = fmAscent;
+                        below = fmDescent;
+                        top = fmTop;
+                        bottom = fmBottom;
                         currentTextWidth = widths[here - paraStart];
+                        moreChars = (endPos < spanEnd);
                     }
                     v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                     here = endPos;
@@ -197,202 +212,218 @@
                     j = here - 1;
                     ok = fit = here;
                     w = 0;
+                    fitWidthGraphing = w;
                     fitAscent = fitDescent = fitTop = fitBottom = 0;
                     okAscent = okDescent = okTop = okBottom = 0;
                     if (--firstWidthLineLimit <= 0) {
@@ -210,216 +226,232 @@
                         break;
                     }
                     if (mLineCount >= mMaximumVisibleLineCount) {
-                        break;
+                        return;
                     }
                 }
             }

