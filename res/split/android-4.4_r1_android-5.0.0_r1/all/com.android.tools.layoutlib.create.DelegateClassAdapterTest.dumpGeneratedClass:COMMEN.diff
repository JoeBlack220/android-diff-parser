Find a functionally equivalent code:com.android.tools.layoutlib.create.DelegateClassAdapterTest.dumpGeneratedClass:COMMENT
Method Modifier: private     
Comment:/**
 * For debugging, it's useful to dump the content of the generated classes
 * along with the exception that was generated.
 *
 * However to make it work you need to pull in the org.objectweb.asm.util.TraceClassVisitor
 * class and associated utilities which are found in the ASM source jar. Since we don't
 * want that dependency in the source code, we only put it manually for development and
 * access the TraceClassVisitor via reflection if present.
 *
 * @param t The exception thrown by {@link ClassLoader2#testModifiedInstance()}
 * @param cl2 The {@link ClassLoader2} instance with the generated bytecode.
 * @return Either original {@code t} or a new wrapper {@link Throwable}
 */

@@ -14,28 +14,27 @@
             StringWriter sw = new StringWriter();
             PrintWriter pw = new PrintWriter(sw);
             // next 2 lines do: TraceClassVisitor tcv = new TraceClassVisitor(pw);
-            Constructor<?> cons = tcvClass.getConstructor(new Class<?>[] { pw.getClass() });
-            Object tcv = cons.newInstance(new Object[] { pw });
+            Constructor<?> cons = tcvClass.getConstructor(pw.getClass());
+            Object tcv = cons.newInstance(pw);
             ClassReader cr2 = new ClassReader(bytes);
             cr2.accept((ClassVisitor) tcv, 0);
             sb.append("\nBytecode dump: <").append(className).append(">:\n").append(sw.toString());
         }
         // Re-throw exception with new message
-        RuntimeException ex = new RuntimeException(sb.toString(), t);
-        return ex;
+        return new RuntimeException(sb.toString(), t);
     } catch (Throwable ignore) {
         // In case of problem, just throw the original exception as-is.
         return t;

