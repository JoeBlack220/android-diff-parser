Find a functionally equivalent code:android.service.dreams.DreamService.attach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called when the Dream is ready to be shown.
 *
 * Must run on mHandler.
 *
 * @param windowToken A window token that will allow a window to be created in the correct layer.
 */

@@ -3,51 +3,65 @@
         Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
         return;
     }
-    if (mDebug)
-        Slog.v(TAG, "Attached on thread " + Thread.currentThread().getId());
-    if (mSandman == null) {
-        loadSandman();
+    if (mFinished || mWaking) {
+        Slog.w(TAG, "attach() called after dream already finished");
+        try {
+            mSandman.finishSelf(windowToken, true);
+        } catch (RemoteException ex) {
+        // system server died
+        }
+        return;
     }
     mWindowToken = windowToken;
-    mWindow = PolicyManager.makeNewWindow(this);
-    mWindow.setCallback(this);
-    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
-    mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
-    mWindow.setFormat(PixelFormat.OPAQUE);
-    if (mDebug)
-        Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
-    WindowManager.LayoutParams lp = mWindow.getAttributes();
-    lp.type = WindowManager.LayoutParams.TYPE_DREAM;
-    lp.token = windowToken;
-    lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
-    lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
-    mWindow.setAttributes(lp);
-    if (mDebug)
-        Slog.v(TAG, "Created and attached window: " + mWindow);
-    mWindow.setWindowManager(null, windowToken, "dream", true);
-    mWindowManager = mWindow.getWindowManager();
-    if (mDebug)
-        Slog.v(TAG, "Window added on thread " + Thread.currentThread().getId());
-    try {
+    mCanDoze = canDoze;
+    if (mWindowless && !mCanDoze) {
+        throw new IllegalStateException("Only doze dreams can be windowless");
+    }
+    if (!mWindowless) {
+        mWindow = PolicyManager.makeNewWindow(this);
+        mWindow.setCallback(this);
+        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
+        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
+        mWindow.setFormat(PixelFormat.OPAQUE);
+        if (mDebug)
+            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
+        WindowManager.LayoutParams lp = mWindow.getAttributes();
+        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
+        lp.token = windowToken;
+        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
+        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
+        mWindow.setAttributes(lp);
+        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
+        // along well. Dreams usually don't need such bars anyways, so disable them by default.
+        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+        mWindow.setWindowManager(null, windowToken, "dream", true);
         applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
-        getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
-    } catch (Throwable t) {
-        Slog.w(TAG, "Crashed adding window view", t);
-        safelyFinish();
-        return;
+        try {
+            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
+        } catch (WindowManager.BadTokenException ex) {
+            // This can happen because the dream manager service will remove the token
+            // immediately without necessarily waiting for the dream to start.
+            // We should receive a finish message soon.
+            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
+            mWindow = null;
+            return;
+        }
     }
-    // start it up
+    // We need to defer calling onDreamingStarted until after onWindowAttached,
+    // which is posted to the handler by addView, so we post onDreamingStarted
+    // to the handler also.  Need to watch out here in case detach occurs before
+    // this callback is invoked.
     mHandler.post(new Runnable() {
 
         @Override
         public void run() {
-            try {
+            if (mWindow != null || mWindowless) {
+                if (mDebug)
+                    Slog.v(TAG, "Calling onDreamingStarted()");
+                mStarted = true;
                 onDreamingStarted();
-            } catch (Throwable t) {
-                Slog.w(TAG, "Crashed in onDreamingStarted()", t);
-                safelyFinish();
             }
         }
     });

