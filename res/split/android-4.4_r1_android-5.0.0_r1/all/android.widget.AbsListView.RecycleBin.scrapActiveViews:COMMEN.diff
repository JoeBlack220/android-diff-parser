Find a functionally equivalent code:android.widget.AbsListView.RecycleBin.scrapActiveViews:COMMENT
Method Modifier: 
Comment:/**
 * Move all views remaining in mActiveViews to mScrapViews.
 */

@@ -8,46 +8,49 @@
         final View victim = activeViews[i];
         if (victim != null) {
             final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
-            int whichScrap = lp.viewType;
+            final int whichScrap = lp.viewType;
             activeViews[i] = null;
-            final boolean scrapHasTransientState = victim.hasTransientState();
-            if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
-                // Do not move views that should be ignored
-                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
+            if (victim.hasTransientState()) {
+                // Store views with transient state for later use.
+                victim.dispatchStartTemporaryDetach();
+                if (mAdapter != null && mAdapterHasStableIds) {
+                    if (mTransientStateViewsById == null) {
+                        mTransientStateViewsById = new LongSparseArray<View>();
+                    }
+                    long id = mAdapter.getItemId(mFirstActivePosition + i);
+                    mTransientStateViewsById.put(id, victim);
+                } else if (!mDataChanged) {
+                    if (mTransientStateViews == null) {
+                        mTransientStateViews = new SparseArray<View>();
+                    }
+                    mTransientStateViews.put(mFirstActivePosition + i, victim);
+                } else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
+                    // The data has changed, we can't keep this view.
                     removeDetachedView(victim, false);
                 }
-                if (scrapHasTransientState) {
-                    if (mAdapter != null && mAdapterHasStableIds) {
-                        if (mTransientStateViewsById == null) {
-                            mTransientStateViewsById = new LongSparseArray<View>();
-                        }
-                        long id = mAdapter.getItemId(mFirstActivePosition + i);
-                        mTransientStateViewsById.put(id, victim);
-                    } else {
-                        if (mTransientStateViews == null) {
-                            mTransientStateViews = new SparseArray<View>();
-                        }
-                        mTransientStateViews.put(mFirstActivePosition + i, victim);
-                    }
+            } else if (!shouldRecycleViewType(whichScrap)) {
+                // Discard non-recyclable views except headers/footers.
+                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
+                    removeDetachedView(victim, false);
                 }
-                continue;
-            }
-            if (multipleScraps) {
-                scrapViews = mScrapViews[whichScrap];
-            }
-            victim.dispatchStartTemporaryDetach();
-            lp.scrappedFromPosition = mFirstActivePosition + i;
-            scrapViews.add(victim);
-            victim.setAccessibilityDelegate(null);
-            if (hasListener) {
-                mRecyclerListener.onMovedToScrapHeap(victim);
+            } else {
+                // Store everything else on the appropriate scrap heap.
+                if (multipleScraps) {
+                    scrapViews = mScrapViews[whichScrap];
+                }
+                victim.dispatchStartTemporaryDetach();
+                lp.scrappedFromPosition = mFirstActivePosition + i;
+                scrapViews.add(victim);
+                if (hasListener) {
+                    mRecyclerListener.onMovedToScrapHeap(victim);
+                }
             }
         }
     }

