Find a functionally equivalent code:com.android.connectivitymanagertest.ConnectivityManagerTestBase.waitForTetherStateChange:COMMENT
<com.android.connectivitymanagertest.ConnectivityManagerTestBase: int waitForTetherStateChange(long)>
Method Modifier: public      protected   
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * Wait for the wifi tethering result:
 * @param timeout is the maximum waiting time
 * @return SUCCESS if tethering result is successful
 * FAILURE if tethering result returns error.
 */

@@ -1,21 +1,26 @@
 {
-    long startTime = System.currentTimeMillis();
+    long startTime = SystemClock.uptimeMillis();
+    String[] wifiRegexes = mCm.getTetherableWifiRegexs();
     while (true) {
-        if ((System.currentTimeMillis() - startTime) > timeout) {
-            return mWifiTetherResult;
+        if ((SystemClock.uptimeMillis() - startTime) > timeout) {
+            return false;
         }
-        log("Wait for wifi tethering result.");
-        synchronized (this) {
-            try {
-                this.wait(SHORT_TIMEOUT);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
+        String[] active = mCm.getTetheredIfaces();
+        String[] error = mCm.getTetheringErroredIfaces();
+        for (String iface : active) {
+            for (String regex : wifiRegexes) {
+                if (iface.matches(regex)) {
+                    return true;
+                }
             }
-            if (mWifiTetherResult == INIT) {
-                continue;
-            } else {
-                return mWifiTetherResult;
+        }
+        for (String iface : error) {
+            for (String regex : wifiRegexes) {
+                if (iface.matches(regex)) {
+                    return false;
+                }
             }
         }
+        SystemClock.sleep(SHORT_TIMEOUT);
     }
 }

