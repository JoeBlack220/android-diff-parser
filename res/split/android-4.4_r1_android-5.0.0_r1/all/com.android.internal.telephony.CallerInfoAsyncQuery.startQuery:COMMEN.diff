Find a functionally equivalent code:com.android.internal.telephony.CallerInfoAsyncQuery.startQuery:COMMENT
Method Modifier: public      static      internal    
Comment:/**
 * Factory method to start the query based on a number.
 *
 * Note: if the number contains an "@" character we treat it
 * as a SIP address, and look it up directly in the Data table
 * rather than using the PhoneLookup table.
 * TODO: But eventually we should expose two separate methods, one for
 * numbers and one for SIP addresses, and then have
 * PhoneUtils.startGetCallerInfo() decide which one to call based on
 * the phone type of the incoming connection.
 */

@@ -1,72 +1,4 @@
 {
-    if (DBG) {
-        Rlog.d(LOG_TAG, "##### CallerInfoAsyncQuery startQuery()... #####");
-        Rlog.d(LOG_TAG, "- number: " + /*number*/
-        "xxxxxxx");
-        Rlog.d(LOG_TAG, "- cookie: " + cookie);
-    }
-    // Construct the URI object and query params, and start the query.
-    Uri contactRef;
-    String selection;
-    String[] selectionArgs;
-    if (PhoneNumberUtils.isUriNumber(number)) {
-        // "number" is really a SIP address.
-        if (DBG)
-            Rlog.d(LOG_TAG, "  - Treating number as a SIP address: " + /*number*/
-            "xxxxxxx");
-        // We look up SIP addresses directly in the Data table:
-        contactRef = Data.CONTENT_URI;
-        // Note Data.DATA1 and SipAddress.SIP_ADDRESS are equivalent.
-        // 
-        // Also note we use "upper(data1)" in the WHERE clause, and
-        // uppercase the incoming SIP address, in order to do a
-        // case-insensitive match.
-        // 
-        // TODO: need to confirm that the use of upper() doesn't
-        // prevent us from using the index!  (Linear scan of the whole
-        // contacts DB can be very slow.)
-        // 
-        // TODO: May also need to normalize by adding "sip:" as a
-        // prefix, if we start storing SIP addresses that way in the
-        // database.
-        selection = "upper(" + Data.DATA1 + ")=?" + " AND " + Data.MIMETYPE + "='" + SipAddress.CONTENT_ITEM_TYPE + "'";
-        selectionArgs = new String[] { number.toUpperCase() };
-    } else {
-        // "number" is a regular phone number.  Use the PhoneLookup table:
-        contactRef = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));
-        selection = null;
-        selectionArgs = null;
-    }
-    if (DBG) {
-        Rlog.d(LOG_TAG, "==> contactRef: " + sanitizeUriToString(contactRef));
-        Rlog.d(LOG_TAG, "==> selection: " + selection);
-        if (selectionArgs != null) {
-            for (int i = 0; i < selectionArgs.length; i++) {
-                Rlog.d(LOG_TAG, "==> selectionArgs[" + i + "]: " + selectionArgs[i]);
-            }
-        }
-    }
-    CallerInfoAsyncQuery c = new CallerInfoAsyncQuery();
-    c.allocate(context, contactRef);
-    // create cookieWrapper, start query
-    CookieWrapper cw = new CookieWrapper();
-    cw.listener = listener;
-    cw.cookie = cookie;
-    cw.number = number;
-    // check to see if these are recognized numbers, and use shortcuts if we can.
-    if (PhoneNumberUtils.isLocalEmergencyNumber(number, context)) {
-        cw.event = EVENT_EMERGENCY_NUMBER;
-    } else if (PhoneNumberUtils.isVoiceMailNumber(number)) {
-        cw.event = EVENT_VOICEMAIL_NUMBER;
-    } else {
-        cw.event = EVENT_NEW_QUERY;
-    }
-    c.mHandler.startQuery(token, // cookie
-    cw, // uri
-    contactRef, // projection
-    null, // selection
-    selection, // selectionArgs
-    selectionArgs, // orderBy
-    null);
-    return c;
+    long subId = SubscriptionManager.getDefaultSubId();
+    return startQuery(token, context, number, listener, cookie, subId);
 }

