Find a functionally equivalent code:com.android.tools.layoutlib.create.AsmGenerator.transform:COMMENT
Method Modifier: 
Comment:/**
 * Transforms a class.
 * <p/>
 * There are 3 kind of transformations:
 *
 * 1- For "mock" dependencies classes, we want to remove all code from methods and replace
 * by a stub. Native methods must be implemented with this stub too. Abstract methods are
 * left intact. Modified classes must be overridable (non-private, non-final).
 * Native methods must be made non-final, non-private.
 *
 * 2- For "keep" classes, we want to rewrite all native methods as indicated above.
 * If a class has native methods, it must also be made non-private, non-final.
 *
 * Note that unfortunately static methods cannot be changed to non-static (since static and
 * non-static are invoked differently.)
 */

@@ -4,23 +4,27 @@
     String className = cr.getClassName();
     String newName = transformName(className);
     // transformName returns its input argument if there's no need to rename the class
-    if (newName != className) {
+    if (!newName.equals(className)) {
         mRenameCount++;
         // This class is being renamed, so remove it from the list of classes not renamed.
         mClassesNotRenamed.remove(className);
     }
-    mLog.debug("Transform %s%s%s%s", className, newName == className ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
+    mLog.debug("Transform %s%s%s%s", className, newName.equals(className) ? "" : " (renamed to " + newName + ")", hasNativeMethods ? " -- has natives" : "", stubNativesOnly ? " -- stub natives only" : "");
     // Rewrite the new class from scratch, without reusing the constant pool from the
     // original class reader.
     ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
-    ClassVisitor cv = new RefactorClassAdapter(cw, mRefactorClasses);
-    if (newName != className) {
+    ClassVisitor cv = cw;
+    if (mReplaceMethodCallsClasses.contains(className)) {
+        cv = new ReplaceMethodCallsAdapter(cv);
+    }
+    cv = new RefactorClassAdapter(cv, mRefactorClasses);
+    if (!newName.equals(className)) {
         cv = new RenameClassAdapter(cv, className, newName);
     }
-    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly, stubNativesOnly || hasNativeMethods);
+    cv = new TransformClassAdapter(mLog, mStubMethods, mDeleteReturns.get(className), newName, cv, stubNativesOnly);
     Set<String> delegateMethods = mDelegateMethods.get(className);
     if (delegateMethods != null && !delegateMethods.isEmpty()) {
         // known to have no native methods, just skip this step.

