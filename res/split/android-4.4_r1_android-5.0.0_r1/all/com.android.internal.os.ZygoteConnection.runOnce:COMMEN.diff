Find a functionally equivalent code:com.android.internal.os.ZygoteConnection.runOnce:COMMENT
Method Modifier: internal    
Comment:/**
 * Reads one start command from the command socket. If successful,
 * a child is forked and a {@link ZygoteInit.MethodAndArgsCaller}
 * exception is thrown in that child while in the parent process,
 * the method returns normally. On failure, the child is not
 * spawned and messages are printed to the log and stderr. Returns
 * a boolean status value indicating whether an end-of-file on the command
 * socket has been encountered.
 *
 * @return false if command socket should continue to be read from, or
 * true if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()
 * method in child process
 */

@@ -2,7 +2,8 @@
     String[] args;
     Arguments parsedArgs = null;
     FileDescriptor[] descriptors;
+    long startTime = SystemClock.elapsedRealtime();
     try {
         args = readArgumentList();
         descriptors = mSocket.getAncillaryFileDescriptors();
@@ -10,15 +11,17 @@
         closeSocket();
         return true;
     }
+    checkTime(startTime, "zygoteConnection.runOnce: readArgumentList");
     if (args == null) {
         // EOF reached.
         closeSocket();
@@ -27,50 +29,82 @@
     FileDescriptor serverPipeFd = null;
     try {
         parsedArgs = new Arguments(args);
+        if (parsedArgs.abiListQuery) {
+            return handleAbiListQuery();
+        }
+        if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
+            throw new ZygoteSecurityException("Client may not specify capabilities: " + "permitted=0x" + Long.toHexString(parsedArgs.permittedCapabilities) + ", effective=0x" + Long.toHexString(parsedArgs.effectiveCapabilities));
+        }
         applyUidSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyRlimitSecurityPolicy(parsedArgs, peer, peerSecurityContext);
-        applyCapabilitiesSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyInvokeWithSecurityPolicy(parsedArgs, peer, peerSecurityContext);
         applyseInfoSecurityPolicy(parsedArgs, peer, peerSecurityContext);
+        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
         applyDebuggerSystemProperty(parsedArgs);
         applyInvokeWithSystemProperty(parsedArgs);
+        checkTime(startTime, "zygoteConnection.runOnce: apply security policies");
         int[][] rlimits = null;
         if (parsedArgs.rlimits != null) {
             rlimits = parsedArgs.rlimits.toArray(intArray2d);
         }
         if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
-            FileDescriptor[] pipeFds = Libcore.os.pipe();
+            FileDescriptor[] pipeFds = Os.pipe();
             childPipeFd = pipeFds[1];
             serverPipeFd = pipeFds[0];
             ZygoteInit.setCloseOnExec(serverPipeFd, true);
         }
-        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName);
+        /**
+         * In order to avoid leaking descriptors to the Zygote child,
+         * the native code must close the two Zygote socket descriptors
+         * in the child process before it switches from Zygote-root to
+         * the UID and privileges of the application being launched.
+         *
+         * In order to avoid "bad file descriptor" errors when the
+         * two LocalSocket objects are closed, the Posix file
+         * descriptors are released via a dup2() call which closes
+         * the socket and substitutes an open descriptor to /dev/null.
+         */
+        int[] fdsToClose = { -1, -1 };
+        FileDescriptor fd = mSocket.getFileDescriptor();
+        if (fd != null) {
+            fdsToClose[0] = fd.getInt$();
+        }
+        fd = ZygoteInit.getServerSocketFileDescriptor();
+        if (fd != null) {
+            fdsToClose[1] = fd.getInt$();
+        }
+        fd = null;
+        checkTime(startTime, "zygoteConnection.runOnce: preForkAndSpecialize");
+        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir);
+        checkTime(startTime, "zygoteConnection.runOnce: postForkAndSpecialize");
     } catch (IOException ex) {
         logAndPrintError(newStderr, "Exception creating pipe", ex);
     } catch (ErrnoException ex) {

