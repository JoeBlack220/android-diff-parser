Find a functionally equivalent code:android.view.ViewGroup.dispatchDraw:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

@@ -1,15 +1,16 @@
 {
-    final int count = mChildrenCount;
+    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
+    final int childrenCount = mChildrenCount;
     final View[] children = mChildren;
     int flags = mGroupFlags;
     if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
         final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
         final boolean buildCache = !isHardwareAccelerated();
-        for (int i = 0; i < count; i++) {
+        for (int i = 0; i < childrenCount; i++) {
             final View child = children[i];
             if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                 final LayoutParams params = child.getLayoutParams();
-                attachLayoutAnimationParameters(child, params, i, count);
+                attachLayoutAnimationParameters(child, params, i, childrenCount);
                 bindLayoutAnimation(child);
                 if (cache) {
                     child.setDrawingCacheEnabled(true);
@@ -33,42 +34,43 @@
             mAnimationListener.onAnimationStart(controller.getAnimation());
         }
     }
-    int saveCount = 0;
+    int clipSaveCount = 0;
     final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
     if (clipToPadding) {
-        saveCount = canvas.save();
+        clipSaveCount = canvas.save();
         canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
     }
     // We will draw our child's animation, let's reset the flag
@@ -44,64 +45,65 @@
     mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
     boolean more = false;
     final long drawingTime = getDrawingTime();
-    if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
-        for (int i = 0; i < count; i++) {
-            final View child = children[i];
-            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
-                more |= drawChild(canvas, child, drawingTime);
-            }
-        }
-    } else {
-        for (int i = 0; i < count; i++) {
-            final View child = children[getChildDrawingOrder(count, i)];
-            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
-                more |= drawChild(canvas, child, drawingTime);
-            }
+    if (usingRenderNodeProperties)
+        canvas.insertReorderBarrier();
+    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
+    // draw reordering internally
+    final ArrayList<View> preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList();
+    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
+    for (int i = 0; i < childrenCount; i++) {
+        int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
+        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
+        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
+            more |= drawChild(canvas, child, drawingTime);
         }
     }
+    if (preorderedList != null)
+        preorderedList.clear();
     // Draw any disappearing views that have animations
     if (mDisappearingChildren != null) {
         final ArrayList<View> disappearingChildren = mDisappearingChildren;
@@ -69,79 +70,82 @@
             more |= drawChild(canvas, child, drawingTime);
         }
     }
+    if (usingRenderNodeProperties)
+        canvas.insertInorderBarrier();
     if (debugDraw()) {
         onDebugDraw(canvas);
     }
     if (clipToPadding) {
-        canvas.restoreToCount(saveCount);
+        canvas.restoreToCount(clipSaveCount);
     }
     // mGroupFlags might have been updated by drawChild()
     flags = mGroupFlags;

